# TECHNICAL SPECIFICATION: WS-034 - Bulk Operations
## Generated by Feature Development Session - 2025-08-21

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding photographer with 80 couples who all need the same timeline form sent before their weddings
**I want to:** Select multiple clients and send the same form/email to all of them at once
**So that:** I can complete admin tasks in minutes instead of spending hours clicking through individual client profiles

**Real Wedding Scenario:**
A photographer realizes all couples with weddings in the next 6 weeks need timeline confirmation forms. Instead of opening 23 individual client profiles and sending the same form 23 times, they can filter the client list by wedding date, select all relevant couples, and send the timeline form to everyone in one action.

### SPECIFICATION SOURCE
- **Feature ID:** WS-034
- **Original Spec:** /CORE-SPECIFICATIONS/02-WEDSYNC-SUPPLIER-PLATFORM/03-Client-Management/06-bulk-operations md.md
- **Current Implementation:** 0% complete
- **Files to Modify:**
  - `/src/components/clients/ClientListView.tsx` (enhance with bulk selection)
  - `/src/components/clients/BulkActionsBar.tsx` (new)
- **New Files to Create:**
  - `/src/components/clients/bulk/BulkEmailModal.tsx`
  - `/src/components/clients/bulk/BulkFormModal.tsx`
  - `/src/components/clients/bulk/BulkTagModal.tsx`
  - `/src/components/clients/bulk/BulkStatusModal.tsx`
  - `/src/lib/services/bulkOperationService.ts`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Bulk operation tracking
CREATE TABLE IF NOT EXISTS bulk_operations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES suppliers(id) ON DELETE CASCADE,
  operation_type TEXT NOT NULL, -- 'email', 'form', 'tag', 'status_update', 'delete'
  target_count INTEGER NOT NULL,
  successful_count INTEGER DEFAULT 0,
  failed_count INTEGER DEFAULT 0,
  status TEXT CHECK (status IN ('queued', 'processing', 'completed', 'failed')) DEFAULT 'queued',
  config JSONB NOT NULL,
  error_log JSONB DEFAULT '[]',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  completed_at TIMESTAMPTZ
);

-- Individual operation results
CREATE TABLE IF NOT EXISTS bulk_operation_results (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  bulk_operation_id UUID REFERENCES bulk_operations(id) ON DELETE CASCADE,
  client_id UUID REFERENCES clients(id) ON DELETE CASCADE,
  success BOOLEAN NOT NULL,
  error_message TEXT,
  processed_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_bulk_operations_supplier_id ON bulk_operations(supplier_id);
CREATE INDEX IF NOT EXISTS idx_bulk_operation_results_bulk_id ON bulk_operation_results(bulk_operation_id);
```

#### API Endpoints Required
```typescript
// POST /api/clients/bulk/email
interface BulkEmailRequest {
  client_ids: string[];
  template_id?: string;
  subject: string;
  content: string;
  send_immediately: boolean;
}

// POST /api/clients/bulk/form
interface BulkFormRequest {
  client_ids: string[];
  form_id: string;
  message?: string;
}

// POST /api/clients/bulk/tags
interface BulkTagRequest {
  client_ids: string[];
  action: 'add' | 'remove' | 'replace';
  tags: string[];
}

// POST /api/clients/bulk/status
interface BulkStatusUpdateRequest {
  client_ids: string[];
  status: string;
}

// GET /api/bulk-operations/[id]/status
interface BulkOperationStatusResponse {
  operation: BulkOperation;
  progress: {
    total: number;
    completed: number;
    failed: number;
    percentage: number;
  };
  results: BulkOperationResult[];
}
```

#### Frontend Components Required
```typescript
// Component: BulkActionsBar
// Location: /src/components/clients/BulkActionsBar.tsx

interface BulkActionsBarProps {
  selectedClientIds: string[];
  onActionComplete: () => void;
  onClearSelection: () => void;
}

// Key functionality:
- Shows selected count
- Action buttons (Email, Form, Tag, Status, Delete)
- Progress indicator during operations
- Success/error notifications
- Keyboard shortcuts (Escape to cancel)

// Component: BulkEmailModal
interface BulkEmailModalProps {
  clientIds: string[];
  isOpen: boolean;
  onClose: () => void;
  onSend: (emailData: BulkEmailData) => void;
}

// Key functionality:
- Template selection with preview
- Rich text editor for custom content
- Recipient preview list
- Send immediately or schedule
- Personalization token support

// Component: BulkFormModal
interface BulkFormModalProps {
  clientIds: string[];
  isOpen: boolean;
  onClose: () => void;
  onSend: (formData: BulkFormData) => void;
}

// Key functionality:
- Form selection dropdown
- Custom message addition
- Preview of form link
- Delivery method selection
```

#### Integration Points
```typescript
// Service: BulkOperationService
// Dependencies: Queue system, Email service, Form service

class BulkOperationService {
  async executeEmailBulkOperation(data: BulkEmailRequest): Promise<string> {
    // Create bulk operation record
    const operation = await supabase
      .from('bulk_operations')
      .insert({
        supplier_id: getCurrentSupplierId(),
        operation_type: 'email',
        target_count: data.client_ids.length,
        config: {
          subject: data.subject,
          content: data.content,
          template_id: data.template_id,
          send_immediately: data.send_immediately
        }
      })
      .select()
      .single();
    
    // Queue individual email tasks
    const emailTasks = data.client_ids.map(clientId => ({
      bulk_operation_id: operation.data.id,
      client_id: clientId,
      action: 'send_email',
      data: {
        subject: data.subject,
        content: data.content
      }
    }));
    
    await this.queueTasks(emailTasks);
    
    return operation.data.id;
  }
  
  async executeBulkTagOperation(data: BulkTagRequest): Promise<string> {
    const operation = await supabase
      .from('bulk_operations')
      .insert({
        supplier_id: getCurrentSupplierId(),
        operation_type: 'tag',
        target_count: data.client_ids.length,
        config: {
          action: data.action,
          tags: data.tags
        }
      })
      .select()
      .single();
    
    // Process tags in batches for performance
    const batchSize = 10;
    const batches = this.chunkArray(data.client_ids, batchSize);
    
    for (const batch of batches) {
      await this.processBatchTagUpdate(operation.data.id, batch, data);
    }
    
    return operation.data.id;
  }
  
  private async processBatchTagUpdate(
    operationId: string,
    clientIds: string[],
    tagData: BulkTagRequest
  ): Promise<void> {
    try {
      for (const clientId of clientIds) {
        const { error } = await this.updateClientTags(clientId, tagData);
        
        await supabase
          .from('bulk_operation_results')
          .insert({
            bulk_operation_id: operationId,
            client_id: clientId,
            success: !error,
            error_message: error?.message
          });
      }
    } catch (error) {
      console.error('Batch tag update failed:', error);
    }
  }
  
  async getBulkOperationStatus(operationId: string): Promise<BulkOperationStatusResponse> {
    const { data: operation } = await supabase
      .from('bulk_operations')
      .select('*')
      .eq('id', operationId)
      .single();
    
    const { data: results } = await supabase
      .from('bulk_operation_results')
      .select('*')
      .eq('bulk_operation_id', operationId);
    
    return {
      operation,
      progress: {
        total: operation.target_count,
        completed: results?.filter(r => r.success).length || 0,
        failed: results?.filter(r => !r.success).length || 0,
        percentage: ((results?.length || 0) / operation.target_count) * 100
      },
      results: results || []
    };
  }
}
```

### CODE EXAMPLES

#### Example 1: Bulk Selection Implementation
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { useState, useCallback } from 'react';
import { useClientListStore } from '@/lib/stores/clientListStore';

export function useClientBulkSelection() {
  const { clients, selectedClientIds, setSelectedClientIds } = useClientListStore();
  
  const selectAll = useCallback(() => {
    const allVisibleIds = clients.map(client => client.id);
    setSelectedClientIds(allVisibleIds);
  }, [clients, setSelectedClientIds]);
  
  const selectNone = useCallback(() => {
    setSelectedClientIds([]);
  }, [setSelectedClientIds]);
  
  const toggleClient = useCallback((clientId: string) => {
    setSelectedClientIds(prev => 
      prev.includes(clientId)
        ? prev.filter(id => id !== clientId)
        : [...prev, clientId]
    );
  }, [setSelectedClientIds]);
  
  const toggleAll = useCallback(() => {
    const allSelected = clients.every(client => selectedClientIds.includes(client.id));
    if (allSelected) {
      selectNone();
    } else {
      selectAll();
    }
  }, [clients, selectedClientIds, selectAll, selectNone]);
  
  return {
    selectedClientIds,
    selectedCount: selectedClientIds.length,
    selectAll,
    selectNone,
    toggleClient,
    toggleAll,
    hasSelection: selectedClientIds.length > 0,
    isAllSelected: clients.length > 0 && clients.every(client => selectedClientIds.includes(client.id))
  };
}
```

#### Example 2: Bulk Progress Tracking
```typescript
import { useState, useEffect } from 'react';

interface BulkOperationProgress {
  operationId: string;
  status: 'queued' | 'processing' | 'completed' | 'failed';
  progress: {
    total: number;
    completed: number;
    failed: number;
    percentage: number;
  };
}

export function useBulkOperationProgress(operationId: string | null) {
  const [progress, setProgress] = useState<BulkOperationProgress | null>(null);
  const [isPolling, setIsPolling] = useState(false);
  
  useEffect(() => {
    if (!operationId) return;
    
    setIsPolling(true);
    
    const pollProgress = async () => {
      try {
        const response = await fetch(`/api/bulk-operations/${operationId}/status`);
        const data = await response.json();
        
        setProgress(data);
        
        // Stop polling when operation is complete
        if (data.operation.status === 'completed' || data.operation.status === 'failed') {
          setIsPolling(false);
        }
      } catch (error) {
        console.error('Failed to fetch bulk operation progress:', error);
        setIsPolling(false);
      }
    };
    
    // Poll immediately, then every 2 seconds
    pollProgress();
    const interval = setInterval(pollProgress, 2000);
    
    return () => {
      clearInterval(interval);
      setIsPolling(false);
    };
  }, [operationId]);
  
  return { progress, isPolling };
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for React state management, batch operations
- [x] Playwright: Test bulk selection, modal interactions, progress tracking
- [x] Filesystem: Access existing email and form components

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/pmndrs/zustand", "bulk state management", 2000);
await mcp__context7__get-library-docs("/vercel/next.js", "api route queuing", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('BulkOperationService', () => {
  it('should create bulk email operation correctly', async () => {
    const data: BulkEmailRequest = {
      client_ids: ['1', '2', '3'],
      subject: 'Test Subject',
      content: 'Test Content',
      send_immediately: true
    };
    
    const operationId = await bulkService.executeEmailBulkOperation(data);
    expect(operationId).toBeDefined();
  });
  
  it('should handle bulk tag operations', async () => {
    const data: BulkTagRequest = {
      client_ids: ['1', '2'],
      action: 'add',
      tags: ['urgent', 'follow-up']
    };
    
    const operationId = await bulkService.executeBulkTagOperation(data);
    expect(operationId).toBeDefined();
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Bulk operations workflow', async () => {
  await mcp__playwright__browser_navigate({url: '/clients'});
  
  // Select multiple clients
  await mcp__playwright__browser_click({
    element: 'First client checkbox',
    ref: '[data-testid="client-checkbox-1"]'
  });
  await mcp__playwright__browser_click({
    element: 'Second client checkbox', 
    ref: '[data-testid="client-checkbox-2"]'
  });
  
  // Open bulk actions
  await mcp__playwright__browser_click({
    element: 'Bulk email button',
    ref: '[data-testid="bulk-email-btn"]'
  });
  
  // Fill email form
  await mcp__playwright__browser_type({
    element: 'Email subject',
    ref: '[data-testid="email-subject"]',
    text: 'Timeline Reminder'
  });
  
  await mcp__playwright__browser_type({
    element: 'Email content',
    ref: '[data-testid="email-content"]',
    text: 'Please confirm your wedding timeline.'
  });
  
  // Send bulk email
  await mcp__playwright__browser_click({
    element: 'Send email button',
    ref: '[data-testid="send-bulk-email"]'
  });
  
  // Wait for progress indication
  await mcp__playwright__browser_wait_for({
    text: 'Sending emails...'
  });
  
  await mcp__playwright__browser_snapshot();
});
```

### ACCEPTANCE CRITERIA
- [x] Can select/deselect individual clients with checkboxes
- [x] "Select All" works with current filter/search results
- [x] Bulk operations support 100+ clients without performance issues
- [x] Progress tracking shows real-time completion status
- [x] Performance: Bulk operations process 50 items in <30 seconds
- [x] Security: Operations isolated by supplier via RLS
- [x] Accessibility: Keyboard navigation, screen reader announcements

### DEPENDENCIES
- Must complete after: WS-031 (Client List Views)
- Must complete before: None (enhances existing list)
- Shares code with: Email service, form service, tag management

### ESTIMATED EFFORT
- Team A Frontend: 12 hours
- Team B Backend: 14 hours
- Team C Integration: 6 hours
- Total: 32 hours