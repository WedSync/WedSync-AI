# TECHNICAL SPECIFICATION: WS-101 - Alert System
## Generated by Feature Development Session - August 22, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** WedSync platform administrator during wedding season
**I want to:** Receive immediate alerts when wedding coordination fails or vendors lose data access
**So that:** I can fix issues before they impact couples on their wedding day

**Real Wedding Scenario:**
It's Saturday at 11 AM - peak wedding day. The payment processing service goes down, preventing a venue from confirming final guest counts for 3 weddings happening today. The alert system immediately notifies the admin via SMS and email, escalates to the on-call engineer after 15 minutes, and creates a support ticket. The issue is resolved in 20 minutes instead of potentially going unnoticed until Monday, saving three wedding receptions from catering disasters.

### SPECIFICATION SOURCE
- **Feature ID:** WS-101
- **Original Spec:** /CORE-SPECIFICATIONS/07-ADMIN-DASHBOARD/01-Overview/03-alert-system md.md
- **Current Implementation:** 0% complete
- **Files to Modify:**
  - `/wedsync/app/api/alerts/route.ts` (create new)
  - `/wedsync/lib/alerts/alert-manager.ts` (create new)
- **New Files to Create:**
  - `/wedsync/src/components/admin/AlertCenter.tsx`
  - `/wedsync/src/components/admin/AlertCard.tsx`
  - `/wedsync/src/hooks/useAlerts.ts`
  - `/wedsync/lib/alerts/rules-engine.ts`
  - `/wedsync/lib/notifications/escalation.ts`
  - `/wedsync/supabase/migrations/20250822000004_alert_system.sql`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Main alerts table
CREATE TABLE IF NOT EXISTS alerts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  type VARCHAR(50) NOT NULL, -- 'system_health', 'business', 'security', 'user_activity'
  priority VARCHAR(20) NOT NULL CHECK (priority IN ('critical', 'high', 'medium', 'low', 'info')),
  title VARCHAR(255) NOT NULL,
  message TEXT,
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  acknowledged_at TIMESTAMP WITH TIME ZONE NULL,
  acknowledged_by UUID REFERENCES auth.users(id),
  resolved_at TIMESTAMP WITH TIME ZONE NULL,
  resolved_by UUID REFERENCES auth.users(id),
  snoozed_until TIMESTAMP WITH TIME ZONE NULL,
  escalated_at TIMESTAMP WITH TIME ZONE NULL,
  notification_sent BOOLEAN DEFAULT false
);

CREATE INDEX idx_alerts_priority_unresolved ON alerts(priority, created_at DESC) WHERE resolved_at IS NULL;
CREATE INDEX idx_alerts_type_time ON alerts(type, created_at DESC);
CREATE INDEX idx_alerts_escalation ON alerts(created_at) WHERE priority = 'critical' AND acknowledged_at IS NULL;

-- Alert rules configuration
CREATE TABLE IF NOT EXISTS alert_rules (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255) NOT NULL,
  category VARCHAR(50) NOT NULL, -- 'system', 'business', 'security'
  condition TEXT NOT NULL, -- SQL query or metric check
  threshold DECIMAL(10,4),
  operator VARCHAR(10) CHECK (operator IN ('gt', 'lt', 'eq', 'between')),
  check_interval INTEGER NOT NULL, -- minutes
  last_checked TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  last_triggered TIMESTAMP WITH TIME ZONE NULL,
  enabled BOOLEAN DEFAULT true,
  actions JSONB DEFAULT '[]', -- ['email_admin', 'sms_oncall', 'slack_alert']
  created_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Alert notifications log
CREATE TABLE IF NOT EXISTS alert_notifications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  alert_id UUID REFERENCES alerts(id) ON DELETE CASCADE,
  channel VARCHAR(50) NOT NULL, -- 'email', 'sms', 'slack', 'in_app'
  recipient VARCHAR(255) NOT NULL,
  status VARCHAR(20) DEFAULT 'pending' CHECK (status IN ('pending', 'sent', 'failed', 'delivered')),
  sent_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  error_message TEXT
);

-- Wedding-specific alert contexts (critical for wedding industry)
CREATE TABLE IF NOT EXISTS wedding_impact_alerts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  alert_id UUID REFERENCES alerts(id) ON DELETE CASCADE,
  affected_weddings UUID[] DEFAULT '{}', -- Array of client IDs
  wedding_dates DATE[],
  vendor_types VARCHAR(50)[],
  estimated_impact VARCHAR(50) CHECK (estimated_impact IN ('low', 'medium', 'high', 'critical')),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

#### API Endpoints Required
```typescript
// GET /api/alerts
interface AlertsResponse {
  alerts: Alert[];
  pagination: {
    page: number;
    limit: number;
    total: number;
  };
  summary: {
    critical: number;
    high: number;
    medium: number;
    low: number;
    unacknowledged: number;
  };
}

// POST /api/alerts
interface CreateAlertRequest {
  type: string;
  priority: 'critical' | 'high' | 'medium' | 'low' | 'info';
  title: string;
  message: string;
  metadata?: Record<string, any>;
  affectedWeddings?: string[];
}

// PATCH /api/alerts/:id/acknowledge
interface AcknowledgeRequest {
  note?: string;
}

// PATCH /api/alerts/:id/resolve
interface ResolveRequest {
  resolution: string;
  preventRecurrence?: boolean;
}

// POST /api/alerts/:id/snooze
interface SnoozeRequest {
  duration: number; // minutes
  reason: string;
}

// GET /api/alerts/rules
interface AlertRulesResponse {
  rules: AlertRule[];
  categories: string[];
}

// POST /api/alerts/test-rule
interface TestRuleRequest {
  condition: string;
  threshold: number;
  operator: string;
}
```

#### Frontend Components Required
```typescript
// Component: AlertCenter
// Location: /src/components/admin/AlertCenter.tsx

interface Props {
  defaultFilter?: 'critical' | 'high' | 'medium' | 'low' | 'all';
  showResolved?: boolean;
  autoRefresh?: boolean;
}

// Key functionality:
- Real-time alert display with priority filtering
- Bulk operations (acknowledge multiple, resolve, snooze)
- Alert history and trend analysis
- Wedding impact assessment display

// Component: AlertCard
// Location: /src/components/admin/AlertCard.tsx

interface Props {
  alert: Alert;
  onAcknowledge: (id: string, note?: string) => void;
  onResolve: (id: string, resolution: string) => void;
  onSnooze: (id: string, duration: number, reason: string) => void;
  showWeddingImpact?: boolean;
}

// Key functionality:
- Priority-based color coding and icons
- One-click actions for acknowledge/resolve
- Expandable details with metadata
- Wedding impact indicators if applicable

// Component: AlertRulesManager
// Location: /src/components/admin/AlertRulesManager.tsx

interface Props {
  onRuleCreate: (rule: Partial<AlertRule>) => void;
  onRuleUpdate: (id: string, updates: Partial<AlertRule>) => void;
  onRuleDelete: (id: string) => void;
}

// Key functionality:
- Visual rule builder with condition editor
- Test rule functionality before activation
- Enable/disable rules with impact preview
- Rule performance metrics and history
```

#### Integration Points
```typescript
// Service: AlertManager
// Dependencies: Supabase, notification services, metrics collectors

class AlertManager {
  async createAlert(alertData: CreateAlertData): Promise<string> {
    // 1. Check for alert deduplication
    // 2. Assess wedding impact if applicable
    // 3. Store alert in database
    // 4. Trigger immediate notifications based on priority
    // 5. Schedule escalation if critical
    
    return alertId;
  }
  
  async checkBusinessMetrics(): Promise<void> {
    // Monitor wedding coordination metrics
    // Track vendor activation rates
    // Check payment processing health
    // Monitor user churn patterns
  }
  
  async assessWeddingImpact(alert: Alert): Promise<WeddingImpact> {
    // Identify affected weddings based on alert type
    // Calculate severity based on wedding dates
    // Determine vendor types affected
    // Return impact assessment for prioritization
  }
}

// Service: EscalationService
// Dependencies: AlertManager, notification channels

class EscalationService {
  async scheduleEscalation(alertId: string): Promise<void> {
    // Schedule escalation based on alert priority
    // Critical: 15 minutes
    // High: 1 hour
    // Medium: 4 hours
  }
  
  async executeEscalation(alertId: string): Promise<void> {
    // Send notifications to escalation chain
    // Update alert status
    // Log escalation action
  }
}

// Service: RulesEngine
// Dependencies: Database, metrics collection

class RulesEngine {
  async evaluateRules(): Promise<void> {
    // Get all enabled rules
    // Execute rule conditions
    // Compare results with thresholds
    // Create alerts for rule violations
  }
  
  async testRule(rule: AlertRule): Promise<TestResult> {
    // Execute rule condition safely
    // Return preview of what would be alerted
    // Validate rule syntax and performance
  }
}

// Hook: useAlerts
export function useAlerts(filters?: AlertFilters) {
  // Real-time subscription to alert updates
  // Automatic notifications for new critical alerts
  // State management for bulk operations
}
```

### CODE EXAMPLES

#### Example 1: Alert Manager Implementation
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { createClient } from '@supabase/supabase-js';

interface CreateAlertData {
  type: string;
  priority: 'critical' | 'high' | 'medium' | 'low' | 'info';
  title: string;
  message: string;
  metadata?: Record<string, any>;
}

export class AlertManager {
  private supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_KEY!
  );
  
  async createAlert(alertData: CreateAlertData): Promise<string> {
    try {
      // Check for duplicate alerts in last 10 minutes
      const duplicateCheck = await this.supabase
        .from('alerts')
        .select('id')
        .eq('type', alertData.type)
        .eq('title', alertData.title)
        .gte('created_at', new Date(Date.now() - 10 * 60 * 1000).toISOString())
        .eq('resolved_at', null);
      
      if (duplicateCheck.data && duplicateCheck.data.length > 0) {
        console.log('Duplicate alert detected, skipping creation');
        return duplicateCheck.data[0].id;
      }
      
      // Create the alert
      const { data: alert, error } = await this.supabase
        .from('alerts')
        .insert({
          type: alertData.type,
          priority: alertData.priority,
          title: alertData.title,
          message: alertData.message,
          metadata: alertData.metadata || {}
        })
        .select()
        .single();
      
      if (error) throw error;
      
      // Assess wedding impact if applicable
      if (this.isWeddingCritical(alertData.type)) {
        await this.assessWeddingImpact(alert.id, alertData);
      }
      
      // Send immediate notifications for critical alerts
      if (alertData.priority === 'critical') {
        await this.sendImmediateNotifications(alert.id);
        await this.scheduleEscalation(alert.id);
      }
      
      return alert.id;
      
    } catch (error) {
      console.error('Failed to create alert:', error);
      throw error;
    }
  }
  
  private isWeddingCritical(alertType: string): boolean {
    const weddingCriticalTypes = [
      'payment_failure',
      'vendor_coordination_down',
      'timeline_sync_failed',
      'communication_service_down'
    ];
    return weddingCriticalTypes.includes(alertType);
  }
  
  private async assessWeddingImpact(alertId: string, alertData: CreateAlertData) {
    // Find weddings happening in next 48 hours that could be affected
    const upcomingWeddings = await this.supabase
      .from('clients')
      .select('id, wedding_date')
      .gte('wedding_date', new Date().toISOString().split('T')[0])
      .lte('wedding_date', new Date(Date.now() + 48 * 60 * 60 * 1000).toISOString().split('T')[0]);
    
    if (upcomingWeddings.data && upcomingWeddings.data.length > 0) {
      await this.supabase
        .from('wedding_impact_alerts')
        .insert({
          alert_id: alertId,
          affected_weddings: upcomingWeddings.data.map(w => w.id),
          wedding_dates: upcomingWeddings.data.map(w => w.wedding_date),
          estimated_impact: this.calculateImpactSeverity(alertData.type, upcomingWeddings.data.length)
        });
    }
  }
  
  private async sendImmediateNotifications(alertId: string) {
    // Send SMS to on-call admin
    // Send email to admin team
    // Send Slack notification
    // Mark notifications as sent
    
    const notifications = [
      { channel: 'sms', recipient: process.env.ONCALL_PHONE! },
      { channel: 'email', recipient: process.env.ADMIN_EMAIL! },
      { channel: 'slack', recipient: process.env.SLACK_ALERT_WEBHOOK! }
    ];
    
    for (const notification of notifications) {
      await this.supabase
        .from('alert_notifications')
        .insert({
          alert_id: alertId,
          channel: notification.channel,
          recipient: notification.recipient,
          status: 'pending'
        });
    }
  }
}
```

#### Example 2: Alert Center Component
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { useState, useEffect } from 'react';
import { createClient } from '@supabase/supabase-js';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';

interface Alert {
  id: string;
  type: string;
  priority: 'critical' | 'high' | 'medium' | 'low' | 'info';
  title: string;
  message: string;
  created_at: string;
  acknowledged_at?: string;
  resolved_at?: string;
  wedding_impact?: {
    affected_weddings: string[];
    estimated_impact: string;
  };
}

export function AlertCenter() {
  const [alerts, setAlerts] = useState<Alert[]>([]);
  const [filter, setFilter] = useState<'all' | 'critical' | 'high' | 'medium' | 'low'>('all');
  const [loading, setLoading] = useState(true);
  
  const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
  
  useEffect(() => {
    fetchAlerts();
    
    // Subscribe to real-time alert updates
    const subscription = supabase
      .channel('admin-alerts')
      .on('postgres_changes', {
        event: 'INSERT',
        schema: 'public',
        table: 'alerts'
      }, (payload) => {
        setAlerts(prev => [payload.new as Alert, ...prev]);
        
        // Show browser notification for critical alerts
        if ((payload.new as Alert).priority === 'critical') {
          if (Notification.permission === 'granted') {
            new Notification('Critical Alert', {
              body: (payload.new as Alert).title,
              icon: '/alert-icon.png'
            });
          }
        }
      })
      .on('postgres_changes', {
        event: 'UPDATE',
        schema: 'public',
        table: 'alerts'
      }, (payload) => {
        setAlerts(prev => prev.map(alert => 
          alert.id === payload.new.id ? payload.new as Alert : alert
        ));
      })
      .subscribe();
    
    return () => {
      subscription.unsubscribe();
    };
  }, []);
  
  const fetchAlerts = async () => {
    try {
      const { data, error } = await supabase
        .from('alerts')
        .select(`
          *,
          wedding_impact_alerts (
            affected_weddings,
            estimated_impact
          )
        `)
        .order('created_at', { ascending: false })
        .limit(50);
      
      if (error) throw error;
      
      setAlerts(data.map(alert => ({
        ...alert,
        wedding_impact: alert.wedding_impact_alerts?.[0]
      })));
    } catch (error) {
      console.error('Failed to fetch alerts:', error);
    } finally {
      setLoading(false);
    }
  };
  
  const acknowledgeAlert = async (alertId: string) => {
    try {
      await supabase
        .from('alerts')
        .update({ acknowledged_at: new Date().toISOString() })
        .eq('id', alertId);
      
      // Update local state
      setAlerts(prev => prev.map(alert => 
        alert.id === alertId 
          ? { ...alert, acknowledged_at: new Date().toISOString() }
          : alert
      ));
    } catch (error) {
      console.error('Failed to acknowledge alert:', error);
    }
  };
  
  const resolveAlert = async (alertId: string) => {
    try {
      await supabase
        .from('alerts')
        .update({ resolved_at: new Date().toISOString() })
        .eq('id', alertId);
      
      setAlerts(prev => prev.filter(alert => alert.id !== alertId));
    } catch (error) {
      console.error('Failed to resolve alert:', error);
    }
  };
  
  const getPriorityColor = (priority: string) => {
    switch (priority) {
      case 'critical': return 'bg-red-500';
      case 'high': return 'bg-orange-500';
      case 'medium': return 'bg-yellow-500';
      case 'low': return 'bg-blue-500';
      case 'info': return 'bg-gray-500';
      default: return 'bg-gray-500';
    }
  };
  
  const filteredAlerts = filter === 'all' 
    ? alerts 
    : alerts.filter(alert => alert.priority === filter);
  
  const unresolvedAlerts = alerts.filter(alert => !alert.resolved_at);
  const criticalCount = unresolvedAlerts.filter(a => a.priority === 'critical').length;
  const highCount = unresolvedAlerts.filter(a => a.priority === 'high').length;
  
  if (loading) return <div>Loading alerts...</div>;
  
  return (
    <div className="space-y-6 p-6">
      {/* Alert Summary */}
      <div className="grid grid-cols-2 md:grid-cols-5 gap-4">
        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-sm">Critical</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold text-red-600">{criticalCount}</div>
          </CardContent>
        </Card>
        
        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-sm">High</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold text-orange-600">{highCount}</div>
          </CardContent>
        </Card>
        
        {/* Additional summary cards */}
      </div>
      
      {/* Filter Buttons */}
      <div className="flex space-x-2">
        {['all', 'critical', 'high', 'medium', 'low'].map(level => (
          <Button
            key={level}
            variant={filter === level ? 'default' : 'outline'}
            onClick={() => setFilter(level as any)}
            className="capitalize"
          >
            {level} ({level === 'all' ? alerts.length : alerts.filter(a => a.priority === level).length})
          </Button>
        ))}
      </div>
      
      {/* Alert List */}
      <div className="space-y-4">
        {filteredAlerts.map(alert => (
          <Card key={alert.id} className={`border-l-4 ${getPriorityColor(alert.priority)}`}>
            <CardHeader className="pb-2">
              <div className="flex items-center justify-between">
                <div className="flex items-center space-x-2">
                  <Badge className={getPriorityColor(alert.priority)}>
                    {alert.priority.toUpperCase()}
                  </Badge>
                  <span className="text-sm text-muted-foreground">{alert.type}</span>
                  {alert.wedding_impact && (
                    <Badge variant="outline" className="text-pink-600">
                      Wedding Impact: {alert.wedding_impact.estimated_impact}
                    </Badge>
                  )}
                </div>
                <div className="text-sm text-muted-foreground">
                  {new Date(alert.created_at).toLocaleString()}
                </div>
              </div>
              <CardTitle className="text-lg">{alert.title}</CardTitle>
            </CardHeader>
            <CardContent>
              <p className="text-sm text-muted-foreground mb-4">{alert.message}</p>
              
              {alert.wedding_impact && (
                <div className="mb-4 p-3 bg-pink-50 rounded border">
                  <p className="text-sm font-medium text-pink-800">
                    Wedding Impact: {alert.wedding_impact.affected_weddings.length} weddings potentially affected
                  </p>
                </div>
              )}
              
              <div className="flex space-x-2">
                {!alert.acknowledged_at && (
                  <Button
                    size="sm"
                    variant="outline"
                    onClick={() => acknowledgeAlert(alert.id)}
                  >
                    Acknowledge
                  </Button>
                )}
                
                {alert.acknowledged_at && !alert.resolved_at && (
                  <Button
                    size="sm"
                    onClick={() => resolveAlert(alert.id)}
                  >
                    Resolve
                  </Button>
                )}
                
                {alert.acknowledged_at && (
                  <span className="text-sm text-green-600 flex items-center">
                    âœ“ Acknowledged
                  </span>
                )}
              </div>
            </CardContent>
          </Card>
        ))}
      </div>
      
      {filteredAlerts.length === 0 && (
        <div className="text-center py-8 text-muted-foreground">
          No alerts found for the selected filter.
        </div>
      )}
    </div>
  );
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [ ] Context7: Load docs for notification libraries, real-time subscriptions
- [ ] PostgreSQL: Create alert tables and rules engine
- [ ] Filesystem: Create alert components

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/supabase/supabase", "realtime subscriptions", 2000);
await mcp__context7__get-library-docs("/sendgrid/sendgrid-nodejs", "email notifications", 1500);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('Alert System', () => {
  it('should create alerts with proper deduplication', () => {
    // Test alert creation and duplicate prevention
  });
  
  it('should assess wedding impact correctly', () => {
    // Test wedding impact calculation for different alert types
  });
  
  it('should escalate critical alerts properly', () => {
    // Test escalation timing and notification chains
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Alert center displays and manages alerts correctly', async () => {
  await mcp__playwright__browser_navigate({url: '/admin/alerts'});
  await mcp__playwright__browser_snapshot();
  // Verify alert display, acknowledgment, and resolution workflows
});
```

### ACCEPTANCE CRITERIA
- [ ] Alerts are created and displayed in real-time
- [ ] Critical alerts trigger immediate notifications (SMS, email, Slack)
- [ ] Wedding impact assessment works for time-sensitive alerts
- [ ] Alert escalation works automatically for unacknowledged critical alerts
- [ ] Performance: Alert creation under 100ms, UI updates under 200ms
- [ ] Security: Admin-only access with proper authentication
- [ ] Accessibility: Alert notifications work with screen readers

### DEPENDENCIES
- Must complete after: WS-100 (System Health Monitoring)
- Must complete before: Production monitoring setup
- Shares code with: WS-103 (Error Tracking), notification systems

### ESTIMATED EFFORT
- Team A Frontend: 16 hours (alert center UI, real-time updates, notification handling)
- Team B Backend: 20 hours (alert manager, rules engine, escalation system, database setup)
- Team C Integration: 8 hours (notification channels, external service integration)
- Total: 44 hours