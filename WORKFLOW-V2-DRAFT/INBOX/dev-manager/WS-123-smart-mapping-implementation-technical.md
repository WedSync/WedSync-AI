# TECHNICAL SPECIFICATION: WS-123 - Smart Mapping Implementation
## Generated by Feature Development Session - August 23, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding florist managing 30+ weddings per season
**I want to:** Have my extracted form fields automatically map to standard wedding data fields
**So that:** When couples fill my forms, their venue address auto-populates from their wedding details, their guest count syncs automatically, and I don't receive conflicting information across 15 different data points, eliminating 2-3 hours of data reconciliation per wedding

**Real Wedding Scenario:**
A florist receives forms with fields like "Event Location", "Number of Centerpieces Needed", and "Delivery Address". Smart mapping recognizes "Event Location" maps to the core "venue_address" field, "Number of Centerpieces" correlates with "guest_count" (typically 1 per 8-10 guests), and "Delivery Address" also maps to "venue_address". When couples update their venue, all three fields automatically update, preventing the nightmare scenario of delivering flowers to the wrong location.

### SPECIFICATION SOURCE
- **Feature ID:** WS-123
- **Original Spec:** /CORE-SPECIFICATIONS/04-AI-INTEGRATION/02-Form-Intelligence/03-smart-mapping md.md
- **Current Implementation:** 0% complete
- **Files to Modify:** None - New feature building on WS-121 and WS-122
- **New Files to Create:**
  - /src/lib/ai/smart-mapper.ts
  - /src/lib/ai/conflict-detector.ts
  - /src/lib/ai/mapping-learner.ts
  - /src/lib/ai/supplier-mappings.ts
  - /src/components/forms/mapping-review.tsx
  - /src/app/api/forms/smart-mapping/route.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Core field definitions for wedding data
CREATE TABLE IF NOT EXISTS core_field_definitions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  field_name TEXT NOT NULL UNIQUE,
  display_name TEXT NOT NULL,
  data_type TEXT NOT NULL CHECK (data_type IN ('text', 'number', 'date', 'time', 'boolean', 'select', 'multiselect', 'address', 'email', 'phone')),
  category TEXT CHECK (category IN ('couple', 'venue', 'timeline', 'guests', 'vendors', 'logistics')),
  is_required BOOLEAN DEFAULT false,
  validation_rules JSONB,
  pattern_keywords TEXT[], -- Array of keywords for matching
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Field mapping configurations per supplier
CREATE TABLE IF NOT EXISTS field_mappings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES user_profiles(id) ON DELETE CASCADE,
  form_template_id UUID,
  source_field_label TEXT NOT NULL,
  source_field_type TEXT,
  core_field_id UUID REFERENCES core_field_definitions(id),
  custom_field_name TEXT,
  mapping_type TEXT CHECK (mapping_type IN ('automatic', 'manual', 'suggested', 'rejected')),
  confidence_score DECIMAL(3,2),
  auto_populate BOOLEAN DEFAULT false,
  transform_rule JSONB, -- Rules for data transformation
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Mapping conflicts and resolutions
CREATE TABLE IF NOT EXISTS mapping_conflicts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES user_profiles(id),
  conflict_type TEXT CHECK (conflict_type IN ('duplicate_mapping', 'type_mismatch', 'missing_required', 'ambiguous')),
  core_field_id UUID REFERENCES core_field_definitions(id),
  conflicting_field_ids UUID[],
  severity TEXT CHECK (severity IN ('high', 'medium', 'low')),
  resolution_status TEXT DEFAULT 'pending',
  resolution_choice UUID REFERENCES field_mappings(id),
  resolved_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Mapping feedback for learning
CREATE TABLE IF NOT EXISTS mapping_feedback (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  mapping_id UUID REFERENCES field_mappings(id) ON DELETE CASCADE,
  supplier_id UUID REFERENCES user_profiles(id),
  feedback_type TEXT CHECK (feedback_type IN ('correct', 'incorrect', 'partial')),
  user_correction TEXT,
  confidence_adjustment DECIMAL(3,2),
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_field_mappings_supplier ON field_mappings(supplier_id);
CREATE INDEX idx_field_mappings_core ON field_mappings(core_field_id);
CREATE INDEX idx_mapping_conflicts_status ON mapping_conflicts(resolution_status);
CREATE INDEX idx_mapping_feedback_type ON mapping_feedback(feedback_type);
```

#### API Endpoints Required
```typescript
// POST /api/forms/smart-mapping/analyze
interface AnalyzeMappingRequest {
  extractedFields: ExtractedField[];
  supplierType: 'photographer' | 'venue' | 'caterer' | 'florist' | 'dj' | 'planner';
  formContext?: string;
  existingMappings?: FieldMapping[];
}

interface AnalyzeMappingResponse {
  success: boolean;
  data: {
    mappings: {
      automatic: FieldMapping[]; // High confidence, auto-applied
      suggested: FieldMapping[]; // Medium confidence, needs review
      unmapped: ExtractedField[]; // No suitable mapping found
    };
    conflicts: MappingConflict[];
    statistics: {
      totalFields: number;
      mappedFields: number;
      mappingRate: number;
      averageConfidence: number;
    };
  };
}

// POST /api/forms/smart-mapping/resolve-conflict
interface ResolveConflictRequest {
  conflictId: string;
  resolution: {
    type: 'select_field' | 'create_custom' | 'skip_all';
    selectedFieldId?: string;
    customFieldName?: string;
  };
}

// PUT /api/forms/smart-mapping/update
interface UpdateMappingRequest {
  mappingId: string;
  updates: {
    coreFieldId?: string;
    confidence?: number;
    autoPopulate?: boolean;
    transformRule?: any;
  };
  feedback?: {
    type: 'correct' | 'incorrect' | 'partial';
    correction?: string;
  };
}
```

#### Frontend Components Required
```typescript
// Component: SmartMappingWizard
// Location: /src/components/forms/smart-mapping-wizard.tsx

interface SmartMappingWizardProps {
  extractedFields: ExtractedField[];
  supplierType: string;
  onComplete: (mappings: FieldMapping[]) => void;
  showLearning?: boolean; // Show AI learning indicators
}

// Key functionality:
- Visual mapping interface with drag-and-drop
- Side-by-side view of source fields and core fields
- Confidence indicators (green >80%, yellow 50-80%, red <50%)
- Conflict resolution interface with suggestions
- Preview of auto-population behavior
- Bulk actions for similar field types

// Component: MappingConflictResolver
// Location: /src/components/forms/mapping-conflict-resolver.tsx

interface MappingConflictResolverProps {
  conflict: MappingConflict;
  onResolve: (resolution: ConflictResolution) => void;
  showAISuggestion?: boolean;
}

// Key functionality:
- Display conflicting fields side-by-side
- Show AI reasoning for each option
- Preview impact of each resolution
- One-click resolution actions
- Option to create custom mapping
```

#### Integration Points
```typescript
// Service: SmartMapper
// Dependencies: OpenAI API, Supabase, Embedding Service

class SmartMapper {
  private openai: OpenAI;
  private embeddings: EmbeddingService;
  private conflictDetector: ConflictDetector;
  
  async mapFields(
    extractedFields: ExtractedField[],
    context: MappingContext
  ): Promise<MappingResult> {
    // Step 1: Load core field definitions for supplier type
    const coreFields = await this.loadCoreFields(context.supplierType);
    
    // Step 2: Generate embeddings for semantic matching
    const fieldEmbeddings = await this.generateEmbeddings(extractedFields);
    const coreEmbeddings = await this.getCoreFieldEmbeddings(coreFields);
    
    // Step 3: Perform initial mapping using multiple strategies
    const mappings = await this.performMultiStrategyMapping(
      extractedFields,
      coreFields,
      fieldEmbeddings,
      coreEmbeddings
    );
    
    // Step 4: Detect and analyze conflicts
    const conflicts = this.conflictDetector.detectConflicts(mappings);
    
    // Step 5: Apply supplier-specific rules
    const enhancedMappings = this.applySupplierRules(
      mappings,
      context.supplierType
    );
    
    // Step 6: Calculate confidence and categorize
    return this.categorizeMappings(enhancedMappings, conflicts);
  }
  
  private async performMultiStrategyMapping(
    fields: ExtractedField[],
    coreFields: CoreField[],
    fieldEmbed: number[][],
    coreEmbed: number[][]
  ): Promise<FieldMapping[]> {
    const mappings: FieldMapping[] = [];
    
    for (let i = 0; i < fields.length; i++) {
      const field = fields[i];
      const embedding = fieldEmbed[i];
      
      // Strategy 1: Exact label matching
      const exactMatch = this.findExactMatch(field.label, coreFields);
      
      // Strategy 2: Pattern-based matching
      const patternMatch = this.findPatternMatch(field.label, coreFields);
      
      // Strategy 3: Semantic similarity using embeddings
      const semanticMatch = this.findSemanticMatch(embedding, coreEmbed, coreFields);
      
      // Strategy 4: AI-powered contextual matching
      const aiMatch = await this.getAIMapping(field, coreFields);
      
      // Combine strategies with weighted scoring
      const bestMapping = this.selectBestMapping({
        exact: exactMatch,
        pattern: patternMatch,
        semantic: semanticMatch,
        ai: aiMatch
      });
      
      mappings.push(bestMapping);
    }
    
    return mappings;
  }
}
```

### CODE EXAMPLES

#### Example 1: Supplier-Specific Mapping Rules
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { supabase } from '@/lib/supabase';

export class SupplierMappingEngine {
  // Wedding supplier-specific mapping configurations
  private supplierRules = {
    photographer: {
      priorityMappings: {
        'shot list': 'photo_requirements',
        'family photos': 'family_groupings',
        'timeline': 'wedding_timeline',
        'getting ready location': 'prep_venue',
        'first look location': 'first_look_venue',
        'ceremony time': 'ceremony_start_time',
        'golden hour': 'sunset_time'
      },
      autoPopulateFields: [
        'wedding_date',
        'venue_address',
        'couple_names',
        'ceremony_time'
      ],
      customTransforms: {
        'number of hours': (value: any) => {
          // Transform to time range
          return { duration: parseInt(value), unit: 'hours' };
        }
      }
    },
    
    caterer: {
      priorityMappings: {
        'guest count': 'total_guests',
        'dietary restrictions': 'dietary_requirements',
        'meal service style': 'service_style',
        'cocktail hour time': 'cocktail_start_time',
        'dinner time': 'dinner_start_time',
        'vendor meals': 'vendor_meal_count'
      },
      autoPopulateFields: [
        'wedding_date',
        'venue_address',
        'guest_count',
        'reception_time'
      ],
      customTransforms: {
        'number of courses': (value: any) => {
          const courseMap = {
            'three': 3,
            'four': 4,
            'five': 5,
            'buffet': 0
          };
          return courseMap[value.toLowerCase()] || parseInt(value);
        }
      }
    },
    
    florist: {
      priorityMappings: {
        'ceremony venue': 'ceremony_venue_address',
        'reception venue': 'reception_venue_address',
        'color scheme': 'wedding_colors',
        'bridal bouquet': 'bridal_bouquet_style',
        'centerpiece count': 'table_count',
        'delivery time': 'setup_time'
      },
      autoPopulateFields: [
        'wedding_date',
        'ceremony_venue_address',
        'reception_venue_address',
        'wedding_colors'
      ],
      customTransforms: {
        'table count': (value: any, context: any) => {
          // Calculate from guest count if available
          if (context.guest_count) {
            return Math.ceil(context.guest_count / 8);
          }
          return parseInt(value);
        }
      }
    }
  };
  
  async applySupplierMapping(
    field: ExtractedField,
    supplierType: string,
    context: MappingContext
  ): Promise<SupplierMapping> {
    const rules = this.supplierRules[supplierType];
    if (!rules) {
      return this.genericMapping(field);
    }
    
    // Check priority mappings first
    const normalizedLabel = field.label.toLowerCase();
    for (const [pattern, coreField] of Object.entries(rules.priorityMappings)) {
      if (normalizedLabel.includes(pattern)) {
        return {
          coreFieldId: coreField,
          confidence: 0.9,
          autoPopulate: rules.autoPopulateFields.includes(coreField),
          transform: rules.customTransforms[pattern],
          source: 'supplier_rules'
        };
      }
    }
    
    // Check if field should auto-populate
    const shouldAutoPopulate = this.checkAutoPopulate(field, rules.autoPopulateFields);
    
    return {
      coreFieldId: null,
      confidence: 0.5,
      autoPopulate: shouldAutoPopulate,
      source: 'fallback'
    };
  }
  
  async learnFromUsage(
    supplierId: string,
    supplierType: string,
    mapping: FieldMapping,
    wasSuccessful: boolean
  ) {
    // Record the mapping usage
    await supabase
      .from('mapping_feedback')
      .insert({
        supplier_id: supplierId,
        mapping_id: mapping.id,
        feedback_type: wasSuccessful ? 'correct' : 'incorrect',
        created_at: new Date().toISOString()
      });
    
    // Update confidence scores based on feedback
    if (wasSuccessful) {
      await this.increaseConfidence(mapping.id, 0.05);
    } else {
      await this.decreaseConfidence(mapping.id, 0.1);
    }
    
    // Check if we should update supplier rules
    const feedbackCount = await this.getFeedbackCount(mapping.source_field_label);
    if (feedbackCount >= 10) {
      await this.suggestRuleUpdate(supplierType, mapping);
    }
  }
}
```

#### Example 2: Conflict Detection and Resolution
```typescript
// Intelligent conflict detection and resolution
export class ConflictResolver {
  async detectAndResolveConflicts(
    mappings: FieldMapping[]
  ): Promise<ConflictResolution[]> {
    const conflicts: MappingConflict[] = [];
    const resolutions: ConflictResolution[] = [];
    
    // Group mappings by core field
    const coreFieldGroups = new Map<string, FieldMapping[]>();
    mappings.forEach(mapping => {
      if (mapping.coreFieldId) {
        const group = coreFieldGroups.get(mapping.coreFieldId) || [];
        group.push(mapping);
        coreFieldGroups.set(mapping.coreFieldId, group);
      }
    });
    
    // Detect duplicate mappings
    for (const [coreFieldId, fieldMappings] of coreFieldGroups.entries()) {
      if (fieldMappings.length > 1) {
        const conflict = await this.analyzeDuplicateMapping(
          coreFieldId,
          fieldMappings
        );
        conflicts.push(conflict);
        
        // Generate AI-powered resolution
        const resolution = await this.generateResolution(conflict);
        resolutions.push(resolution);
      }
    }
    
    // Detect missing required fields
    const requiredFields = await this.getRequiredCoreFields();
    const mappedCoreFields = new Set(mappings.map(m => m.coreFieldId).filter(Boolean));
    
    for (const required of requiredFields) {
      if (!mappedCoreFields.has(required.id)) {
        conflicts.push({
          type: 'missing_required',
          coreField: required.field_name,
          severity: 'high',
          message: `Required field "${required.display_name}" has no mapping`
        });
      }
    }
    
    // Detect type mismatches
    for (const mapping of mappings) {
      if (mapping.coreFieldId) {
        const coreField = await this.getCoreFieldDefinition(mapping.coreFieldId);
        if (!this.areTypesCompatible(mapping.sourceType, coreField.data_type)) {
          conflicts.push({
            type: 'type_mismatch',
            coreField: coreField.field_name,
            severity: 'medium',
            message: `Type mismatch: "${mapping.sourceLabel}" (${mapping.sourceType}) â†’ "${coreField.display_name}" (${coreField.data_type})`
          });
        }
      }
    }
    
    return resolutions;
  }
  
  private async generateResolution(
    conflict: MappingConflict
  ): Promise<ConflictResolution> {
    if (conflict.type === 'duplicate_mapping') {
      // Use AI to determine best mapping
      const response = await this.openai.chat.completions.create({
        model: 'gpt-4',
        messages: [{
          role: 'system',
          content: 'You are a wedding form field expert. Resolve mapping conflicts by choosing the most appropriate field.'
        }, {
          role: 'user',
          content: `
            Multiple fields map to "${conflict.coreField}":
            ${conflict.conflictingFields.map(f => `- "${f.label}" (confidence: ${f.confidence})`).join('\n')}
            
            Which field should map to this core field? Consider:
            1. Label similarity
            2. Context relevance
            3. Data type compatibility
            
            Return JSON with your choice and reasoning.
          `
        }],
        response_format: { type: 'json_object' }
      });
      
      const decision = JSON.parse(response.choices[0].message.content);
      
      return {
        conflictId: conflict.id,
        resolution: 'select_field',
        selectedField: decision.selectedField,
        reasoning: decision.reasoning,
        alternativeAction: 'create_custom_fields_for_others'
      };
    }
    
    return {
      conflictId: conflict.id,
      resolution: 'manual_review',
      reasoning: 'Requires user decision'
    };
  }
  
  private areTypesCompatible(sourceType: string, coreType: string): boolean {
    const compatibilityMap = {
      'text': ['text', 'textarea', 'select'],
      'number': ['number', 'text'],
      'date': ['date', 'text'],
      'email': ['email', 'text'],
      'select': ['select', 'radio', 'text'],
      'multiselect': ['multiselect', 'checkbox'],
      'boolean': ['boolean', 'checkbox', 'radio']
    };
    
    const compatible = compatibilityMap[coreType] || [];
    return compatible.includes(sourceType);
  }
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [ ] Context7: Load OpenAI embeddings documentation
- [ ] Supabase: Database operations for mappings and feedback
- [ ] Memory: Store learned mapping patterns

#### Context7 Queries Needed
```typescript
// Load OpenAI embeddings for semantic matching
await mcp__context7__get-library-docs("/openai/openai", "embeddings text-embedding-3", 3000);

// Load vector similarity algorithms
await mcp__context7__get-library-docs("/pgvector/pgvector", "vector similarity cosine", 2000);

// Load machine learning utilities
await mcp__context7__get-library-docs("/tensorflow/tfjs", "similarity matching", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('SmartMapper', () => {
  const mapper = new SmartMapper();
  
  it('should map exact label matches with high confidence', async () => {
    const fields = [{ label: 'Wedding Date', type: 'date' }];
    const result = await mapper.mapFields(fields, { supplierType: 'photographer' });
    
    expect(result.mappings[0].coreFieldId).toBe('wedding_date');
    expect(result.mappings[0].confidence).toBeGreaterThan(0.9);
  });
  
  it('should detect duplicate mapping conflicts', async () => {
    const fields = [
      { label: 'Event Date', type: 'date' },
      { label: 'Wedding Date', type: 'date' }
    ];
    const result = await mapper.mapFields(fields, { supplierType: 'venue' });
    
    expect(result.conflicts).toHaveLength(1);
    expect(result.conflicts[0].type).toBe('duplicate_mapping');
  });
  
  it('should apply supplier-specific rules', async () => {
    const fields = [{ label: 'Shot List', type: 'textarea' }];
    const result = await mapper.mapFields(fields, { supplierType: 'photographer' });
    
    expect(result.mappings[0].coreFieldId).toBe('photo_requirements');
    expect(result.mappings[0].autoPopulate).toBe(false);
  });
  
  it('should handle type mismatches gracefully', async () => {
    const fields = [{ label: 'Guest Count', type: 'text' }]; // Should be number
    const result = await mapper.mapFields(fields, { supplierType: 'caterer' });
    
    expect(result.conflicts).toContainEqual(
      expect.objectContaining({ type: 'type_mismatch' })
    );
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Smart mapping review and correction flow', async () => {
  // Navigate to mapping review
  await mcp__playwright__browser_navigate({url: '/forms/mapping/review'});
  
  // Check automatic mappings display
  await mcp__playwright__browser_snapshot();
  // Should show fields with mapping suggestions
  
  // Resolve a conflict
  await mcp__playwright__browser_click({
    element: 'Resolve conflict button',
    ref: '[data-conflict-id="conf-1"]'
  });
  
  // Select preferred mapping
  await mcp__playwright__browser_click({
    element: 'Select Wedding Date field',
    ref: '[data-field="wedding_date"]'
  });
  
  // Manually map an unmapped field
  await mcp__playwright__browser_drag({
    startElement: 'Unmapped field',
    startRef: '[data-unmapped="special_requests"]',
    endElement: 'Core field target',
    endRef: '[data-core="notes"]'
  });
  
  // Confirm all mappings
  await mcp__playwright__browser_click({
    element: 'Confirm Mappings',
    ref: 'button#confirm-mappings'
  });
  
  // Verify success
  await mcp__playwright__browser_wait_for({
    text: 'Mappings saved successfully'
  });
});
```

### ACCEPTANCE CRITERIA
- [ ] Maps 85%+ of common wedding fields automatically
- [ ] Achieves 90%+ accuracy for exact label matches
- [ ] Detects all duplicate mapping conflicts
- [ ] Provides resolution suggestions for conflicts
- [ ] Applies supplier-specific rules correctly
- [ ] Supports manual override of any mapping
- [ ] Learns from user corrections over time
- [ ] Handles 50+ fields in under 3 seconds
- [ ] Shows clear confidence indicators for each mapping
- [ ] Prevents data type mismatches

### DEPENDENCIES
- Must complete after: WS-121 (PDF Analysis) and WS-122 (Field Extraction)
- Must complete before: Form builder integration features
- Shares code with: WS-121, WS-122 (AI form intelligence pipeline)

### ESTIMATED EFFORT
- Team A Frontend: 16 hours (mapping UI, conflict resolver)
- Team B Backend: 24 hours (mapping engine, AI integration, learning)
- Team C Integration: 12 hours (database, supplier rules, feedback)
- Total: 52 hours