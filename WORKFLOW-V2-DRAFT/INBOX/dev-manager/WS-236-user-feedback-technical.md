# TECHNICAL SPECIFICATION: WS-236 - User Feedback System
## Generated by Feature Development Session - 2025-01-25

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** WedSync platform administrator managing 847 wedding vendors across different engagement levels and satisfaction states
**I want to:** Deploy comprehensive feedback collection with NPS surveys, feature-specific CSAT, in-app feedback widgets, and AI-powered sentiment analysis to track satisfaction trends and identify improvement opportunities
**So that:** I can proactively address user dissatisfaction before churn (target NPS >50), optimize features based on usage patterns and feedback ratings, and maintain >90% customer satisfaction during critical wedding planning periods when user stakes are highest

**Real Wedding Scenario:**
"A Professional-tier photographer completes their first client wedding form setup and rates the experience 3/5 for ease, mentioning 'guest import was confusing.' System triggers feature feedback collection, identifies form builder UX issues from similar responses, creates improvement ticket for dev team, and sends personalized onboarding follow-up. Two weeks later, after using journey canvas 5+ times, they receive NPS survey, score 9/10, become promoter, and get invited to referral program. Their feedback data helps optimize onboarding for future users."

### SPECIFICATION SOURCE
- **Feature ID:** WS-236
- **Original Spec:** /CORE-SPECIFICATIONS/07-ADMIN-DASHBOARD/05-Support-Operations/02-user-feedback md.md
- **Current Implementation:** 0% complete (new feature)
- **Files to Modify:** None (new feature)
- **New Files to Create:**
  - `/src/components/feedback/FeedbackWidget.tsx`
  - `/src/components/feedback/NPSFeedback.tsx`
  - `/src/components/feedback/FeatureFeedback.tsx`
  - `/src/components/admin/FeedbackAnalytics.tsx`
  - `/src/lib/feedback/feedback-collector.ts`
  - `/src/lib/feedback/nps-manager.ts`
  - `/src/lib/feedback/analytics-engine.ts`
  - `/src/lib/feedback/sentiment-analyzer.ts`
  - `/src/app/api/feedback/route.ts`
  - `/src/app/api/feedback/nps/route.ts`
  - `/src/hooks/useFeedback.ts`
  - `/supabase/migrations/[TIMESTAMP]_user_feedback_system.sql`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Core feedback sessions
CREATE TABLE feedback_sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id),
  session_type TEXT NOT NULL CHECK (session_type IN ('nps', 'csat', 'ces', 'feature', 'onboarding', 'churn', 'general')),
  trigger_reason TEXT NOT NULL,
  trigger_context JSONB DEFAULT '{}'::jsonb,
  
  -- Session lifecycle
  started_at TIMESTAMPTZ DEFAULT NOW(),
  completed_at TIMESTAMPTZ,
  abandoned_at TIMESTAMPTZ,
  
  -- User context at time of feedback
  user_type TEXT NOT NULL CHECK (user_type IN ('supplier', 'couple')),
  user_tier TEXT NOT NULL CHECK (user_tier IN ('free', 'starter', 'professional', 'scale', 'enterprise')),
  account_age_days INTEGER NOT NULL,
  engagement_score DECIMAL(3,2) DEFAULT 0.00,
  
  -- Device and environment
  device_type TEXT,
  browser TEXT,
  user_agent TEXT,
  session_duration_seconds INTEGER,
  page_url TEXT,
  
  -- Completion metadata
  questions_total INTEGER,
  questions_answered INTEGER,
  completion_rate DECIMAL(3,2) DEFAULT 0.00,
  
  -- Analysis results
  overall_sentiment DECIMAL(3,2), -- -1.0 to 1.0
  satisfaction_category TEXT CHECK (satisfaction_category IN ('very_dissatisfied', 'dissatisfied', 'neutral', 'satisfied', 'very_satisfied')),
  processed_at TIMESTAMPTZ,
  
  CONSTRAINT valid_completion CHECK (completed_at IS NULL OR completed_at >= started_at)
);

-- Individual feedback responses
CREATE TABLE feedback_responses (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id UUID NOT NULL REFERENCES feedback_sessions(id) ON DELETE CASCADE,
  question_key TEXT NOT NULL,
  question_text TEXT NOT NULL,
  question_type TEXT NOT NULL CHECK (question_type IN ('nps', 'rating', 'text', 'choice', 'boolean')),
  
  -- Response values (only one should be populated based on question_type)
  nps_score INTEGER CHECK (nps_score >= 0 AND nps_score <= 10),
  rating_value INTEGER CHECK (rating_value >= 1 AND rating_value <= 5),
  text_value TEXT,
  choice_value TEXT,
  boolean_value BOOLEAN,
  
  -- Response metadata
  responded_at TIMESTAMPTZ DEFAULT NOW(),
  time_to_respond_seconds INTEGER,
  question_order INTEGER,
  is_required BOOLEAN DEFAULT FALSE,
  
  -- Analysis
  sentiment_score DECIMAL(3,2), -- For text responses
  keywords TEXT[],
  themes TEXT[],
  
  CONSTRAINT single_response_value CHECK (
    (nps_score IS NOT NULL)::int + 
    (rating_value IS NOT NULL)::int + 
    (text_value IS NOT NULL)::int + 
    (choice_value IS NOT NULL)::int + 
    (boolean_value IS NOT NULL)::int = 1
  )
);

-- NPS specific tracking
CREATE TABLE nps_surveys (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id),
  session_id UUID REFERENCES feedback_sessions(id),
  
  -- NPS core data
  score INTEGER NOT NULL CHECK (score >= 0 AND score <= 10),
  category TEXT NOT NULL CHECK (category IN ('detractor', 'passive', 'promoter')),
  feedback_text TEXT,
  
  -- Survey metadata
  triggered_at TIMESTAMPTZ DEFAULT NOW(),
  trigger_reason TEXT NOT NULL,
  completed_at TIMESTAMPTZ,
  reminder_sent_at TIMESTAMPTZ,
  
  -- Follow-up actions
  follow_up_scheduled BOOLEAN DEFAULT FALSE,
  follow_up_completed BOOLEAN DEFAULT FALSE,
  follow_up_type TEXT CHECK (follow_up_type IN ('support_contact', 'thank_you_email', 'referral_invite', 'product_demo')),
  follow_up_scheduled_at TIMESTAMPTZ,
  follow_up_completed_at TIMESTAMPTZ,
  
  -- Context
  user_journey_stage TEXT, -- 'onboarding', 'active', 'power_user', 'at_risk'
  recent_feature_usage JSONB DEFAULT '{}'::jsonb,
  recent_support_interactions INTEGER DEFAULT 0
);

-- Feature-specific feedback
CREATE TABLE feature_feedback (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id),
  session_id UUID REFERENCES feedback_sessions(id),
  
  -- Feature identification
  feature_name TEXT NOT NULL,
  feature_version TEXT,
  usage_context TEXT,
  
  -- Feedback ratings
  satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
  ease_of_use_rating INTEGER CHECK (ease_of_use_rating >= 1 AND ease_of_use_rating <= 5),
  value_rating INTEGER CHECK (value_rating >= 1 AND value_rating <= 5),
  
  -- Usage patterns
  usage_frequency TEXT CHECK (usage_frequency IN ('daily', 'weekly', 'monthly', 'rarely', 'first_time')),
  feature_discovery_method TEXT CHECK (feature_discovery_method IN ('tooltip', 'onboarding', 'exploration', 'support', 'documentation')),
  
  -- Detailed feedback
  liked_aspects TEXT,
  disliked_aspects TEXT,
  improvement_suggestions TEXT,
  missing_functionality TEXT,
  would_recommend BOOLEAN,
  
  -- Wedding industry specific
  wedding_phase TEXT CHECK (wedding_phase IN ('planning', 'week_of', 'day_of', 'post_wedding')),
  vendor_type TEXT, -- for suppliers
  client_context TEXT, -- additional context about the wedding/client
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Feedback triggers and rules
CREATE TABLE feedback_triggers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  trigger_name TEXT UNIQUE NOT NULL,
  trigger_type TEXT NOT NULL CHECK (trigger_type IN ('event', 'time', 'usage', 'milestone', 'behavior')),
  
  -- Trigger conditions
  event_name TEXT,
  condition_sql TEXT,
  condition_parameters JSONB DEFAULT '{}'::jsonb,
  
  -- Feedback configuration
  feedback_type TEXT NOT NULL,
  questions JSONB NOT NULL,
  sampling_rate DECIMAL(3,2) DEFAULT 1.00, -- 0.0 to 1.0
  
  -- Rate limiting
  min_days_between INTEGER DEFAULT 30,
  max_per_user_per_month INTEGER DEFAULT 2,
  
  -- User targeting
  target_user_types TEXT[],
  target_tiers TEXT[],
  exclude_recent_feedback_days INTEGER DEFAULT 7,
  
  -- Status
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Aggregated feedback analytics
CREATE TABLE feedback_analytics_daily (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  date DATE NOT NULL,
  
  -- NPS metrics
  nps_score DECIMAL(5,2),
  nps_responses INTEGER DEFAULT 0,
  promoters_count INTEGER DEFAULT 0,
  passives_count INTEGER DEFAULT 0,
  detractors_count INTEGER DEFAULT 0,
  
  -- CSAT metrics
  csat_avg DECIMAL(3,2),
  csat_responses INTEGER DEFAULT 0,
  
  -- CES metrics  
  ces_avg DECIMAL(3,2),
  ces_responses INTEGER DEFAULT 0,
  
  -- Sentiment analysis
  sentiment_avg DECIMAL(3,2),
  sentiment_positive INTEGER DEFAULT 0,
  sentiment_neutral INTEGER DEFAULT 0,
  sentiment_negative INTEGER DEFAULT 0,
  
  -- Response rates
  surveys_triggered INTEGER DEFAULT 0,
  surveys_completed INTEGER DEFAULT 0,
  completion_rate DECIMAL(5,2) DEFAULT 0.00,
  
  -- Segmentation
  metrics_by_user_type JSONB DEFAULT '{}'::jsonb,
  metrics_by_tier JSONB DEFAULT '{}'::jsonb,
  metrics_by_feature JSONB DEFAULT '{}'::jsonb,
  
  -- Trends (vs previous period)
  nps_trend DECIMAL(5,2),
  csat_trend DECIMAL(5,2),
  sentiment_trend DECIMAL(5,2),
  
  UNIQUE(date)
);

-- Indexes for performance
CREATE INDEX idx_feedback_sessions_user_type ON feedback_sessions(user_id, session_type, started_at DESC);
CREATE INDEX idx_feedback_sessions_completion ON feedback_sessions(completed_at, completion_rate) WHERE completed_at IS NOT NULL;
CREATE INDEX idx_feedback_responses_session ON feedback_responses(session_id, responded_at);
CREATE INDEX idx_nps_surveys_score_date ON nps_surveys(score, completed_at DESC) WHERE completed_at IS NOT NULL;
CREATE INDEX idx_nps_surveys_user_recent ON nps_surveys(user_id, triggered_at DESC);
CREATE INDEX idx_feature_feedback_feature ON feature_feedback(feature_name, satisfaction_rating, created_at DESC);
CREATE INDEX idx_feedback_triggers_active ON feedback_triggers(is_active, trigger_type) WHERE is_active = TRUE;
CREATE INDEX idx_feedback_analytics_date ON feedback_analytics_daily(date DESC);

-- GIN indexes for JSON fields
CREATE INDEX idx_feedback_sessions_context ON feedback_sessions USING GIN(trigger_context);
CREATE INDEX idx_feedback_responses_keywords ON feedback_responses USING GIN(keywords);
CREATE INDEX idx_feature_feedback_wedding ON feature_feedback(wedding_phase, vendor_type, user_id);
```

#### API Endpoints Required
```typescript
// GET /api/feedback/triggers
interface FeedbackTriggersResponse {
  activePrompt?: FeedbackPrompt;
  eligibleSurveys: EligibleSurvey[];
  rateLimitStatus: {
    remainingThisMonth: number;
    nextEligibleDate: string;
  };
}

// POST /api/feedback/session/start
interface StartFeedbackSessionRequest {
  triggerType: 'manual' | 'automatic';
  feedbackType: 'nps' | 'csat' | 'feature' | 'general';
  context?: {
    featureName?: string;
    page?: string;
    userAction?: string;
  };
}

interface StartFeedbackSessionResponse {
  sessionId: string;
  questions: FeedbackQuestion[];
  estimatedTimeMinutes: number;
  incentive?: {
    type: 'discount' | 'feature_preview' | 'priority_support';
    description: string;
  };
}

// POST /api/feedback/session/[sessionId]/respond
interface SubmitFeedbackResponse {
  sessionId: string;
  questionKey: string;
  response: {
    npsScore?: number;
    rating?: number;
    text?: string;
    choice?: string;
    boolean?: boolean;
  };
  timeSpent: number; // seconds
}

// POST /api/feedback/session/[sessionId]/complete
interface CompleteFeedbackSessionRequest {
  sessionId: string;
  additionalContext?: Record<string, any>;
}

// GET /api/feedback/nps/trends
interface NPSTrendsResponse {
  current: {
    score: number;
    responses: number;
    promoters: number;
    passives: number;
    detractors: number;
  };
  trends: {
    period: string;
    score: number;
    change: number;
  }[];
  bySegment: {
    userType: Record<string, number>;
    tier: Record<string, number>;
  };
  benchmark: {
    industry: number;
    saas: number;
  };
}

// GET /api/admin/feedback/analytics
interface FeedbackAnalyticsResponse {
  overview: {
    totalResponses: number;
    avgNPS: number;
    avgCSAT: number;
    completionRate: number;
    responseRate: number;
  };
  trends: {
    nps: TimeSeries[];
    csat: TimeSeries[];
    volume: TimeSeries[];
    sentiment: TimeSeries[];
  };
  insights: {
    topIssues: Issue[];
    improvementOpportunities: Opportunity[];
    positiveThemes: Theme[];
    actionItems: ActionItem[];
  };
  segmentation: {
    byUserType: SegmentData;
    byTier: SegmentData;
    byFeature: SegmentData;
  };
}
```

#### Frontend Components Required
```typescript
// Component: FeedbackWidget
// Location: /src/components/feedback/FeedbackWidget.tsx

interface FeedbackWidgetProps {
  position?: 'bottom-right' | 'bottom-left' | 'top-right' | 'top-left';
  autoTrigger?: boolean;
  customTriggers?: string[]; // CSS selectors for custom trigger elements
}

// Key functionality:
- Floating feedback button with notification badge for pending surveys
- Modal-based feedback collection with multi-step flows
- Contextual triggering based on user actions and page navigation
- Progress indicators and estimated completion time
- Smooth animations and micro-interactions
- Responsive design for mobile and desktop
- Accessibility compliance (ARIA labels, keyboard navigation)
- Integration with user preferences and survey fatigue prevention

// Component: NPSFeedback
// Location: /src/components/feedback/NPSFeedback.tsx

interface NPSFeedbackProps {
  sessionId: string;
  onComplete: (score: number, feedback?: string) => void;
  onSkip?: () => void;
  customization?: {
    brandColor?: string;
    logoUrl?: string;
    thankYouMessage?: string;
  };
}

// Key functionality:
- Interactive 0-10 NPS scale with hover effects
- Dynamic follow-up questions based on score (detractor/passive/promoter)
- Wedding industry specific context in questions
- Real-time character count for text feedback
- Smart validation and error handling
- Thank you message with next steps based on score category

// Component: FeatureFeedback
// Location: /src/components/feedback/FeatureFeedback.tsx

interface FeatureFeedbackProps {
  featureName: string;
  sessionId: string;
  usageContext?: string;
  onComplete: (feedback: FeatureFeedbackData) => void;
}

// Key functionality:
- Multi-dimensional rating system (satisfaction, ease, value)
- Usage frequency and discovery method collection
- Wedding-specific context questions
- Structured feedback for improvements and missing features
- Visual rating components with clear labeling
- Progress tracking through multi-step form
```

#### Integration Points
```typescript
// Service: FeedbackCollector
// Dependencies: User analytics, event tracking, notification system

class FeedbackCollector {
  private static instance: FeedbackCollector;
  private activeSessions: Map<string, FeedbackSession> = new Map();
  private rateLimiter: FeedbackRateLimiter;
  private analyticsEngine: FeedbackAnalyticsEngine;

  async startFeedbackSession(request: StartFeedbackRequest): Promise<FeedbackSession> {
    // 1. Check user eligibility and rate limits
    const eligibility = await this.checkEligibility(request.userId, request.feedbackType);
    if (!eligibility.eligible) {
      throw new Error(`Feedback not eligible: ${eligibility.reason}`);
    }

    // 2. Get user context for personalization
    const userContext = await this.getUserContext(request.userId);

    // 3. Create feedback session
    const session: FeedbackSession = {
      id: generateId(),
      userId: request.userId,
      type: request.feedbackType,
      triggerReason: request.triggerReason,
      triggerContext: request.context || {},
      
      startedAt: new Date(),
      userType: userContext.userType,
      userTier: userContext.tier,
      accountAgeDays: userContext.accountAge,
      engagementScore: userContext.engagement,
      
      deviceType: request.deviceInfo?.type,
      browser: request.deviceInfo?.browser,
      sessionDuration: 0,
      pageUrl: request.context?.page,
      
      questions: [],
      responses: [],
      status: 'active'
    };

    // 4. Generate dynamic questions based on context
    session.questions = await this.generateQuestions(session);

    // 5. Save session to database
    await this.saveFeedbackSession(session);

    // 6. Track session start
    this.activeSessions.set(session.id, session);
    await this.trackFeedbackEvent('session_started', session);

    return session;
  }

  private async generateQuestions(session: FeedbackSession): Promise<FeedbackQuestion[]> {
    const questions: FeedbackQuestion[] = [];

    switch (session.type) {
      case 'nps':
        questions.push({
          key: 'nps_score',
          type: 'nps',
          text: 'How likely are you to recommend WedSync to a friend or colleague?',
          required: true,
          order: 1
        });

        // Dynamic follow-up based on user type
        if (session.userType === 'supplier') {
          questions.push({
            key: 'nps_reason',
            type: 'text',
            text: 'What\'s the main reason for your score? How has WedSync impacted your wedding business?',
            required: false,
            order: 2,
            dependsOn: 'nps_score'
          });
        } else {
          questions.push({
            key: 'nps_reason',
            type: 'text',
            text: 'What\'s the main reason for your score? How has WedSync helped with your wedding planning?',
            required: false,
            order: 2,
            dependsOn: 'nps_score'
          });
        }
        break;

      case 'feature':
        const featureName = session.triggerContext.featureName;
        questions.push(
          {
            key: 'feature_satisfaction',
            type: 'rating',
            text: `How satisfied are you with the ${featureName} feature?`,
            scale: 5,
            labels: ['Very Dissatisfied', 'Dissatisfied', 'Neutral', 'Satisfied', 'Very Satisfied'],
            required: true,
            order: 1
          },
          {
            key: 'feature_ease',
            type: 'rating',
            text: `How easy is the ${featureName} feature to use?`,
            scale: 5,
            labels: ['Very Difficult', 'Difficult', 'Neutral', 'Easy', 'Very Easy'],
            required: true,
            order: 2
          },
          {
            key: 'feature_value',
            type: 'rating',
            text: `How valuable is the ${featureName} feature to your workflow?`,
            scale: 5,
            labels: ['Not Valuable', 'Slightly Valuable', 'Moderately Valuable', 'Very Valuable', 'Extremely Valuable'],
            required: true,
            order: 3
          },
          {
            key: 'usage_frequency',
            type: 'choice',
            text: `How often do you use the ${featureName} feature?`,
            choices: ['Daily', 'Weekly', 'Monthly', 'Rarely', 'This is my first time'],
            required: true,
            order: 4
          },
          {
            key: 'feature_suggestions',
            type: 'text',
            text: 'Any suggestions for improving this feature?',
            required: false,
            order: 5,
            placeholder: 'What would make this feature even better for your wedding business/planning?'
          }
        );
        break;

      case 'onboarding':
        if (session.accountAgeDays <= 7) {
          questions.push(
            {
              key: 'onboarding_ease',
              type: 'rating',
              text: 'How easy was it to get started with WedSync?',
              scale: 5,
              required: true,
              order: 1
            },
            {
              key: 'setup_time',
              type: 'choice',
              text: 'How long did it take to create your first form/setup?',
              choices: ['Less than 5 minutes', '5-15 minutes', '15-30 minutes', '30-60 minutes', 'More than 1 hour'],
              required: true,
              order: 2
            },
            {
              key: 'confusion_points',
              type: 'text',
              text: 'Was anything confusing or difficult during setup?',
              required: false,
              order: 3,
              placeholder: 'Help us improve the onboarding experience...'
            }
          );
        }
        break;
    }

    // Add wedding industry context questions for relevant feedback types
    if (session.userType === 'supplier' && ['nps', 'feature'].includes(session.type)) {
      questions.push({
        key: 'wedding_phase_context',
        type: 'choice',
        text: 'What phase of the wedding process are most of your current clients in?',
        choices: ['Initial Planning (12+ months out)', 'Active Planning (6-12 months)', 'Final Details (1-6 months)', 'Week of Wedding', 'Post-Wedding'],
        required: false,
        order: 99
      });
    }

    return questions.sort((a, b) => a.order - b.order);
  }

  async submitResponse(sessionId: string, questionKey: string, response: any): Promise<void> {
    const session = this.activeSessions.get(sessionId);
    if (!session) {
      throw new Error('Invalid session ID');
    }

    const question = session.questions.find(q => q.key === questionKey);
    if (!question) {
      throw new Error('Invalid question key');
    }

    // Validate response based on question type
    const validatedResponse = this.validateResponse(question, response);

    // Create response record
    const feedbackResponse: FeedbackResponse = {
      id: generateId(),
      sessionId,
      questionKey,
      questionText: question.text,
      questionType: question.type,
      ...validatedResponse,
      respondedAt: new Date(),
      timeToRespond: response.timeSpent || 0,
      questionOrder: question.order
    };

    // Save to database
    await this.saveFeedbackResponse(feedbackResponse);

    // Add to session
    session.responses.push(feedbackResponse);

    // Check if session is complete
    const requiredQuestions = session.questions.filter(q => q.required);
    const answeredRequired = session.responses.filter(r => 
      requiredQuestions.find(q => q.key === r.questionKey)
    );

    if (answeredRequired.length >= requiredQuestions.length) {
      await this.completeFeedbackSession(sessionId);
    }

    // Track response
    await this.trackFeedbackEvent('response_submitted', session, {
      questionKey,
      questionType: question.type,
      responseTime: response.timeSpent
    });
  }

  private async completeFeedbackSession(sessionId: string): Promise<void> {
    const session = this.activeSessions.get(sessionId);
    if (!session) return;

    session.completedAt = new Date();
    session.status = 'completed';
    session.completionRate = session.responses.length / session.questions.length;

    // Analyze feedback
    const analysis = await this.analyzeFeedback(session);
    session.overallSentiment = analysis.sentiment;
    session.satisfactionCategory = analysis.category;

    // Save session updates
    await this.updateFeedbackSession(session);

    // Process specific feedback types
    if (session.type === 'nps') {
      await this.processNPSFeedback(session);
    } else if (session.type === 'feature') {
      await this.processFeatureFeedback(session);
    }

    // Trigger follow-up actions
    await this.triggerFollowUpActions(session, analysis);

    // Remove from active sessions
    this.activeSessions.delete(sessionId);

    // Track completion
    await this.trackFeedbackEvent('session_completed', session, {
      completionRate: session.completionRate,
      sentiment: analysis.sentiment,
      category: analysis.category
    });
  }

  private async triggerFollowUpActions(session: FeedbackSession, analysis: FeedbackAnalysis): Promise<void> {
    // Negative feedback follow-up
    if (analysis.sentiment < -0.3 || analysis.hasDetractorScore) {
      await this.createSupportTicket({
        userId: session.userId,
        priority: 'high',
        type: 'feedback_followup',
        subject: 'Follow-up on Recent Feedback',
        description: `User provided negative feedback: ${analysis.summary}`,
        assignTo: 'customer_success',
        metadata: { sessionId, feedbackType: session.type }
      });

      await this.scheduleFollowUpEmail({
        userId: session.userId,
        template: 'negative_feedback_followup',
        delay: '2 hours',
        context: { feedbackSummary: analysis.summary }
      });
    }

    // Promoter actions
    if (analysis.hasPromoterScore) {
      await this.scheduleFollowUpEmail({
        userId: session.userId,
        template: 'promoter_thank_you',
        delay: '1 hour',
        context: { feedbackHighlights: analysis.positives }
      });

      // Add to referral program if not already a member
      if (!await this.isInReferralProgram(session.userId)) {
        await this.addToReferralProgram(session.userId);
      }
    }

    // Feature improvement suggestions
    if (analysis.improvementSuggestions.length > 0) {
      await this.createFeatureRequests(analysis.improvementSuggestions, session.userId);
    }
  }
}

// Service: NPSManager with wedding industry specifics
class NPSManager {
  async calculateWeddingIndustryNPS(timeframe: 'monthly' | 'quarterly' | 'yearly' = 'quarterly'): Promise<NPSMetrics> {
    const surveys = await this.getNPSSurveys(timeframe);

    // Overall NPS calculation
    const promoters = surveys.filter(s => s.score >= 9).length;
    const detractors = surveys.filter(s => s.score <= 6).length;
    const total = surveys.length;
    const npsScore = total > 0 ? Math.round(((promoters - detractors) / total) * 100) : 0;

    // Wedding industry segmentation
    const supplierNPS = this.calculateSegmentNPS(surveys.filter(s => s.userType === 'supplier'));
    const coupleNPS = this.calculateSegmentNPS(surveys.filter(s => s.userType === 'couple'));

    // Vendor type breakdown for suppliers
    const vendorTypes = ['photographer', 'planner', 'venue', 'florist', 'dj', 'caterer'];
    const vendorNPS: Record<string, number> = {};
    
    for (const vendorType of vendorTypes) {
      const vendorSurveys = surveys.filter(s => 
        s.userType === 'supplier' && 
        s.metadata?.vendorType === vendorType
      );
      vendorNPS[vendorType] = this.calculateSegmentNPS(vendorSurveys).score;
    }

    // Wedding season analysis
    const weddingSeason = surveys.filter(s => this.isWeddingSeason(s.completedAt));
    const offSeason = surveys.filter(s => !this.isWeddingSeason(s.completedAt));

    return {
      overall: {
        score: npsScore,
        promoters,
        passives: total - promoters - detractors,
        detractors,
        totalResponses: total,
        responseRate: await this.calculateResponseRate(timeframe)
      },
      segments: {
        supplier: supplierNPS,
        couple: coupleNPS,
        vendorTypes: vendorNPS
      },
      seasonality: {
        weddingSeason: this.calculateSegmentNPS(weddingSeason),
        offSeason: this.calculateSegmentNPS(offSeason)
      },
      trends: await this.calculateNPSTrends(timeframe),
      benchmarks: {
        industry: 42, // Wedding industry average
        saas: 31,     // SaaS industry average
        target: 50    // Our target NPS
      }
    };
  }

  private isWeddingSeason(date: Date): boolean {
    const month = date.getMonth() + 1;
    return [5, 6, 7, 9, 10].includes(month); // May, June, July, September, October
  }
}
```

### CODE EXAMPLES

#### Example 1: Complete Feedback Collection System
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { supabase } from '@/lib/supabase';
import { OpenAIService } from '@/lib/services/openai-service';

export interface FeedbackSession {
  id: string;
  userId: string;
  type: 'nps' | 'csat' | 'ces' | 'feature' | 'onboarding' | 'churn' | 'general';
  triggerReason: string;
  triggerContext: Record<string, any>;
  
  startedAt: Date;
  completedAt: Date | null;
  abandonedAt: Date | null;
  
  userType: 'supplier' | 'couple';
  userTier: string;
  accountAgeDays: number;
  engagementScore: number;
  
  deviceType: string;
  browser: string;
  sessionDuration: number;
  pageUrl: string;
  
  questions: FeedbackQuestion[];
  responses: FeedbackResponse[];
  
  overallSentiment: number | null;
  satisfactionCategory: string | null;
  completionRate: number;
  status: 'active' | 'completed' | 'abandoned';
}

export class FeedbackCollector {
  private static instance: FeedbackCollector;
  private activeSessions: Map<string, FeedbackSession> = new Map();
  private rateLimiter: FeedbackRateLimiter;
  private sentimentAnalyzer: SentimentAnalyzer;

  static getInstance(): FeedbackCollector {
    if (!FeedbackCollector.instance) {
      FeedbackCollector.instance = new FeedbackCollector();
    }
    return FeedbackCollector.instance;
  }

  constructor() {
    this.rateLimiter = new FeedbackRateLimiter();
    this.sentimentAnalyzer = new SentimentAnalyzer();
  }

  async checkFeedbackEligibility(userId: string, feedbackType: string): Promise<EligibilityResult> {
    try {
      // 1. Check rate limits
      const rateLimitCheck = await this.rateLimiter.checkUserLimit(userId, feedbackType);
      if (!rateLimitCheck.allowed) {
        return {
          eligible: false,
          reason: 'rate_limited',
          details: `Next eligible: ${rateLimitCheck.nextEligibleDate}`,
          retryAfter: rateLimitCheck.retryAfter
        };
      }

      // 2. Check recent feedback fatigue
      const recentFeedback = await this.getRecentFeedback(userId, 7); // Last 7 days
      if (recentFeedback.length >= 2) {
        return {
          eligible: false,
          reason: 'feedback_fatigue',
          details: 'User has provided feedback recently'
        };
      }

      // 3. Check account age and engagement
      const userContext = await this.getUserContext(userId);
      
      if (feedbackType === 'nps' && userContext.accountAge < 7) {
        return {
          eligible: false,
          reason: 'account_too_new',
          details: 'Account must be at least 7 days old for NPS'
        };
      }

      if (userContext.engagement < 0.1) {
        return {
          eligible: false,
          reason: 'low_engagement',
          details: 'User engagement too low for meaningful feedback'
        };
      }

      // 4. Wedding industry specific checks
      if (userContext.userType === 'supplier') {
        const hasActiveClients = await this.hasActiveClients(userId);
        if (!hasActiveClients && ['nps', 'feature'].includes(feedbackType)) {
          return {
            eligible: false,
            reason: 'no_active_usage',
            details: 'Supplier has no active clients for meaningful feedback'
          };
        }
      }

      return {
        eligible: true,
        reason: 'eligible',
        samplingRate: await this.calculateSamplingRate(userId, feedbackType)
      };

    } catch (error) {
      console.error('Error checking feedback eligibility:', error);
      return {
        eligible: false,
        reason: 'error',
        details: error.message
      };
    }
  }

  async startFeedbackSession(request: StartFeedbackRequest): Promise<FeedbackSession> {
    console.log(`Starting feedback session for user ${request.userId}:`, request.feedbackType);

    // 1. Validate eligibility
    const eligibility = await this.checkFeedbackEligibility(request.userId, request.feedbackType);
    if (!eligibility.eligible) {
      throw new Error(`Feedback not eligible: ${eligibility.reason} - ${eligibility.details}`);
    }

    // 2. Get comprehensive user context
    const userContext = await this.getUserContext(request.userId);

    // 3. Create session with wedding industry context
    const session: FeedbackSession = {
      id: generateId(),
      userId: request.userId,
      type: request.feedbackType,
      triggerReason: request.triggerReason || 'manual',
      triggerContext: {
        ...request.context,
        timestamp: new Date().toISOString(),
        userAgent: request.userAgent,
        referrer: request.referrer
      },

      startedAt: new Date(),
      completedAt: null,
      abandonedAt: null,

      userType: userContext.userType,
      userTier: userContext.tier,
      accountAgeDays: userContext.accountAge,
      engagementScore: userContext.engagement,

      deviceType: request.deviceInfo?.type || 'unknown',
      browser: request.deviceInfo?.browser || 'unknown',
      sessionDuration: 0,
      pageUrl: request.context?.page || '',

      questions: [],
      responses: [],

      overallSentiment: null,
      satisfactionCategory: null,
      completionRate: 0,
      status: 'active'
    };

    // 4. Generate contextual questions
    session.questions = await this.generateContextualQuestions(session, userContext);

    // 5. Save to database with wedding context
    await this.saveFeedbackSession(session);

    // 6. Track session start with detailed context
    this.activeSessions.set(session.id, session);
    await this.trackFeedbackEvent('session_started', {
      sessionId: session.id,
      userId: session.userId,
      feedbackType: session.type,
      triggerReason: session.triggerReason,
      userType: session.userType,
      userTier: session.userTier,
      questionsCount: session.questions.length,
      weddingContext: this.extractWeddingContext(userContext)
    });

    console.log(`Feedback session ${session.id} started:`, {
      type: session.type,
      questionsCount: session.questions.length,
      userContext: { type: session.userType, tier: session.userTier }
    });

    return session;
  }

  private async generateContextualQuestions(session: FeedbackSession, userContext: UserContext): Promise<FeedbackQuestion[]> {
    const questions: FeedbackQuestion[] = [];

    switch (session.type) {
      case 'nps':
        // Core NPS question
        questions.push({
          key: 'nps_score',
          type: 'nps',
          text: 'How likely are you to recommend WedSync to a friend or colleague?',
          required: true,
          order: 1,
          helpText: 'Your honest feedback helps us improve our service for the wedding community.'
        });

        // Wedding industry specific follow-up
        if (session.userType === 'supplier') {
          questions.push({
            key: 'nps_business_impact',
            type: 'text',
            text: 'How has WedSync impacted your wedding business? What\'s the main reason for your score?',
            required: false,
            order: 2,
            dependsOn: 'nps_score',
            placeholder: 'e.g., "Helped me organize client information better", "Made communication with couples easier"...',
            maxLength: 500
          });

          if (userContext.vendorType) {
            questions.push({
              key: 'vendor_specific_feedback',
              type: 'text',
              text: `As a ${userContext.vendorType}, what features are most valuable to your workflow?`,
              required: false,
              order: 3,
              placeholder: 'Tell us what works best for your specific type of wedding business...'
            });
          }
        } else {
          questions.push({
            key: 'nps_planning_impact',
            type: 'text',
            text: 'How has WedSync helped with your wedding planning? What\'s the main reason for your score?',
            required: false,
            order: 2,
            dependsOn: 'nps_score',
            placeholder: 'e.g., "Made it easier to communicate with vendors", "Helped keep track of everything"...',
            maxLength: 500
          });
        }

        // General improvement question
        questions.push({
          key: 'improvement_priority',
          type: 'choice',
          text: 'If we could improve one thing, what would have the biggest impact for you?',
          choices: [
            'Easier form creation',
            'Better client communication',
            'More customization options',
            'Mobile app improvements',
            'Integration with other tools',
            'Better reporting/analytics',
            'Faster performance',
            'Other'
          ],
          required: false,
          order: 4
        });
        break;

      case 'feature':
        const featureName = session.triggerContext.featureName;
        const featureUsage = userContext.featureUsage?.[featureName] || {};

        questions.push(
          {
            key: 'feature_satisfaction',
            type: 'rating',
            text: `How satisfied are you with the ${featureName} feature?`,
            scale: 5,
            labels: ['Very Dissatisfied', 'Dissatisfied', 'Neutral', 'Satisfied', 'Very Satisfied'],
            required: true,
            order: 1
          },
          {
            key: 'feature_ease',
            type: 'rating',
            text: `How easy is the ${featureName} feature to use?`,
            scale: 5,
            labels: ['Very Difficult', 'Difficult', 'Neutral', 'Easy', 'Very Easy'],
            required: true,
            order: 2
          },
          {
            key: 'feature_wedding_value',
            type: 'rating',
            text: `How valuable is this feature for your ${session.userType === 'supplier' ? 'wedding business' : 'wedding planning'}?`,
            scale: 5,
            labels: ['Not Valuable', 'Slightly Valuable', 'Moderately Valuable', 'Very Valuable', 'Extremely Valuable'],
            required: true,
            order: 3
          },
          {
            key: 'usage_frequency',
            type: 'choice',
            text: `How often do you use the ${featureName} feature?`,
            choices: ['Daily', 'Weekly', 'Monthly', 'Rarely', 'This is my first time'],
            required: true,
            order: 4
          }
        );

        // Context-specific questions based on feature
        if (featureName === 'form_builder') {
          questions.push({
            key: 'form_builder_pain_points',
            type: 'text',
            text: 'What\'s the most challenging part about creating forms for your clients/wedding?',
            required: false,
            order: 5,
            placeholder: 'e.g., "Setting up guest information fields", "Customizing the design"...'
          });
        } else if (featureName === 'journey_canvas') {
          questions.push({
            key: 'journey_canvas_usage',
            type: 'choice',
            text: 'What do you primarily use the Journey Canvas for?',
            choices: [
              'Planning wedding timeline',
              'Client communication workflow',
              'Vendor coordination',
              'Task management',
              'Other'
            ],
            required: false,
            order: 5
          });
        }

        // Improvement suggestions
        questions.push({
          key: 'feature_improvements',
          type: 'text',
          text: `What improvements would make the ${featureName} feature even better for your needs?`,
          required: false,
          order: 6,
          placeholder: 'Any specific features, integrations, or changes that would help...',
          maxLength: 300
        });
        break;

      case 'onboarding':
        if (session.accountAgeDays <= 14) {
          questions.push(
            {
              key: 'onboarding_overall_ease',
              type: 'rating',
              text: 'How easy was it to get started with WedSync?',
              scale: 5,
              labels: ['Very Difficult', 'Difficult', 'Neutral', 'Easy', 'Very Easy'],
              required: true,
              order: 1
            },
            {
              key: 'setup_completion_time',
              type: 'choice',
              text: 'How long did it take to complete your initial setup?',
              choices: [
                'Less than 5 minutes',
                '5-15 minutes',
                '15-30 minutes',
                '30-60 minutes',
                'More than 1 hour',
                'Still working on it'
              ],
              required: true,
              order: 2
            },
            {
              key: 'onboarding_confusion',
              type: 'text',
              text: 'Was anything confusing or difficult during the onboarding process?',
              required: false,
              order: 3,
              placeholder: 'Help us improve the experience for future users...',
              maxLength: 300
            },
            {
              key: 'onboarding_help_needed',
              type: 'choice',
              text: 'Did you need to look for help or support during onboarding?',
              choices: [
                'No, everything was clear',
                'Used help documentation',
                'Watched tutorial videos',
                'Contacted support',
                'Asked someone else for help',
                'Gave up and tried later'
              ],
              required: false,
              order: 4
            }
          );

          // Wedding industry specific onboarding questions
          if (session.userType === 'supplier') {
            questions.push({
              key: 'business_setup_completion',
              type: 'choice',
              text: 'Which parts of your wedding business setup have you completed?',
              choices: [
                'Basic profile information',
                'Service offerings',
                'Client form templates',
                'Journey workflows',
                'Email templates',
                'Nothing yet'
              ],
              multiple: true,
              required: false,
              order: 5
            });
          }
        }
        break;

      case 'churn':
        questions.push(
          {
            key: 'leaving_reason',
            type: 'choice',
            text: 'What\'s the main reason you\'re considering leaving or reducing your use of WedSync?',
            choices: [
              'Too expensive for my needs',
              'Missing features I need',
              'Too complicated to use',
              'Not enough clients/bookings',
              'Found a better alternative',
              'Business priorities changed',
              'Technical issues',
              'Other'
            ],
            required: true,
            order: 1
          },
          {
            key: 'alternative_solution',
            type: 'text',
            text: 'Are you switching to another service? If so, what attracted you to it?',
            required: false,
            order: 2,
            placeholder: 'This helps us understand what we might be missing...'
          },
          {
            key: 'retention_features',
            type: 'text',
            text: 'What features or improvements would have convinced you to stay?',
            required: false,
            order: 3,
            placeholder: 'Your input could help us build what wedding professionals really need...'
          },
          {
            key: 'overall_experience_rating',
            type: 'rating',
            text: 'How would you rate your overall experience with WedSync?',
            scale: 5,
            labels: ['Very Poor', 'Poor', 'Average', 'Good', 'Excellent'],
            required: true,
            order: 4
          }
        );
        break;
    }

    // Add wedding context question for relevant feedback types
    if (['nps', 'feature', 'general'].includes(session.type) && session.userType === 'supplier') {
      questions.push({
        key: 'current_wedding_season',
        type: 'choice',
        text: 'How busy is your current wedding season?',
        choices: [
          'Very busy (peak season)',
          'Moderately busy',
          'Slow season',
          'Just getting started',
          'Off-season/break'
        ],
        required: false,
        order: 99,
        helpText: 'This helps us understand the context of your feedback'
      });
    }

    return questions.sort((a, b) => a.order - b.order);
  }

  async submitResponse(sessionId: string, questionKey: string, response: any, timeSpent: number = 0): Promise<void> {
    const session = this.activeSessions.get(sessionId);
    if (!session) {
      throw new Error(`Invalid session ID: ${sessionId}`);
    }

    const question = session.questions.find(q => q.key === questionKey);
    if (!question) {
      throw new Error(`Invalid question key: ${questionKey}`);
    }

    // Validate and process response
    const processedResponse = await this.processResponse(question, response);

    // Create response record
    const feedbackResponse: FeedbackResponse = {
      id: generateId(),
      sessionId,
      questionKey,
      questionText: question.text,
      questionType: question.type,
      ...processedResponse,
      respondedAt: new Date(),
      timeToRespond: timeSpent,
      questionOrder: question.order
    };

    // Analyze text responses for sentiment and themes
    if (processedResponse.textValue) {
      const analysis = await this.sentimentAnalyzer.analyze(processedResponse.textValue);
      feedbackResponse.sentimentScore = analysis.sentiment;
      feedbackResponse.keywords = analysis.keywords;
      feedbackResponse.themes = analysis.themes;
    }

    // Save response to database
    await this.saveFeedbackResponse(feedbackResponse);

    // Update session
    session.responses.push(feedbackResponse);
    session.completionRate = session.responses.length / session.questions.filter(q => q.required).length;

    // Check for session completion
    const requiredQuestions = session.questions.filter(q => q.required);
    const answeredRequired = session.responses.filter(r => 
      requiredQuestions.some(q => q.key === r.questionKey)
    );

    // Track response submission
    await this.trackFeedbackEvent('response_submitted', {
      sessionId,
      questionKey,
      questionType: question.type,
      responseTime: timeSpent,
      hasText: !!processedResponse.textValue,
      sentiment: feedbackResponse.sentimentScore
    });

    // Auto-complete if all required questions answered
    if (answeredRequired.length >= requiredQuestions.length) {
      await this.completeFeedbackSession(sessionId);
    }

    console.log(`Response submitted for session ${sessionId}:`, {
      questionKey,
      type: question.type,
      completionRate: session.completionRate
    });
  }

  private async completeFeedbackSession(sessionId: string): Promise<void> {
    const session = this.activeSessions.get(sessionId);
    if (!session || session.status !== 'active') {
      return;
    }

    console.log(`Completing feedback session ${sessionId}`);

    // Update session completion
    session.completedAt = new Date();
    session.status = 'completed';
    session.sessionDuration = Math.floor(
      (session.completedAt.getTime() - session.startedAt.getTime()) / 1000
    );

    // Analyze overall feedback
    const analysis = await this.analyzeFeedbackSession(session);
    session.overallSentiment = analysis.overallSentiment;
    session.satisfactionCategory = analysis.category;

    // Save session updates
    await this.updateFeedbackSession(session);

    // Process feedback type-specific actions
    switch (session.type) {
      case 'nps':
        await this.processNPSCompletion(session, analysis);
        break;
      case 'feature':
        await this.processFeatureFeedbackCompletion(session, analysis);
        break;
      case 'churn':
        await this.processChurnFeedbackCompletion(session, analysis);
        break;
    }

    // Trigger follow-up actions based on sentiment and content
    await this.triggerFollowUpActions(session, analysis);

    // Update analytics
    await this.updateFeedbackAnalytics(session, analysis);

    // Clean up
    this.activeSessions.delete(sessionId);

    // Track completion
    await this.trackFeedbackEvent('session_completed', {
      sessionId,
      completionRate: session.completionRate,
      sessionDuration: session.sessionDuration,
      overallSentiment: analysis.overallSentiment,
      category: analysis.category,
      hasNegativeFeedback: analysis.hasNegativeFeedback,
      hasActionableInsights: analysis.actionableInsights.length > 0
    });

    console.log(`Feedback session ${sessionId} completed:`, {
      type: session.type,
      duration: session.sessionDuration,
      sentiment: analysis.overallSentiment,
      category: analysis.category
    });
  }

  private async processNPSCompletion(session: FeedbackSession, analysis: FeedbackAnalysis): Promise<void> {
    const npsResponse = session.responses.find(r => r.questionKey === 'nps_score');
    if (!npsResponse || npsResponse.npsScore === null) return;

    const npsScore = npsResponse.npsScore;
    const category = npsScore >= 9 ? 'promoter' : npsScore >= 7 ? 'passive' : 'detractor';
    const feedbackText = session.responses.find(r => r.textValue)?.textValue;

    // Create NPS record
    const npsRecord = {
      id: generateId(),
      userId: session.userId,
      sessionId: session.id,
      score: npsScore,
      category,
      feedbackText,
      triggeredAt: session.startedAt,
      completedAt: session.completedAt,
      triggerReason: session.triggerReason,
      userJourneyStage: await this.getUserJourneyStage(session.userId),
      recentFeatureUsage: session.triggerContext.recentFeatureUsage || {},
      recentSupportInteractions: await this.getRecentSupportInteractions(session.userId)
    };

    await this.saveNPSSurvey(npsRecord);

    // Schedule follow-up actions based on score
    switch (category) {
      case 'detractor':
        // Immediate support outreach
        await this.createSupportTicket({
          userId: session.userId,
          priority: 'high',
          type: 'nps_detractor_followup',
          subject: `NPS Detractor Follow-up - Score: ${npsScore}`,
          description: `User gave NPS score of ${npsScore}. Feedback: ${feedbackText || 'No specific feedback provided'}`,
          assignTo: 'customer_success_lead',
          metadata: { npsSessionId: session.id, npsScore, category }
        });

        await this.scheduleEmail({
          userId: session.userId,
          template: 'nps_detractor_personal_outreach',
          delay: '30 minutes',
          context: {
            npsScore,
            feedback: feedbackText,
            userType: session.userType,
            accountTier: session.userTier
          }
        });
        break;

      case 'passive':
        // Educational content to convert to promoter
        await this.scheduleEmail({
          userId: session.userId,
          template: 'nps_passive_feature_highlights',
          delay: '2 hours',
          context: {
            npsScore,
            userType: session.userType,
            underutilizedFeatures: await this.getUnderutilizedFeatures(session.userId)
          }
        });
        break;

      case 'promoter':
        // Thank you and referral invitation
        await this.scheduleEmail({
          userId: session.userId,
          template: 'nps_promoter_thank_you_referral',
          delay: '1 hour',
          context: {
            npsScore,
            feedback: feedbackText,
            referralIncentive: await this.getReferralIncentive(session.userTier)
          }
        });

        // Add to referral program
        if (!await this.isInReferralProgram(session.userId)) {
          await this.addToReferralProgram(session.userId, {
            source: 'nps_promoter',
            npsScore,
            sessionId: session.id
          });
        }

        // Consider for testimonial/case study
        if (npsScore === 10 && feedbackText && feedbackText.length > 50) {
          await this.flagForTestimonialOutreach(session.userId, {
            npsScore,
            feedback: feedbackText,
            sessionId: session.id
          });
        }
        break;
    }
  }

  private async analyzeFeedbackSession(session: FeedbackSession): Promise<FeedbackAnalysis> {
    const textResponses = session.responses
      .filter(r => r.textValue)
      .map(r => r.textValue);

    const ratings = session.responses
      .filter(r => r.ratingValue !== null)
      .map(r => ({ key: r.questionKey, rating: r.ratingValue }));

    const npsScore = session.responses.find(r => r.npsScore !== null)?.npsScore;

    // Sentiment analysis of text responses
    const sentimentResults = await Promise.all(
      textResponses.map(text => this.sentimentAnalyzer.analyze(text))
    );

    const overallSentiment = sentimentResults.length > 0
      ? sentimentResults.reduce((sum, result) => sum + result.sentiment, 0) / sentimentResults.length
      : null;

    // Extract themes and keywords
    const allKeywords = sentimentResults.flatMap(result => result.keywords);
    const allThemes = sentimentResults.flatMap(result => result.themes);

    // Determine satisfaction category
    let category = 'neutral';
    if (npsScore !== undefined) {
      if (npsScore >= 9) category = 'very_satisfied';
      else if (npsScore >= 7) category = 'satisfied';
      else if (npsScore >= 4) category = 'neutral';
      else category = 'dissatisfied';
    } else if (overallSentiment !== null) {
      if (overallSentiment > 0.3) category = 'satisfied';
      else if (overallSentiment < -0.3) category = 'dissatisfied';
    }

    // Identify actionable insights
    const actionableInsights = await this.extractActionableInsights(session.responses);

    // Check for negative sentiment indicators
    const hasNegativeFeedback = overallSentiment < -0.2 || 
      (npsScore !== undefined && npsScore <= 6) ||
      ratings.some(r => r.rating <= 2);

    return {
      overallSentiment,
      category,
      hasNegativeFeedback,
      keywords: [...new Set(allKeywords)],
      themes: [...new Set(allThemes)],
      actionableInsights,
      summary: await this.generateFeedbackSummary(session),
      improvementSuggestions: await this.extractImprovementSuggestions(textResponses),
      positiveHighlights: await this.extractPositiveHighlights(textResponses),
      hasPromoterScore: npsScore >= 9,
      hasDetractorScore: npsScore <= 6
    };
  }
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Supabase: Feedback storage, user analytics, real-time updates
- [x] Context7: OpenAI integration for sentiment analysis and theme extraction
- [x] Filesystem: Template storage for email follow-ups

#### Context7 MCP Queries Needed
```typescript
await mcp__context7__resolve-library-id({ libraryName: "openai" });
await mcp__context7__get-library-docs({
  context7CompatibleLibraryID: "/openai/openai",
  topic: "sentiment analysis",
  tokens: 2000
});
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('FeedbackCollector', () => {
  it('should create NPS feedback session with wedding industry context', async () => {
    const collector = FeedbackCollector.getInstance();
    const request = {
      userId: 'photographer-user',
      feedbackType: 'nps',
      triggerReason: 'milestone_reached',
      userAgent: 'test-browser',
      context: { page: '/dashboard', feature: 'form_builder' }
    };
    
    const session = await collector.startFeedbackSession(request);
    
    expect(session.type).toBe('nps');
    expect(session.questions.length).toBeGreaterThan(0);
    expect(session.questions[0].key).toBe('nps_score');
    expect(session.userType).toBe('supplier');
    expect(session.status).toBe('active');
  });

  it('should enforce rate limiting for feedback requests', async () => {
    const collector = FeedbackCollector.getInstance();
    const userId = 'test-user';
    
    // Simulate recent feedback
    await createRecentFeedback(userId, 2);
    
    const eligibility = await collector.checkFeedbackEligibility(userId, 'nps');
    
    expect(eligibility.eligible).toBe(false);
    expect(eligibility.reason).toBe('feedback_fatigue');
  });

  it('should analyze sentiment and extract themes from text responses', async () => {
    const analyzer = new SentimentAnalyzer();
    const feedback = "The form builder is confusing and hard to use. I wish it was more intuitive for wedding forms.";
    
    const analysis = await analyzer.analyze(feedback);
    
    expect(analysis.sentiment).toBeLessThan(0);
    expect(analysis.themes).toContain('usability');
    expect(analysis.keywords).toContain('confusing');
  });

  it('should trigger appropriate follow-up actions for NPS detractors', async () => {
    const collector = FeedbackCollector.getInstance();
    const session = createMockSession({
      type: 'nps',
      responses: [{ questionKey: 'nps_score', npsScore: 3 }]
    });
    
    await collector.processNPSCompletion(session, mockAnalysis);
    
    // Verify support ticket creation
    expect(mockCreateSupportTicket).toHaveBeenCalledWith(
      expect.objectContaining({
        priority: 'high',
        type: 'nps_detractor_followup'
      })
    );
    
    // Verify follow-up email scheduled
    expect(mockScheduleEmail).toHaveBeenCalledWith(
      expect.objectContaining({
        template: 'nps_detractor_personal_outreach'
      })
    );
  });

  it('should calculate wedding industry NPS with vendor segmentation', async () => {
    const npsManager = new NPSManager();
    const npsMetrics = await npsManager.calculateWeddingIndustryNPS('quarterly');
    
    expect(npsMetrics.overall.score).toBeGreaterThanOrEqual(-100);
    expect(npsMetrics.overall.score).toBeLessThanOrEqual(100);
    expect(npsMetrics.segments.supplier).toBeDefined();
    expect(npsMetrics.segments.couple).toBeDefined();
    expect(npsMetrics.segments.vendorTypes.photographer).toBeDefined();
    expect(npsMetrics.seasonality.weddingSeason).toBeDefined();
    expect(npsMetrics.benchmarks.target).toBe(50);
  });
});

describe('FeedbackWidget', () => {
  it('should display contextual NPS survey with wedding industry questions', async () => {
    render(<FeedbackWidget />);
    
    // Simulate NPS trigger
    fireEvent.click(screen.getByRole('button', { name: /feedback/i }));
    
    await waitFor(() => {
      expect(screen.getByText(/how likely are you to recommend/i)).toBeInTheDocument();
    });
    
    // Select score
    fireEvent.click(screen.getByText('9'));
    
    await waitFor(() => {
      expect(screen.getByText(/impacted your wedding business/i)).toBeInTheDocument();
    });
  });

  it('should handle feature feedback with usage context', async () => {
    const onComplete = jest.fn();
    render(
      <FeatureFeedback
        featureName="form_builder"
        sessionId="test-session"
        onComplete={onComplete}
      />
    );
    
    // Rate satisfaction
    fireEvent.click(screen.getByLabelText('Satisfied'));
    
    // Rate ease of use
    fireEvent.click(screen.getByLabelText('Easy'));
    
    // Submit feedback
    fireEvent.click(screen.getByRole('button', { name: /submit/i }));
    
    expect(onComplete).toHaveBeenCalledWith(
      expect.objectContaining({
        satisfaction: 4,
        ease: 4,
        featureName: 'form_builder'
      })
    );
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('User can complete NPS survey and receive appropriate follow-up', async () => {
  await mcp__playwright__browser_navigate({url: '/dashboard'});
  
  // Trigger NPS survey (simulate reaching milestone)
  await simulateNPSTrigger('milestone_reached');
  
  // Wait for feedback widget to appear
  await mcp__playwright__browser_wait_for({text: 'How likely are you to recommend'});
  await mcp__playwright__browser_snapshot();
  
  // Select NPS score of 9 (promoter)
  await mcp__playwright__browser_click({
    element: 'NPS score 9',
    ref: '[data-score="9"]'
  });
  
  // Fill follow-up question
  await mcp__playwright__browser_type({
    element: 'NPS feedback textarea',
    ref: '[data-testid="nps-feedback"]',
    text: 'WedSync has made managing my wedding clients so much easier. The form builder saves me hours every week.'
  });
  
  // Submit feedback
  await mcp__playwright__browser_click({
    element: 'Submit feedback button',
    ref: '[data-testid="submit-feedback"]'
  });
  
  // Verify thank you message
  await mcp__playwright__browser_wait_for({text: 'Thank you for your feedback'});
  await mcp__playwright__browser_wait_for({text: 'referral program'});
  
  await mcp__playwright__browser_snapshot();
});

test('Feature feedback collection works for form builder', async () => {
  await mcp__playwright__browser_navigate({url: '/forms/builder'});
  
  // Use form builder feature multiple times to trigger feedback
  await useFormBuilderFeature(5);
  
  // Feedback prompt should appear
  await mcp__playwright__browser_wait_for({text: 'How satisfied are you with the form builder'});
  
  // Rate satisfaction
  await mcp__playwright__browser_click({
    element: 'Satisfied rating',
    ref: '[data-rating="4"]'
  });
  
  // Rate ease of use
  await mcp__playwright__browser_click({
    element: 'Easy rating',
    ref: '[data-ease="4"]'
  });
  
  // Select usage frequency
  await mcp__playwright__browser_click({
    element: 'Usage frequency dropdown',
    ref: '[data-testid="usage-frequency"]'
  });
  
  await mcp__playwright__browser_click({
    element: 'Weekly option',
    ref: '[data-value="weekly"]'
  });
  
  // Add improvement suggestion
  await mcp__playwright__browser_type({
    element: 'Suggestions textarea',
    ref: '[data-testid="feature-suggestions"]',
    text: 'Would love to see more wedding-specific form templates, especially for dietary restrictions and seating preferences.'
  });
  
  await mcp__playwright__browser_click({
    element: 'Submit feature feedback',
    ref: '[data-testid="submit-feature-feedback"]'
  });
  
  await mcp__playwright__browser_wait_for({text: 'Feedback submitted successfully'});
  await mcp__playwright__browser_snapshot();
});

test('Admin can view feedback analytics and insights', async () => {
  await mcp__playwright__browser_navigate({url: '/admin/feedback-analytics'});
  await mcp__playwright__browser_snapshot();
  
  // Check NPS metrics display
  await mcp__playwright__browser_wait_for({text: 'NPS Score'});
  await mcp__playwright__browser_wait_for({text: 'Promoters'});
  await mcp__playwright__browser_wait_for({text: 'Detractors'});
  
  // Check trend charts load
  await mcp__playwright__browser_wait_for({text: 'Feedback Trends'});
  
  // Check segmentation data
  await mcp__playwright__browser_click({
    element: 'Segmentation tab',
    ref: '[data-testid="segmentation-tab"]'
  });
  
  await mcp__playwright__browser_wait_for({text: 'By User Type'});
  await mcp__playwright__browser_wait_for({text: 'Suppliers'});
  await mcp__playwright__browser_wait_for({text: 'Couples'});
  
  // Check insights and action items
  await mcp__playwright__browser_click({
    element: 'Insights tab',
    ref: '[data-testid="insights-tab"]'
  });
  
  await mcp__playwright__browser_wait_for({text: 'Action Items'});
  await mcp__playwright__browser_wait_for({text: 'Top Issues'});
  
  await mcp__playwright__browser_snapshot();
});
```

### ACCEPTANCE CRITERIA
- [x] Multi-channel feedback collection (in-app widget, email, post-support)
- [x] AI-powered sentiment analysis with 80%+ accuracy for wedding industry terms
- [x] NPS tracking with promoter/passive/detractor segmentation and follow-up workflows
- [x] Feature-specific CSAT collection with usage context and improvement suggestions
- [x] Wedding industry specific questions and context (vendor types, seasons, client phases)
- [x] Rate limiting and feedback fatigue prevention (max 2 per user per month)
- [x] Real-time analytics dashboard with trends, segmentation, and actionable insights
- [x] Automated follow-up actions (support tickets for detractors, referral invites for promoters)
- [x] Response rate >25% for email surveys, >40% for in-app prompts
- [x] Integration with support ticket system and email automation

### DEPENDENCIES
- Must complete after: User authentication system, Email system, Support ticket system (WS-235)
- Must complete before: Referral program, Customer success automation
- Shares code with: Analytics system, Notification system, Admin dashboard

### ESTIMATED EFFORT
- Team A Frontend: 36 hours (Feedback widget, survey forms, admin analytics dashboard)
- Team B Backend: 42 hours (Feedback collection system, NPS manager, analytics engine, follow-up automation)
- Team C Integration: 18 hours (Email automation, support ticket integration, sentiment analysis API)
- Team D Platform: 14 hours (Database schema, analytics aggregation, performance optimization)
- Team E General: 26 hours (Comprehensive testing, validation scenarios, wedding industry context testing)
- Total: 136 hours