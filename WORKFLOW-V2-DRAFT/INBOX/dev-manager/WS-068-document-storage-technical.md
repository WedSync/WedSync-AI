# TECHNICAL SPECIFICATION: WS-068 - Document Storage
## Generated by Feature Development Session - August 21, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding DJ
**I want to:** Store my PAT testing certificates, PLI insurance, and music licenses in one place that automatically shares with venues
**So that:** I don't spend 30+ minutes per booking hunting down and emailing the same 6 documents to venue coordinators, and venues see I'm compliant before arrival

**Real Wedding Scenario:**
A wedding DJ currently maintains a folder of 12 documents (PLI insurance, PAT certificates, music licenses, equipment lists, setup guides). Each venue coordinator emails asking for "current insurance and electrical certificates." DJ spends 15-20 minutes per booking finding documents, checking expiry dates, and sending emails. With centralized storage, documents auto-expire in 30 days before certificates expire, venues access current documents via secure links, and client dashboards show compliance status automatically.

### SPECIFICATION SOURCE
- **Feature ID:** WS-068
- **Original Spec:** /CORE-SPECIFICATIONS/02-WEDSYNC-SUPPLIER-PLATFORM/09-Documents-Articles/01-document-storage md.md
- **Current Implementation:** 0% complete
- **Files to Modify:** 
  - `/wedsync/src/lib/services/file-upload-service.ts`
- **New Files to Create:** 
  - `/wedsync/src/components/documents/DocumentManager.tsx`
  - `/wedsync/src/components/documents/DocumentUploader.tsx`
  - `/wedsync/src/components/documents/DocumentLibrary.tsx`
  - `/wedsync/src/components/documents/ExpiryTracker.tsx`
  - `/wedsync/src/components/documents/AccessControlPanel.tsx`
  - `/wedsync/src/app/api/documents/route.ts`
  - `/wedsync/src/app/api/documents/[id]/share/route.ts`
  - `/wedsync/src/app/api/documents/bulk-share/route.ts`
  - `/wedsync/src/types/documents.ts`
  - `/wedsync/supabase/migrations/031_document_storage_system.sql`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Document storage and metadata
CREATE TABLE IF NOT EXISTS documents (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  file_name VARCHAR(255) NOT NULL,
  display_name VARCHAR(255) NOT NULL,
  description TEXT,
  category document_category NOT NULL,
  subcategory VARCHAR(100),
  file_url TEXT NOT NULL,
  storage_path TEXT NOT NULL,
  file_size INTEGER NOT NULL,
  mime_type VARCHAR(100) NOT NULL,
  file_hash VARCHAR(64), -- For duplicate detection
  version INTEGER DEFAULT 1,
  parent_document_id UUID REFERENCES documents(id) ON DELETE SET NULL,
  access_level document_access_level NOT NULL DEFAULT 'private',
  is_active BOOLEAN DEFAULT true,
  expiry_date DATE, -- For certificates and licenses
  expiry_alert_sent BOOLEAN DEFAULT false,
  compliance_status compliance_status DEFAULT 'valid',
  tags TEXT[] DEFAULT '{}',
  metadata JSONB DEFAULT '{}'::jsonb, -- PDF pages, image dimensions, etc.
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TYPE document_category AS ENUM (
  'credentials_insurance',
  'client_resources',
  'contracts_legal',
  'marketing_materials',
  'technical_specs',
  'venue_requirements',
  'portfolio_samples'
);

CREATE TYPE document_access_level AS ENUM (
  'private',           -- Only supplier can see
  'client_only',       -- Visible after booking confirmation
  'public',           -- Viewable by all prospects
  'venue_required',   -- Auto-shared with venue coordinators
  'restricted'        -- Custom access rules
);

CREATE TYPE compliance_status AS ENUM (
  'valid',
  'expiring_soon',    -- Within 30 days
  'expired',
  'pending_renewal',
  'not_applicable'
);

-- Document categories and requirements by supplier type
CREATE TABLE IF NOT EXISTS document_requirements (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  service_category VARCHAR(100) NOT NULL,
  required_categories document_category[] NOT NULL,
  venue_required_docs TEXT[] DEFAULT '{}', -- Document IDs that venues typically need
  client_welcome_docs TEXT[] DEFAULT '{}', -- Documents shown to new clients
  renewal_cycle_months INTEGER, -- How often to renew
  is_mandatory BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Document access permissions and sharing
CREATE TABLE IF NOT EXISTS document_access_permissions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  document_id UUID REFERENCES documents(id) ON DELETE CASCADE,
  granted_to_type permission_target_type NOT NULL,
  granted_to_id UUID, -- Client ID, venue ID, or null for public
  permission_level permission_level NOT NULL,
  granted_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  expires_at TIMESTAMPTZ,
  access_conditions JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TYPE permission_target_type AS ENUM (
  'client',
  'venue',
  'supplier',
  'public_link'
);

CREATE TYPE permission_level AS ENUM (
  'view',
  'download',
  'share',
  'manage'
);

-- Document sharing history and analytics
CREATE TABLE IF NOT EXISTS document_shares (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  document_id UUID REFERENCES documents(id) ON DELETE CASCADE,
  shared_with_type share_target_type NOT NULL,
  shared_with_id UUID, -- Client, venue, or email recipient
  share_method share_method NOT NULL,
  shared_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  share_link TEXT, -- Generated secure link
  access_count INTEGER DEFAULT 0,
  last_accessed TIMESTAMPTZ,
  expires_at TIMESTAMPTZ,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TYPE share_target_type AS ENUM (
  'client',
  'venue_coordinator',
  'email_recipient',
  'public_link'
);

CREATE TYPE share_method AS ENUM (
  'direct_link',
  'email_attachment',
  'dashboard_embed',
  'journey_automation'
);

-- Document expiry tracking and alerts
CREATE TABLE IF NOT EXISTS document_expiry_alerts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  document_id UUID REFERENCES documents(id) ON DELETE CASCADE,
  alert_type expiry_alert_type NOT NULL,
  alert_date DATE NOT NULL,
  sent_at TIMESTAMPTZ,
  delivery_method delivery_method NOT NULL DEFAULT 'email',
  recipient_email VARCHAR(255),
  message_content TEXT,
  is_sent BOOLEAN DEFAULT false
);

CREATE TYPE expiry_alert_type AS ENUM (
  'expiry_30_days',
  'expiry_14_days',
  'expiry_7_days',
  'expiry_1_day',
  'expired'
);

-- Document collections for bulk operations
CREATE TABLE IF NOT EXISTS document_collections (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  collection_name VARCHAR(255) NOT NULL,
  description TEXT,
  document_ids UUID[] NOT NULL,
  collection_type collection_type NOT NULL,
  is_template BOOLEAN DEFAULT false,
  auto_share_rules JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TYPE collection_type AS ENUM (
  'venue_package',     -- All docs venues typically need
  'client_welcome',    -- Welcome packet documents
  'credential_bundle', -- Insurance + certifications
  'service_portfolio', -- Marketing materials
  'custom'
);

-- RLS policies
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;
ALTER TABLE document_requirements ENABLE ROW LEVEL SECURITY;
ALTER TABLE document_access_permissions ENABLE ROW LEVEL SECURITY;
ALTER TABLE document_shares ENABLE ROW LEVEL SECURITY;
ALTER TABLE document_expiry_alerts ENABLE ROW LEVEL SECURITY;
ALTER TABLE document_collections ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can manage their own documents" ON documents
  FOR ALL USING (auth.uid() = user_id);

CREATE POLICY "Users can access documents shared with them" ON documents
  FOR SELECT USING (
    auth.uid() = user_id OR
    access_level = 'public' OR
    EXISTS (
      SELECT 1 FROM document_access_permissions 
      WHERE document_access_permissions.document_id = documents.id 
      AND document_access_permissions.granted_to_id = auth.uid()
    )
  );

CREATE POLICY "Users can manage their document requirements" ON document_requirements
  FOR ALL USING (auth.uid() = user_id);

CREATE POLICY "Users can manage access permissions for their documents" ON document_access_permissions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM documents 
      WHERE documents.id = document_access_permissions.document_id 
      AND documents.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can access their document shares" ON document_shares
  FOR ALL USING (
    shared_by = auth.uid() OR
    EXISTS (
      SELECT 1 FROM documents 
      WHERE documents.id = document_shares.document_id 
      AND documents.user_id = auth.uid()
    )
  );
```

#### API Endpoints Required
```typescript
// POST /api/documents
interface UploadDocumentRequest {
  file: File;
  displayName: string;
  description?: string;
  category: DocumentCategory;
  subcategory?: string;
  accessLevel: DocumentAccessLevel;
  expiryDate?: string;
  tags?: string[];
  metadata?: any;
}

interface UploadDocumentResponse {
  success: boolean;
  data: {
    document: Document;
    uploadedUrl: string;
    fileSize: number;
    processingStatus: 'pending' | 'complete';
  };
}

// GET /api/documents
interface GetDocumentsResponse {
  success: boolean;
  data: {
    documents: Document[];
    categories: Array<{category: string; count: number}>;
    expiringCount: number;
    totalStorageUsed: number;
    storageLimit: number;
  };
}

// PUT /api/documents/[id]
interface UpdateDocumentRequest {
  displayName?: string;
  description?: string;
  category?: DocumentCategory;
  accessLevel?: DocumentAccessLevel;
  expiryDate?: string;
  tags?: string[];
}

// POST /api/documents/[id]/share
interface ShareDocumentRequest {
  shareWithType: ShareTargetType;
  shareWithId?: string; // Client ID, venue ID, or email
  shareMethod: ShareMethod;
  expiresIn?: number; // Hours until expiry
  accessLevel?: PermissionLevel;
  message?: string;
}

interface ShareDocumentResponse {
  success: boolean;
  data: {
    shareId: string;
    shareLink: string;
    expiresAt: string;
    accessInstructions: string;
  };
}

// POST /api/documents/bulk-share
interface BulkShareRequest {
  documentIds: string[];
  shareWithType: ShareTargetType;
  recipients: Array<{
    id?: string;
    email?: string;
    name?: string;
  }>;
  shareMethod: ShareMethod;
  collectionName?: string;
}

interface BulkShareResponse {
  success: boolean;
  data: {
    sharesCreated: number;
    failedShares: Array<{documentId: string; reason: string}>;
    bulkShareLink?: string;
  };
}

// GET /api/documents/requirements
interface GetDocumentRequirementsResponse {
  success: boolean;
  data: {
    requirements: DocumentRequirement[];
    missingDocuments: Array<{
      category: string;
      description: string;
      priority: 'high' | 'medium' | 'low';
    }>;
    complianceScore: number; // 0-100%
  };
}

// GET /api/documents/expiring
interface GetExpiringDocumentsResponse {
  success: boolean;
  data: {
    expiringSoon: Document[]; // Within 30 days
    expired: Document[];
    alertsScheduled: ExpiryAlert[];
  };
}

// POST /api/documents/collections
interface CreateCollectionRequest {
  collectionName: string;
  description?: string;
  documentIds: string[];
  collectionType: CollectionType;
  autoShareRules?: any;
}

// GET /api/documents/analytics
interface GetDocumentAnalyticsResponse {
  success: boolean;
  data: {
    totalViews: number;
    topDocuments: Array<{documentId: string; viewCount: number}>;
    shareBreakdown: Record<ShareMethod, number>;
    clientEngagement: {
      documentsViewed: number;
      averageViewTime: number;
    };
  };
}
```

#### Frontend Components Required
```typescript
// Component: DocumentManager
// Location: /src/components/documents/DocumentManager.tsx

interface DocumentManagerProps {
  onDocumentSelect?: (document: Document) => void;
  filterCategory?: DocumentCategory;
  showExpiring?: boolean;
}

// Key functionality:
- Grid/list view of documents with thumbnails
- Category filtering and search
- Bulk operations (share, delete, organize)
- Drag-and-drop upload interface
- Document preview with PDF/image viewer
- Expiry status indicators and alerts
- Access level configuration
- Document analytics and sharing history

// Component: DocumentUploader
// Location: /src/components/documents/DocumentUploader.tsx

interface DocumentUploaderProps {
  category?: DocumentCategory;
  onUploadComplete: (documents: Document[]) => void;
  acceptedTypes?: string[];
  maxFileSize?: number;
}

// Key functionality:
- Drag-and-drop file upload with progress tracking
- Multiple file selection and batch upload
- Automatic file type detection and categorization
- Image/PDF compression and optimization
- Duplicate detection and versioning
- Metadata extraction (PDF pages, image dimensions)
- Wedding-specific category suggestions

// Component: DocumentLibrary
// Location: /src/components/documents/DocumentLibrary.tsx

interface DocumentLibraryProps {
  documents: Document[];
  viewMode: 'grid' | 'list';
  onDocumentAction: (action: string, document: Document) => void;
}

// Key functionality:
- Responsive document grid with thumbnails
- Document card with preview, sharing, and access controls
- Quick actions menu (share, download, edit, delete)
- Batch selection for bulk operations
- Filter by category, access level, and expiry status
- Search by name, description, and tags

// Component: ExpiryTracker
// Location: /src/components/documents/ExpiryTracker.tsx

interface ExpiryTrackerProps {
  documents: Document[];
  onRenewalAction: (document: Document) => void;
}

// Key functionality:
- Dashboard widget showing expiring documents
- Calendar view of expiry dates
- Automated renewal reminders setup
- Compliance status overview
- Quick renewal upload interface
- Email alert configuration

// Component: AccessControlPanel
// Location: /src/components/documents/AccessControlPanel.tsx

interface AccessControlPanelProps {
  document: Document;
  onAccessChange: (permissions: DocumentAccessPermission[]) => void;
}

// Key functionality:
- Visual access level editor (private, client-only, public, venue-required)
- Client and venue sharing interface
- Secure link generation with expiry options
- Permission history and audit trail
- Bulk access control for document collections
```

#### Integration Points
```typescript
// Service: DocumentStorageService
// Dependencies: Supabase Storage, File Processing, Email Service

class DocumentStorageService {
  async uploadDocument(
    file: File,
    metadata: DocumentMetadata
  ): Promise<Document> {
    // 1. Validate file type and size restrictions
    // 2. Generate unique storage path with user hierarchy
    // 3. Process file (compress, extract metadata, generate thumbnail)
    // 4. Upload to Supabase Storage with proper permissions
    // 5. Create document record with metadata
    // 6. Set up expiry alerts if applicable
    // 7. Apply auto-categorization based on filename/content
  }

  async shareDocumentWithClient(
    documentId: string,
    clientId: string,
    shareMethod: ShareMethod
  ): Promise<DocumentShare> {
    // 1. Validate document access permissions
    // 2. Create secure share link with expiry
    // 3. Log sharing activity for analytics
    // 4. Send notification via preferred method (email, dashboard)
    // 5. Track access and engagement metrics
  }

  async bulkShareWithVenue(
    venueRequiredDocuments: string[],
    venueCoordinatorEmail: string
  ): Promise<void> {
    // 1. Collect all venue-required documents
    // 2. Check compliance status and expiry dates
    // 3. Generate secure collection link
    // 4. Send email with professional formatting
    // 5. Track venue engagement and downloads
  }

  async checkComplianceStatus(
    userId: string,
    serviceCategory: string
  ): Promise<ComplianceReport> {
    // 1. Get document requirements for service category
    // 2. Check which required documents are present and valid
    // 3. Identify missing or expired documents
    // 4. Calculate compliance score
    // 5. Generate recommendations for improvement
  }

  async processExpiryAlerts(): Promise<void> {
    // 1. Find documents expiring in 30, 14, 7, 1 days
    // 2. Generate personalized alert emails
    // 3. Send via email service with renewal instructions
    // 4. Update alert tracking to prevent duplicates
    // 5. Set dashboard notifications for urgent renewals
  }
}

// Service: DocumentAccessService
// Dependencies: Authentication, Client Management, Venue Directory

class DocumentAccessService {
  async validateDocumentAccess(
    documentId: string,
    requestingUserId: string,
    accessContext: AccessContext
  ): Promise<boolean> {
    // 1. Check document access level and permissions
    // 2. Validate user relationship (client, venue coordinator, etc.)
    // 3. Check expiry of share links and permissions
    // 4. Log access attempt for security audit
    // 5. Return access decision with reasoning
  }

  async generateSecureShareLink(
    documentId: string,
    expiryHours: number = 72
  ): Promise<string> {
    // 1. Create cryptographically secure token
    // 2. Store share record with expiry
    // 3. Generate time-limited signed URL
    // 4. Return shareable link with access instructions
  }

  async trackDocumentEngagement(
    shareId: string,
    accessDetails: AccessDetails
  ): Promise<void> {
    // 1. Update access count and last accessed time
    // 2. Track user agent and referrer for analytics
    // 3. Log view duration and interaction type
    // 4. Update document popularity scores
  }
}
```

### CODE EXAMPLES

#### Example 1: Wedding Document Upload with Auto-Categorization
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { supabase } from '@/lib/supabase';
import { v4 as uuidv4 } from 'uuid';

export async function uploadWeddingDocument(
  file: File,
  metadata: DocumentMetadata,
  userId: string
): Promise<Document> {
  // Step 1: Validate file and detect wedding document type
  const fileValidation = validateWeddingDocument(file);
  if (!fileValidation.isValid) {
    throw new Error(fileValidation.error);
  }
  
  // Step 2: Auto-categorize based on filename and content
  const category = detectDocumentCategory(file.name, metadata.description);
  
  // Step 3: Generate storage path with user hierarchy
  const fileExtension = file.name.split('.').pop();
  const uniqueFileName = `${uuidv4()}.${fileExtension}`;
  const storagePath = `${userId}/documents/${category}/${uniqueFileName}`;
  
  // Step 4: Upload to Supabase Storage
  const { data: uploadResult, error: uploadError } = await supabase.storage
    .from('supplier-documents')
    .upload(storagePath, file, {
      cacheControl: '3600',
      upsert: false
    });
    
  if (uploadError) throw uploadError;
  
  // Step 5: Get public URL for the document
  const { data: urlData } = supabase.storage
    .from('supplier-documents')
    .getPublicUrl(storagePath);
  
  // Step 6: Extract metadata (PDF pages, image dimensions, etc.)
  const extractedMetadata = await extractDocumentMetadata(file);
  
  // Step 7: Create document record
  const documentData = {
    user_id: userId,
    file_name: file.name,
    display_name: metadata.displayName || file.name,
    description: metadata.description,
    category,
    subcategory: detectSubcategory(file.name, category),
    file_url: urlData.publicUrl,
    storage_path: storagePath,
    file_size: file.size,
    mime_type: file.type,
    file_hash: await generateFileHash(file),
    access_level: metadata.accessLevel || 'private',
    expiry_date: metadata.expiryDate,
    tags: generateAutoTags(file.name, category),
    metadata: {
      ...extractedMetadata,
      originalFileName: file.name,
      uploadedAt: new Date().toISOString()
    }
  };
  
  const { data: document, error: docError } = await supabase
    .from('documents')
    .insert(documentData)
    .select()
    .single();
    
  if (docError) throw docError;
  
  // Step 8: Set up expiry alerts if document has expiry date
  if (metadata.expiryDate) {
    await scheduleExpiryAlerts(document.id, metadata.expiryDate);
  }
  
  // Step 9: Apply default sharing rules based on category
  await applyDefaultSharingRules(document.id, category);
  
  return document;
}

function detectDocumentCategory(fileName: string, description?: string): DocumentCategory {
  const nameLower = fileName.toLowerCase();
  const descLower = (description || '').toLowerCase();
  
  // Insurance and credentials
  if (nameLower.includes('insurance') || nameLower.includes('pli') || 
      nameLower.includes('liability') || nameLower.includes('certificate')) {
    return 'credentials_insurance';
  }
  
  // PAT testing for DJs/musicians
  if (nameLower.includes('pat') || nameLower.includes('electrical') ||
      nameLower.includes('testing') || nameLower.includes('appliance')) {
    return 'venue_requirements';
  }
  
  // Licenses (music, drone, food hygiene)
  if (nameLower.includes('license') || nameLower.includes('licence') ||
      nameLower.includes('permit') || nameLower.includes('hygiene')) {
    return 'credentials_insurance';
  }
  
  // Client guides and resources
  if (nameLower.includes('guide') || nameLower.includes('checklist') ||
      nameLower.includes('timeline') || nameLower.includes('preparation')) {
    return 'client_resources';
  }
  
  // Portfolio and marketing
  if (nameLower.includes('portfolio') || nameLower.includes('lookbook') ||
      nameLower.includes('brochure') || nameLower.includes('samples')) {
    return 'marketing_materials';
  }
  
  // Contracts and legal
  if (nameLower.includes('contract') || nameLower.includes('terms') ||
      nameLower.includes('agreement') || nameLower.includes('dbs')) {
    return 'contracts_legal';
  }
  
  // Equipment specs
  if (nameLower.includes('equipment') || nameLower.includes('spec') ||
      nameLower.includes('requirements') || nameLower.includes('setup')) {
    return 'technical_specs';
  }
  
  // Default fallback
  return 'client_resources';
}

async function scheduleExpiryAlerts(
  documentId: string,
  expiryDate: string
): Promise<void> {
  const expiry = new Date(expiryDate);
  const alertDays = [30, 14, 7, 1]; // Days before expiry
  
  for (const days of alertDays) {
    const alertDate = new Date(expiry);
    alertDate.setDate(alertDate.getDate() - days);
    
    // Only schedule future alerts
    if (alertDate > new Date()) {
      await supabase
        .from('document_expiry_alerts')
        .insert({
          document_id: documentId,
          alert_type: `expiry_${days}_days` as ExpiryAlertType,
          alert_date: alertDate.toISOString().split('T')[0],
          delivery_method: 'email'
        });
    }
  }
}

export async function shareDocumentsWithVenue(
  venueCoordinatorEmail: string,
  clientWeddingId: string,
  documentCategories: DocumentCategory[] = ['venue_requirements', 'credentials_insurance']
): Promise<void> {
  // Step 1: Get user's venue-required documents
  const { data: documents } = await supabase
    .from('documents')
    .select('*')
    .eq('user_id', auth.uid())
    .in('category', documentCategories)
    .eq('is_active', true)
    .eq('compliance_status', 'valid');
  
  if (!documents || documents.length === 0) {
    throw new Error('No valid venue documents available to share');
  }
  
  // Step 2: Create secure collection for venue access
  const collectionId = uuidv4();
  const expiryDate = new Date();
  expiryDate.setDate(expiryDate.getDate() + 30); // 30 days access
  
  // Step 3: Generate secure links for each document
  const documentShares = await Promise.all(
    documents.map(async (doc) => {
      const shareToken = uuidv4();
      const shareLink = `${process.env.NEXT_PUBLIC_APP_URL}/share/document/${shareToken}`;
      
      // Create share record
      const { data: share } = await supabase
        .from('document_shares')
        .insert({
          document_id: doc.id,
          shared_with_type: 'venue_coordinator',
          share_method: 'email_attachment',
          shared_by: auth.uid(),
          share_link: shareLink,
          expires_at: expiryDate.toISOString()
        })
        .select()
        .single();
      
      return {
        document: doc,
        shareLink,
        shareId: share.id
      };
    })
  );
  
  // Step 4: Get client and wedding details for context
  const { data: wedding } = await supabase
    .from('clients')
    .select(`
      *,
      wedding_details:wedding_details(*)
    `)
    .eq('id', clientWeddingId)
    .single();
  
  // Step 5: Send professional email to venue coordinator
  const emailContent = `
    <h2>Wedding Supplier Documentation</h2>
    <p>Dear Venue Coordinator,</p>
    
    <p>Please find attached the required documentation for the upcoming wedding:</p>
    <ul>
      <li><strong>Couple:</strong> ${wedding?.partner1_name} & ${wedding?.partner2_name}</li>
      <li><strong>Wedding Date:</strong> ${new Date(wedding?.wedding_date).toLocaleDateString()}</li>
      <li><strong>Venue:</strong> ${wedding?.wedding_details?.venue_name}</li>
    </ul>
    
    <h3>Documents Provided:</h3>
    <ul>
      ${documentShares.map(share => `
        <li>
          <strong>${share.document.display_name}</strong><br>
          <small>${share.document.description || ''}</small><br>
          <a href="${share.shareLink}" style="color: #0066cc;">View Document</a>
          ${share.document.expiry_date ? `<br><em>Valid until: ${new Date(share.document.expiry_date).toLocaleDateString()}</em>` : ''}
        </li>
      `).join('')}
    </ul>
    
    <p>All documents are current and compliant. Links will remain active for 30 days.</p>
    
    <p>Best regards,<br>
    ${auth.user?.user_metadata?.business_name || 'Wedding Supplier'}</p>
  `;
  
  // Send email via email service (using existing email templates system)
  await sendVenueDocumentationEmail(
    venueCoordinatorEmail,
    emailContent,
    documentShares
  );
  
  // Step 6: Log bulk share activity
  await supabase
    .from('document_collections')
    .insert({
      user_id: auth.uid(),
      collection_name: `Venue Documents - ${wedding?.wedding_details?.venue_name}`,
      description: `Documents shared with ${venueCoordinatorEmail} for ${wedding?.partner1_name} & ${wedding?.partner2_name} wedding`,
      document_ids: documents.map(d => d.id),
      collection_type: 'venue_package'
    });
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for file processing libraries, PDF manipulation
- [x] Filesystem: Access existing file upload and storage implementations
- [x] Memory: Store document categorization patterns and compliance rules

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/supabase/storage-js", "file upload storage", 3000);
await mcp__context7__get-library-docs("/mozilla/pdf-js", "pdf processing", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('DocumentStorageService', () => {
  it('should auto-categorize wedding documents correctly', () => {
    expect(detectDocumentCategory('PLI_Certificate_2025.pdf')).toBe('credentials_insurance');
    expect(detectDocumentCategory('PAT_Testing_Certificate.pdf')).toBe('venue_requirements');
    expect(detectDocumentCategory('Wedding_Planning_Guide.pdf')).toBe('client_resources');
    expect(detectDocumentCategory('Portfolio_Samples.pdf')).toBe('marketing_materials');
  });

  it('should schedule expiry alerts for certificates', async () => {
    const documentId = 'doc-123';
    const expiryDate = '2025-12-31';
    
    await scheduleExpiryAlerts(documentId, expiryDate);
    
    const alerts = await getScheduledAlerts(documentId);
    expect(alerts).toHaveLength(4); // 30, 14, 7, 1 days before
    expect(alerts[0].alert_type).toBe('expiry_30_days');
  });

  it('should validate file types for wedding documents', () => {
    const pdfFile = new File([''], 'certificate.pdf', { type: 'application/pdf' });
    const imageFile = new File([''], 'portfolio.jpg', { type: 'image/jpeg' });
    const invalidFile = new File([''], 'virus.exe', { type: 'application/exe' });
    
    expect(validateWeddingDocument(pdfFile).isValid).toBe(true);
    expect(validateWeddingDocument(imageFile).isValid).toBe(true);
    expect(validateWeddingDocument(invalidFile).isValid).toBe(false);
  });

  it('should generate secure share links with expiry', async () => {
    const shareLink = await generateSecureShareLink('doc-123', 72);
    expect(shareLink).toMatch(/\/share\/document\/[a-f0-9-]{36}/);
    
    const shareRecord = await getShareByLink(shareLink);
    expect(shareRecord.expires_at).toBeDefined();
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Document upload and venue sharing workflow', async () => {
  await mcp__playwright__browser_navigate({url: '/documents'});
  
  // Upload PLI certificate
  await mcp__playwright__browser_file_upload({
    paths: ['/path/to/test-pli-certificate.pdf']
  });
  
  // Verify auto-categorization
  await mcp__playwright__browser_wait_for({text: 'Credentials & Insurance'});
  
  // Set expiry date
  await mcp__playwright__browser_click({element: 'edit document button', ref: 'button[data-testid="edit-doc"]'});
  await mcp__playwright__browser_type({
    element: 'expiry date input',
    ref: 'input[name="expiryDate"]',
    text: '2025-12-31'
  });
  
  // Set as venue-required
  await mcp__playwright__browser_select_option({
    element: 'access level select',
    ref: 'select[name="accessLevel"]',
    values: ['venue_required']
  });
  
  await mcp__playwright__browser_click({element: 'save button', ref: 'button[data-testid="save-document"]'});
  
  // Share with venue coordinator
  await mcp__playwright__browser_click({element: 'bulk share button', ref: 'button[data-testid="bulk-share"]'});
  await mcp__playwright__browser_select_option({
    element: 'share with type',
    ref: 'select[name="shareWithType"]',
    values: ['venue_coordinator']
  });
  
  await mcp__playwright__browser_type({
    element: 'venue email input',
    ref: 'input[name="venueEmail"]',
    text: 'coordinator@venue.com'
  });
  
  await mcp__playwright__browser_click({element: 'send documents button', ref: 'button[data-testid="send-documents"]'});
  
  // Verify confirmation
  await mcp__playwright__browser_wait_for({text: 'Documents shared successfully'});
  
  // Check sharing history
  await mcp__playwright__browser_click({element: 'sharing history tab', ref: 'button[data-tab="sharing"]'});
  await mcp__playwright__browser_wait_for({text: 'coordinator@venue.com'});
  
  // Verify accessibility
  await mcp__playwright__browser_evaluate({
    function: '() => axe.run()'
  });
});
```

### ACCEPTANCE CRITERIA
- [x] Centralized document storage with 5GB per supplier limit
- [x] Auto-categorization of wedding industry documents (insurance, PAT certificates, guides)
- [x] Expiry tracking with automated email alerts (30, 14, 7, 1 days before)
- [x] Secure document sharing with venues and clients via time-limited links
- [x] Bulk venue documentation packages with professional email formatting
- [x] Performance: Document upload and processing completes within 10 seconds
- [x] Security: Document access restricted by RLS policies and sharing permissions
- [x] Accessibility: Document management interface meets WCAG 2.1 AA standards

### DEPENDENCIES
- Must complete after: None (foundational feature)
- Must complete before: WS-069 (Article Creation), WS-070 (FAQ Management)
- Shares code with: File upload service, email templates, client dashboard system

### ESTIMATED EFFORT
- Team D Full-stack: 28 hours (Document storage, categorization, sharing system)
- Team B Backend: 20 hours (Database schema, API endpoints, expiry tracking)
- Team A Frontend: 16 hours (Document manager, uploader, sharing interface)
- Total: 64 hours