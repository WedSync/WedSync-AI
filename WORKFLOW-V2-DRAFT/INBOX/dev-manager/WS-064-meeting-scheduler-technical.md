# TECHNICAL SPECIFICATION: WS-064 - Meeting Scheduler
## Generated by Feature Development Session - August 21, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding venue coordinator
**I want to:** Allow couples to book consultation meetings directly from my availability without phone/email back-and-forth
**So that:** I can reduce 15+ minutes of scheduling coordination per couple and capture more bookings by removing friction from the initial consultation process

**Real Wedding Scenario:**
A venue coordinator currently spends 2-3 hours weekly coordinating consultation schedules via email ("Are you free Tuesday at 2pm?" "Actually, can we do Wednesday?" "Let me check..."). With self-service scheduling, couples see real availability, book 30-minute venue tours instantly, and automatically receive confirmation emails with venue address, parking instructions, and video call backup links. Coordinator sees bookings appear in calendar automatically.

### SPECIFICATION SOURCE
- **Feature ID:** WS-064
- **Original Spec:** /CORE-SPECIFICATIONS/02-WEDSYNC-SUPPLIER-PLATFORM/06-Communications/05-meeting-scheduler md.md
- **Current Implementation:** 0% complete
- **Files to Modify:** 
  - `/wedsync/src/lib/services/calendar-service.ts`
- **New Files to Create:** 
  - `/wedsync/src/components/scheduling/BookingPageBuilder.tsx`
  - `/wedsync/src/components/scheduling/AvailabilityCalendar.tsx`
  - `/wedsync/src/components/scheduling/MeetingTypeEditor.tsx`
  - `/wedsync/src/components/scheduling/ClientBookingForm.tsx`
  - `/wedsync/src/app/book/[slug]/page.tsx`
  - `/wedsync/src/app/api/bookings/route.ts`
  - `/wedsync/src/app/api/availability/route.ts`
  - `/wedsync/src/types/scheduling.ts`
  - `/wedsync/supabase/migrations/027_meeting_scheduler_system.sql`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Booking pages for suppliers
CREATE TABLE IF NOT EXISTS booking_pages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  slug VARCHAR(100) NOT NULL UNIQUE,
  title VARCHAR(255) NOT NULL,
  description TEXT,
  is_active BOOLEAN DEFAULT true,
  timezone VARCHAR(50) NOT NULL DEFAULT 'UTC',
  booking_window_days INTEGER DEFAULT 30, -- How far ahead clients can book
  min_notice_hours INTEGER DEFAULT 24, -- Minimum notice required
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Meeting types offered by suppliers
CREATE TABLE IF NOT EXISTS meeting_types (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  booking_page_id UUID REFERENCES booking_pages(id) ON DELETE CASCADE,
  name VARCHAR(255) NOT NULL,
  category meeting_category NOT NULL,
  duration_minutes INTEGER NOT NULL,
  price DECIMAL(10,2), -- Optional paid consultations
  location_type meeting_location_type NOT NULL,
  location_details TEXT,
  buffer_before_minutes INTEGER DEFAULT 0,
  buffer_after_minutes INTEGER DEFAULT 0,
  max_attendees INTEGER DEFAULT 2,
  is_active BOOLEAN DEFAULT true,
  sort_order INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TYPE meeting_category AS ENUM (
  'consultation',
  'planning',
  'venue_visit', 
  'tasting',
  'final_walkthrough',
  'custom'
);

CREATE TYPE meeting_location_type AS ENUM (
  'in_person',
  'phone',
  'video_zoom',
  'video_google_meet',
  'video_teams'
);

-- Availability rules for suppliers
CREATE TABLE IF NOT EXISTS availability_rules (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  booking_page_id UUID REFERENCES booking_pages(id) ON DELETE CASCADE,
  day_of_week INTEGER NOT NULL CHECK (day_of_week >= 0 AND day_of_week <= 6), -- 0=Sunday
  start_time TIME NOT NULL,
  end_time TIME NOT NULL,
  is_available BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Booked appointments
CREATE TABLE IF NOT EXISTS meetings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  booking_page_id UUID REFERENCES booking_pages(id) ON DELETE CASCADE,
  meeting_type_id UUID REFERENCES meeting_types(id) ON DELETE CASCADE,
  client_id UUID REFERENCES clients(id) ON DELETE SET NULL,
  client_name VARCHAR(255) NOT NULL,
  client_email VARCHAR(255) NOT NULL,
  client_phone VARCHAR(20),
  partner_name VARCHAR(255),
  wedding_date DATE,
  guest_count INTEGER,
  additional_notes TEXT,
  scheduled_start TIMESTAMPTZ NOT NULL,
  scheduled_end TIMESTAMPTZ NOT NULL,
  timezone VARCHAR(50) NOT NULL,
  location_type meeting_location_type NOT NULL,
  location_details TEXT,
  video_link TEXT,
  meeting_link_id VARCHAR(255), -- Zoom/Teams meeting ID
  status meeting_status DEFAULT 'scheduled',
  price_paid DECIMAL(10,2),
  payment_status VARCHAR(20) DEFAULT 'not_required',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TYPE meeting_status AS ENUM (
  'scheduled',
  'confirmed',
  'cancelled',
  'completed',
  'no_show'
);

-- Calendar integration tracking
CREATE TABLE IF NOT EXISTS calendar_integrations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  provider calendar_provider NOT NULL,
  calendar_id VARCHAR(255) NOT NULL,
  access_token_encrypted TEXT NOT NULL,
  refresh_token_encrypted TEXT,
  expires_at TIMESTAMPTZ,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TYPE calendar_provider AS ENUM (
  'google',
  'outlook',
  'apple'
);

-- Meeting reminders and notifications
CREATE TABLE IF NOT EXISTS meeting_reminders (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  meeting_id UUID REFERENCES meetings(id) ON DELETE CASCADE,
  reminder_type reminder_type NOT NULL,
  scheduled_for TIMESTAMPTZ NOT NULL,
  sent_at TIMESTAMPTZ,
  delivery_method delivery_method NOT NULL,
  content TEXT NOT NULL,
  status VARCHAR(20) DEFAULT 'pending'
);

CREATE TYPE reminder_type AS ENUM (
  'initial_confirmation',
  '24_hour_reminder',
  '2_hour_reminder',
  'follow_up'
);

CREATE TYPE delivery_method AS ENUM (
  'email',
  'sms',
  'whatsapp'
);

-- Blocked time slots for suppliers
CREATE TABLE IF NOT EXISTS blocked_times (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  booking_page_id UUID REFERENCES booking_pages(id) ON DELETE CASCADE,
  start_time TIMESTAMPTZ NOT NULL,
  end_time TIMESTAMPTZ NOT NULL,
  reason VARCHAR(255),
  is_recurring BOOLEAN DEFAULT false,
  recurrence_rule TEXT, -- RRULE format
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- RLS policies
ALTER TABLE booking_pages ENABLE ROW LEVEL SECURITY;
ALTER TABLE meeting_types ENABLE ROW LEVEL SECURITY;
ALTER TABLE availability_rules ENABLE ROW LEVEL SECURITY;
ALTER TABLE meetings ENABLE ROW LEVEL SECURITY;
ALTER TABLE calendar_integrations ENABLE ROW LEVEL SECURITY;
ALTER TABLE meeting_reminders ENABLE ROW LEVEL SECURITY;
ALTER TABLE blocked_times ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can manage their own booking pages" ON booking_pages
  FOR ALL USING (auth.uid() = user_id);

CREATE POLICY "Users can manage their own meeting types" ON meeting_types
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM booking_pages 
      WHERE booking_pages.id = meeting_types.booking_page_id 
      AND booking_pages.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can manage their own availability" ON availability_rules
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM booking_pages 
      WHERE booking_pages.id = availability_rules.booking_page_id 
      AND booking_pages.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can access their own meetings" ON meetings
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM booking_pages 
      WHERE booking_pages.id = meetings.booking_page_id 
      AND booking_pages.user_id = auth.uid()
    )
  );

-- Public access for booking pages (clients can view)
CREATE POLICY "Public can view active booking pages" ON booking_pages
  FOR SELECT USING (is_active = true);

CREATE POLICY "Public can view active meeting types" ON meeting_types
  FOR SELECT USING (
    is_active = true AND
    EXISTS (
      SELECT 1 FROM booking_pages 
      WHERE booking_pages.id = meeting_types.booking_page_id 
      AND booking_pages.is_active = true
    )
  );
```

#### API Endpoints Required
```typescript
// GET /api/booking-pages/[slug]
interface GetBookingPageResponse {
  success: boolean;
  data: {
    bookingPage: BookingPage;
    meetingTypes: MeetingType[];
    supplierInfo: {
      businessName: string;
      description: string;
      profileImage?: string;
    };
  };
}

// GET /api/availability/[bookingPageId]
interface GetAvailabilityRequest {
  date: string; // YYYY-MM-DD
  meetingTypeId: string;
  timezone: string;
}

interface GetAvailabilityResponse {
  success: boolean;
  data: {
    availableSlots: Array<{
      start: string; // ISO datetime
      end: string;
      isRecommended?: boolean;
    }>;
    blockedPeriods: Array<{
      start: string;
      end: string;
      reason: string;
    }>;
  };
}

// POST /api/bookings
interface CreateBookingRequest {
  bookingPageId: string;
  meetingTypeId: string;
  clientName: string;
  clientEmail: string;
  clientPhone?: string;
  partnerName?: string;
  weddingDate?: string;
  guestCount?: number;
  additionalNotes?: string;
  scheduledStart: string; // ISO datetime
  timezone: string;
}

interface CreateBookingResponse {
  success: boolean;
  data: {
    meetingId: string;
    confirmationNumber: string;
    videoLink?: string;
    calendarInvite: {
      icsContent: string;
      googleCalendarUrl: string;
    };
  };
}

// PUT /api/meetings/[id]/status
interface UpdateMeetingStatusRequest {
  status: 'confirmed' | 'cancelled' | 'completed' | 'no_show';
  reason?: string;
  rescheduleTo?: string; // ISO datetime
}

// POST /api/booking-pages
interface CreateBookingPageRequest {
  slug: string;
  title: string;
  description: string;
  timezone: string;
  bookingWindowDays: number;
  minNoticeHours: number;
}

// POST /api/meeting-types
interface CreateMeetingTypeRequest {
  bookingPageId: string;
  name: string;
  category: MeetingCategory;
  durationMinutes: number;
  price?: number;
  locationType: MeetingLocationType;
  locationDetails?: string;
  bufferBeforeMinutes: number;
  bufferAfterMinutes: number;
  maxAttendees: number;
}

// POST /api/calendar/connect
interface ConnectCalendarRequest {
  provider: 'google' | 'outlook' | 'apple';
  authCode: string;
  calendarId: string;
}

// GET /api/meetings
interface GetMeetingsResponse {
  success: boolean;
  data: {
    upcomingMeetings: Meeting[];
    pastMeetings: Meeting[];
    totalCount: number;
  };
}
```

#### Frontend Components Required
```typescript
// Component: BookingPageBuilder
// Location: /src/components/scheduling/BookingPageBuilder.tsx

interface BookingPageBuilderProps {
  bookingPage?: BookingPage;
  onSave: (page: Partial<BookingPage>) => Promise<void>;
}

// Key functionality:
- Custom booking page URL configuration
- Meeting type creation and editing
- Availability rules setup (weekly schedule)
- Branding customization (colors, logo, description)
- Preview mode for client experience
- Integration with calendar providers
- Blocked time management

// Component: AvailabilityCalendar
// Location: /src/components/scheduling/AvailabilityCalendar.tsx

interface AvailabilityCalendarProps {
  meetingType: MeetingType;
  bookingPageId: string;
  onSlotSelect: (slot: TimeSlot) => void;
  timezone: string;
}

// Key functionality:
- Interactive calendar with available time slots
- Real-time availability checking
- Timezone conversion and display
- Buffer time visualization
- Blocked periods indication
- Smart scheduling suggestions
- Mobile-responsive time picker

// Component: MeetingTypeEditor
// Location: /src/components/scheduling/MeetingTypeEditor.tsx

interface MeetingTypeEditorProps {
  meetingType?: MeetingType;
  onSave: (type: Partial<MeetingType>) => Promise<void>;
}

// Key functionality:
- Meeting duration and buffer configuration
- Location type selection (in-person, video, phone)
- Pricing setup for paid consultations
- Wedding-specific form fields configuration
- Capacity and attendee limits
- Integration with video providers

// Component: ClientBookingForm
// Location: /src/components/scheduling/ClientBookingForm.tsx

interface ClientBookingFormProps {
  meetingType: MeetingType;
  selectedSlot: TimeSlot;
  onBookingComplete: (meeting: Meeting) => void;
}

// Key functionality:
- Client information capture (names, contact, wedding details)
- Wedding date and guest count collection
- Additional notes and special requests
- Contact preference selection
- Terms and conditions acceptance
- Real-time form validation
```

#### Integration Points
```typescript
// Service: SchedulingService (extends calendar-service.ts)
// Dependencies: Calendar APIs, Email Service, SMS Service, Video Providers

class SchedulingService {
  async checkAvailability(
    bookingPageId: string,
    date: string,
    meetingTypeId: string,
    timezone: string
  ): Promise<TimeSlot[]> {
    // 1. Get availability rules for the booking page
    // 2. Check existing meetings for conflicts
    // 3. Apply buffer times and blocked periods
    // 4. Convert to user's timezone
    // 5. Return available slots with smart recommendations
  }

  async createMeeting(
    bookingData: CreateBookingRequest
  ): Promise<Meeting> {
    // 1. Validate slot is still available
    // 2. Create meeting record in database
    // 3. Generate video meeting link if needed
    // 4. Create calendar events for both parties
    // 5. Send confirmation emails with ICS attachments
    // 6. Schedule reminder notifications
    // 7. Integrate with existing client record if found
  }

  async generateVideoMeetingLink(
    locationType: MeetingLocationType,
    scheduledStart: Date,
    duration: number
  ): Promise<string> {
    // 1. Use appropriate video provider API
    // 2. Create meeting with wedding-specific settings
    // 3. Return meeting URL and join details
  }

  async sendMeetingReminders(): Promise<void> {
    // 1. Find meetings needing reminders
    // 2. Use email templates (WS-061) for personalized content
    // 3. Send via preferred communication method
    // 4. Mark reminders as sent
  }

  async syncWithExternalCalendar(
    userId: string,
    meeting: Meeting
  ): Promise<void> {
    // 1. Get calendar integration for user
    // 2. Create event in external calendar
    // 3. Handle conflicts and double-booking prevention
    // 4. Update meeting with external event ID
  }
}
```

### CODE EXAMPLES

#### Example 1: Available Slot Calculation with Wedding Context
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { supabase } from '@/lib/supabase';
import { addMinutes, startOfDay, endOfDay, isWithinInterval } from 'date-fns';
import { zonedTimeToUtc, utcToZonedTime } from 'date-fns-tz';

export async function getAvailableSlots(
  bookingPageId: string,
  date: string, // YYYY-MM-DD
  meetingTypeId: string,
  clientTimezone: string
): Promise<TimeSlot[]> {
  // Step 1: Get meeting type details
  const { data: meetingType, error: typeError } = await supabase
    .from('meeting_types')
    .select('*')
    .eq('id', meetingTypeId)
    .single();
    
  if (typeError) throw typeError;
  
  // Step 2: Get booking page and availability rules
  const { data: bookingPage } = await supabase
    .from('booking_pages')
    .select(`
      *,
      availability_rules(*),
      blocked_times(*)
    `)
    .eq('id', bookingPageId)
    .single();
    
  const dayOfWeek = new Date(date).getDay();
  const availabilityRule = bookingPage.availability_rules.find(
    rule => rule.day_of_week === dayOfWeek && rule.is_available
  );
  
  if (!availabilityRule) return []; // No availability on this day
  
  // Step 3: Get existing meetings for this date
  const dayStart = zonedTimeToUtc(startOfDay(new Date(date)), bookingPage.timezone);
  const dayEnd = zonedTimeToUtc(endOfDay(new Date(date)), bookingPage.timezone);
  
  const { data: existingMeetings } = await supabase
    .from('meetings')
    .select('scheduled_start, scheduled_end')
    .eq('booking_page_id', bookingPageId)
    .gte('scheduled_start', dayStart.toISOString())
    .lte('scheduled_end', dayEnd.toISOString())
    .in('status', ['scheduled', 'confirmed']);
  
  // Step 4: Generate potential time slots
  const slots: TimeSlot[] = [];
  const startTime = new Date(`${date}T${availabilityRule.start_time}`);
  const endTime = new Date(`${date}T${availabilityRule.end_time}`);
  const slotDuration = meetingType.duration_minutes + 
                      meetingType.buffer_before_minutes + 
                      meetingType.buffer_after_minutes;
  
  let currentSlot = startTime;
  while (addMinutes(currentSlot, slotDuration) <= endTime) {
    const slotStart = addMinutes(currentSlot, meetingType.buffer_before_minutes);
    const slotEnd = addMinutes(slotStart, meetingType.duration_minutes);
    
    // Step 5: Check for conflicts
    const hasConflict = existingMeetings?.some(meeting => {
      const meetingStart = new Date(meeting.scheduled_start);
      const meetingEnd = new Date(meeting.scheduled_end);
      
      return isWithinInterval(slotStart, { start: meetingStart, end: meetingEnd }) ||
             isWithinInterval(slotEnd, { start: meetingStart, end: meetingEnd }) ||
             isWithinInterval(meetingStart, { start: slotStart, end: slotEnd });
    });
    
    // Step 6: Check blocked times
    const isBlocked = bookingPage.blocked_times?.some(blocked => {
      const blockedStart = new Date(blocked.start_time);
      const blockedEnd = new Date(blocked.end_time);
      
      return isWithinInterval(slotStart, { start: blockedStart, end: blockedEnd });
    });
    
    // Step 7: Apply minimum notice requirement
    const minNoticeTime = addMinutes(new Date(), bookingPage.min_notice_hours * 60);
    const isWithinNotice = slotStart <= minNoticeTime;
    
    if (!hasConflict && !isBlocked && !isWithinNotice) {
      // Convert to client timezone for display
      const clientSlotStart = utcToZonedTime(
        zonedTimeToUtc(slotStart, bookingPage.timezone), 
        clientTimezone
      );
      const clientSlotEnd = utcToZonedTime(
        zonedTimeToUtc(slotEnd, bookingPage.timezone), 
        clientTimezone
      );
      
      slots.push({
        start: clientSlotStart.toISOString(),
        end: clientSlotEnd.toISOString(),
        isRecommended: isRecommendedTime(slotStart), // Business hours, etc.
        supplierLocalTime: slotStart.toISOString()
      });
    }
    
    // Move to next 15-minute increment
    currentSlot = addMinutes(currentSlot, 15);
  }
  
  return slots;
}

export async function createWeddingConsultationMeeting(
  bookingData: CreateBookingRequest
): Promise<Meeting> {
  // Step 1: Double-check slot availability
  const availableSlots = await getAvailableSlots(
    bookingData.bookingPageId,
    bookingData.scheduledStart.split('T')[0],
    bookingData.meetingTypeId,
    bookingData.timezone
  );
  
  const requestedSlot = availableSlots.find(
    slot => slot.start === bookingData.scheduledStart
  );
  
  if (!requestedSlot) {
    throw new Error('Selected time slot is no longer available');
  }
  
  // Step 2: Get meeting type for video link generation
  const { data: meetingType } = await supabase
    .from('meeting_types')
    .select('*')
    .eq('id', bookingData.meetingTypeId)
    .single();
  
  // Step 3: Generate video meeting link if needed
  let videoLink = null;
  let meetingLinkId = null;
  
  if (meetingType.location_type.startsWith('video_')) {
    const provider = meetingType.location_type.replace('video_', '');
    const meetingDetails = await generateVideoMeeting(
      provider,
      bookingData.scheduledStart,
      meetingType.duration_minutes,
      `Wedding Consultation - ${bookingData.clientName}`
    );
    
    videoLink = meetingDetails.joinUrl;
    meetingLinkId = meetingDetails.meetingId;
  }
  
  // Step 4: Create meeting record
  const { data: meeting, error: meetingError } = await supabase
    .from('meetings')
    .insert({
      booking_page_id: bookingData.bookingPageId,
      meeting_type_id: bookingData.meetingTypeId,
      client_name: bookingData.clientName,
      client_email: bookingData.clientEmail,
      client_phone: bookingData.clientPhone,
      partner_name: bookingData.partnerName,
      wedding_date: bookingData.weddingDate,
      guest_count: bookingData.guestCount,
      additional_notes: bookingData.additionalNotes,
      scheduled_start: bookingData.scheduledStart,
      scheduled_end: addMinutes(new Date(bookingData.scheduledStart), meetingType.duration_minutes).toISOString(),
      timezone: bookingData.timezone,
      location_type: meetingType.location_type,
      location_details: meetingType.location_details,
      video_link: videoLink,
      meeting_link_id: meetingLinkId,
      status: 'scheduled'
    })
    .select()
    .single();
    
  if (meetingError) throw meetingError;
  
  // Step 5: Send confirmation email using email templates (WS-061)
  await sendMeetingConfirmationEmail(meeting);
  
  // Step 6: Schedule reminders
  await scheduleMeetingReminders(meeting.id);
  
  // Step 7: Create calendar events
  await syncMeetingWithCalendar(meeting);
  
  return meeting;
}

async function generateVideoMeeting(
  provider: string,
  startTime: string,
  duration: number,
  topic: string
): Promise<{joinUrl: string; meetingId: string}> {
  switch (provider) {
    case 'zoom':
      // Integrate with Zoom API to create meeting
      const zoomMeeting = await createZoomMeeting({
        topic,
        start_time: startTime,
        duration,
        settings: {
          waiting_room: true,
          join_before_host: false,
          mute_upon_entry: true
        }
      });
      return {
        joinUrl: zoomMeeting.join_url,
        meetingId: zoomMeeting.id.toString()
      };
      
    case 'google_meet':
      // Generate Google Meet link
      const meetLink = await createGoogleMeetLink({
        summary: topic,
        start: { dateTime: startTime },
        end: { dateTime: addMinutes(new Date(startTime), duration).toISOString() },
        conferenceData: {
          createRequest: { requestId: uuidv4() }
        }
      });
      return {
        joinUrl: meetLink.hangoutLink,
        meetingId: meetLink.id
      };
      
    default:
      throw new Error(`Unsupported video provider: ${provider}`);
  }
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for calendar APIs, video conferencing SDKs
- [x] Filesystem: Access existing calendar service implementation
- [x] Memory: Store scheduling patterns and meeting templates

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/google/googleapis", "calendar api", 3000);
await mcp__context7__get-library-docs("/zoom/websdk", "meeting integration", 2000);
await mcp__context7__get-library-docs("/date-fns/date-fns", "timezone handling", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('SchedulingService', () => {
  it('should calculate available slots correctly with buffers', async () => {
    const slots = await getAvailableSlots('page-123', '2025-03-15', 'type-456', 'America/New_York');
    expect(slots).toHaveLength(16); // 8 hours / 30min slots
    expect(slots[0].start).toBe('2025-03-15T09:00:00.000Z');
  });

  it('should prevent double-booking conflicts', async () => {
    // Create existing meeting at 2pm-3pm
    await createTestMeeting('2025-03-15T14:00:00.000Z', 60);
    
    const slots = await getAvailableSlots('page-123', '2025-03-15', 'type-456', 'UTC');
    const conflictingSlot = slots.find(slot => slot.start === '2025-03-15T14:00:00.000Z');
    expect(conflictingSlot).toBeUndefined();
  });

  it('should handle timezone conversions for international clients', async () => {
    const slots = await getAvailableSlots('page-123', '2025-03-15', 'type-456', 'Asia/Tokyo');
    // Verify slots are converted to Tokyo time
    expect(slots[0].start).toContain('+09:00');
  });

  it('should generate video meeting links for virtual consultations', async () => {
    const meeting = await createWeddingConsultationMeeting({
      meetingTypeId: 'video-type-123',
      clientName: 'John & Jane',
      scheduledStart: '2025-03-15T14:00:00.000Z'
    });
    
    expect(meeting.video_link).toMatch(/zoom\.us|meet\.google\.com|teams\.microsoft\.com/);
    expect(meeting.meeting_link_id).toBeDefined();
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Complete booking flow for wedding consultation', async () => {
  await mcp__playwright__browser_navigate({url: '/book/venue-consultations'});
  
  // Select meeting type
  await mcp__playwright__browser_click({element: 'venue visit option', ref: 'button[data-meeting-type="venue_visit"]'});
  
  // Pick available time slot
  await mcp__playwright__browser_click({element: 'calendar day', ref: '[data-date="2025-03-15"]'});
  await mcp__playwright__browser_click({element: '2pm slot', ref: '[data-slot="14:00"]'});
  
  // Fill client information
  await mcp__playwright__browser_type({
    element: 'client name input',
    ref: 'input[name="clientName"]',
    text: 'John Smith & Jane Doe'
  });
  
  await mcp__playwright__browser_type({
    element: 'email input',
    ref: 'input[name="clientEmail"]',
    text: 'john.jane@example.com'
  });
  
  await mcp__playwright__browser_type({
    element: 'wedding date input',
    ref: 'input[name="weddingDate"]',
    text: '2025-08-15'
  });
  
  // Submit booking
  await mcp__playwright__browser_click({element: 'confirm booking button', ref: 'button[type="submit"]'});
  
  // Verify confirmation page
  await mcp__playwright__browser_wait_for({text: 'Your consultation is confirmed!'});
  await mcp__playwright__browser_wait_for({text: 'Venue Visit - March 15'});
  
  // Verify calendar invite download
  await mcp__playwright__browser_click({element: 'add to calendar button', ref: 'button[data-testid="calendar-invite"]'});
  
  // Verify accessibility
  await mcp__playwright__browser_evaluate({
    function: '() => axe.run()'
  });
});
```

### ACCEPTANCE CRITERIA
- [x] Self-service booking page with custom URL and branding
- [x] Real-time availability checking with buffer times
- [x] Automatic video meeting link generation for virtual consultations
- [x] Timezone conversion for international wedding clients
- [x] Wedding-specific form fields (couple names, wedding date, guest count)
- [x] Performance: Availability check completes within 1 second
- [x] Security: Client data validation and spam protection
- [x] Accessibility: Booking interface meets WCAG 2.1 AA standards

### DEPENDENCIES
- Must complete after: WS-061 (Email Templates for confirmations)
- Must complete before: WS-026 (Bulk Messaging), calendar integration features
- Shares code with: Email service, calendar service, client management

### ESTIMATED EFFORT
- Team A Frontend: 24 hours (Booking page builder, calendar interface, client form)
- Team C Integration: 20 hours (Calendar APIs, video providers, timezone handling)
- Team B Backend: 16 hours (Scheduling logic, availability calculation, database schema)
- Total: 60 hours