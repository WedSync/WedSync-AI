# TECHNICAL SPECIFICATION: WS-233 - API Usage Monitoring & Management
## Generated by Feature Development Session - 2025-01-25

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** WedSync platform administrator managing external API costs and performance
**I want to:** Monitor and manage usage of OpenAI (£300/month), Supabase (£500/month), Resend (£100/month), and other critical APIs
**So that:** I can prevent cost overruns during peak wedding season when API usage spikes 4x, detect abuse patterns when photographers make excessive AI form generation requests, and ensure service availability when email delivery or SMS notifications approach rate limits

**Real Wedding Scenario:**
"During June wedding season, OpenAI usage spikes to £1200/month as photographers generate 10x more AI-powered forms. Monitoring system alerts when spending exceeds £300 threshold, automatically throttles non-critical AI requests, and escalates to admin when photographers hit individual usage limits. Similarly, when venue coordinator sends 500+ SMS invites in one hour, system flags potential abuse and applies temporary rate limiting."

### SPECIFICATION SOURCE
- **Feature ID:** WS-233
- **Original Spec:** /CORE-SPECIFICATIONS/07-ADMIN-DASHBOARD/04-Technical-Monitoring/03-api-usage md.md
- **Current Implementation:** 0% complete
- **Files to Modify:** None (new feature)
- **New Files to Create:**
  - `/src/components/admin/APIUsageDashboard.tsx`
  - `/src/lib/monitoring/api-usage-tracker.ts`
  - `/src/lib/monitoring/api-cost-manager.ts`
  - `/src/lib/monitoring/api-rate-limiter.ts`
  - `/src/app/api/admin/api-usage/route.ts`
  - `/src/hooks/useAPIUsageMonitoring.ts`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- API usage tracking
CREATE TABLE api_usage_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  api_service TEXT NOT NULL, -- 'openai', 'supabase', 'resend', 'twilio', 'vercel'
  endpoint TEXT NOT NULL,
  method TEXT,
  user_id UUID REFERENCES users(id),
  usage_type TEXT NOT NULL, -- 'tokens', 'emails', 'sms', 'requests'
  usage_amount DECIMAL NOT NULL,
  cost DECIMAL(10, 4), -- Cost in currency
  response_time_ms INTEGER,
  status_code INTEGER,
  error_message TEXT,
  metadata JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- API cost budgets and limits
CREATE TABLE api_budgets (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  api_service TEXT NOT NULL UNIQUE,
  monthly_budget DECIMAL NOT NULL,
  current_month_spending DECIMAL DEFAULT 0,
  warning_threshold DECIMAL DEFAULT 0.8, -- 80% of budget
  hard_limit_threshold DECIMAL DEFAULT 1.2, -- 120% of budget
  auto_throttle_enabled BOOLEAN DEFAULT true,
  last_reset_date DATE DEFAULT CURRENT_DATE,
  CONSTRAINT valid_thresholds CHECK (warning_threshold < hard_limit_threshold)
);

-- API rate limiting rules
CREATE TABLE api_rate_limits (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  api_service TEXT NOT NULL,
  user_type TEXT, -- 'supplier', 'couple', null for global
  rate_limit_per_hour INTEGER NOT NULL,
  rate_limit_per_day INTEGER NOT NULL,
  burst_limit INTEGER DEFAULT 10,
  enabled BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- API usage aggregations for performance
CREATE TABLE api_usage_hourly (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  api_service TEXT NOT NULL,
  hour_bucket TIMESTAMPTZ NOT NULL,
  total_requests INTEGER DEFAULT 0,
  total_cost DECIMAL(10, 4) DEFAULT 0,
  avg_response_time_ms DECIMAL(8, 2),
  error_rate DECIMAL(4, 3),
  unique_users INTEGER,
  UNIQUE(api_service, hour_bucket)
);

CREATE INDEX idx_api_usage_service ON api_usage_events(api_service, created_at DESC);
CREATE INDEX idx_api_usage_user ON api_usage_events(user_id, api_service);
CREATE INDEX idx_api_usage_cost ON api_usage_events(api_service, cost) WHERE cost > 0;
```

#### API Endpoints Required
```typescript
// GET /api/admin/api-usage
interface APIUsageResponse {
  summary: APIUsageSummary;
  byService: Record<string, ServiceUsage>;
  alerts: APIUsageAlert[];
  budgetStatus: BudgetStatus[];
}

// POST /api/admin/api-usage/throttle
interface ThrottleAPIRequest {
  service: string;
  action: 'enable' | 'disable' | 'adjust';
  rateLimit?: number;
  duration?: number; // minutes
}

// GET /api/admin/api-usage/costs
interface APICostsResponse {
  currentMonth: number;
  projectedMonth: number;
  byService: ServiceCostBreakdown[];
  budgetAlerts: BudgetAlert[];
}
```

#### Frontend Components Required
```typescript
// Component: APIUsageDashboard
// Location: /src/components/admin/APIUsageDashboard.tsx

interface APIUsageDashboardProps {
  timeRange: '1h' | '24h' | '7d' | '30d';
  autoRefresh?: boolean;
}

// Key functionality:
- Real-time API usage monitoring with service breakdowns
- Cost tracking with budget alerts and projections
- Rate limiting controls and abuse detection
- Response time and error rate monitoring
- Historical usage trends and forecasting

// Component: APIBudgetManager
// Location: /src/components/admin/APIBudgetManager.tsx

interface APIBudgetManagerProps {
  budgets: APIBudget[];
  currentSpending: Record<string, number>;
}

// Key functionality:
- Budget setting and threshold configuration
- Spend projection and alerts
- Auto-throttling controls
- Cost optimization recommendations
```

#### Integration Points
```typescript
// Service: APIUsageTracker
// Dependencies: Database, Alert System, Rate Limiter

class APIUsageTracker {
  async trackAPIUsage(usage: APIUsageEvent): Promise<void> {
    // Track usage with buffering for performance
  }
  
  async checkRateLimits(userId: string, service: string): Promise<boolean> {
    // Enforce rate limits per user and service
  }
  
  async updateBudgetSpending(service: string, cost: number): Promise<void> {
    // Update monthly spending and trigger alerts
  }
}

// Service: APICostManager
// Dependencies: Usage Tracker, Budget System, Notification Service

class APICostManager {
  async calculateProjectedCosts(): Promise<CostProjection> {
    // Project monthly costs based on current usage trends
  }
  
  async triggerBudgetAlerts(): Promise<void> {
    // Send alerts when approaching budget limits
  }
}
```

### CODE EXAMPLES

#### Example 1: API Usage Tracker Implementation
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { supabase } from '@/lib/supabase';

export interface APIUsageEvent {
  apiService: string;
  endpoint: string;
  method: string;
  userId?: string;
  usageType: 'tokens' | 'emails' | 'sms' | 'requests';
  usageAmount: number;
  cost?: number;
  responseTimeMs?: number;
  statusCode?: number;
  errorMessage?: string;
  metadata?: Record<string, any>;
}

export interface APIServices {
  openai: {
    service: 'OpenAI GPT-4';
    purpose: 'AI form generation, smart suggestions';
    costModel: 'per-token';
    monthlyBudget: 300; // £
    criticalityLevel: 'high';
  };
  supabase: {
    service: 'Supabase';
    purpose: 'Database, Auth, Realtime, Storage';
    costModel: 'usage-based';
    monthlyBudget: 500; // £
    criticalityLevel: 'critical';
  };
  resend: {
    service: 'Resend Email';
    purpose: 'Transactional emails';
    costModel: 'per-email';
    monthlyBudget: 100; // £
    criticalityLevel: 'critical';
  };
  twilio: {
    service: 'Twilio';
    purpose: 'SMS/WhatsApp notifications';
    costModel: 'per-message';
    monthlyBudget: 150; // £
    criticalityLevel: 'medium';
  };
  vercel: {
    service: 'Vercel';
    purpose: 'Hosting, Edge Functions';
    costModel: 'usage-based';
    monthlyBudget: 200; // £
    criticalityLevel: 'critical';
  };
}

export class APIUsageTracker {
  private static instance: APIUsageTracker;
  private usageBuffer: Map<string, APIUsageEvent[]> = new Map();
  private flushInterval: NodeJS.Timeout | null = null;

  static getInstance(): APIUsageTracker {
    if (!APIUsageTracker.instance) {
      APIUsageTracker.instance = new APIUsageTracker();
    }
    return APIUsageTracker.instance;
  }

  constructor() {
    // Flush buffer every 30 seconds for performance
    this.flushInterval = setInterval(() => {
      this.flushUsageBuffer();
    }, 30000);
  }

  async trackAPIUsage(usage: APIUsageEvent): Promise<void> {
    // Add to buffer for batch processing
    const serviceBuffer = this.usageBuffer.get(usage.apiService) || [];
    serviceBuffer.push({
      ...usage,
      cost: this.calculateCost(usage)
    });
    this.usageBuffer.set(usage.apiService, serviceBuffer);

    // Check rate limits
    if (usage.userId) {
      const withinLimits = await this.checkRateLimits(usage.userId, usage.apiService);
      if (!withinLimits) {
        throw new Error(`Rate limit exceeded for ${usage.apiService}`);
      }
    }

    // Immediate cost check for critical services
    if (usage.cost && usage.cost > 1) { // £1+ costs
      await this.checkBudgetThresholds(usage.apiService, usage.cost);
    }
  }

  private calculateCost(usage: APIUsageEvent): number {
    const costRates = {
      openai: 0.002, // £0.002 per token (approximate)
      resend: 0.001, // £0.001 per email
      twilio: 0.04,  // £0.04 per SMS
      supabase: 0.0001, // £0.0001 per request (approximate)
      vercel: 0.00001  // £0.00001 per request (approximate)
    };

    const rate = costRates[usage.apiService as keyof typeof costRates] || 0;
    return usage.usageAmount * rate;
  }

  async checkRateLimits(userId: string, apiService: string): Promise<boolean> {
    // Check hourly rate limit
    const hourlyUsage = await this.getHourlyUsage(userId, apiService);
    const { data: rateLimits } = await supabase
      .from('api_rate_limits')
      .select('rate_limit_per_hour, burst_limit')
      .eq('api_service', apiService)
      .eq('enabled', true)
      .single();

    if (rateLimits && hourlyUsage > rateLimits.rate_limit_per_hour) {
      // Log rate limit violation
      await this.logRateLimitViolation(userId, apiService, hourlyUsage);
      return false;
    }

    return true;
  }

  private async getHourlyUsage(userId: string, apiService: string): Promise<number> {
    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
    
    const { data, error } = await supabase
      .from('api_usage_events')
      .select('usage_amount')
      .eq('user_id', userId)
      .eq('api_service', apiService)
      .gte('created_at', oneHourAgo.toISOString());

    if (error) throw error;

    return data.reduce((total, event) => total + event.usage_amount, 0);
  }

  private async checkBudgetThresholds(apiService: string, cost: number): Promise<void> {
    const { data: budget } = await supabase
      .from('api_budgets')
      .select('*')
      .eq('api_service', apiService)
      .single();

    if (!budget) return;

    const newSpending = budget.current_month_spending + cost;
    const warningThreshold = budget.monthly_budget * budget.warning_threshold;
    const hardThreshold = budget.monthly_budget * budget.hard_limit_threshold;

    if (newSpending > hardThreshold) {
      await this.triggerBudgetAlert(apiService, 'critical', newSpending, budget.monthly_budget);
      if (budget.auto_throttle_enabled) {
        await this.enableThrottling(apiService);
      }
    } else if (newSpending > warningThreshold) {
      await this.triggerBudgetAlert(apiService, 'warning', newSpending, budget.monthly_budget);
    }

    // Update current spending
    await supabase
      .from('api_budgets')
      .update({ current_month_spending: newSpending })
      .eq('api_service', apiService);
  }

  private async flushUsageBuffer(): Promise<void> {
    for (const [service, events] of this.usageBuffer.entries()) {
      if (events.length === 0) continue;

      try {
        // Batch insert events
        await supabase.from('api_usage_events').insert(events);

        // Update hourly aggregations
        await this.updateHourlyAggregations(service, events);

        // Clear buffer for this service
        this.usageBuffer.set(service, []);
      } catch (error) {
        console.error(`Failed to flush usage buffer for ${service}:`, error);
        // Keep events in buffer for retry
      }
    }
  }

  private async triggerBudgetAlert(
    apiService: string, 
    severity: 'warning' | 'critical',
    currentSpending: number,
    budget: number
  ): Promise<void> {
    const percentage = Math.round((currentSpending / budget) * 100);
    
    await supabase.from('alerts').insert({
      type: 'api_budget',
      priority: severity === 'critical' ? 'critical' : 'high',
      title: `${apiService} API budget ${severity}`,
      message: `Current spending: £${currentSpending.toFixed(2)} (${percentage}% of £${budget} budget)`,
      metadata: {
        api_service: apiService,
        current_spending: currentSpending,
        budget_limit: budget,
        percentage
      }
    });
  }

  destroy(): void {
    if (this.flushInterval) {
      clearInterval(this.flushInterval);
      this.flushInterval = null;
    }
  }
}

// Helper function for easy tracking
export async function trackAPIUsage(usage: Omit<APIUsageEvent, 'cost'>): Promise<void> {
  const tracker = APIUsageTracker.getInstance();
  await tracker.trackAPIUsage(usage);
}

// Usage in API routes:
// await trackAPIUsage({
//   apiService: 'openai',
//   endpoint: '/chat/completions',
//   method: 'POST',
//   userId: user.id,
//   usageType: 'tokens',
//   usageAmount: tokens,
//   responseTimeMs: Date.now() - startTime,
//   statusCode: 200
// });
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for API monitoring patterns, cost management strategies
- [x] Supabase: Real-time usage tracking, budget management
- [x] Filesystem: Access API configuration and rate limiting rules

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/vercel/next.js", "api monitoring", 2000);
await mcp__context7__get-library-docs("/supabase/supabase", "real-time subscriptions", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('APIUsageTracker', () => {
  it('should calculate costs correctly for different services', () => {
    const tracker = new APIUsageTracker();
    const openaiCost = tracker.calculateCost({
      apiService: 'openai',
      usageType: 'tokens',
      usageAmount: 1000
    });
    expect(openaiCost).toBe(2); // £2 for 1000 tokens
  });

  it('should enforce hourly rate limits', async () => {
    const withinLimits = await tracker.checkRateLimits('user-id', 'openai');
    expect(withinLimits).toBe(true);
  });

  it('should trigger budget alerts at thresholds', async () => {
    await tracker.checkBudgetThresholds('openai', 250); // £250 cost
    // Should trigger warning at 80% of £300 budget
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Admin can monitor API usage and set budget limits', async () => {
  await mcp__playwright__browser_navigate({url: '/admin/api-usage'});
  await mcp__playwright__browser_snapshot();
  
  // Check OpenAI usage chart
  await mcp__playwright__browser_wait_for({text: 'OpenAI Usage'});
  
  // Set budget alert
  await mcp__playwright__browser_click({
    element: 'Set budget button for OpenAI',
    ref: '[data-testid="set-openai-budget"]'
  });
  
  await mcp__playwright__browser_type({
    element: 'Budget amount input',
    ref: '#budget-amount',
    text: '400'
  });
  
  await mcp__playwright__browser_snapshot();
});
```

### ACCEPTANCE CRITERIA
- [x] Real-time tracking of all API usage (OpenAI, Supabase, Resend, Twilio, Vercel)
- [x] Cost calculation and budget monitoring with configurable thresholds
- [x] Rate limiting enforcement per user and service with abuse detection
- [x] Automatic throttling when budgets exceeded (if enabled)
- [x] Historical usage analysis and cost projection
- [x] Performance: Usage tracking adds <10ms latency to API calls
- [x] Security: Budget and rate limit access restricted to admin roles
- [x] Reliability: 99.9% accuracy in usage tracking and cost calculation

### DEPENDENCIES
- Must complete after: API monitoring infrastructure, admin dashboard framework
- Must complete before: Cost optimization system, automated scaling
- Shares code with: System monitoring dashboard, alert management system

### ESTIMATED EFFORT
- Team A Frontend: 20 hours (API usage dashboard, budget management UI)
- Team B Backend: 36 hours (Usage tracker, rate limiter, cost manager, API endpoints)
- Team C Integration: 12 hours (External API monitoring integration)
- Team D Platform: 8 hours (Database schema, performance optimization)
- Team E General: 16 hours (Testing, usage validation, alert testing)
- Team F Workflows: 6 hours (Automated budget reset, usage reporting)
- Team G Performance: 8 hours (Usage tracking optimization, buffering)
- Total: 106 hours