# TECHNICAL SPECIFICATION: WS-030 - Journey Execution Engine
## Generated by Feature Development Session - August 21, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding photographer with 15 active clients in different journey stages
**I want to:** Have all client communications execute automatically at the right times without manual intervention
**So that:** I can focus on shooting weddings instead of remembering to send timeline requests or contract reminders

**Real Wedding Scenario:**
A photographer forgets to send the "6-week timeline planning" email to 3 different couples.
This causes last-minute timeline confusion, venue conflicts, and stressed clients.
With the execution engine, journeys run automatically - sending timeline requests exactly 42 days before each wedding date.

### SPECIFICATION SOURCE
- **Feature ID:** WS-030
- **Original Spec:** /CORE-SPECIFICATIONS/02-WEDSYNC-SUPPLIER-PLATFORM/05-Customer-Journey/07-execution-engine md.md
- **Current Implementation:** 75% complete (core scheduling exists)
- **Files to Modify:**
  - /wedsync/src/lib/services/journey-service.ts (add execution logic)
  - /wedsync/src/app/api/journeys/execute/route.ts (enhance endpoint)
- **New Files to Create:**
  - /wedsync/src/lib/execution/journey-executor.ts
  - /wedsync/src/lib/execution/execution-queue.ts
  - /wedsync/src/lib/execution/state-manager.ts
  - /wedsync/src/lib/execution/retry-handler.ts
  - /wedsync/src/app/api/execution/status/route.ts
  - /wedsync/src/app/api/execution/retry/route.ts
  - /wedsync/supabase/migrations/022_execution_engine.sql

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Journey execution state tracking
CREATE TABLE IF NOT EXISTS journey_execution_state (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  journey_instance_id UUID NOT NULL REFERENCES journey_instances(id) ON DELETE CASCADE,
  current_node_id UUID,
  execution_status TEXT NOT NULL CHECK (execution_status IN ('active', 'paused', 'completed', 'failed', 'waiting')),
  variables JSONB DEFAULT '{}',
  completed_nodes UUID[] DEFAULT '{}',
  scheduled_nodes JSONB DEFAULT '[]',
  error_count INTEGER DEFAULT 0,
  last_error_message TEXT,
  last_execution_at TIMESTAMPTZ,
  next_execution_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(journey_instance_id)
);

-- Execution queue for scheduled tasks
CREATE TABLE IF NOT EXISTS execution_queue (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  journey_instance_id UUID NOT NULL REFERENCES journey_instances(id) ON DELETE CASCADE,
  node_id UUID NOT NULL,
  module_type TEXT NOT NULL,
  module_config JSONB NOT NULL,
  scheduled_for TIMESTAMPTZ NOT NULL,
  priority INTEGER DEFAULT 0, -- Higher = more urgent
  retry_count INTEGER DEFAULT 0,
  max_retries INTEGER DEFAULT 3,
  execution_status TEXT DEFAULT 'pending' CHECK (execution_status IN ('pending', 'running', 'completed', 'failed', 'cancelled')),
  execution_started_at TIMESTAMPTZ,
  execution_completed_at TIMESTAMPTZ,
  execution_error TEXT,
  execution_result JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Execution metrics and monitoring
CREATE TABLE IF NOT EXISTS execution_metrics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  date DATE NOT NULL DEFAULT CURRENT_DATE,
  total_executions INTEGER DEFAULT 0,
  successful_executions INTEGER DEFAULT 0,
  failed_executions INTEGER DEFAULT 0,
  retry_executions INTEGER DEFAULT 0,
  avg_execution_time_ms INTEGER DEFAULT 0,
  queue_depth_max INTEGER DEFAULT 0,
  queue_depth_avg INTEGER DEFAULT 0,
  error_rate DECIMAL(5,4) DEFAULT 0.0000,
  UNIQUE(date)
);

-- Module execution history for debugging
CREATE TABLE IF NOT EXISTS module_execution_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  queue_item_id UUID NOT NULL REFERENCES execution_queue(id) ON DELETE CASCADE,
  journey_instance_id UUID NOT NULL REFERENCES journey_instances(id),
  module_type TEXT NOT NULL,
  execution_status TEXT NOT NULL,
  input_data JSONB,
  output_data JSONB,
  execution_time_ms INTEGER,
  error_details JSONB,
  executed_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_execution_state_next_run ON journey_execution_state(next_execution_at) WHERE execution_status = 'active';
CREATE INDEX idx_queue_scheduled ON execution_queue(scheduled_for, priority DESC) WHERE execution_status = 'pending';
CREATE INDEX idx_queue_status ON execution_queue(execution_status, created_at);
CREATE INDEX idx_metrics_date ON execution_metrics(date DESC);
CREATE INDEX idx_execution_history_journey ON module_execution_history(journey_instance_id, executed_at DESC);

-- Database functions
CREATE OR REPLACE FUNCTION update_execution_metrics()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO execution_metrics (date, total_executions, successful_executions, failed_executions)
  VALUES (CURRENT_DATE, 1, 
    CASE WHEN NEW.execution_status = 'completed' THEN 1 ELSE 0 END,
    CASE WHEN NEW.execution_status = 'failed' THEN 1 ELSE 0 END
  )
  ON CONFLICT (date) DO UPDATE SET
    total_executions = execution_metrics.total_executions + 1,
    successful_executions = execution_metrics.successful_executions + 
      CASE WHEN NEW.execution_status = 'completed' THEN 1 ELSE 0 END,
    failed_executions = execution_metrics.failed_executions + 
      CASE WHEN NEW.execution_status = 'failed' THEN 1 ELSE 0 END,
    retry_executions = execution_metrics.retry_executions + 
      CASE WHEN NEW.retry_count > 0 THEN 1 ELSE 0 END;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_execution_metrics
  AFTER UPDATE ON execution_queue
  FOR EACH ROW
  WHEN (OLD.execution_status != NEW.execution_status)
  EXECUTE FUNCTION update_execution_metrics();
```

#### API Endpoints Required
```typescript
// POST /api/execution/process
interface ProcessExecutionRequest {
  batchSize?: number;
  maxRetries?: number;
}

interface ProcessExecutionResponse {
  success: boolean;
  data: {
    processed: number;
    successful: number;
    failed: number;
    queueDepth: number;
    nextScheduled?: string;
  };
}

// GET /api/execution/status/{journeyInstanceId}
interface ExecutionStatusResponse {
  success: boolean;
  data: {
    status: 'active' | 'paused' | 'completed' | 'failed' | 'waiting';
    currentNode?: string;
    completedNodes: string[];
    scheduledNodes: ScheduledNode[];
    variables: Record<string, any>;
    errorCount: number;
    lastError?: string;
    nextExecution?: string;
    progress: {
      completed: number;
      total: number;
      percentage: number;
    };
  };
}

// POST /api/execution/retry/{queueItemId}
interface RetryExecutionRequest {
  resetRetryCount?: boolean;
}

// GET /api/execution/metrics
interface ExecutionMetricsResponse {
  success: boolean;
  data: {
    today: {
      totalExecutions: number;
      successRate: number;
      avgExecutionTime: number;
      queueDepth: number;
    };
    trends: {
      date: string;
      executions: number;
      successRate: number;
    }[];
    errors: {
      moduleType: string;
      errorCount: number;
      lastError: string;
    }[];
  };
}

// POST /api/execution/pause/{journeyInstanceId}
// POST /api/execution/resume/{journeyInstanceId}
interface ExecutionControlResponse {
  success: boolean;
  data: {
    status: string;
    affectedNodes: number;
  };
}
```

#### Frontend Components Required
```typescript
// Component: ExecutionMonitor (for admin dashboard)
// Location: /src/components/execution/ExecutionMonitor.tsx

interface ExecutionMonitorProps {
  journeyInstanceId?: string;
  showMetrics?: boolean;
  onRetry?: (queueItemId: string) => void;
}

// Key functionality:
- Real-time execution status
- Queue depth monitoring
- Error rate visualization
- Manual retry controls
- Performance metrics display

// Component: JourneyProgress (for client view)
// Location: /src/components/execution/JourneyProgress.tsx

interface JourneyProgressProps {
  journeyInstanceId: string;
  showDetails?: boolean;
}

// Key functionality:
- Visual progress indicator
- Completed/upcoming steps
- Current status display
- Timeline visualization
- Next action preview
```

#### Integration Points
```typescript
// Service: JourneyExecutor
// Dependencies: NotificationService, EmailService, SMSService, TaskService

class JourneyExecutor {
  private queue: ExecutionQueue;
  private stateManager: StateManager;
  private retryHandler: RetryHandler;

  async processQueue(batchSize: number = 10): Promise<ProcessingResult> {
    // Get pending items from queue
    // Execute modules in priority order
    // Update state and schedule next nodes
    // Handle errors with retry logic
  }

  async executeModule(queueItem: QueueItem): Promise<ExecutionResult> {
    // Determine module type and config
    // Call appropriate service (email, SMS, etc.)
    // Record execution result
    // Update journey state
  }

  async scheduleNextNodes(journeyInstance: JourneyInstance, completedNode: string) {
    // Find next nodes in journey flow
    // Calculate execution timing
    // Add to execution queue
    // Update journey state
  }
}
```

### CODE EXAMPLES

#### Example 1: Core Execution Loop
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { supabase } from '@/lib/supabase';
import { EmailService } from '@/lib/services/email-service';
import { SMSService } from '@/lib/services/sms-service';

export class JourneyExecutor {
  private emailService: EmailService;
  private smsService: SMSService;

  constructor() {
    this.emailService = new EmailService();
    this.smsService = new SMSService();
  }

  async processExecutionQueue(batchSize: number = 10): Promise<ProcessingResult> {
    // Step 1: Get pending queue items ordered by priority and scheduled time
    const { data: queueItems, error } = await supabase
      .from('execution_queue')
      .select('*')
      .eq('execution_status', 'pending')
      .lte('scheduled_for', new Date().toISOString())
      .order('priority', { ascending: false })
      .order('scheduled_for', { ascending: true })
      .limit(batchSize);

    if (error) throw error;

    const results = {
      processed: 0,
      successful: 0,
      failed: 0
    };

    // Step 2: Process each queue item
    for (const item of queueItems) {
      try {
        // Mark as running
        await supabase
          .from('execution_queue')
          .update({
            execution_status: 'running',
            execution_started_at: new Date().toISOString()
          })
          .eq('id', item.id);

        // Execute the module
        const executionResult = await this.executeModule(item);

        // Update queue item with result
        await supabase
          .from('execution_queue')
          .update({
            execution_status: 'completed',
            execution_completed_at: new Date().toISOString(),
            execution_result: executionResult
          })
          .eq('id', item.id);

        // Update journey state
        await this.updateJourneyState(item.journey_instance_id, item.node_id, executionResult);

        // Schedule next nodes if this was successful
        await this.scheduleNextNodes(item.journey_instance_id, item.node_id);

        results.successful++;

      } catch (error) {
        // Handle execution error
        await this.handleExecutionError(item, error as Error);
        results.failed++;
      }

      results.processed++;
    }

    return results;
  }

  async executeModule(queueItem: QueueItem): Promise<ExecutionResult> {
    const startTime = Date.now();
    
    try {
      let result: any;

      // Route to appropriate service based on module type
      switch (queueItem.module_type) {
        case 'email':
          result = await this.emailService.sendTemplatedEmail({
            to: queueItem.module_config.recipient,
            templateId: queueItem.module_config.templateId,
            variables: queueItem.module_config.variables
          });
          break;

        case 'sms':
          result = await this.smsService.sendMessage({
            to: queueItem.module_config.phoneNumber,
            message: queueItem.module_config.message
          });
          break;

        case 'task':
          result = await this.createTask({
            title: queueItem.module_config.title,
            description: queueItem.module_config.description,
            assignedTo: queueItem.module_config.assignedTo,
            dueDate: queueItem.module_config.dueDate
          });
          break;

        case 'delay':
          // Delay modules just schedule the next execution
          result = { delayed: true, nextExecution: queueItem.module_config.delayUntil };
          break;

        default:
          throw new Error(`Unknown module type: ${queueItem.module_type}`);
      }

      // Record execution in history
      await supabase
        .from('module_execution_history')
        .insert({
          queue_item_id: queueItem.id,
          journey_instance_id: queueItem.journey_instance_id,
          module_type: queueItem.module_type,
          execution_status: 'completed',
          input_data: queueItem.module_config,
          output_data: result,
          execution_time_ms: Date.now() - startTime
        });

      return {
        success: true,
        result,
        executionTime: Date.now() - startTime
      };

    } catch (error) {
      // Record failed execution
      await supabase
        .from('module_execution_history')
        .insert({
          queue_item_id: queueItem.id,
          journey_instance_id: queueItem.journey_instance_id,
          module_type: queueItem.module_type,
          execution_status: 'failed',
          input_data: queueItem.module_config,
          error_details: { message: error.message, stack: error.stack },
          execution_time_ms: Date.now() - startTime
        });

      throw error;
    }
  }
}
```

#### Example 2: Smart Retry Logic with Exponential Backoff
```typescript
// Advanced retry handling with different strategies per module type
export class RetryHandler {
  private readonly retryStrategies = {
    email: { maxRetries: 3, backoffMultiplier: 2, baseDelay: 60000 }, // 1min, 2min, 4min
    sms: { maxRetries: 5, backoffMultiplier: 1.5, baseDelay: 30000 }, // 30s, 45s, 67s, 101s, 152s
    task: { maxRetries: 1, backoffMultiplier: 1, baseDelay: 300000 }, // 5min only
    delay: { maxRetries: 0, backoffMultiplier: 1, baseDelay: 0 } // No retries for delays
  };

  async handleExecutionError(queueItem: QueueItem, error: Error): Promise<void> {
    const strategy = this.retryStrategies[queueItem.module_type] || this.retryStrategies.email;
    const shouldRetry = queueItem.retry_count < strategy.maxRetries;

    if (shouldRetry) {
      // Calculate next retry time with exponential backoff
      const backoffDelay = strategy.baseDelay * Math.pow(strategy.backoffMultiplier, queueItem.retry_count);
      const nextRetryAt = new Date(Date.now() + backoffDelay);

      await supabase
        .from('execution_queue')
        .update({
          execution_status: 'pending',
          retry_count: queueItem.retry_count + 1,
          scheduled_for: nextRetryAt.toISOString(),
          execution_error: error.message,
          execution_started_at: null // Reset running state
        })
        .eq('id', queueItem.id);

      // Log retry attempt
      console.log(`Scheduling retry ${queueItem.retry_count + 1}/${strategy.maxRetries} for queue item ${queueItem.id} at ${nextRetryAt}`);

    } else {
      // Max retries exceeded - mark as failed and pause journey
      await supabase
        .from('execution_queue')
        .update({
          execution_status: 'failed',
          execution_error: error.message,
          execution_completed_at: new Date().toISOString()
        })
        .eq('id', queueItem.id);

      // Pause the journey to prevent further issues
      await supabase
        .from('journey_execution_state')
        .update({
          execution_status: 'failed',
          error_count: supabase.sql`error_count + 1`,
          last_error_message: error.message
        })
        .eq('journey_instance_id', queueItem.journey_instance_id);

      // Send alert to supplier about failed journey
      await this.sendFailureAlert(queueItem.journey_instance_id, error);
    }
  }

  async sendFailureAlert(journeyInstanceId: string, error: Error): Promise<void> {
    // Get journey and supplier details
    const { data: journey } = await supabase
      .from('journey_instances')
      .select(`
        *,
        journeys(name, supplier_id),
        clients(name, email)
      `)
      .eq('id', journeyInstanceId)
      .single();

    if (journey) {
      // Send email alert to supplier
      await this.emailService.sendAlert({
        to: journey.journeys.supplier_id,
        subject: `Journey Execution Failed: ${journey.journeys.name}`,
        message: `The journey "${journey.journeys.name}" for client "${journey.clients.name}" has failed execution. Error: ${error.message}`,
        priority: 'high'
      });
    }
  }
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load Supabase edge functions docs
- [x] Filesystem: Access project structure
- [ ] Playwright: Test execution monitoring UI

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/supabase/supabase", "edge functions triggers", 3000);
await mcp__context7__get-library-docs("/vercel/next.js", "cron jobs api routes", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('JourneyExecutor', () => {
  it('should process queue items in priority order', async () => {
    const mockItems = [
      { priority: 1, scheduled_for: '2025-01-01T10:00:00Z' },
      { priority: 5, scheduled_for: '2025-01-01T09:00:00Z' },
      { priority: 3, scheduled_for: '2025-01-01T08:00:00Z' }
    ];
    const executor = new JourneyExecutor();
    const processed = await executor.processQueue(mockItems);
    expect(processed[0].priority).toBe(5); // Highest priority first
  });

  it('should handle module execution failures gracefully', async () => {
    const failingModule = { type: 'email', config: { invalid: true } };
    const executor = new JourneyExecutor();
    await expect(executor.executeModule(failingModule)).rejects.toThrow();
    // Verify retry was scheduled
  });

  it('should apply exponential backoff for retries', () => {
    const retryHandler = new RetryHandler();
    const delay1 = retryHandler.calculateBackoff('email', 0);
    const delay2 = retryHandler.calculateBackoff('email', 1);
    const delay3 = retryHandler.calculateBackoff('email', 2);
    expect(delay2).toBe(delay1 * 2);
    expect(delay3).toBe(delay1 * 4);
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Journey execution monitoring dashboard', async () => {
  await mcp__playwright__browser_navigate({url: '/admin/execution'});
  
  // Verify metrics display
  await mcp__playwright__browser_snapshot();
  
  // Test retry functionality
  await mcp__playwright__browser_click({
    element: 'Retry failed execution button',
    ref: 'button:has-text("Retry")'
  });
  
  // Verify queue status updates
  await mcp__playwright__browser_wait_for({text: 'Execution retried'});
});
```

### ACCEPTANCE CRITERIA
- [x] Processes queue items automatically every 5 minutes
- [x] Executes modules in priority order
- [x] Implements retry logic with exponential backoff
- [x] Handles different module types (email, SMS, task, delay)
- [x] Maintains execution state across restarts
- [x] Provides real-time execution monitoring
- [x] Alerts on journey failures
- [x] Performance: Processes 100+ items per minute
- [x] Security: Isolated execution per supplier
- [x] Reliability: 99.9% execution success rate

### DEPENDENCIES
- Must complete after: WS-015 (Journey Builder UI), WS-029 (Journey Templates)
- Must complete before: None (final feature)
- Shares code with: All journey-related features

### ESTIMATED EFFORT
- Team A Frontend: 16 hours (monitoring UI)
- Team B Backend: 40 hours (execution engine)
- Team D Infrastructure: 24 hours (queue optimization)
- Total: 80 hours