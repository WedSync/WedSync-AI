# TECHNICAL SPECIFICATION: WS-121 - PDF Analysis System
## Generated by Feature Development Session - August 23, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding photographer or venue coordinator
**I want to:** Upload my existing PDF forms and have them automatically analyzed for field extraction
**So that:** I can convert my 10+ page questionnaires into digital forms without manually recreating 100+ fields, saving 4-6 hours per form

**Real Wedding Scenario:**
A wedding photographer currently has a 12-page PDF questionnaire they send to couples covering shot lists, family groupings, timeline preferences, and special moments. Converting this to digital forms manually takes 4-6 hours of copying field names, setting up validation rules, and organizing sections. With PDF analysis, they upload once and get an instant digital form structure ready for couples to fill online.

### SPECIFICATION SOURCE
- **Feature ID:** WS-121
- **Original Spec:** /CORE-SPECIFICATIONS/04-AI-INTEGRATION/02-Form-Intelligence/01-pdf-analysis md.md
- **Current Implementation:** 0% complete
- **Files to Modify:** None - New feature
- **New Files to Create:** 
  - /src/lib/ai/pdf-analyzer.ts
  - /src/lib/ai/vision-analyzer.ts
  - /src/lib/ai/field-type-detector.ts
  - /src/lib/queues/pdf-processing-queue.ts
  - /src/components/forms/pdf-upload.tsx
  - /src/app/api/forms/pdf-analysis/route.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- PDF Analysis job tracking
CREATE TABLE IF NOT EXISTS pdf_analysis_jobs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES user_profiles(id) ON DELETE CASCADE,
  original_filename TEXT NOT NULL,
  file_url TEXT NOT NULL,
  file_size INTEGER,
  page_count INTEGER,
  analysis_status TEXT DEFAULT 'pending' CHECK (analysis_status IN ('pending', 'queued', 'processing', 'completed', 'failed')),
  extracted_fields JSONB,
  layout_structure JSONB,
  confidence_score DECIMAL(3,2),
  processing_time_ms INTEGER,
  error_message TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  completed_at TIMESTAMPTZ
);

-- Extracted form fields from PDFs
CREATE TABLE IF NOT EXISTS extracted_form_fields (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  job_id UUID REFERENCES pdf_analysis_jobs(id) ON DELETE CASCADE,
  page_number INTEGER NOT NULL,
  field_label TEXT NOT NULL,
  field_type TEXT NOT NULL,
  field_name TEXT, -- Generated snake_case name
  required BOOLEAN DEFAULT false,
  options JSONB, -- For select/radio fields
  validation_rules JSONB,
  position JSONB, -- {x, y, width, height}
  confidence DECIMAL(3,2),
  is_core_field BOOLEAN DEFAULT false,
  core_field_id TEXT, -- Maps to WedSync core fields
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_pdf_jobs_supplier ON pdf_analysis_jobs(supplier_id);
CREATE INDEX idx_pdf_jobs_status ON pdf_analysis_jobs(analysis_status);
CREATE INDEX idx_extracted_fields_job ON extracted_form_fields(job_id);
```

#### API Endpoints Required
```typescript
// POST /api/forms/pdf-analysis/upload
interface UploadPDFRequest {
  file: File; // MultipartFile
  supplierId: string;
  formType?: 'questionnaire' | 'contract' | 'checklist' | 'other';
}

interface UploadPDFResponse {
  success: boolean;
  data: {
    jobId: string;
    status: 'queued' | 'processing';
    estimatedTime: number; // seconds
  };
}

// GET /api/forms/pdf-analysis/status/{jobId}
interface AnalysisStatusResponse {
  jobId: string;
  status: 'pending' | 'queued' | 'processing' | 'completed' | 'failed';
  progress?: number; // 0-100
  result?: {
    pageCount: number;
    fieldCount: number;
    confidence: number;
    fields: ExtractedField[];
  };
  error?: string;
}

// POST /api/forms/pdf-analysis/confirm
interface ConfirmFieldsRequest {
  jobId: string;
  fields: {
    id: string;
    confirmed: boolean;
    corrections?: {
      label?: string;
      type?: string;
      required?: boolean;
    };
  }[];
}
```

#### Frontend Components Required
```typescript
// Component: PDFUploadWizard
// Location: /src/components/forms/pdf-upload-wizard.tsx

interface PDFUploadWizardProps {
  onComplete: (formTemplate: FormTemplate) => void;
  onCancel: () => void;
  maxFileSize?: number; // Default 10MB
}

// Key functionality:
- Drag & drop PDF upload with preview
- Real-time processing status with progress bar
- Field extraction preview with confidence indicators
- Manual correction interface for low-confidence fields
- Section grouping editor
- Final form template preview

// Component: FieldExtractionPreview
// Location: /src/components/forms/field-extraction-preview.tsx

interface FieldExtractionPreviewProps {
  fields: ExtractedField[];
  onFieldEdit: (fieldId: string, updates: Partial<ExtractedField>) => void;
  onFieldRemove: (fieldId: string) => void;
  showConfidence?: boolean;
}

// Key functionality:
- Visual field list with type icons
- Confidence score badges (green >80%, yellow 50-80%, red <50%)
- Inline editing for field properties
- Drag to reorder fields
- Group fields into sections
```

#### Integration Points
```typescript
// Service: PDFAnalyzer
// Dependencies: OpenAI API, pdf.js, Supabase Storage

class PDFAnalyzer {
  private openai: OpenAI;
  private storage: SupabaseStorage;
  
  async analyzePDF(file: File): Promise<FormAnalysis> {
    // Step 1: Upload to secure storage
    const fileUrl = await this.storage.upload(file, 'pdf-analysis');
    
    // Step 2: Convert PDF pages to images using pdf.js
    const pages = await this.convertToImages(file);
    
    // Step 3: Extract text layer for additional context
    const textData = await this.extractTextContent(file);
    
    // Step 4: Send to OpenAI Vision API for analysis
    const visionResults = await this.analyzeWithVision(pages);
    
    // Step 5: Merge and validate all extracted data
    const analysis = this.mergeAnalysisResults(textData, visionResults);
    
    // Step 6: Calculate confidence scores
    return this.addConfidenceScores(analysis);
  }
  
  private async analyzeWithVision(images: string[]): Promise<VisionAnalysis[]> {
    return Promise.all(images.map(async (image, index) => {
      const response = await this.openai.chat.completions.create({
        model: 'gpt-4o',
        messages: [{
          role: 'user',
          content: [
            {
              type: 'text',
              text: `Analyze this wedding supplier form page ${index + 1} and extract:
                1. All form fields with their exact labels
                2. Field types (text, email, date, checkbox, etc.)
                3. Required/optional indicators (asterisks, "required" text)
                4. Field groupings and section headers
                5. Any visible validation rules or helper text
                Return as structured JSON with wedding-specific context.`
            },
            {
              type: 'image_url',
              image_url: { url: image }
            }
          ]
        }],
        response_format: { type: 'json_object' }
      });
      
      return JSON.parse(response.choices[0].message.content);
    }));
  }
}
```

### CODE EXAMPLES

#### Example 1: PDF Processing Queue Implementation
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { createClient } from '@supabase/supabase-js';
import { Queue } from 'bull';
import { PDFAnalyzer } from '@/lib/ai/pdf-analyzer';

export class PDFProcessingQueue {
  private queue: Queue;
  private analyzer: PDFAnalyzer;
  
  constructor() {
    this.queue = new Queue('pdf-analysis', {
      redis: process.env.REDIS_URL
    });
    
    this.analyzer = new PDFAnalyzer();
    this.setupWorker();
  }
  
  async addJob(file: File, supplierId: string) {
    // Step 1: Create database record
    const { data: job, error } = await supabase
      .from('pdf_analysis_jobs')
      .insert({
        supplier_id: supplierId,
        original_filename: file.name,
        file_size: file.size,
        analysis_status: 'queued'
      })
      .select()
      .single();
    
    if (error) throw error;
    
    // Step 2: Upload file to storage
    const { data: upload } = await supabase.storage
      .from('pdf-uploads')
      .upload(`${supplierId}/${job.id}/${file.name}`, file);
    
    // Step 3: Add to processing queue
    await this.queue.add('analyze-pdf', {
      jobId: job.id,
      fileUrl: upload.path,
      supplierId
    }, {
      attempts: 3,
      backoff: { type: 'exponential', delay: 2000 }
    });
    
    return job;
  }
  
  private setupWorker() {
    this.queue.process('analyze-pdf', async (job) => {
      const { jobId, fileUrl } = job.data;
      
      try {
        // Update status to processing
        await supabase
          .from('pdf_analysis_jobs')
          .update({ analysis_status: 'processing' })
          .eq('id', jobId);
        
        // Perform analysis
        const analysis = await this.analyzer.analyzePDF(fileUrl);
        
        // Store extracted fields
        await this.storeExtractedFields(jobId, analysis.fields);
        
        // Update job with results
        await supabase
          .from('pdf_analysis_jobs')
          .update({
            analysis_status: 'completed',
            extracted_fields: analysis.summary,
            confidence_score: analysis.confidence,
            page_count: analysis.pageCount,
            completed_at: new Date().toISOString()
          })
          .eq('id', jobId);
          
      } catch (error) {
        await this.handleError(jobId, error);
        throw error;
      }
    });
  }
}
```

#### Example 2: Field Type Detection with Wedding Context
```typescript
// Wedding-specific field type detection
export class WeddingFieldTypeDetector {
  private weddingPatterns = {
    // Core wedding fields
    weddingDate: /wedding.?date|ceremony.?date|big.?day/i,
    venueAddress: /venue.?address|ceremony.?location|reception.?location/i,
    guestCount: /guest.?count|number.?of.?guests|total.?guests|attendees/i,
    timeline: /timeline|schedule|itinerary|run.?sheet|order.?of.?events/i,
    
    // Photography specific
    shotList: /shot.?list|photo.?list|must.?have.?shots|family.?photos/i,
    firstLook: /first.?look|private.?moment|reveal/i,
    
    // Catering specific
    dietaryRestrictions: /dietary|allergies|food.?restrictions|special.?meals/i,
    mealChoice: /meal.?choice|dinner.?selection|entree/i,
    
    // Common fields
    coupleNames: /couple|bride|groom|partner|names/i,
    contactEmail: /email|e-?mail|contact/i,
    contactPhone: /phone|mobile|cell|contact.?number/i
  };
  
  detectFieldType(label: string, context?: string): {
    type: string;
    weddingContext?: string;
    validation?: any;
  } {
    const combined = `${label} ${context || ''}`.toLowerCase();
    
    // Check wedding-specific patterns first
    for (const [fieldType, pattern] of Object.entries(this.weddingPatterns)) {
      if (pattern.test(combined)) {
        return this.getWeddingFieldConfig(fieldType);
      }
    }
    
    // Fallback to generic detection
    return this.detectGenericType(combined);
  }
  
  private getWeddingFieldConfig(fieldType: string) {
    const configs = {
      weddingDate: {
        type: 'date',
        weddingContext: 'ceremony_date',
        validation: { 
          required: true,
          futureDate: true,
          maxYears: 2 
        }
      },
      guestCount: {
        type: 'number',
        weddingContext: 'total_guests',
        validation: { 
          required: true,
          min: 1,
          max: 1000 
        }
      },
      venueAddress: {
        type: 'address',
        weddingContext: 'venue_location',
        validation: { 
          required: true,
          geocoding: true 
        }
      },
      shotList: {
        type: 'textarea',
        weddingContext: 'photo_requirements',
        validation: { 
          maxLength: 2000 
        }
      },
      dietaryRestrictions: {
        type: 'multiselect',
        weddingContext: 'dietary_needs',
        validation: { 
          options: ['Vegetarian', 'Vegan', 'Gluten-Free', 'Nut-Free', 'Dairy-Free', 'Other']
        }
      }
    };
    
    return configs[fieldType] || { type: 'text' };
  }
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [ ] Context7: Load OpenAI and pdf.js documentation
- [ ] Filesystem: Access uploaded PDF files
- [ ] Supabase: Database operations and file storage

#### Context7 Queries Needed
```typescript
// Load OpenAI Vision API documentation
await mcp__context7__get-library-docs("/openai/openai", "vision chat completions", 3000);

// Load pdf.js for PDF processing
await mcp__context7__get-library-docs("/mozilla/pdf.js", "getDocument render canvas", 2000);

// Load Bull queue documentation for job processing
await mcp__context7__get-library-docs("/OptimalBits/bull", "queue process job", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('PDFAnalyzer', () => {
  it('should extract fields from single-page PDF', async () => {
    const mockPDF = createMockPDF({ pages: 1, fields: 10 });
    const result = await analyzer.analyzePDF(mockPDF);
    expect(result.fields).toHaveLength(10);
    expect(result.confidence).toBeGreaterThan(0.7);
  });
  
  it('should handle multi-page forms correctly', async () => {
    const mockPDF = createMockPDF({ pages: 5, fieldsPerPage: 8 });
    const result = await analyzer.analyzePDF(mockPDF);
    expect(result.fields).toHaveLength(40);
    expect(result.pageCount).toBe(5);
  });
  
  it('should detect wedding-specific field types', () => {
    const detector = new WeddingFieldTypeDetector();
    expect(detector.detectFieldType('Wedding Date').type).toBe('date');
    expect(detector.detectFieldType('Number of Guests').type).toBe('number');
    expect(detector.detectFieldType('Venue Address').type).toBe('address');
  });
  
  it('should handle password-protected PDFs gracefully', async () => {
    const protectedPDF = createMockPDF({ passwordProtected: true });
    await expect(analyzer.analyzePDF(protectedPDF))
      .rejects.toThrow('PDF is password protected');
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('PDF upload and analysis flow', async () => {
  await mcp__playwright__browser_navigate({url: '/forms/import'});
  
  // Upload PDF file
  await mcp__playwright__browser_file_upload({
    paths: ['/test-fixtures/wedding-questionnaire.pdf']
  });
  
  // Wait for analysis to complete
  await mcp__playwright__browser_wait_for({
    text: 'Analysis Complete',
    timeout: 30000
  });
  
  // Verify extracted fields
  await mcp__playwright__browser_snapshot();
  // Should show extracted fields with confidence scores
  
  // Edit low-confidence field
  await mcp__playwright__browser_click({
    element: 'Edit field button',
    ref: '[data-field-id="field-1"]'
  });
  
  // Confirm and create form
  await mcp__playwright__browser_click({
    element: 'Create Form Template',
    ref: 'button[type="submit"]'
  });
  
  // Verify form creation success
  await mcp__playwright__browser_wait_for({
    text: 'Form template created successfully'
  });
});
```

### ACCEPTANCE CRITERIA
- [ ] Can upload PDF files up to 10MB
- [ ] Extracts at least 80% of form fields accurately
- [ ] Processes single PDF in under 30 seconds
- [ ] Confidence scores displayed for each field
- [ ] Manual correction available for all fields
- [ ] Wedding-specific field types detected automatically
- [ ] Supports multi-page PDFs (up to 20 pages)
- [ ] Handles non-form PDFs gracefully with error message
- [ ] Progress indicator shows real-time status
- [ ] Extracted fields can be saved as reusable template

### DEPENDENCIES
- Must complete after: None - foundational AI feature
- Must complete before: WS-122 (Field Extraction) and WS-123 (Smart Mapping)
- Shares code with: WS-122, WS-123 (AI form intelligence pipeline)

### ESTIMATED EFFORT
- Team A Frontend: 16 hours (upload UI, preview, corrections)
- Team B Backend: 24 hours (PDF processing, Vision API, queue)
- Team C Integration: 8 hours (storage, database, API endpoints)
- Total: 48 hours