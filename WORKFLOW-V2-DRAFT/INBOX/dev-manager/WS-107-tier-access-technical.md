# TECHNICAL SPECIFICATION: WS-107 - Marketplace Tier Access
## Generated by Feature Development Session - August 22, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Successful wedding planner on the Professional tier wanting to share my proven client onboarding sequence
**I want to:** List my template in the marketplace to earn additional revenue while helping other planners
**So that:** I can monetize my proven processes and build my reputation as a top-tier wedding professional

**Real Wedding Scenario:**
A wedding planner has refined an onboarding sequence over 3 years that consistently results in 85% client retention and Â£12,000 average contract values. They attempt to list it on the marketplace but discover they need Professional tier access. After upgrading from Starter (Â£29/month) to Professional (Â£99/month), they list their "Luxury Wedding Planner Client Journey" for Â£147. Within 6 months, 23 planners purchase it, generating Â£2,646 in additional revenue (after 30% commission). The upgrade cost pays for itself in the first month, and they now earn an extra Â£4,000 annually from template sales while establishing themselves as an industry expert.

### SPECIFICATION SOURCE
- **Feature ID:** WS-107
- **Original Spec:** /CORE-SPECIFICATIONS/05-MARKETPLACE/01-Structure/02-tier-access md.md
- **Current Implementation:** 0% complete
- **Files to Modify:**
  - `/wedsync/lib/auth/permissions.ts` (enhance existing)
  - `/wedsync/middleware.ts` (enhance existing)
- **New Files to Create:**
  - `/wedsync/src/components/marketplace/TierGate.tsx`
  - `/wedsync/src/components/marketplace/UpgradePrompt.tsx`
  - `/wedsync/src/components/marketplace/LockedFeature.tsx`
  - `/wedsync/src/components/marketplace/TierBadge.tsx`
  - `/wedsync/src/hooks/useMarketplaceAccess.ts`
  - `/wedsync/src/hooks/useTierValidation.ts`
  - `/wedsync/lib/marketplace/tier-access.ts`
  - `/wedsync/lib/marketplace/usage-tracking.ts`
  - `/wedsync/lib/marketplace/tier-validation.ts`
  - `/wedsync/app/api/marketplace/access/route.ts`
  - `/wedsync/app/api/marketplace/usage/route.ts`
  - `/wedsync/supabase/migrations/20250822000008_marketplace_tier_access.sql`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Marketplace tier access and usage tracking
CREATE TABLE IF NOT EXISTS marketplace_usage_tracking (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID NOT NULL REFERENCES suppliers(id),
  action_type VARCHAR(20) NOT NULL CHECK (action_type IN ('browse', 'preview', 'purchase', 'install', 'sell_attempt')),
  template_id UUID REFERENCES marketplace_templates(id),
  blocked_by_tier BOOLEAN DEFAULT false,
  required_tier VARCHAR(20),
  current_tier VARCHAR(20),
  
  -- Monthly limit tracking
  monthly_count INTEGER DEFAULT 1,
  monthly_limit INTEGER,
  limit_exceeded BOOLEAN DEFAULT false,
  
  -- Wedding business context
  template_category VARCHAR(50),
  template_price_cents INTEGER,
  wedding_context JSONB DEFAULT '{}',
  
  -- Session and tracking
  session_id VARCHAR(255),
  ip_address INET,
  user_agent TEXT,
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_marketplace_usage_supplier_month ON marketplace_usage_tracking(supplier_id, date_trunc('month', created_at));
CREATE INDEX idx_marketplace_usage_action_tier ON marketplace_usage_tracking(action_type, blocked_by_tier, created_at DESC);
CREATE INDEX idx_marketplace_usage_template ON marketplace_usage_tracking(template_id, action_type, created_at DESC);

-- Monthly usage summaries for performance
CREATE TABLE IF NOT EXISTS marketplace_monthly_usage (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID NOT NULL REFERENCES suppliers(id),
  month_year DATE NOT NULL, -- First day of month
  tier VARCHAR(20) NOT NULL,
  
  -- Action counts
  browse_count INTEGER DEFAULT 0,
  preview_count INTEGER DEFAULT 0,
  purchase_count INTEGER DEFAULT 0,
  install_count INTEGER DEFAULT 0,
  
  -- Blocked action counts
  blocked_purchase_count INTEGER DEFAULT 0,
  blocked_sell_count INTEGER DEFAULT 0,
  
  -- Limits and usage
  purchase_limit INTEGER,
  purchase_limit_reached BOOLEAN DEFAULT false,
  preview_limit INTEGER,
  preview_limit_reached BOOLEAN DEFAULT false,
  
  -- Revenue tracking for creators
  total_sales_cents INTEGER DEFAULT 0,
  commission_earned_cents INTEGER DEFAULT 0,
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(supplier_id, month_year)
);

CREATE INDEX idx_marketplace_monthly_usage_supplier ON marketplace_monthly_usage(supplier_id, month_year DESC);
CREATE INDEX idx_marketplace_monthly_usage_tier ON marketplace_monthly_usage(tier, month_year DESC);

-- Tier upgrade prompts and tracking
CREATE TABLE IF NOT EXISTS marketplace_upgrade_prompts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID NOT NULL REFERENCES suppliers(id),
  prompt_type VARCHAR(50) NOT NULL, -- 'purchase_blocked', 'sell_blocked', 'limit_reached'
  current_tier VARCHAR(20) NOT NULL,
  recommended_tier VARCHAR(20) NOT NULL,
  
  -- Context for personalization
  blocked_template_id UUID REFERENCES marketplace_templates(id),
  blocked_action VARCHAR(20),
  template_category VARCHAR(50),
  estimated_monthly_value_cents INTEGER, -- Potential earnings/savings
  
  -- Response tracking
  prompt_shown BOOLEAN DEFAULT false,
  shown_at TIMESTAMP WITH TIME ZONE,
  clicked BOOLEAN DEFAULT false,
  clicked_at TIMESTAMP WITH TIME ZONE,
  upgraded BOOLEAN DEFAULT false,
  upgraded_at TIMESTAMP WITH TIME ZONE,
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_marketplace_upgrade_prompts_supplier ON marketplace_upgrade_prompts(supplier_id, created_at DESC);
CREATE INDEX idx_marketplace_upgrade_prompts_type ON marketplace_upgrade_prompts(prompt_type, shown_at DESC);

-- Seller verification and eligibility tracking
CREATE TABLE IF NOT EXISTS marketplace_seller_eligibility (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID NOT NULL REFERENCES suppliers(id) UNIQUE,
  
  -- Eligibility criteria
  tier_qualified BOOLEAN DEFAULT false,
  minimum_tier_required VARCHAR(20) DEFAULT 'professional',
  account_age_days INTEGER DEFAULT 0,
  account_age_qualified BOOLEAN DEFAULT false,
  completed_client_journeys INTEGER DEFAULT 0,
  journey_count_qualified BOOLEAN DEFAULT false,
  is_verified BOOLEAN DEFAULT false,
  
  -- Manual review status
  verification_status VARCHAR(20) DEFAULT 'pending' CHECK (verification_status IN ('pending', 'approved', 'rejected', 'suspended')),
  verified_by UUID REFERENCES suppliers(id),
  verification_notes TEXT,
  verified_at TIMESTAMP WITH TIME ZONE,
  
  -- Performance requirements
  average_client_rating DECIMAL(3,2) DEFAULT 0.00,
  rating_qualified BOOLEAN DEFAULT false,
  has_portfolio BOOLEAN DEFAULT false,
  portfolio_qualified BOOLEAN DEFAULT false,
  
  -- Disqualification tracking
  rejection_reason TEXT,
  suspension_reason TEXT,
  can_reapply_at TIMESTAMP WITH TIME ZONE,
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Wedding-specific tier benefits configuration
CREATE TABLE IF NOT EXISTS marketplace_tier_benefits (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tier VARCHAR(20) UNIQUE NOT NULL,
  
  -- Access permissions
  can_browse BOOLEAN DEFAULT true,
  can_purchase BOOLEAN DEFAULT false,
  can_sell BOOLEAN DEFAULT false,
  can_preview BOOLEAN DEFAULT false,
  
  -- Limits
  monthly_purchase_limit INTEGER,
  daily_preview_limit INTEGER,
  listing_limit INTEGER,
  
  -- Creator benefits
  commission_rate DECIMAL(4,3), -- e.g., 0.700 for 70%
  analytics_level VARCHAR(20) CHECK (analytics_level IN ('none', 'basic', 'advanced', 'premium')),
  promotion_level VARCHAR(20) CHECK (promotion_level IN ('none', 'standard', 'featured', 'spotlight')),
  creator_badge VARCHAR(50),
  
  -- Special features
  featured_creator BOOLEAN DEFAULT false,
  custom_storefront BOOLEAN DEFAULT false,
  priority_support BOOLEAN DEFAULT false,
  
  -- Wedding-specific benefits
  access_categories TEXT[] DEFAULT '{}',
  premium_templates BOOLEAN DEFAULT false,
  exclusive_content BOOLEAN DEFAULT false,
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Insert default tier benefits
INSERT INTO marketplace_tier_benefits (
  tier, can_browse, can_purchase, can_sell, can_preview,
  monthly_purchase_limit, daily_preview_limit, listing_limit,
  commission_rate, analytics_level, promotion_level,
  access_categories, premium_templates
) VALUES 
('free', true, false, false, true, 0, 3, 0, null, 'none', 'none', ARRAY['basic_forms'], false),
('starter', true, true, false, true, 5, 10, 0, null, 'none', 'none', ARRAY['basic_forms', 'email_templates'], false),
('professional', true, true, true, true, null, null, 10, 0.700, 'basic', 'standard', ARRAY['all'], true),
('scale', true, true, true, true, null, null, 50, 0.750, 'advanced', 'featured', ARRAY['all'], true),
('enterprise', true, true, true, true, null, null, null, 0.800, 'premium', 'spotlight', ARRAY['all'], true);

-- Row Level Security policies for tier-based access
ALTER TABLE marketplace_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE marketplace_purchases ENABLE ROW LEVEL SECURITY;
ALTER TABLE marketplace_usage_tracking ENABLE ROW LEVEL SECURITY;

-- Everyone can browse templates
CREATE POLICY marketplace_browse_templates ON marketplace_templates
  FOR SELECT USING (status = 'active');

-- Only eligible tiers can purchase templates
CREATE POLICY marketplace_purchase_access ON marketplace_purchases
  FOR INSERT WITH CHECK (
    EXISTS (
      SELECT 1 FROM suppliers s
      JOIN marketplace_tier_benefits tb ON s.tier = tb.tier
      WHERE s.id = auth.uid()
      AND tb.can_purchase = true
    )
  );

-- Only professional+ tiers can sell templates
CREATE POLICY marketplace_sell_access ON marketplace_templates
  FOR INSERT WITH CHECK (
    EXISTS (
      SELECT 1 FROM suppliers s
      JOIN marketplace_tier_benefits tb ON s.tier = tb.tier
      JOIN marketplace_seller_eligibility se ON s.id = se.supplier_id
      WHERE s.id = auth.uid()
      AND tb.can_sell = true
      AND se.verification_status = 'approved'
    )
  );

-- Users can only see their own usage tracking
CREATE POLICY marketplace_usage_own_data ON marketplace_usage_tracking
  FOR ALL USING (supplier_id = auth.uid());
```

#### API Endpoints Required
```typescript
// GET /api/marketplace/access
interface MarketplaceAccessResponse {
  access: {
    canBrowse: boolean;
    canPurchase: boolean;
    canSell: boolean;
    canPreview: boolean;
  };
  limits: {
    monthlyPurchaseLimit?: number;
    dailyPreviewLimit?: number;
    listingLimit?: number;
    currentMonthPurchases: number;
    currentDayPreviews: number;
    currentListings: number;
  };
  benefits: {
    commissionRate?: number;
    analyticsLevel: string;
    promotionLevel: string;
    creatorBadge?: string;
    featuredCreator: boolean;
    customStorefront: boolean;
  };
  restrictions: {
    accessCategories: string[];
    premiumTemplates: boolean;
    exclusiveContent: boolean;
  };
  nextTier?: {
    name: string;
    benefits: string[];
    upgradeUrl: string;
  };
}

// POST /api/marketplace/access/validate
interface ValidateAccessRequest {
  action: 'browse' | 'purchase' | 'sell' | 'preview';
  templateId?: string;
  context?: Record<string, any>;
}

interface ValidateAccessResponse {
  allowed: boolean;
  reason?: string;
  requiredTier?: string;
  upgradeOptions?: {
    currentTier: string;
    recommendedTier: string;
    benefits: string[];
    priceIncrease: number;
    upgradeUrl: string;
  };
  usage?: {
    currentCount: number;
    limit: number;
    resetDate: string;
  };
}

// GET /api/marketplace/usage/summary
interface UsageSummaryResponse {
  currentMonth: {
    browseCount: number;
    previewCount: number;
    purchaseCount: number;
    installCount: number;
    blockedAttempts: number;
  };
  limits: {
    purchaseLimit?: number;
    previewLimit?: number;
    purchasesRemaining?: number;
    previewsRemaining?: number;
  };
  upgradePrompts: Array<{
    type: string;
    templateCategory: string;
    estimatedValue: number;
    recommendedTier: string;
  }>;
}

// POST /api/marketplace/seller-verification/apply
interface SellerVerificationRequest {
  businessProof?: string; // File upload
  portfolioItems: Array<{
    type: 'form' | 'journey' | 'success_story';
    id: string;
    title: string;
    description: string;
  }>;
  references?: Array<{
    clientName: string;
    contactEmail: string;
    projectDescription: string;
  }>;
}

interface SellerVerificationResponse {
  applicationId: string;
  status: 'submitted' | 'under_review' | 'approved' | 'rejected';
  estimatedReviewTime: string;
  requirements: Array<{
    requirement: string;
    status: 'met' | 'pending' | 'not_met';
    details?: string;
  }>;
}
```

#### Frontend Components Required
```typescript
// Component: TierGate
// Location: /src/components/marketplace/TierGate.tsx

interface Props {
  requiredTier: 'starter' | 'professional' | 'scale' | 'enterprise';
  action: 'browse' | 'purchase' | 'sell' | 'preview';
  children: React.ReactNode;
  fallback?: React.ReactNode;
  templateId?: string;
  showUpgradePrompt?: boolean;
}

// Key functionality:
- Validates user tier against required permissions
- Shows upgrade prompts for blocked actions
- Tracks tier gate interactions for analytics
- Provides context-aware messaging
- Handles loading states during validation

// Component: UpgradePrompt
// Location: /src/components/marketplace/UpgradePrompt.tsx

interface Props {
  currentTier: string;
  recommendedTier: string;
  blockedAction: string;
  templateCategory?: string;
  estimatedValue?: number;
  benefits: string[];
  onUpgrade: () => void;
  onDismiss: () => void;
}

// Key functionality:
- Contextual upgrade messaging based on blocked action
- Tier comparison with benefit highlights
- ROI calculator for template creators
- Direct link to billing upgrade page
- Dismissal tracking and frequency limiting

// Component: LockedFeature
// Location: /src/components/marketplace/LockedFeature.tsx

interface Props {
  feature: string;
  requiredTier: string;
  message?: string;
  showPreview?: boolean;
  className?: string;
}

// Key functionality:
- Visual indication of locked features
- Tier requirement badges
- Preview functionality for higher-tier features
- Consistent styling for locked states
- Mobile-friendly responsive design

// Component: TierBadge
// Location: /src/components/marketplace/TierBadge.tsx

interface Props {
  tier: string;
  size?: 'sm' | 'md' | 'lg';
  showBenefits?: boolean;
  variant?: 'default' | 'creator' | 'seller';
}

// Key functionality:
- Visual tier identification with colors/icons
- Benefit tooltips on hover
- Creator and seller specific badges
- Responsive sizing for different contexts
- Accessibility support with proper ARIA labels
```

#### Integration Points
```typescript
// Service: TierAccessService
// Dependencies: Supabase, user context, subscription system

class TierAccessService {
  async validateAccess(
    userId: string,
    action: string,
    templateId?: string
  ): Promise<AccessValidationResult> {
    // 1. Get user tier and current usage
    // 2. Check tier-specific permissions
    // 3. Validate against monthly/daily limits
    // 4. Track access attempt (allowed or blocked)
    // 5. Generate upgrade recommendations if blocked
  }
  
  async checkSellerEligibility(
    userId: string
  ): Promise<SellerEligibilityResult> {
    // 1. Validate tier requirements
    // 2. Check account age and activity
    // 3. Verify client journey completions
    // 4. Assess portfolio and ratings
    // 5. Return qualification status with improvement areas
  }
  
  async trackUsage(
    userId: string,
    action: string,
    templateId?: string,
    blocked?: boolean
  ): Promise<void> {
    // Track usage for analytics and limit enforcement
    // Update monthly usage summaries
    // Trigger upgrade prompts based on patterns
  }
}

// Service: UpgradePromptService
// Dependencies: Tier access, analytics, billing

class UpgradePromptService {
  async generatePrompt(
    userId: string,
    blockedAction: string,
    context: any
  ): Promise<UpgradePrompt> {
    // Calculate potential value of upgrade
    // Personalize messaging based on vendor type
    // Create compelling upgrade copy
    // Track prompt generation for analytics
  }
  
  async trackPromptInteraction(
    promptId: string,
    interaction: 'shown' | 'clicked' | 'dismissed'
  ): Promise<void> {
    // Track prompt effectiveness
    // Update user engagement metrics
    // Adjust prompt frequency based on response
  }
}

// Hook: useMarketplaceAccess
export function useMarketplaceAccess() {
  // Current user tier and permissions
  // Real-time access validation
  // Usage limit tracking
  // Upgrade prompt management
}

// Hook: useTierValidation
export function useTierValidation(requiredTier: string, action: string) {
  // Validate specific action against user tier
  // Return access status and upgrade options
  // Handle loading and error states
}
```

### CODE EXAMPLES

#### Example 1: TierGate Component Implementation
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { useState, useEffect } from 'react';
import { useUser } from '@/hooks/useUser';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Alert, AlertDescription } from '@/components/ui/alert';

interface TierAccess {
  allowed: boolean;
  reason?: string;
  requiredTier?: string;
  upgradeOptions?: {
    currentTier: string;
    recommendedTier: string;
    benefits: string[];
    priceIncrease: number;
    upgradeUrl: string;
  };
  usage?: {
    currentCount: number;
    limit: number;
    resetDate: string;
  };
}

interface Props {
  requiredTier: 'starter' | 'professional' | 'scale' | 'enterprise';
  action: 'browse' | 'purchase' | 'sell' | 'preview';
  children: React.ReactNode;
  fallback?: React.ReactNode;
  templateId?: string;
  showUpgradePrompt?: boolean;
  onAccessDenied?: (reason: string) => void;
}

export function TierGate({
  requiredTier,
  action,
  children,
  fallback,
  templateId,
  showUpgradePrompt = true,
  onAccessDenied
}: Props) {
  const { user } = useUser();
  const [access, setAccess] = useState<TierAccess | null>(null);
  const [loading, setLoading] = useState(true);
  const [promptDismissed, setPromptDismissed] = useState(false);
  
  useEffect(() => {
    validateAccess();
  }, [user?.id, requiredTier, action, templateId]);
  
  const validateAccess = async () => {
    if (!user?.id) {
      setLoading(false);
      return;
    }
    
    setLoading(true);
    try {
      const response = await fetch('/api/marketplace/access/validate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action,
          templateId,
          context: { requiredTier }
        })
      });
      
      const accessData = await response.json();
      setAccess(accessData);
      
      // Track access attempt
      if (!accessData.allowed) {
        onAccessDenied?.(accessData.reason || 'Access denied');
        
        // Track blocked attempt for analytics
        await fetch('/api/marketplace/usage', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            action,
            templateId,
            blocked: true,
            requiredTier,
            reason: accessData.reason
          })
        });
      }
    } catch (error) {
      console.error('Failed to validate tier access:', error);
      setAccess({ allowed: false, reason: 'Validation failed' });
    } finally {
      setLoading(false);
    }
  };
  
  const handleUpgradeClick = () => {
    if (access?.upgradeOptions?.upgradeUrl) {
      // Track upgrade click
      trackUpgradeClick();
      window.location.href = access.upgradeOptions.upgradeUrl;
    }
  };
  
  const trackUpgradeClick = async () => {
    try {
      await fetch('/api/marketplace/usage/upgrade-click', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action,
          templateId,
          currentTier: access?.upgradeOptions?.currentTier,
          recommendedTier: access?.upgradeOptions?.recommendedTier
        })
      });
    } catch (error) {
      console.error('Failed to track upgrade click:', error);
    }
  };
  
  if (loading) {
    return (
      <div className="flex items-center justify-center p-4">
        <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-blue-600"></div>
        <span className="ml-2 text-sm text-muted-foreground">Checking access...</span>
      </div>
    );
  }
  
  if (!user?.id) {
    return (
      <Alert>
        <AlertDescription>
          Please sign in to access marketplace features.
        </AlertDescription>
      </Alert>
    );
  }
  
  if (access?.allowed) {
    return <>{children}</>;
  }
  
  // Access denied - show fallback or upgrade prompt
  if (fallback) {
    return <>{fallback}</>;
  }
  
  if (!showUpgradePrompt || promptDismissed) {
    return (
      <div className="text-center p-4 bg-gray-50 rounded-lg">
        <p className="text-sm text-muted-foreground">
          {access?.reason || 'This feature requires a higher tier subscription.'}
        </p>
        {access?.requiredTier && (
          <Badge variant="outline" className="mt-2">
            Requires {access.requiredTier} tier
          </Badge>
        )}
      </div>
    );
  }
  
  return (
    <Card className="border-orange-200 bg-orange-50">
      <CardHeader>
        <CardTitle className="flex items-center text-orange-800">
          <span className="mr-2">ðŸ”“</span>
          Upgrade to {access?.upgradeOptions?.recommendedTier || requiredTier}
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        <p className="text-sm text-orange-700">
          {getActionMessage(action, access?.requiredTier)}
        </p>
        
        {access?.upgradeOptions?.benefits && (
          <div>
            <p className="text-sm font-medium text-orange-800 mb-2">
              What you'll unlock:
            </p>
            <ul className="text-sm text-orange-700 space-y-1">
              {access.upgradeOptions.benefits.slice(0, 3).map((benefit, index) => (
                <li key={index} className="flex items-center">
                  <span className="mr-2">âœ“</span>
                  {benefit}
                </li>
              ))}
            </ul>
          </div>
        )}
        
        {access?.usage && (
          <div className="bg-white rounded p-3">
            <p className="text-sm text-gray-600">
              You've used {access.usage.currentCount} of {access.usage.limit} {action}s this month.
            </p>
            <p className="text-xs text-gray-500 mt-1">
              Resets on {new Date(access.usage.resetDate).toLocaleDateString()}
            </p>
          </div>
        )}
        
        <div className="flex space-x-2">
          <Button onClick={handleUpgradeClick} className="flex-1">
            Upgrade Now
            {access?.upgradeOptions?.priceIncrease && (
              <span className="ml-1">
                (+Â£{access.upgradeOptions.priceIncrease}/month)
              </span>
            )}
          </Button>
          <Button
            variant="outline"
            onClick={() => setPromptDismissed(true)}
          >
            Maybe Later
          </Button>
        </div>
        
        <p className="text-xs text-center text-orange-600">
          Upgrade anytime. Cancel within 30 days for full refund.
        </p>
      </CardContent>
    </Card>
  );
}

function getActionMessage(action: string, requiredTier?: string): string {
  switch (action) {
    case 'purchase':
      return `Purchase marketplace templates to accelerate your wedding business growth. ${requiredTier} tier required.`;
    case 'sell':
      return `Start earning by selling your proven templates to other wedding professionals. ${requiredTier} tier required.`;
    case 'preview':
      return `Get detailed previews of templates before purchasing. Upgrade for unlimited previews.`;
    default:
      return `Access this feature with a ${requiredTier} tier subscription.`;
  }
}
```

#### Example 2: Tier Access Validation Service
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { createClient } from '@supabase/supabase-js';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_KEY!
);

interface TierBenefits {
  canBrowse: boolean;
  canPurchase: boolean;
  canSell: boolean;
  canPreview: boolean;
  monthlyPurchaseLimit?: number;
  dailyPreviewLimit?: number;
  listingLimit?: number;
  commissionRate?: number;
  analyticsLevel: string;
  promotionLevel: string;
  accessCategories: string[];
  premiumTemplates: boolean;
}

export class TierAccessService {
  private tierHierarchy = {
    free: 0,
    starter: 1,
    professional: 2,
    scale: 3,
    enterprise: 4
  };
  
  async validateAccess(
    userId: string,
    action: 'browse' | 'purchase' | 'sell' | 'preview',
    templateId?: string
  ): Promise<{
    allowed: boolean;
    reason?: string;
    requiredTier?: string;
    upgradeOptions?: any;
    usage?: any;
  }> {
    try {
      // 1. Get user's current tier and benefits
      const { data: supplier, error: supplierError } = await supabase
        .from('suppliers')
        .select('id, tier, created_at')
        .eq('id', userId)
        .single();
      
      if (supplierError || !supplier) {
        return { allowed: false, reason: 'User not found' };
      }
      
      const { data: tierBenefits, error: benefitsError } = await supabase
        .from('marketplace_tier_benefits')
        .select('*')
        .eq('tier', supplier.tier)
        .single();
      
      if (benefitsError || !tierBenefits) {
        return { allowed: false, reason: 'Tier configuration not found' };
      }
      
      // 2. Check basic permission for action
      const hasPermission = this.checkBasicPermission(tierBenefits, action);
      if (!hasPermission.allowed) {
        const upgradeOptions = await this.generateUpgradeOptions(
          supplier.tier,
          action,
          templateId
        );
        
        return {
          allowed: false,
          reason: hasPermission.reason,
          requiredTier: hasPermission.requiredTier,
          upgradeOptions
        };
      }
      
      // 3. Check template-specific restrictions
      if (templateId) {
        const templateAccess = await this.checkTemplateAccess(
          tierBenefits,
          templateId
        );
        if (!templateAccess.allowed) {
          return templateAccess;
        }
      }
      
      // 4. Check usage limits
      if (action === 'purchase' || action === 'preview') {
        const usageCheck = await this.checkUsageLimits(
          userId,
          supplier.tier,
          action,
          tierBenefits
        );
        if (!usageCheck.allowed) {
          return usageCheck;
        }
      }
      
      // 5. Check seller eligibility for sell actions
      if (action === 'sell') {
        const sellerCheck = await this.checkSellerEligibility(userId);
        if (!sellerCheck.allowed) {
          return sellerCheck;
        }
      }
      
      // 6. Track successful access
      await this.trackUsage(userId, action, templateId, false);
      
      return { allowed: true };
      
    } catch (error) {
      console.error('Tier access validation error:', error);
      return { allowed: false, reason: 'Validation error occurred' };
    }
  }
  
  private checkBasicPermission(
    tierBenefits: TierBenefits,
    action: string
  ): { allowed: boolean; reason?: string; requiredTier?: string } {
    switch (action) {
      case 'browse':
        return tierBenefits.canBrowse
          ? { allowed: true }
          : { allowed: false, reason: 'Browsing not allowed', requiredTier: 'free' };
      
      case 'purchase':
        return tierBenefits.canPurchase
          ? { allowed: true }
          : { allowed: false, reason: 'Purchase access requires subscription', requiredTier: 'starter' };
      
      case 'sell':
        return tierBenefits.canSell
          ? { allowed: true }
          : { allowed: false, reason: 'Selling requires professional tier', requiredTier: 'professional' };
      
      case 'preview':
        return tierBenefits.canPreview
          ? { allowed: true }
          : { allowed: false, reason: 'Template previews require subscription', requiredTier: 'starter' };
      
      default:
        return { allowed: false, reason: 'Unknown action' };
    }
  }
  
  private async checkTemplateAccess(
    tierBenefits: TierBenefits,
    templateId: string
  ): Promise<{ allowed: boolean; reason?: string }> {
    // Get template details
    const { data: template, error } = await supabase
      .from('marketplace_templates')
      .select('category, subcategory, minimum_tier, price_cents')
      .eq('id', templateId)
      .single();
    
    if (error || !template) {
      return { allowed: false, reason: 'Template not found' };
    }
    
    // Check category access
    if (!tierBenefits.accessCategories.includes('all') &&
        !tierBenefits.accessCategories.includes(template.category)) {
      return {
        allowed: false,
        reason: `${template.category} templates require higher tier`
      };
    }
    
    // Check premium template access
    if (template.price_cents > 10000 && !tierBenefits.premiumTemplates) {
      return {
        allowed: false,
        reason: 'Premium templates require professional tier or higher'
      };
    }
    
    // Check minimum tier requirement
    const templateTierLevel = this.tierHierarchy[template.minimum_tier as keyof typeof this.tierHierarchy];
    const userTierLevel = this.getTierLevel(tierBenefits);
    
    if (userTierLevel < templateTierLevel) {
      return {
        allowed: false,
        reason: `This template requires ${template.minimum_tier} tier`
      };
    }
    
    return { allowed: true };
  }
  
  private async checkUsageLimits(
    userId: string,
    userTier: string,
    action: string,
    tierBenefits: TierBenefits
  ): Promise<{ allowed: boolean; reason?: string; usage?: any }> {
    const currentMonth = new Date();
    currentMonth.setDate(1);
    currentMonth.setHours(0, 0, 0, 0);
    
    // Get current month usage
    const { data: monthlyUsage } = await supabase
      .from('marketplace_monthly_usage')
      .select('*')
      .eq('supplier_id', userId)
      .eq('month_year', currentMonth.toISOString().split('T')[0])
      .single();
    
    if (action === 'purchase' && tierBenefits.monthlyPurchaseLimit) {
      const currentPurchases = monthlyUsage?.purchase_count || 0;
      if (currentPurchases >= tierBenefits.monthlyPurchaseLimit) {
        const resetDate = new Date(currentMonth);
        resetDate.setMonth(resetDate.getMonth() + 1);
        
        return {
          allowed: false,
          reason: 'Monthly purchase limit reached',
          usage: {
            currentCount: currentPurchases,
            limit: tierBenefits.monthlyPurchaseLimit,
            resetDate: resetDate.toISOString()
          }
        };
      }
    }
    
    if (action === 'preview' && tierBenefits.dailyPreviewLimit) {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      const { count: dailyPreviews } = await supabase
        .from('marketplace_usage_tracking')
        .select('id', { count: 'exact' })
        .eq('supplier_id', userId)
        .eq('action_type', 'preview')
        .gte('created_at', today.toISOString());
      
      if (dailyPreviews && dailyPreviews >= tierBenefits.dailyPreviewLimit) {
        const resetDate = new Date(today);
        resetDate.setDate(resetDate.getDate() + 1);
        
        return {
          allowed: false,
          reason: 'Daily preview limit reached',
          usage: {
            currentCount: dailyPreviews,
            limit: tierBenefits.dailyPreviewLimit,
            resetDate: resetDate.toISOString()
          }
        };
      }
    }
    
    return { allowed: true };
  }
  
  private async checkSellerEligibility(
    userId: string
  ): Promise<{ allowed: boolean; reason?: string }> {
    const { data: eligibility } = await supabase
      .from('marketplace_seller_eligibility')
      .select('*')
      .eq('supplier_id', userId)
      .single();
    
    if (!eligibility) {
      return {
        allowed: false,
        reason: 'Seller verification required. Please apply first.'
      };
    }
    
    if (eligibility.verification_status !== 'approved') {
      return {
        allowed: false,
        reason: `Seller verification ${eligibility.verification_status}. Check your application status.`
      };
    }
    
    return { allowed: true };
  }
  
  private async generateUpgradeOptions(
    currentTier: string,
    action: string,
    templateId?: string
  ) {
    const recommendedTier = this.getRecommendedTierForAction(action);
    const benefits = await this.getTierBenefits(recommendedTier);
    
    return {
      currentTier,
      recommendedTier,
      benefits: benefits.slice(0, 4), // Top 4 benefits
      priceIncrease: this.calculatePriceIncrease(currentTier, recommendedTier),
      upgradeUrl: `/billing/upgrade?from=${currentTier}&to=${recommendedTier}&action=${action}`
    };
  }
  
  private getRecommendedTierForAction(action: string): string {
    switch (action) {
      case 'purchase': return 'starter';
      case 'sell': return 'professional';
      case 'preview': return 'starter';
      default: return 'professional';
    }
  }
  
  private async trackUsage(
    userId: string,
    action: string,
    templateId?: string,
    blocked: boolean = false
  ) {
    await supabase
      .from('marketplace_usage_tracking')
      .insert({
        supplier_id: userId,
        action_type: action,
        template_id: templateId,
        blocked_by_tier: blocked
      });
  }
  
  private getTierLevel(tierBenefits: any): number {
    // Determine tier level from benefits
    if (!tierBenefits.canPurchase) return 0; // free
    if (!tierBenefits.canSell) return 1; // starter
    if (tierBenefits.commissionRate <= 0.70) return 2; // professional
    if (tierBenefits.commissionRate <= 0.75) return 3; // scale
    return 4; // enterprise
  }
  
  private async getTierBenefits(tier: string): Promise<string[]> {
    const benefitMap = {
      starter: [
        'Purchase marketplace templates',
        'Unlimited template previews',
        '5 purchases per month',
        'Access to basic templates'
      ],
      professional: [
        'Unlimited template purchases',
        'Sell your own templates',
        'Keep 70% of template sales',
        'Advanced analytics dashboard'
      ],
      scale: [
        'All professional benefits',
        'Keep 75% of template sales',
        'Featured creator status',
        'Priority customer support'
      ],
      enterprise: [
        'All scale benefits',
        'Keep 80% of template sales',
        'Custom marketplace storefront',
        'Dedicated account manager'
      ]
    };
    
    return benefitMap[tier as keyof typeof benefitMap] || [];
  }
  
  private calculatePriceIncrease(fromTier: string, toTier: string): number {
    const pricing = {
      free: 0,
      starter: 29,
      professional: 99,
      scale: 299,
      enterprise: 999
    };
    
    const fromPrice = pricing[fromTier as keyof typeof pricing] || 0;
    const toPrice = pricing[toTier as keyof typeof pricing] || 0;
    
    return Math.max(0, toPrice - fromPrice);
  }
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [ ] Context7: Load docs for subscription systems, access control patterns
- [ ] PostgreSQL: Create tier access control schema and policies
- [ ] Filesystem: Create tier gate components

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/supabase/supabase", "row level security", 1500);
await mcp__context7__get-library-docs("/stripe/stripe-node", "subscription tiers", 1000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('Marketplace Tier Access', () => {
  it('should validate tier permissions correctly', () => {
    // Test tier permission validation logic
  });
  
  it('should enforce monthly and daily limits', () => {
    // Test usage limit enforcement
  });
  
  it('should generate appropriate upgrade prompts', () => {
    // Test upgrade prompt generation
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Tier gates block unauthorized actions and show upgrade prompts', async () => {
  await mcp__playwright__browser_navigate({url: '/marketplace'});
  await mcp__playwright__browser_click({element: 'purchase button', ref: '[data-tier-required="professional"]'});
  await mcp__playwright__browser_snapshot();
  // Verify tier gate blocks action and shows upgrade prompt
});
```

### ACCEPTANCE CRITERIA
- [ ] Free tier users can browse but cannot purchase templates
- [ ] Starter tier users can purchase basic templates with monthly limits
- [ ] Professional+ tier users can sell templates after verification
- [ ] Usage limits are enforced and tracked accurately
- [ ] Upgrade prompts show relevant benefits and pricing
- [ ] Performance: Tier validation completes under 200ms
- [ ] Security: RLS policies prevent unauthorized access
- [ ] Accessibility: Tier gates and prompts are screen reader accessible

### DEPENDENCIES
- Must complete after: Marketplace foundation (WS-106), subscription system (WS-071)
- Must complete before: Revenue model (WS-108), creator onboarding (WS-110)
- Shares code with: Billing system, user management, subscription tiers

### ESTIMATED EFFORT
- Team A Frontend: 16 hours (tier gate components, upgrade prompts, usage dashboards)
- Team B Backend: 20 hours (tier validation service, RLS policies, usage tracking, seller verification)
- Team C Integration: 8 hours (billing system integration, subscription webhooks)
- Total: 44 hours