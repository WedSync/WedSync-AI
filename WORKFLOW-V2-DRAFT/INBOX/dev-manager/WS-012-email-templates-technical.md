# TECHNICAL SPECIFICATION: WS-012 - Email Templates
## Generated by Feature Development Session - 2025-08-21

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding venue coordinator sending similar emails repeatedly
**I want to:** Create, customize, and reuse email templates with personalization and rich formatting
**So that:** I can send professional communications in 30 seconds instead of writing each email from scratch for 5+ minutes

**Real Wedding Scenario:**
A venue coordinator sends 15+ emails weekly: welcome messages, payment reminders, timeline confirmations, weather updates. Currently writing each email manually takes 5-8 minutes, totaling 90+ minutes weekly on repetitive emails. With email templates, they create "Payment Reminder" template once with merge fields {{couple_names}}, {{amount_due}}, {{due_date}}, then send personalized reminders in 30 seconds by selecting template and client. The system auto-fills "John & Jane, your $2,500 final payment is due March 15th" - reducing weekly email time from 90 minutes to 15 minutes while maintaining professional, personalized communication.

### SPECIFICATION SOURCE
- **Feature ID:** WS-012
- **Original Spec:** /CORE-SPECIFICATIONS/02-WEDSYNC-SUPPLIER-PLATFORM/06-Communications/01-email-templates md.md
- **Current Implementation:** 0% complete
- **Files to Modify:** None - new feature
- **New Files to Create:**
  - /src/app/(dashboard)/communications/templates/page.tsx
  - /src/components/email/TemplateEditor.tsx
  - /src/components/email/TemplateLibrary.tsx
  - /src/components/email/MergeFieldPanel.tsx
  - /src/components/email/EmailPreview.tsx
  - /src/lib/email/templateEngine.ts
  - /src/lib/stores/emailTemplateStore.ts
  - /src/app/api/email/templates/route.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Email template storage and metadata
CREATE TABLE IF NOT EXISTS email_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  subject TEXT NOT NULL,
  html_content TEXT NOT NULL,
  plain_text_content TEXT,
  category TEXT CHECK (category IN ('welcome', 'reminder', 'follow_up', 'payment', 'timeline', 'custom')) DEFAULT 'custom',
  merge_fields TEXT[] DEFAULT ARRAY[]::TEXT[], -- Available merge fields
  is_default BOOLEAN DEFAULT false, -- System default templates
  is_shared BOOLEAN DEFAULT false, -- Shared with team
  usage_count INTEGER DEFAULT 0,
  last_used_at TIMESTAMP,
  folder_id UUID REFERENCES template_folders(id),
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  
  INDEX(supplier_id, category),
  INDEX(usage_count DESC),
  INDEX(last_used_at DESC)
);

-- Template organization folders
CREATE TABLE IF NOT EXISTS template_folders (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  description TEXT,
  parent_folder_id UUID REFERENCES template_folders(id),
  color TEXT DEFAULT '#3B82F6',
  sort_order INTEGER DEFAULT 0,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Template usage analytics
CREATE TABLE IF NOT EXISTS template_usage_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id UUID REFERENCES email_templates(id) ON DELETE CASCADE,
  used_by UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  client_id UUID REFERENCES client_profiles(id),
  personalization_data JSONB DEFAULT '{}',
  delivery_status TEXT CHECK (delivery_status IN ('sent', 'delivered', 'opened', 'clicked', 'bounced', 'failed')) DEFAULT 'sent',
  created_at TIMESTAMP DEFAULT NOW()
);

-- Reusable content blocks
CREATE TABLE IF NOT EXISTS content_blocks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  block_type TEXT CHECK (block_type IN ('header', 'footer', 'signature', 'cta', 'social', 'custom')) NOT NULL,
  content TEXT NOT NULL,
  variables JSONB DEFAULT '{}', -- Customizable variables
  usage_count INTEGER DEFAULT 0,
  created_at TIMESTAMP DEFAULT NOW()
);
```

#### API Endpoints Required
```typescript
// GET /api/email/templates
interface GetEmailTemplatesRequest {
  category?: string;
  folderId?: string;
  search?: string;
  sortBy?: 'name' | 'usage_count' | 'last_used_at' | 'created_at';
  sortOrder?: 'asc' | 'desc';
}

interface GetEmailTemplatesResponse {
  success: boolean;
  data: {
    templates: Array<{
      id: string;
      name: string;
      subject: string;
      category: string;
      mergeFields: string[];
      usageCount: number;
      lastUsedAt: string;
      isDefault: boolean;
      isShared: boolean;
      folder?: {
        id: string;
        name: string;
        color: string;
      };
      createdAt: string;
    }>;
    folders: Array<{
      id: string;
      name: string;
      description: string;
      color: string;
      templateCount: number;
    }>;
    categories: Record<string, number>; // Count per category
  };
}

// POST /api/email/templates
interface CreateEmailTemplateRequest {
  name: string;
  subject: string;
  htmlContent: string;
  plainTextContent?: string;
  category?: string;
  folderId?: string;
  isShared?: boolean;
  mergeFields?: string[];
}

interface CreateEmailTemplateResponse {
  success: boolean;
  data: {
    template: EmailTemplate;
    detectedMergeFields: string[];
    suggestions: {
      category: string;
      folder?: string;
      contentBlocks: Array<{
        type: string;
        name: string;
        relevanceScore: number;
      }>;
    };
  };
}

// POST /api/email/templates/[id]/preview
interface PreviewEmailTemplateRequest {
  templateId: string;
  clientId?: string;
  customData?: Record<string, any>;
}

interface PreviewEmailTemplateResponse {
  success: boolean;
  data: {
    subject: string;
    htmlContent: string;
    plainTextContent: string;
    mergeFieldValues: Record<string, string>;
    warnings: Array<{
      field: string;
      message: string;
    }>;
  };
}

// POST /api/email/templates/[id]/send
interface SendEmailFromTemplateRequest {
  templateId: string;
  recipients: Array<{
    clientId: string;
    customData?: Record<string, any>;
  }>;
  scheduleTime?: string;
  trackOpens?: boolean;
  trackClicks?: boolean;
}

interface SendEmailFromTemplateResponse {
  success: boolean;
  data: {
    sentCount: number;
    failedCount: number;
    scheduledCount: number;
    estimatedDeliveryTime: string;
    failures: Array<{
      clientId: string;
      reason: string;
    }>;
  };
}
```

#### Frontend Components Required
```typescript
// Component: TemplateEditor
// Location: /src/components/email/TemplateEditor.tsx

interface TemplateEditorProps {
  template?: EmailTemplate;
  onSave: (template: EmailTemplateData) => void;
  onPreview: (data: EmailTemplateData) => void;
  availableMergeFields: MergeField[];
  contentBlocks: ContentBlock[];
}

// Key functionality:
- Rich WYSIWYG editor with HTML/text modes
- Drag-and-drop merge field insertion
- Live preview with sample data
- Responsive design preview (desktop/mobile)
- Content block library integration
- Auto-save every 30 seconds
- Spell check and grammar suggestions

// Component: TemplateLibrary
// Location: /src/components/email/TemplateLibrary.tsx

interface TemplateLibraryProps {
  templates: EmailTemplate[];
  folders: TemplateFolder[];
  onTemplateSelect: (template: EmailTemplate) => void;
  onCreateTemplate: () => void;
  onEditTemplate: (templateId: string) => void;
  onDeleteTemplate: (templateId: string) => void;
}

// Key functionality:
- Grid/list view toggle
- Category and folder filtering
- Search with highlighting
- Template preview on hover
- Usage statistics display
- Bulk operations (delete, move, share)
- Template duplication
- Import/export functionality

// Component: MergeFieldPanel
// Location: /src/components/email/MergeFieldPanel.tsx

interface MergeFieldPanelProps {
  availableFields: MergeField[];
  onFieldInsert: (field: string) => void;
  context?: 'client' | 'wedding' | 'payment' | 'form';
}

// Key functionality:
- Categorized merge field browser
- Search and filter fields
- Field descriptions and examples
- One-click insertion at cursor
- Custom field creation
- Field validation and formatting
- Conditional field logic

// Component: EmailPreview
// Location: /src/components/email/EmailPreview.tsx

interface EmailPreviewProps {
  subject: string;
  htmlContent: string;
  plainTextContent: string;
  mergeData?: Record<string, any>;
  viewMode: 'desktop' | 'mobile' | 'text';
}

// Key functionality:
- Real-time merge field replacement
- Mobile/desktop responsive preview
- HTML and plain text views
- Email client compatibility testing
- Accessibility checking
- Print preview option
- Share preview link
```

#### Integration Points
```typescript
// Template engine with merge field processing
export class EmailTemplateEngine {
  private mergeFieldRegistry: Map<string, MergeFieldDefinition> = new Map();
  
  constructor() {
    this.registerDefaultMergeFields();
  }
  
  private registerDefaultMergeFields(): void {
    // Client fields
    this.register('couple_names', {
      description: 'Full couple names (e.g., "John & Jane Smith")',
      category: 'client',
      example: 'John & Jane Smith',
      validator: (value) => value && value.length > 0
    });
    
    this.register('wedding_date', {
      description: 'Wedding date (formatted)',
      category: 'wedding',
      example: 'June 15, 2024',
      formatter: (date: string) => format(new Date(date), 'MMMM d, yyyy')
    });
    
    this.register('venue_name', {
      description: 'Wedding venue name',
      category: 'wedding',
      example: 'Grand Oak Manor',
      validator: (value) => value && value.length > 0
    });
    
    this.register('days_until_wedding', {
      description: 'Days until wedding date',
      category: 'wedding',
      example: '45',
      calculator: (weddingDate: string) => {
        const days = Math.ceil((new Date(weddingDate).getTime() - Date.now()) / (1000 * 60 * 60 * 24));
        return days > 0 ? days.toString() : '0';
      }
    });
    
    // Payment fields
    this.register('amount_due', {
      description: 'Outstanding payment amount',
      category: 'payment',
      example: '$2,500.00',
      formatter: (amount: number) => new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD'
      }).format(amount)
    });
  }
  
  async processTemplate(templateId: string, clientId: string, customData?: Record<string, any>): Promise<ProcessedTemplate> {
    // Step 1: Get template and client data
    const [template, client] = await Promise.all([
      this.getTemplate(templateId),
      this.getClientData(clientId)
    ]);
    
    if (!template || !client) {
      throw new Error('Template or client not found');
    }
    
    // Step 2: Build merge data
    const mergeData = await this.buildMergeData(client, customData);
    
    // Step 3: Process subject and content
    const processedSubject = this.processMergeFields(template.subject, mergeData);
    const processedHtml = this.processMergeFields(template.htmlContent, mergeData);
    const processedText = this.processMergeFields(template.plainTextContent || '', mergeData);
    
    // Step 4: Validate required fields
    const warnings = this.validateMergeFields(template.mergeFields, mergeData);
    
    return {
      subject: processedSubject,
      htmlContent: processedHtml,
      plainTextContent: processedText,
      mergeFieldValues: mergeData,
      warnings
    };
  }
  
  private processMergeFields(content: string, mergeData: Record<string, any>): string {
    return content.replace(/\{\{(\w+)\}\}/g, (match, fieldName) => {
      const fieldDef = this.mergeFieldRegistry.get(fieldName);
      const rawValue = mergeData[fieldName];
      
      if (rawValue === undefined || rawValue === null) {
        return `[${fieldName}]`; // Placeholder for missing data
      }
      
      // Apply formatter if available
      if (fieldDef?.formatter) {
        return fieldDef.formatter(rawValue);
      }
      
      // Apply calculator if available
      if (fieldDef?.calculator) {
        return fieldDef.calculator(rawValue);
      }
      
      return String(rawValue);
    });
  }
  
  private async buildMergeData(client: ClientProfile, customData?: Record<string, any>): Promise<Record<string, any>> {
    const mergeData: Record<string, any> = {
      // Client data
      couple_names: client.coupleNames,
      partner1_name: client.partner1Name,
      partner2_name: client.partner2Name,
      partner1_email: client.partner1Email,
      partner1_phone: client.partner1Phone,
      
      // Wedding data
      wedding_date: client.weddingDate,
      venue_name: client.venueName,
      venue_address: client.venueAddress,
      guest_count: client.guestCount,
      
      // Calculated fields
      days_until_wedding: client.weddingDate,
      
      // Package data
      package_name: client.packageDetails?.name,
      package_price: client.packageDetails?.price,
      
      // Custom data override
      ...customData
    };
    
    // Add dynamic calculations
    if (client.weddingDate) {
      const daysUntil = Math.ceil((new Date(client.weddingDate).getTime() - Date.now()) / (1000 * 60 * 60 * 24));
      mergeData.days_until_wedding = daysUntil;
      mergeData.wedding_season = this.getWeddingSeason(new Date(client.weddingDate));
    }
    
    // Add payment data if available
    const paymentData = await this.getPaymentData(client.id);
    if (paymentData) {
      mergeData.amount_due = paymentData.amountDue;
      mergeData.payment_due_date = paymentData.dueDate;
      mergeData.total_paid = paymentData.totalPaid;
    }
    
    return mergeData;
  }
}

// Store: emailTemplateStore
interface EmailTemplateStore {
  templates: EmailTemplate[];
  folders: TemplateFolder[];
  contentBlocks: ContentBlock[];
  loading: boolean;
  selectedTemplate: EmailTemplate | null;
  
  fetchTemplates: (filters?: TemplateFilters) => Promise<void>;
  createTemplate: (templateData: CreateTemplateData) => Promise<EmailTemplate>;
  updateTemplate: (id: string, updates: Partial<EmailTemplate>) => Promise<void>;
  deleteTemplate: (id: string) => Promise<void>;
  duplicateTemplate: (id: string, newName: string) => Promise<EmailTemplate>;
  
  previewTemplate: (templateId: string, clientId?: string, customData?: Record<string, any>) => Promise<ProcessedTemplate>;
  sendFromTemplate: (templateId: string, recipients: TemplateRecipient[]) => Promise<SendResult>;
  
  createFolder: (folderData: CreateFolderData) => Promise<TemplateFolder>;
  moveToFolder: (templateId: string, folderId: string) => Promise<void>;
}
```

### CODE EXAMPLES

#### Example 1: Advanced Template Processing with Conditional Logic
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
export class AdvancedTemplateProcessor extends EmailTemplateEngine {
  
  async processAdvancedTemplate(templateId: string, clientId: string): Promise<ProcessedTemplate> {
    const template = await this.getTemplate(templateId);
    const client = await this.getClientData(clientId);
    
    // Step 1: Build comprehensive merge data
    const mergeData = await this.buildComprehensiveMergeData(client);
    
    // Step 2: Process conditional blocks
    let processedContent = await this.processConditionalBlocks(template.htmlContent, mergeData);
    
    // Step 3: Process standard merge fields
    processedContent = this.processMergeFields(processedContent, mergeData);
    
    // Step 4: Apply content enhancements
    processedContent = await this.applyContentEnhancements(processedContent, client);
    
    return {
      subject: this.processMergeFields(template.subject, mergeData),
      htmlContent: processedContent,
      plainTextContent: this.convertToPlainText(processedContent),
      mergeFieldValues: mergeData,
      warnings: this.validateTemplate(template, mergeData)
    };
  }
  
  private async processConditionalBlocks(content: string, mergeData: Record<string, any>): Promise<string> {
    // Process conditional blocks like {{#if venue_type == "outdoor"}}...{{/if}}
    const conditionalRegex = /\{\{#if\s+(.+?)\}\}([\s\S]*?)\{\{\/if\}\}/g;
    
    return content.replace(conditionalRegex, (match, condition, blockContent) => {
      if (this.evaluateCondition(condition, mergeData)) {
        return blockContent;
      }
      return '';
    });
  }
  
  private evaluateCondition(condition: string, data: Record<string, any>): boolean {
    // Parse and evaluate conditions like "venue_type == 'outdoor'" or "days_until_wedding < 30"
    const operators = ['==', '!=', '>', '<', '>=', '<=', 'contains', 'startsWith'];
    
    for (const op of operators) {
      if (condition.includes(op)) {
        const [left, right] = condition.split(op).map(s => s.trim());
        const leftValue = this.resolveValue(left, data);
        const rightValue = this.resolveValue(right, data);
        
        switch (op) {
          case '==':
            return leftValue == rightValue;
          case '!=':
            return leftValue != rightValue;
          case '>':
            return Number(leftValue) > Number(rightValue);
          case '<':
            return Number(leftValue) < Number(rightValue);
          case '>=':
            return Number(leftValue) >= Number(rightValue);
          case '<=':
            return Number(leftValue) <= Number(rightValue);
          case 'contains':
            return String(leftValue).toLowerCase().includes(String(rightValue).toLowerCase());
          case 'startsWith':
            return String(leftValue).toLowerCase().startsWith(String(rightValue).toLowerCase());
        }
      }
    }
    
    return false;
  }
  
  private resolveValue(expression: string, data: Record<string, any>): any {
    // Remove quotes if present
    if ((expression.startsWith('"') && expression.endsWith('"')) ||
        (expression.startsWith("'") && expression.endsWith("'"))) {
      return expression.slice(1, -1);
    }
    
    // Check if it's a number
    if (!isNaN(Number(expression))) {
      return Number(expression);
    }
    
    // Check if it's a boolean
    if (expression === 'true') return true;
    if (expression === 'false') return false;
    
    // Otherwise, treat as a merge field
    return data[expression];
  }
  
  private async applyContentEnhancements(content: string, client: ClientProfile): Promise<string> {
    // Add weather information for outdoor weddings
    if (client.venueType === 'outdoor' && client.weddingDate) {
      const weatherInfo = await this.getWeatherForecast(client.weddingDate, client.venueAddress);
      if (weatherInfo) {
        content = content.replace('{{weather_info}}', this.formatWeatherInfo(weatherInfo));
      }
    }
    
    // Add timeline suggestions based on wedding size
    if (client.guestCount) {
      const timelineSuggestions = this.getTimelineSuggestions(client.guestCount);
      content = content.replace('{{timeline_suggestions}}', timelineSuggestions);
    }
    
    // Add vendor coordination info
    const vendorInfo = await this.getVendorCoordinationInfo(client.id);
    if (vendorInfo) {
      content = content.replace('{{vendor_coordination}}', this.formatVendorInfo(vendorInfo));
    }
    
    return content;
  }
  
  private async buildComprehensiveMergeData(client: ClientProfile): Promise<Record<string, any>> {
    const baseData = await super.buildMergeData(client);
    
    // Add enhanced calculations
    const enhancedData = {
      ...baseData,
      
      // Time-based calculations
      is_wedding_soon: baseData.days_until_wedding <= 30,
      is_wedding_this_month: baseData.days_until_wedding <= 31 && baseData.days_until_wedding > 0,
      wedding_season: this.getWeddingSeason(new Date(client.weddingDate)),
      
      // Venue-based data
      venue_type: client.customFields?.venueType || 'unknown',
      is_outdoor_venue: (client.customFields?.venueType || '').toLowerCase().includes('outdoor'),
      
      // Package-based data
      is_premium_client: client.packageDetails?.tier === 'premium',
      is_budget_client: client.packageDetails?.tier === 'budget',
      
      // Personalization
      preferred_contact_method: client.customFields?.preferredContact || 'email',
      special_requests: client.customFields?.specialRequests || '',
      
      // Dynamic calculations
      preparation_weeks: Math.ceil(baseData.days_until_wedding / 7),
      milestone_phase: this.calculateMilestonePhase(baseData.days_until_wedding),
      
      // Form completion status
      forms_completed: await this.getCompletedFormsCount(client.id),
      forms_pending: await this.getPendingFormsCount(client.id),
      completion_percentage: await this.getOverallCompletionPercentage(client.id)
    };
    
    return enhancedData;
  }
  
  private calculateMilestonePhase(daysUntil: number): string {
    if (daysUntil <= 7) return 'wedding_week';
    if (daysUntil <= 30) return 'final_month';
    if (daysUntil <= 90) return 'final_preparations';
    if (daysUntil <= 180) return 'active_planning';
    return 'early_planning';
  }
}
```

#### Example 2: Template Analytics and Optimization
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
export class TemplateAnalyticsEngine {
  
  async analyzeTemplatePerformance(templateId: string, dateRange: DateRange): Promise<TemplateAnalytics> {
    // Step 1: Gather usage data
    const { data: usageData } = await supabase
      .from('template_usage_log')
      .select(`
        *,
        client:client_profiles(couple_names, wedding_date)
      `)
      .eq('template_id', templateId)
      .gte('created_at', dateRange.start)
      .lte('created_at', dateRange.end);
      
    if (!usageData?.length) {
      return this.getEmptyAnalytics();
    }
    
    // Step 2: Calculate performance metrics
    const totalSent = usageData.length;
    const delivered = usageData.filter(u => ['delivered', 'opened', 'clicked'].includes(u.delivery_status)).length;
    const opened = usageData.filter(u => ['opened', 'clicked'].includes(u.delivery_status)).length;
    const clicked = usageData.filter(u => u.delivery_status === 'clicked').length;
    const bounced = usageData.filter(u => u.delivery_status === 'bounced').length;
    
    // Step 3: Calculate engagement rates
    const deliveryRate = delivered / totalSent;
    const openRate = opened / delivered;
    const clickRate = clicked / opened;
    const bounceRate = bounced / totalSent;
    
    // Step 4: Analyze usage patterns
    const usageByDay = this.groupUsageByDay(usageData);
    const usageByClient = this.analyzeClientSegments(usageData);
    
    // Step 5: Generate optimization suggestions
    const suggestions = await this.generateOptimizationSuggestions({
      templateId,
      deliveryRate,
      openRate,
      clickRate,
      bounceRate,
      usageData
    });
    
    return {
      totalSent,
      delivered,
      opened,
      clicked,
      bounced,
      deliveryRate,
      openRate,
      clickRate,
      bounceRate,
      usageByDay,
      usageByClient,
      suggestions,
      benchmark: await this.getBenchmarkData(templateId)
    };
  }
  
  private async generateOptimizationSuggestions(metrics: AnalyticsInput): Promise<OptimizationSuggestion[]> {
    const suggestions: OptimizationSuggestion[] = [];
    
    // Low delivery rate suggestions
    if (metrics.deliveryRate < 0.95) {
      suggestions.push({
        type: 'delivery',
        priority: 'high',
        title: 'Improve Delivery Rate',
        description: `${Math.round((1 - metrics.deliveryRate) * 100)}% of emails are not being delivered`,
        recommendations: [
          'Check email addresses for typos',
          'Verify domain reputation',
          'Review spam trigger words in content',
          'Consider sender authentication (SPF, DKIM)'
        ],
        expectedImpact: 'high'
      });
    }
    
    // Low open rate suggestions
    if (metrics.openRate < 0.25) {
      const template = await this.getTemplate(metrics.templateId);
      
      suggestions.push({
        type: 'engagement',
        priority: 'medium',
        title: 'Increase Open Rate',
        description: `${Math.round(metrics.openRate * 100)}% open rate is below average`,
        recommendations: [
          'A/B test different subject lines',
          'Personalize subject line with client names',
          'Optimize send time (Tuesday-Thursday, 10-11 AM)',
          'Keep subject line under 50 characters',
          'Add urgency or curiosity to subject'
        ],
        expectedImpact: 'medium',
        subjectLineAnalysis: this.analyzeSubjectLine(template.subject)
      });
    }
    
    // Low click rate suggestions
    if (metrics.clickRate < 0.10 && metrics.openRate > 0.20) {
      suggestions.push({
        type: 'content',
        priority: 'medium',
        title: 'Improve Click-Through Rate',
        description: 'Emails are being opened but not generating clicks',
        recommendations: [
          'Add clear call-to-action buttons',
          'Improve email design and layout',
          'Make links more prominent',
          'Reduce content length',
          'Add more relevant content'
        ],
        expectedImpact: 'medium'
      });
    }
    
    // Usage pattern suggestions
    const bestPerformingTime = this.findBestSendTime(metrics.usageData);
    if (bestPerformingTime) {
      suggestions.push({
        type: 'timing',
        priority: 'low',
        title: 'Optimize Send Time',
        description: `Emails sent at ${bestPerformingTime} show better engagement`,
        recommendations: [
          `Schedule emails for ${bestPerformingTime}`,
          'Consider client time zones',
          'Test different days of the week'
        ],
        expectedImpact: 'low'
      });
    }
    
    return suggestions.sort((a, b) => {
      const priorityOrder = { high: 3, medium: 2, low: 1 };
      return priorityOrder[b.priority] - priorityOrder[a.priority];
    });
  }
  
  private analyzeSubjectLine(subject: string): SubjectLineAnalysis {
    const length = subject.length;
    const hasPersonalization = subject.includes('{{') && subject.includes('}}');
    const hasNumbers = /\d/.test(subject);
    const hasEmojis = /[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]/u.test(subject);
    const urgencyWords = ['urgent', 'limited', 'deadline', 'expires', 'last chance', 'final'].some(word => 
      subject.toLowerCase().includes(word)
    );
    
    const spamTriggers = [
      'free', 'guaranteed', 'no obligation', 'act now', 'click here',
      'congratulations', 'winner', '$$$', 'make money', 'work from home'
    ].filter(trigger => subject.toLowerCase().includes(trigger));
    
    return {
      length,
      optimalLength: length >= 30 && length <= 50,
      hasPersonalization,
      hasNumbers,
      hasEmojis,
      urgencyWords,
      spamTriggers,
      recommendations: this.getSubjectLineRecommendations({
        length,
        hasPersonalization,
        urgencyWords,
        spamTriggers
      })
    };
  }
  
  private getSubjectLineRecommendations(analysis: SubjectLineAnalysis): string[] {
    const recommendations: string[] = [];
    
    if (analysis.length > 60) {
      recommendations.push('Shorten subject line to under 50 characters for better mobile display');
    }
    
    if (analysis.length < 20) {
      recommendations.push('Consider adding more descriptive words to increase engagement');
    }
    
    if (!analysis.hasPersonalization) {
      recommendations.push('Add client names ({{couple_names}}) for better personalization');
    }
    
    if (analysis.spamTriggers.length > 0) {
      recommendations.push(`Remove spam trigger words: ${analysis.spamTriggers.join(', ')}`);
    }
    
    if (!analysis.urgencyWords && !analysis.hasNumbers) {
      recommendations.push('Consider adding urgency or specific numbers to increase open rates');
    }
    
    return recommendations;
  }
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for email templates and WYSIWYG editors
- [ ] Playwright: Test template creation and email sending
- [x] Filesystem: Access email template components

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/tinymce/tinymce", "rich text editor", 3000);
await mcp__context7__get-library-docs("/nodemailer/nodemailer", "email sending", 2000);
await mcp__context7__get-library-docs("/handlebars.js/handlebars.js", "template engine", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('Email Template Engine', () => {
  it('should process merge fields correctly', async () => {
    const engine = new EmailTemplateEngine();
    const template = 'Hello {{couple_names}}, your wedding is in {{days_until_wedding}} days!';
    const mergeData = { couple_names: 'John & Jane', days_until_wedding: 45 };
    
    const result = engine.processMergeFields(template, mergeData);
    
    expect(result).toBe('Hello John & Jane, your wedding is in 45 days!');
  });
  
  it('should handle conditional blocks', async () => {
    const engine = new AdvancedTemplateProcessor();
    const template = '{{#if venue_type == "outdoor"}}Weather forecast attached{{/if}}';
    const mergeData = { venue_type: 'outdoor' };
    
    const result = await engine.processConditionalBlocks(template, mergeData);
    
    expect(result).toBe('Weather forecast attached');
  });
  
  it('should validate required merge fields', () => {
    const engine = new EmailTemplateEngine();
    const requiredFields = ['couple_names', 'wedding_date'];
    const mergeData = { couple_names: 'John & Jane' }; // missing wedding_date
    
    const warnings = engine.validateMergeFields(requiredFields, mergeData);
    
    expect(warnings).toHaveLength(1);
    expect(warnings[0].field).toBe('wedding_date');
  });
});

describe('Template Analytics', () => {
  it('should calculate performance metrics correctly', async () => {
    const analytics = new TemplateAnalyticsEngine();
    const mockUsageData = [
      { delivery_status: 'delivered' },
      { delivery_status: 'opened' },
      { delivery_status: 'clicked' },
      { delivery_status: 'bounced' }
    ];
    
    const metrics = await analytics.calculateMetrics(mockUsageData);
    
    expect(metrics.deliveryRate).toBe(0.75); // 3/4
    expect(metrics.openRate).toBe(0.67); // 2/3 delivered
    expect(metrics.clickRate).toBe(0.5); // 1/2 opened
  });
  
  it('should generate optimization suggestions', async () => {
    const analytics = new TemplateAnalyticsEngine();
    const lowPerformanceMetrics = {
      deliveryRate: 0.8,
      openRate: 0.15,
      clickRate: 0.05
    };
    
    const suggestions = await analytics.generateOptimizationSuggestions(lowPerformanceMetrics);
    
    expect(suggestions.some(s => s.type === 'delivery')).toBe(true);
    expect(suggestions.some(s => s.type === 'engagement')).toBe(true);
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Email template creation and editing', async () => {
  await mcp__playwright__browser_navigate({url: '/communications/templates'});
  
  // Create new template
  await mcp__playwright__browser_click({
    element: 'Create template button',
    ref: '[data-testid="create-template"]'
  });
  
  // Fill template details
  await mcp__playwright__browser_type({
    element: 'Template name',
    ref: '[name="templateName"]',
    text: 'Payment Reminder'
  });
  
  await mcp__playwright__browser_type({
    element: 'Subject line',
    ref: '[name="subject"]',
    text: 'Payment Due: {{couple_names}}'
  });
  
  // Use rich editor
  await mcp__playwright__browser_type({
    element: 'Email content',
    ref: '[data-testid="rich-editor"]',
    text: 'Hi {{couple_names}}, your payment of {{amount_due}} is due on {{due_date}}.'
  });
  
  // Insert merge field
  await mcp__playwright__browser_click({
    element: 'Insert merge field',
    ref: '[data-testid="merge-field-couple_names"]'
  });
  
  // Preview template
  await mcp__playwright__browser_click({
    element: 'Preview button',
    ref: '[data-testid="preview-template"]'
  });
  
  await mcp__playwright__browser_wait_for({text: 'Hi John & Jane Smith'});
  
  // Save template
  await mcp__playwright__browser_click({
    element: 'Save template',
    ref: '[data-testid="save-template"]'
  });
  
  await mcp__playwright__browser_wait_for({text: 'Template saved successfully'});
});

test('Template preview with real client data', async () => {
  await mcp__playwright__browser_navigate({url: '/communications/templates/123'});
  
  // Select client for preview
  await mcp__playwright__browser_click({
    element: 'Preview with client',
    ref: '[data-testid="preview-with-client"]'
  });
  
  await mcp__playwright__browser_select_option({
    element: 'Client selector',
    ref: '[data-testid="client-selector"]',
    values: ['client-456']
  });
  
  // Verify merge fields are replaced
  await mcp__playwright__browser_wait_for({text: 'John & Jane Smith'});
  await mcp__playwright__browser_wait_for({text: 'June 15, 2024'});
  
  // Test mobile preview
  await mcp__playwright__browser_click({
    element: 'Mobile preview',
    ref: '[data-testid="mobile-preview"]'
  });
  
  // Verify mobile layout
  await mcp__playwright__browser_wait_for({text: 'Mobile View'});
});

test('Bulk email sending from template', async () => {
  await mcp__playwright__browser_navigate({url: '/communications/templates/123'});
  
  // Send to multiple clients
  await mcp__playwright__browser_click({
    element: 'Send to clients',
    ref: '[data-testid="send-template"]'
  });
  
  // Select multiple clients
  await mcp__playwright__browser_click({
    element: 'Select all active clients',
    ref: '[data-testid="select-all-active"]'
  });
  
  // Configure sending options
  await mcp__playwright__browser_click({
    element: 'Track opens',
    ref: '[data-testid="track-opens"]'
  });
  
  await mcp__playwright__browser_click({
    element: 'Track clicks',
    ref: '[data-testid="track-clicks"]'
  });
  
  // Send emails
  await mcp__playwright__browser_click({
    element: 'Send emails',
    ref: '[data-testid="confirm-send"]'
  });
  
  // Verify success
  await mcp__playwright__browser_wait_for({text: 'Emails sent successfully'});
  await mcp__playwright__browser_wait_for({text: '5 emails sent'});
});
```

### ACCEPTANCE CRITERIA
- [ ] WYSIWYG editor supports rich formatting and responsive design
- [ ] Merge fields auto-complete and show examples
- [ ] Template preview works with real client data
- [ ] Conditional content blocks process correctly
- [ ] Bulk sending to multiple clients works
- [ ] Template analytics show delivery, open, and click rates
- [ ] Content blocks can be saved and reused
- [ ] Templates can be organized in folders
- [ ] Mobile preview shows accurate rendering
- [ ] HTML and plain text versions generated
- [ ] Spam checking warns about problematic content
- [ ] Template usage tracking and optimization suggestions

### DEPENDENCIES
- Must complete after: WS-002 (Client Profiles), WS-004 (Bulk Operations)
- Must complete before: None (enhances communications)
- Shares code with: WS-004 (bulk email), WS-013 (journey communications)

### ESTIMATED EFFORT
- Team A Frontend: 32 hours
- Team B Backend: 24 hours
- Team C Integration: 8 hours
- Total: 64 hours