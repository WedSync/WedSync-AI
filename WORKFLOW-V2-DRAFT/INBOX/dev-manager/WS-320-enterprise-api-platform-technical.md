# TECHNICAL SPECIFICATION: WS-320 - Enterprise API Platform & Developer Portal
## Generated by Feature Development Session - 2025-01-05

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Large wedding venue chain with existing booking systems and POS integration
**I want to:** Connect my existing systems to WedSync through robust APIs with proper documentation
**So that:** My venues can sync client data, bookings, and payments without manual data entry

**Real Wedding Scenario:**
The Marriott Hotels wedding division wants to integrate their existing booking system with WedSync. Their IT team needs comprehensive APIs to sync venue availability, client bookings, menu selections, and payment processing. They require enterprise-grade API documentation, rate limiting, webhooks, and dedicated support.

### SPECIFICATION SOURCE
- **Feature ID:** WS-320
- **Original Spec:** Enterprise Integration - API Platform & Developer Portal
- **Current Implementation:** 0% complete (internal APIs exist)
- **Files to Modify:** Existing API routes for public exposure
- **New Files to Create:**
  - `/src/app/api/v1/` - Versioned public API endpoints
  - `/src/app/api/webhooks/` - Webhook management system
  - `/src/app/(portal)/developers/` - Developer portal interface
  - `/src/lib/api/rate-limiting.ts` - Rate limiting and throttling
  - `/src/lib/api/authentication.ts` - API key management

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- API Keys table
CREATE TABLE IF NOT EXISTS api_keys (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id),
  key_name VARCHAR(100) NOT NULL,
  api_key VARCHAR(128) NOT NULL UNIQUE,
  api_secret VARCHAR(128) NOT NULL,
  key_type VARCHAR(20) DEFAULT 'standard' CHECK (key_type IN ('standard', 'premium', 'enterprise')),
  permissions JSONB NOT NULL DEFAULT '{}', -- Granular API permissions
  rate_limit_per_hour INTEGER DEFAULT 1000,
  is_active BOOLEAN DEFAULT TRUE,
  last_used_at TIMESTAMP WITH TIME ZONE,
  expires_at TIMESTAMP WITH TIME ZONE,
  created_by UUID REFERENCES users(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- API Usage Analytics table
CREATE TABLE IF NOT EXISTS api_usage_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  api_key_id UUID NOT NULL REFERENCES api_keys(id),
  endpoint VARCHAR(255) NOT NULL,
  method VARCHAR(10) NOT NULL,
  status_code INTEGER NOT NULL,
  response_time_ms INTEGER,
  request_size_bytes INTEGER,
  response_size_bytes INTEGER,
  user_agent TEXT,
  ip_address INET,
  request_id VARCHAR(100),
  timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Webhook Subscriptions table
CREATE TABLE IF NOT EXISTS webhook_subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id),
  api_key_id UUID NOT NULL REFERENCES api_keys(id),
  webhook_url TEXT NOT NULL,
  event_types TEXT[] NOT NULL, -- ['client.created', 'wedding.updated', etc.]
  secret_key VARCHAR(128) NOT NULL,
  is_active BOOLEAN DEFAULT TRUE,
  retry_policy JSONB DEFAULT '{"max_attempts": 3, "backoff": "exponential"}',
  last_delivery_at TIMESTAMP WITH TIME ZONE,
  success_count INTEGER DEFAULT 0,
  failure_count INTEGER DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Webhook Delivery Attempts table
CREATE TABLE IF NOT EXISTS webhook_deliveries (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  subscription_id UUID NOT NULL REFERENCES webhook_subscriptions(id),
  event_type VARCHAR(100) NOT NULL,
  payload JSONB NOT NULL,
  status VARCHAR(20) DEFAULT 'pending' CHECK (status IN ('pending', 'delivered', 'failed', 'retrying')),
  http_status_code INTEGER,
  response_body TEXT,
  response_time_ms INTEGER,
  attempt_number INTEGER DEFAULT 1,
  next_retry_at TIMESTAMP WITH TIME ZONE,
  delivered_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Developer Applications table
CREATE TABLE IF NOT EXISTS developer_applications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id),
  application_name VARCHAR(100) NOT NULL,
  application_description TEXT,
  application_url TEXT,
  contact_email VARCHAR(255) NOT NULL,
  api_tier VARCHAR(20) DEFAULT 'standard',
  approval_status VARCHAR(20) DEFAULT 'pending' CHECK (approval_status IN ('pending', 'approved', 'rejected', 'suspended')),
  approved_by UUID REFERENCES users(id),
  approved_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- API Rate Limiting table
CREATE TABLE IF NOT EXISTS api_rate_limits (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  api_key_id UUID NOT NULL REFERENCES api_keys(id),
  window_start TIMESTAMP WITH TIME ZONE NOT NULL,
  request_count INTEGER DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(api_key_id, window_start)
);
```

### CORE FUNCTIONALITY REQUIREMENTS

#### RESTful API Design
- Full REST API covering all WedSync functionality
- Proper HTTP status codes and error handling
- JSON-first with XML support for enterprise clients
- API versioning with backward compatibility
- Comprehensive input validation and sanitization

#### Authentication & Authorization
- API key-based authentication with secrets
- JWT tokens for user-context operations
- OAuth 2.0 support for third-party integrations
- Granular permission system per endpoint
- Role-based access control (RBAC)

#### Rate Limiting & Throttling
- Configurable rate limits per API tier
- Sliding window rate limiting algorithm
- Burst request handling
- Fair usage quotas
- Automatic scaling for enterprise clients

#### Developer Experience
- Interactive API documentation with OpenAPI 3.0
- Code examples in multiple programming languages
- SDK generation for popular languages
- Sandbox environment for testing
- Comprehensive error messages with debugging info

### API ENDPOINTS STRUCTURE
```typescript
// Core Resource APIs
GET    /api/v1/organizations
POST   /api/v1/organizations
GET    /api/v1/organizations/{id}
PUT    /api/v1/organizations/{id}
DELETE /api/v1/organizations/{id}

GET    /api/v1/clients
POST   /api/v1/clients
GET    /api/v1/clients/{id}
PUT    /api/v1/clients/{id}
DELETE /api/v1/clients/{id}

GET    /api/v1/weddings
POST   /api/v1/weddings
GET    /api/v1/weddings/{id}
PUT    /api/v1/weddings/{id}
DELETE /api/v1/weddings/{id}

GET    /api/v1/forms
POST   /api/v1/forms
GET    /api/v1/forms/{id}
PUT    /api/v1/forms/{id}
DELETE /api/v1/forms/{id}

// Webhook Management
GET    /api/v1/webhooks
POST   /api/v1/webhooks
GET    /api/v1/webhooks/{id}
PUT    /api/v1/webhooks/{id}
DELETE /api/v1/webhooks/{id}
POST   /api/v1/webhooks/{id}/test

// API Management
GET    /api/v1/api-keys
POST   /api/v1/api-keys
GET    /api/v1/api-keys/{id}
PUT    /api/v1/api-keys/{id}
DELETE /api/v1/api-keys/{id}
POST   /api/v1/api-keys/{id}/regenerate

// Analytics & Usage
GET    /api/v1/usage/summary
GET    /api/v1/usage/endpoints
GET    /api/v1/usage/errors
GET    /api/v1/usage/quotas
```

### API ARCHITECTURE
```typescript
interface APIConfig {
  version: string;
  baseUrl: string;
  rateLimit: RateLimitConfig;
  authentication: AuthConfig;
  webhooks: WebhookConfig;
}

interface RateLimitConfig {
  standard: { requests: 1000, window: '1h' };
  premium: { requests: 5000, window: '1h' };
  enterprise: { requests: 50000, window: '1h' };
}

class EnterpriseAPIGateway {
  private rateLimiter: RateLimiter;
  private authenticator: APIAuthenticator;
  private webhookManager: WebhookManager;
  
  async handleRequest(req: APIRequest): Promise<APIResponse> {
    // 1. Authenticate request
    const authResult = await this.authenticator.authenticate(req);
    if (!authResult.success) {
      return this.unauthorizedResponse();
    }
    
    // 2. Check rate limits
    const rateLimitResult = await this.rateLimiter.checkLimit(
      authResult.apiKey,
      req.endpoint
    );
    if (!rateLimitResult.allowed) {
      return this.rateLimitResponse(rateLimitResult);
    }
    
    // 3. Validate permissions
    if (!this.hasPermission(authResult.apiKey, req.endpoint, req.method)) {
      return this.forbiddenResponse();
    }
    
    // 4. Process request
    const response = await this.processAPIRequest(req);
    
    // 5. Log usage
    await this.logUsage(authResult.apiKey, req, response);
    
    return response;
  }
  
  async triggerWebhook(
    event: WebhookEvent,
    organizationId: string
  ): Promise<void> {
    const subscriptions = await this.webhookManager.getSubscriptions(
      organizationId,
      event.type
    );
    
    for (const subscription of subscriptions) {
      await this.webhookManager.deliverWebhook(subscription, event);
    }
  }
}
```

### WEBHOOK SYSTEM
```typescript
interface WebhookEvent {
  type: string; // 'client.created', 'wedding.updated', 'payment.completed'
  data: any;
  timestamp: string;
  organizationId: string;
}

class WebhookManager {
  async deliverWebhook(
    subscription: WebhookSubscription,
    event: WebhookEvent
  ): Promise<DeliveryResult> {
    const payload = {
      id: generateId(),
      type: event.type,
      data: event.data,
      timestamp: event.timestamp,
      organization_id: event.organizationId
    };
    
    const signature = this.generateSignature(payload, subscription.secret);
    
    try {
      const response = await fetch(subscription.url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-WedSync-Signature': signature,
          'X-WedSync-Delivery': generateId(),
          'User-Agent': 'WedSync-Webhooks/1.0'
        },
        body: JSON.stringify(payload),
        timeout: 30000
      });
      
      if (response.ok) {
        await this.logSuccessfulDelivery(subscription, event, response);
        return { success: true, statusCode: response.status };
      } else {
        await this.handleFailedDelivery(subscription, event, response);
        return { success: false, statusCode: response.status };
      }
    } catch (error) {
      await this.handleFailedDelivery(subscription, event, error);
      return { success: false, error: error.message };
    }
  }
  
  private async handleFailedDelivery(
    subscription: WebhookSubscription,
    event: WebhookEvent,
    error: any
  ): Promise<void> {
    // Log failure
    await this.logFailedDelivery(subscription, event, error);
    
    // Schedule retry with exponential backoff
    const retryCount = await this.getRetryCount(subscription, event);
    if (retryCount < subscription.retryPolicy.maxAttempts) {
      const delay = this.calculateBackoffDelay(retryCount);
      await this.scheduleRetry(subscription, event, delay);
    }
  }
}
```

### DEVELOPER PORTAL COMPONENTS
```typescript
const DeveloperPortal: React.FC = () => {
  return (
    <div className="developer-portal">
      <DashboardOverview />
      <APIDocumentation />
      <APIKeyManagement />
      <WebhookConfiguration />
      <UsageAnalytics />
      <CodeExamples />
      <SupportCenter />
    </div>
  );
};

const APIDocumentation: React.FC = () => {
  // Features:
  // - Interactive OpenAPI 3.0 documentation
  // - Try-it-out functionality with live API calls
  // - Code generation in multiple languages
  // - Authentication examples
  // - Response schema visualization
};

const APIKeyManagement: React.FC = () => {
  // Features:
  // - Generate new API keys
  // - Configure permissions and rate limits
  // - View usage statistics
  // - Regenerate keys with proper rotation
  // - Download API credentials securely
};

const WebhookTester: React.FC = () => {
  // Features:
  // - Test webhook endpoints
  // - Simulate different event types
  // - Verify signature validation
  // - Debug delivery failures
  // - Replay failed webhooks
};
```

### SDK GENERATION
```typescript
// Auto-generated SDK examples
class WedSyncClient {
  constructor(apiKey: string, options?: ClientOptions) {
    this.apiKey = apiKey;
    this.baseUrl = options?.baseUrl || 'https://api.wedsync.com/v1';
    this.httpClient = new HttpClient(this.baseUrl, {
      headers: {
        'Authorization': `Bearer ${this.apiKey}`,
        'Content-Type': 'application/json',
        'User-Agent': 'WedSync-SDK-Node/1.0.0'
      }
    });
  }
  
  // Client management
  async getClients(params?: GetClientsParams): Promise<ClientList> {
    return this.httpClient.get('/clients', { params });
  }
  
  async createClient(client: CreateClientParams): Promise<Client> {
    return this.httpClient.post('/clients', client);
  }
  
  async updateClient(id: string, client: UpdateClientParams): Promise<Client> {
    return this.httpClient.put(`/clients/${id}`, client);
  }
  
  // Webhook management
  async createWebhook(webhook: CreateWebhookParams): Promise<Webhook> {
    return this.httpClient.post('/webhooks', webhook);
  }
  
  async testWebhook(id: string, event: WebhookTestEvent): Promise<TestResult> {
    return this.httpClient.post(`/webhooks/${id}/test`, event);
  }
}

// Usage example
const client = new WedSyncClient('your-api-key-here');

const newClient = await client.createClient({
  name: 'John & Jane Smith',
  email: 'john@example.com',
  wedding_date: '2025-06-15',
  package_type: 'premium'
});

console.log('Created client:', newClient.id);
```

### RATE LIMITING IMPLEMENTATION
```typescript
interface RateLimitWindow {
  windowStart: Date;
  requestCount: number;
  resetTime: Date;
}

class SlidingWindowRateLimiter {
  async checkRateLimit(
    apiKeyId: string,
    endpoint: string
  ): Promise<RateLimitResult> {
    const config = await this.getRateLimitConfig(apiKeyId);
    const windowSize = this.parseWindowSize(config.window);
    const currentWindow = this.getCurrentWindow(windowSize);
    
    // Get current usage
    const usage = await this.getCurrentUsage(apiKeyId, currentWindow);
    
    if (usage.requestCount >= config.requests) {
      return {
        allowed: false,
        limit: config.requests,
        remaining: 0,
        resetTime: usage.resetTime,
        retryAfter: this.calculateRetryAfter(usage.resetTime)
      };
    }
    
    // Increment counter
    await this.incrementUsage(apiKeyId, currentWindow);
    
    return {
      allowed: true,
      limit: config.requests,
      remaining: config.requests - usage.requestCount - 1,
      resetTime: usage.resetTime
    };
  }
  
  private getCurrentWindow(windowSize: number): RateLimitWindow {
    const now = new Date();
    const windowStart = new Date(
      Math.floor(now.getTime() / windowSize) * windowSize
    );
    const resetTime = new Date(windowStart.getTime() + windowSize);
    
    return {
      windowStart,
      requestCount: 0,
      resetTime
    };
  }
}
```

### ACCEPTANCE CRITERIA
- [x] Complete REST API with OpenAPI 3.0 specification covering all features
- [x] Enterprise-grade authentication with API keys and OAuth 2.0 support
- [x] Configurable rate limiting with burst handling and fair usage policies
- [x] Comprehensive webhook system with retry logic and failure handling
- [x] Interactive developer portal with documentation and testing tools
- [x] SDKs generated for Node.js, Python, PHP, and C# programming languages
- [x] 99.9% API uptime with response times under 200ms (p95)
- [x] Enterprise support with dedicated technical account management

### DEPENDENCIES
- Must complete after: Core Platform Features - needs stable API foundation
- Must complete before: Third-Party Integrations - provides integration platform
- Integrates with: Authentication system, database, payment processing, webhooks

### ESTIMATED EFFORT
- Team A (API Development): 72 hours
- Team B (Developer Portal): 48 hours
- Team C (Documentation): 32 hours
- Team D (SDK Generation): 24 hours
- Team E (Testing/QA): 24 hours
- Total: 200 hours