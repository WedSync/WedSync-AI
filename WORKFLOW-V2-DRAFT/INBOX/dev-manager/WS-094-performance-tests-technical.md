# TECHNICAL SPECIFICATION: WS-094 - Performance Tests Implementation
## Generated by Feature Development Session - 2025-08-22

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** WedSync development team and wedding suppliers
**I want to:** Monitor system performance under realistic wedding season loads
**So that:** The platform handles peak booking seasons (April-October) without slowdowns, preventing lost bookings when couples are comparing vendors

**Real Wedding Scenario:**
During peak wedding season, a venue's form loads slowly when 50+ couples are browsing simultaneously. Couples abandon the form and book competitors instead. Performance tests would identify the bottleneck before peak season, preventing lost business for suppliers.

### SPECIFICATION SOURCE
- **Feature ID:** WS-094
- **Original Spec:** /CORE-SPECIFICATIONS/11-TESTING-DEPLOYMENT/01-Testing/04-performance-tests md.md
- **Current Implementation:** 0% complete
- **Files to Modify:** 
  - /wedsync/package.json (add performance test scripts)
  - /wedsync/playwright.config.ts (add performance config)
- **New Files to Create:** 
  - /wedsync/tests/performance/setup.ts
  - /wedsync/tests/performance/*.spec.ts
  - /wedsync/tests/performance/load-scenarios.ts
  - /wedsync/scripts/performance-monitoring.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Performance monitoring table
CREATE TABLE IF NOT EXISTS performance_metrics (
  id SERIAL PRIMARY KEY,
  test_run_id UUID DEFAULT uuid_generate_v4(),
  test_name VARCHAR(100) NOT NULL,
  metric_type VARCHAR(50) NOT NULL, -- 'response_time', 'throughput', 'memory', 'cpu'
  metric_value DECIMAL(10,4) NOT NULL,
  threshold_value DECIMAL(10,4),
  passed BOOLEAN NOT NULL,
  user_load INTEGER,
  test_environment VARCHAR(20) DEFAULT 'staging',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  metadata JSONB
);

-- Performance thresholds configuration
CREATE TABLE IF NOT EXISTS performance_thresholds (
  id SERIAL PRIMARY KEY,
  endpoint VARCHAR(200) NOT NULL,
  metric_type VARCHAR(50) NOT NULL,
  threshold_value DECIMAL(10,4) NOT NULL,
  user_load INTEGER DEFAULT 1,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Insert default thresholds for wedding critical paths
INSERT INTO performance_thresholds (endpoint, metric_type, threshold_value, user_load) VALUES
  ('/api/clients', 'response_time', 500.0, 10),
  ('/api/journeys/execute', 'response_time', 1000.0, 5),
  ('/api/import/csv', 'response_time', 3000.0, 1),
  ('/dashboard', 'first_contentful_paint', 1500.0, 1),
  ('/clients/[id]/profile', 'largest_contentful_paint', 2000.0, 1);
```

#### API Endpoints Required
```typescript
// Performance monitoring API
export interface PerformanceMetric {
  test_run_id: string;
  test_name: string;
  metric_type: 'response_time' | 'throughput' | 'memory' | 'cpu' | 'first_contentful_paint' | 'largest_contentful_paint';
  metric_value: number;
  threshold_value?: number;
  passed: boolean;
  user_load: number;
  metadata?: Record<string, any>;
}

// POST /api/performance/metrics
interface RecordMetricsRequest {
  metrics: PerformanceMetric[];
}

// GET /api/performance/report
interface PerformanceReport {
  test_run_id: string;
  overall_score: number;
  passed_tests: number;
  failed_tests: number;
  critical_failures: string[];
  recommendations: string[];
  comparison_to_baseline?: {
    performance_change: number;
    regression_detected: boolean;
  };
}
```

#### Frontend Components Required
```typescript
// Performance Dashboard Component (for dev team)
interface PerformanceDashboardProps {
  timeRange: '1h' | '24h' | '7d' | '30d';
}

const PerformanceDashboard: React.FC<PerformanceDashboardProps> = ({ timeRange }) => {
  return (
    <div className="performance-dashboard">
      <MetricsOverview timeRange={timeRange} />
      <PerformanceCharts metrics={['response_time', 'throughput']} />
      <ThresholdAlerts />
      <TestRunHistory />
    </div>
  );
};

// Performance monitoring hook for real-time metrics
export const usePerformanceMonitoring = () => {
  const [metrics, setMetrics] = useState<PerformanceMetric[]>([]);
  
  const recordMetric = useCallback((metric: PerformanceMetric) => {
    setMetrics(prev => [...prev, metric]);
    // Send to backend
    fetch('/api/performance/metrics', {
      method: 'POST',
      body: JSON.stringify({ metrics: [metric] })
    });
  }, []);
  
  return { metrics, recordMetric };
};
```

#### Integration Points
```typescript
// Performance testing service
class PerformanceTestService {
  async runLoadTest(scenario: LoadTestScenario) {
    const results = await this.executePuppeteerScenario(scenario);
    await this.recordMetrics(results);
    return this.generateReport(results);
  }
  
  async executePuppeteerScenario(scenario: LoadTestScenario) {
    // Launch multiple browser instances
    // Simulate concurrent user actions
    // Measure response times and resource usage
  }
  
  async validateThresholds(metrics: PerformanceMetric[]) {
    const thresholds = await this.getThresholds();
    return metrics.map(metric => ({
      ...metric,
      passed: metric.metric_value <= (thresholds[metric.test_name]?.[metric.metric_type] || Infinity)
    }));
  }
}
```

### CODE EXAMPLES

#### Example 1: Load Test Scenario Configuration
```typescript
// tests/performance/load-scenarios.ts
export interface LoadTestScenario {
  name: string;
  description: string;
  userCount: number;
  duration: string;
  actions: ScenarioAction[];
  thresholds: PerformanceThresholds;
}

export const weddingSeasonScenarios: LoadTestScenario[] = [
  {
    name: 'peak_season_venue_browsing',
    description: 'Simulate 50 couples browsing venue profiles simultaneously',
    userCount: 50,
    duration: '5m',
    actions: [
      { type: 'navigate', url: '/vendors/venues' },
      { type: 'search', query: 'outdoor venue' },
      { type: 'click', selector: '.venue-card:first-child' },
      { type: 'wait', duration: 2000 },
      { type: 'click', selector: '.contact-form-button' },
      { type: 'fill_form', fields: {
        couple_names: 'Test Couple',
        email: 'test@example.com',
        wedding_date: '2025-08-15',
        guest_count: '150'
      }},
      { type: 'submit', selector: '.submit-button' }
    ],
    thresholds: {
      response_time: 2000,
      first_contentful_paint: 1500,
      form_submission: 3000
    }
  },
  
  {
    name: 'supplier_dashboard_heavy_load',
    description: 'Test dashboard performance when supplier has 200+ active clients',
    userCount: 10,
    duration: '3m',
    actions: [
      { type: 'auth', credentials: 'test_supplier' },
      { type: 'navigate', url: '/dashboard' },
      { type: 'wait_for_load' },
      { type: 'click', selector: '.clients-tab' },
      { type: 'scroll', direction: 'down', pixels: 1000 },
      { type: 'click', selector: '.client-row:nth-child(25)' },
      { type: 'navigate', url: '/clients/profile' }
    ],
    thresholds: {
      response_time: 1500,
      largest_contentful_paint: 2000,
      client_list_load: 1000
    }
  }
];
```

#### Example 2: Playwright Performance Test
```typescript
// tests/performance/venue-browsing.spec.ts
import { test, expect } from '@playwright/test';
import { PerformanceTestService } from './utils/performance-service';

test.describe('Venue Browsing Performance', () => {
  let perfService: PerformanceTestService;
  
  test.beforeEach(async ({ page }) => {
    perfService = new PerformanceTestService(page);
    await perfService.startMonitoring();
  });
  
  test('should handle 50 concurrent venue profile views', async ({ page }) => {
    // Start performance monitoring
    const startTime = Date.now();
    
    // Navigate to venue directory
    await page.goto('/vendors/venues');
    const firstPaint = await perfService.getFirstContentfulPaint();
    
    // Search for venues
    await page.fill('[data-testid="venue-search"]', 'outdoor wedding');
    await page.click('[data-testid="search-button"]');
    
    // Wait for search results
    await page.waitForSelector('.venue-card', { timeout: 5000 });
    const searchResponseTime = Date.now() - startTime;
    
    // Click on first venue
    await page.click('.venue-card:first-child');
    await page.waitForLoadState('networkidle');
    const venueLoadTime = await perfService.getPageLoadTime();
    
    // Verify performance thresholds
    expect(firstPaint).toBeLessThan(1500);
    expect(searchResponseTime).toBeLessThan(2000);
    expect(venueLoadTime).toBeLessThan(2000);
    
    // Record metrics
    await perfService.recordMetrics([
      {
        test_run_id: perfService.testRunId,
        test_name: 'venue_browsing',
        metric_type: 'first_contentful_paint',
        metric_value: firstPaint,
        threshold_value: 1500,
        passed: firstPaint < 1500,
        user_load: 1
      },
      {
        test_run_id: perfService.testRunId,
        test_name: 'venue_browsing',
        metric_type: 'response_time',
        metric_value: searchResponseTime,
        threshold_value: 2000,
        passed: searchResponseTime < 2000,
        user_load: 1
      }
    ]);
  });
  
  test('should maintain performance under load', async ({ page }) => {
    // Simulate multiple users by opening multiple contexts
    const contexts = await Promise.all(
      Array.from({ length: 10 }, () => page.context().browser()?.newContext())
    );
    
    const loadTestPromises = contexts.map(async (context, index) => {
      if (!context) return;
      const testPage = await context.newPage();
      
      const startTime = Date.now();
      await testPage.goto('/vendors/venues');
      await testPage.waitForLoadState('networkidle');
      const loadTime = Date.now() - startTime;
      
      return {
        user: index + 1,
        loadTime,
        success: loadTime < 3000
      };
    });
    
    const results = await Promise.all(loadTestPromises);
    const successfulLoads = results.filter(r => r?.success).length;
    const avgLoadTime = results.reduce((sum, r) => sum + (r?.loadTime || 0), 0) / results.length;
    
    // Verify load test results
    expect(successfulLoads).toBeGreaterThan(8); // 80% success rate
    expect(avgLoadTime).toBeLessThan(2500);
    
    // Clean up contexts
    await Promise.all(contexts.map(c => c?.close()));
  });
});
```

#### Example 3: Memory and Resource Monitoring
```typescript
// tests/performance/utils/resource-monitor.ts
export class ResourceMonitor {
  private page: Page;
  private metrics: ResourceMetric[] = [];
  
  constructor(page: Page) {
    this.page = page;
  }
  
  async startMonitoring() {
    // Monitor network requests
    this.page.on('response', (response) => {
      this.metrics.push({
        type: 'network',
        url: response.url(),
        responseTime: response.timing().responseEnd,
        size: parseInt(response.headers()['content-length'] || '0'),
        status: response.status()
      });
    });
    
    // Monitor JavaScript heap size
    await this.page.addInitScript(() => {
      setInterval(() => {
        if (performance.memory) {
          window.memoryMetrics = {
            usedJSHeapSize: performance.memory.usedJSHeapSize,
            totalJSHeapSize: performance.memory.totalJSHeapSize,
            jsHeapSizeLimit: performance.memory.jsHeapSizeLimit
          };
        }
      }, 1000);
    });
  }
  
  async getMemoryUsage() {
    return await this.page.evaluate(() => window.memoryMetrics);
  }
  
  async detectMemoryLeaks() {
    const initialMemory = await this.getMemoryUsage();
    
    // Perform actions that might cause memory leaks
    for (let i = 0; i < 10; i++) {
      await this.page.reload();
      await this.page.waitForLoadState('networkidle');
      await this.page.waitForTimeout(1000);
    }
    
    const finalMemory = await this.getMemoryUsage();
    const memoryIncrease = finalMemory.usedJSHeapSize - initialMemory.usedJSHeapSize;
    
    return {
      memoryLeak: memoryIncrease > 10 * 1024 * 1024, // 10MB threshold
      increase: memoryIncrease,
      initialMemory: initialMemory.usedJSHeapSize,
      finalMemory: finalMemory.usedJSHeapSize
    };
  }
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [ ] Context7: Load Playwright performance testing documentation
- [ ] Playwright: Execute performance tests
- [ ] Filesystem: Create performance test files and reports
- [ ] PostgreSQL: Store performance metrics and thresholds

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/microsoft/playwright", "performance", 3000);
await mcp__context7__get-library-docs("/microsoft/playwright", "load-testing", 2000);
await mcp__context7__get-library-docs("/puppeteer/puppeteer", "performance-monitoring", 2000);
```

### TEST REQUIREMENTS

#### Performance Tests Required
```typescript
describe('Performance Test Coverage', () => {
  it('should test critical user journeys under load', () => {
    // Wedding season scenarios:
    // - 50+ couples browsing venues simultaneously
    // - Supplier dashboard with 200+ active clients
    // - CSV import of 1000+ client records
    // - Journey execution with multiple branches
    // - Form submission during peak hours
  });
  
  it('should monitor resource usage', () => {
    // Memory leak detection
    // CPU usage monitoring
    // Network request optimization
    // Bundle size impact measurement
  });
  
  it('should validate performance regressions', () => {
    // Compare against baseline metrics
    // Alert on threshold violations
    // Track performance trends over time
  });
});
```

#### Load Testing Scenarios
```typescript
const criticalWeddingScenarios = [
  'peak_season_venue_browsing',
  'supplier_dashboard_heavy_load',
  'bulk_client_import',
  'journey_execution_concurrent',
  'form_submission_peak_hours',
  'photo_gallery_large_albums',
  'real_time_chat_multiple_users'
];
```

### ACCEPTANCE CRITERIA
- [ ] Performance tests configured and running
- [ ] Critical wedding scenarios covered (venue browsing, dashboard, forms)
- [ ] Load testing for 50+ concurrent users
- [ ] Memory leak detection implemented
- [ ] Performance regression monitoring
- [ ] Threshold-based pass/fail criteria
- [ ] Performance dashboard for monitoring
- [ ] Integration with CI/CD pipeline
- [ ] Performance reports generated automatically
- [ ] Baseline metrics established for comparison

### DEPENDENCIES
- Must complete after: WS-091 (Unit Tests), WS-092 (Integration Tests)
- Must complete before: WS-095 (CI/CD Pipeline)
- Shares code with: All features (performance impact measurement)

### ESTIMATED EFFORT
- Team A Frontend: 14 hours (client-side performance tests)
- Team B Backend: 12 hours (API load tests and monitoring)
- Team C Integration: 10 hours (test setup and CI integration)
- Total: 36 hours