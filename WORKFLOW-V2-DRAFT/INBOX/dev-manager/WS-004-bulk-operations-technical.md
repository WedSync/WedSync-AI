# TECHNICAL SPECIFICATION: WS-004 - Bulk Operations
## Generated by Feature Development Session - 2025-08-21

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding venue coordinator managing 150+ weddings annually
**I want to:** Perform bulk operations on multiple clients simultaneously for common tasks and updates
**So that:** I can send season reminders to 45 spring couples in 2 minutes instead of opening 45 individual profiles and sending messages one by one for 90+ minutes

**Real Wedding Scenario:**
A venue coordinator needs to: 1) Send weather contingency info to 25 outdoor weddings in June, 2) Update status to "Final Details" for 15 couples with weddings in next 6 weeks, 3) Assign 20 recent bookings to the "New Client Onboarding" journey. Currently this takes 2+ hours of repetitive clicking. With bulk operations, they select clients by criteria (outdoor venues + June dates), choose "Send Message" from bulk menu, personalize the weather template, and send to all 25 couples in under 3 minutes - saving 117+ minutes of manual work.

### SPECIFICATION SOURCE
- **Feature ID:** WS-004
- **Original Spec:** /CORE-SPECIFICATIONS/02-WEDSYNC-SUPPLIER-PLATFORM/03-Client-Management/06-bulk-operations md.md
- **Current Implementation:** 0% complete
- **Files to Modify:** 
  - /src/components/clients/ClientListView.tsx (add selection)
  - /src/components/clients/ClientGridView.tsx (add selection)
- **New Files to Create:**
  - /src/components/clients/bulk/BulkActionBar.tsx
  - /src/components/clients/bulk/BulkSelectionPanel.tsx
  - /src/components/clients/bulk/BulkEmailModal.tsx
  - /src/components/clients/bulk/BulkProgressModal.tsx
  - /src/lib/bulk/bulkOperations.ts
  - /src/lib/stores/bulkSelectionStore.ts
  - /src/app/api/bulk/email/route.ts
  - /src/app/api/bulk/update/route.ts
  - /src/app/api/bulk/journey/route.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Bulk operation job tracking
CREATE TABLE IF NOT EXISTS bulk_operations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  operation_type TEXT CHECK (operation_type IN ('email', 'sms', 'update_status', 'add_tags', 'remove_tags', 'assign_journey', 'archive', 'delete')) NOT NULL,
  target_client_ids UUID[] NOT NULL,
  operation_data JSONB NOT NULL,
  status TEXT CHECK (status IN ('queued', 'processing', 'completed', 'failed', 'cancelled')) DEFAULT 'queued',
  total_targets INTEGER NOT NULL,
  processed_count INTEGER DEFAULT 0,
  success_count INTEGER DEFAULT 0,
  failure_count INTEGER DEFAULT 0,
  error_details JSONB DEFAULT '{}',
  created_at TIMESTAMP DEFAULT NOW(),
  started_at TIMESTAMP,
  completed_at TIMESTAMP,
  cancelled_at TIMESTAMP
);

-- Saved client selections for reuse
CREATE TABLE IF NOT EXISTS saved_client_selections (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  selection_name TEXT NOT NULL,
  description TEXT,
  client_ids UUID[] NOT NULL,
  selection_criteria JSONB DEFAULT '{}', -- For dynamic selections
  created_at TIMESTAMP DEFAULT NOW(),
  last_used_at TIMESTAMP DEFAULT NOW(),
  usage_count INTEGER DEFAULT 0
);

-- Bulk operation audit log
CREATE TABLE IF NOT EXISTS bulk_operation_audit (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  bulk_operation_id UUID REFERENCES bulk_operations(id) ON DELETE CASCADE,
  client_id UUID NOT NULL,
  action_taken TEXT NOT NULL,
  old_value JSONB,
  new_value JSONB,
  success BOOLEAN DEFAULT true,
  error_message TEXT,
  processed_at TIMESTAMP DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_bulk_operations_supplier_id ON bulk_operations(supplier_id);
CREATE INDEX idx_bulk_operations_status ON bulk_operations(status);
CREATE INDEX idx_saved_selections_supplier_id ON saved_client_selections(supplier_id);
CREATE INDEX idx_bulk_audit_operation_id ON bulk_operation_audit(bulk_operation_id);
```

#### API Endpoints Required
```typescript
// POST /api/bulk/email
interface BulkEmailRequest {
  clientIds: string[];
  subject: string;
  htmlContent: string;
  plainTextContent: string;
  scheduleTime?: string; // ISO string for scheduled sending
  personalizationTokens?: Record<string, string>;
  trackOpens?: boolean;
  trackClicks?: boolean;
}

interface BulkEmailResponse {
  success: boolean;
  data: {
    operationId: string;
    queuedCount: number;
    estimatedCompletionTime: string;
    invalidEmails: string[];
  };
}

// POST /api/bulk/update
interface BulkUpdateRequest {
  clientIds: string[];
  updates: {
    status?: 'active' | 'upcoming' | 'past' | 'archived';
    tags?: {
      add?: string[];
      remove?: string[];
    };
    customFields?: Record<string, any>;
  };
  confirmDestructive?: boolean; // Required for dangerous operations
}

interface BulkUpdateResponse {
  success: boolean;
  data: {
    operationId: string;
    updatedCount: number;
    skippedCount: number;
    conflicts: Array<{
      clientId: string;
      reason: string;
    }>;
  };
}

// POST /api/bulk/journey
interface BulkJourneyAssignRequest {
  clientIds: string[];
  journeyId: string;
  startDate?: string; // Override default start timing
  skipIfAlreadyActive?: boolean;
  pauseCurrentJourneys?: boolean;
}

// GET /api/bulk/status/[operationId]
interface BulkOperationStatusResponse {
  success: boolean;
  data: {
    status: 'queued' | 'processing' | 'completed' | 'failed' | 'cancelled';
    progress: number; // 0-100
    processedCount: number;
    successCount: number;
    failureCount: number;
    estimatedTimeRemaining: number; // seconds
    errors: Array<{
      clientId: string;
      clientName: string;
      error: string;
    }>;
  };
}

// DELETE /api/bulk/[operationId]
interface CancelBulkOperationResponse {
  success: boolean;
  data: {
    cancelled: boolean;
    processedBeforeCancellation: number;
  };
}
```

#### Frontend Components Required
```typescript
// Component: BulkActionBar
// Location: /src/components/clients/bulk/BulkActionBar.tsx

interface BulkActionBarProps {
  selectedCount: number;
  onClearSelection: () => void;
  onBulkAction: (action: BulkAction) => void;
  availableActions: BulkAction[];
}

// Key functionality:
- Fixed position bar appearing when clients selected
- Action buttons with icons and counts
- Progress indicator for active operations
- Cancel operation capability
- Keyboard shortcuts (Esc to clear, Delete for bulk delete)
- Mobile: Collapse to floating action button

// Component: BulkSelectionPanel
// Location: /src/components/clients/bulk/BulkSelectionPanel.tsx

interface BulkSelectionPanelProps {
  clients: ClientListItem[];
  selectedIds: string[];
  onSelectionChange: (ids: string[]) => void;
  onSaveSelection: (name: string, description?: string) => void;
  savedSelections: SavedSelection[];
}

// Key functionality:
- Select all/none toggle
- Smart selection by criteria (status, tags, date range)
- Save/load selection presets
- Selection count and size indicators
- Batch selection limits (max 200 clients)
- Visual feedback for selection state

// Component: BulkProgressModal
// Location: /src/components/clients/bulk/BulkProgressModal.tsx

interface BulkProgressModalProps {
  operationId: string;
  operationType: string;
  onClose: () => void;
  onCancel: () => void;
}

// Key functionality:
- Real-time progress updates via WebSocket
- Client-by-client processing status
- Error details with retry options
- Download error report capability
- Success summary with statistics
- Auto-close on completion option
```

#### Integration Points
```typescript
// Store: bulkSelectionStore
// Dependencies: zustand, supabase client

import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface BulkSelectionStore {
  selectedClientIds: string[];
  selectionMode: boolean;
  activeOperation: string | null;
  
  toggleSelection: (clientId: string) => void;
  toggleAllSelection: (clientIds: string[]) => void;
  clearSelection: () => void;
  setSelectionMode: (enabled: boolean) => void;
  selectByFilters: (filters: SelectionFilters) => Promise<void>;
  
  executeOperation: (operation: BulkOperation) => Promise<string>;
  cancelOperation: (operationId: string) => Promise<void>;
  trackOperationProgress: (operationId: string) => void;
}

// Background job processing
export class BulkOperationProcessor {
  private queue: BulkOperation[] = [];
  private processing: boolean = false;
  
  async enqueue(operation: BulkOperation): Promise<string> {
    const operationId = await this.createOperationRecord(operation);
    this.queue.push({ ...operation, id: operationId });
    
    if (!this.processing) {
      this.processQueue();
    }
    
    return operationId;
  }
  
  private async processQueue(): Promise<void> {
    this.processing = true;
    
    while (this.queue.length > 0) {
      const operation = this.queue.shift()!;
      await this.processOperation(operation);
    }
    
    this.processing = false;
  }
  
  private async processOperation(operation: BulkOperation): Promise<void> {
    // Process in batches to avoid overwhelming the system
    const batchSize = 20;
    const totalTargets = operation.targetClientIds.length;
    let processedCount = 0;
    
    for (let i = 0; i < totalTargets; i += batchSize) {
      const batch = operation.targetClientIds.slice(i, i + batchSize);
      await this.processBatch(operation, batch);
      processedCount += batch.length;
      
      // Update progress
      await this.updateOperationProgress(operation.id, processedCount, totalTargets);
    }
  }
}
```

### CODE EXAMPLES

#### Example 1: Smart Selection by Criteria
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { supabase } from '@/lib/supabase';

export async function selectClientsByCriteria(criteria: SelectionCriteria): Promise<string[]> {
  // Step 1: Build dynamic query based on criteria
  let query = supabase
    .from('client_list_cache')
    .select('id');
  
  // Step 2: Apply filters
  if (criteria.status?.length) {
    query = query.in('status', criteria.status);
  }
  
  if (criteria.tags?.length) {
    // Array overlap check for tags
    query = query.overlaps('tags', criteria.tags);
  }
  
  if (criteria.dateRange) {
    query = query
      .gte('wedding_date', criteria.dateRange.start)
      .lte('wedding_date', criteria.dateRange.end);
  }
  
  if (criteria.wedmeStatus?.length) {
    query = query.in('wedme_status', criteria.wedmeStatus);
  }
  
  if (criteria.venueType) {
    // Search in custom fields for venue type
    query = query.contains('custom_fields', { venue_type: criteria.venueType });
  }
  
  if (criteria.packageTier?.length) {
    query = query.contains('package_details', { tier: criteria.packageTier });
  }
  
  // Step 3: Apply limits for safety
  query = query.limit(200); // Maximum bulk operation size
  
  // Step 4: Execute query
  const { data, error } = await query;
  
  if (error) {
    throw new Error(`Selection failed: ${error.message}`);
  }
  
  return data?.map(client => client.id) || [];
}
```

#### Example 2: Bulk Email with Personalization and Progress Tracking
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { supabase } from '@/lib/supabase';
import { sendEmail } from '@/lib/email/emailService';

export async function processBulkEmail(
  operationId: string,
  clientIds: string[],
  emailData: BulkEmailData
): Promise<BulkOperationResult> {
  const results = {
    successCount: 0,
    failureCount: 0,
    errors: [] as Array<{ clientId: string; error: string }>
  };
  
  // Step 1: Fetch client data for personalization
  const { data: clients, error: fetchError } = await supabase
    .from('client_profiles')
    .select('id, couple_names, partner1_email, wedding_date, venue_name, custom_fields')
    .in('id', clientIds);
    
  if (fetchError) {
    throw new Error(`Failed to fetch client data: ${fetchError.message}`);
  }
  
  // Step 2: Process each client with personalization
  for (const client of clients) {
    try {
      // Step 3: Personalize email content
      const personalizedContent = personalizeEmailContent(emailData.htmlContent, {
        couple_names: client.couple_names,
        wedding_date: formatDate(client.wedding_date),
        venue_name: client.venue_name,
        days_until: calculateDaysUntil(client.wedding_date),
        ...client.custom_fields
      });
      
      const personalizedSubject = personalizeEmailContent(emailData.subject, {
        couple_names: client.couple_names,
        wedding_date: formatDate(client.wedding_date)
      });
      
      // Step 4: Send email
      await sendEmail({
        to: client.partner1_email,
        subject: personalizedSubject,
        html: personalizedContent,
        trackOpens: emailData.trackOpens,
        trackClicks: emailData.trackClicks,
        metadata: {
          operationId,
          clientId: client.id,
          operationType: 'bulk_email'
        }
      });
      
      results.successCount++;
      
      // Step 5: Log successful action
      await supabase
        .from('bulk_operation_audit')
        .insert({
          bulk_operation_id: operationId,
          client_id: client.id,
          action_taken: 'email_sent',
          new_value: { subject: personalizedSubject },
          success: true
        });
        
    } catch (error) {
      results.failureCount++;
      results.errors.push({
        clientId: client.id,
        error: error.message
      });
      
      // Step 6: Log failed action
      await supabase
        .from('bulk_operation_audit')
        .insert({
          bulk_operation_id: operationId,
          client_id: client.id,
          action_taken: 'email_send_failed',
          success: false,
          error_message: error.message
        });
    }
    
    // Step 7: Update operation progress
    await supabase
      .from('bulk_operations')
      .update({
        processed_count: results.successCount + results.failureCount,
        success_count: results.successCount,
        failure_count: results.failureCount
      })
      .eq('id', operationId);
  }
  
  // Step 8: Mark operation as completed
  await supabase
    .from('bulk_operations')
    .update({
      status: 'completed',
      completed_at: new Date().toISOString(),
      error_details: results.errors
    })
    .eq('id', operationId);
    
  return results;
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for bulk operations patterns
- [ ] Playwright: Test bulk selection and operations
- [x] Filesystem: Access bulk operation components

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/pmndrs/zustand", "store state management", 2000);
await mcp__context7__get-library-docs("/supabase/supabase", "bulk operations queries", 3000);
await mcp__context7__get-library-docs("/vercel/next.js", "background jobs", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('Bulk Selection', () => {
  it('should select clients by criteria', async () => {
    const criteria = { status: ['active'], tags: ['vip'] };
    const selectedIds = await selectClientsByCriteria(criteria);
    expect(selectedIds.length).toBeGreaterThan(0);
  });
  
  it('should respect selection limits', async () => {
    const criteria = { status: ['active', 'upcoming'] };
    const selectedIds = await selectClientsByCriteria(criteria);
    expect(selectedIds.length).toBeLessThanOrEqual(200);
  });
  
  it('should handle empty selection gracefully', async () => {
    const criteria = { tags: ['non-existent-tag'] };
    const selectedIds = await selectClientsByCriteria(criteria);
    expect(selectedIds).toEqual([]);
  });
});

describe('Bulk Operations', () => {
  it('should process bulk email with personalization', async () => {
    const result = await processBulkEmail('test-op', ['client1'], {
      subject: 'Hello {{couple_names}}',
      htmlContent: 'Your wedding is in {{days_until}} days!'
    });
    
    expect(result.successCount).toBe(1);
    expect(result.failureCount).toBe(0);
  });
  
  it('should handle partial failures gracefully', async () => {
    // Mock some clients with invalid emails
    const result = await processBulkEmail('test-op', ['valid-client', 'invalid-email-client'], emailData);
    
    expect(result.successCount).toBe(1);
    expect(result.failureCount).toBe(1);
    expect(result.errors).toHaveLength(1);
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Bulk client selection and email', async () => {
  await mcp__playwright__browser_navigate({url: '/clients'});
  
  // Select multiple clients
  await mcp__playwright__browser_click({
    element: 'Client checkbox 1',
    ref: '[data-testid="client-checkbox-1"]'
  });
  
  await mcp__playwright__browser_click({
    element: 'Client checkbox 2', 
    ref: '[data-testid="client-checkbox-2"]'
  });
  
  // Verify bulk action bar appears
  await mcp__playwright__browser_wait_for({text: '2 clients selected'});
  
  // Open bulk email modal
  await mcp__playwright__browser_click({
    element: 'Bulk email button',
    ref: '[data-testid="bulk-email"]'
  });
  
  // Fill email details
  await mcp__playwright__browser_type({
    element: 'Email subject',
    ref: '[name="subject"]',
    text: 'Important Update'
  });
  
  // Send bulk email
  await mcp__playwright__browser_click({
    element: 'Send email button',
    ref: '[data-testid="send-bulk-email"]'
  });
  
  // Verify progress modal
  await mcp__playwright__browser_wait_for({text: 'Sending emails...'});
});

test('Smart selection by criteria', async () => {
  await mcp__playwright__browser_navigate({url: '/clients'});
  
  // Open smart selection
  await mcp__playwright__browser_click({
    element: 'Smart select button',
    ref: '[data-testid="smart-select"]'
  });
  
  // Set criteria
  await mcp__playwright__browser_select_option({
    element: 'Status filter',
    ref: '[data-testid="status-filter"]',
    values: ['active']
  });
  
  await mcp__playwright__browser_type({
    element: 'Tags input',
    ref: '[data-testid="tags-input"]',
    text: 'vip'
  });
  
  // Apply selection
  await mcp__playwright__browser_click({
    element: 'Apply criteria',
    ref: '[data-testid="apply-criteria"]'
  });
  
  // Verify clients selected
  await mcp__playwright__browser_wait_for({text: 'clients selected'});
});
```

### ACCEPTANCE CRITERIA
- [ ] Supports selection of up to 200 clients simultaneously
- [ ] Smart selection by multiple criteria (status, tags, dates, venue type)
- [ ] Bulk email with personalization tokens works correctly
- [ ] Bulk status updates with audit trail
- [ ] Bulk tag assignment/removal functionality
- [ ] Journey assignment to multiple clients
- [ ] Real-time progress tracking for all operations
- [ ] Cancel operation capability during processing
- [ ] Detailed error reporting with client-specific failures
- [ ] Saved selection presets for reuse
- [ ] Undo capability for reversible operations
- [ ] Mobile-optimized bulk selection interface

### DEPENDENCIES
- Must complete after: WS-001 (Client List Views), WS-002 (Client Profiles)
- Must complete before: WS-012 (Email Templates - enhanced integration)
- Shares code with: WS-003 (batch processing), WS-005 (tagging operations)

### ESTIMATED EFFORT
- Team A Frontend: 24 hours
- Team B Backend: 20 hours
- Team C Integration: 4 hours
- Total: 48 hours