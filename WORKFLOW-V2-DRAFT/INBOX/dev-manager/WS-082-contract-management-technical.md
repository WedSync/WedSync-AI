# TECHNICAL SPECIFICATION: WS-082 - Contract Management
## Generated by Feature Development Session - August 22, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding planner managing contracts for 8 vendors across 5 different weddings
**I want to:** Store, track, and get alerts for all contract milestones and deadlines
**So that:** I never miss a payment deadline or contract requirement (missed deadlines cost average of $2,500 per incident in penalties/rebookings)

**Real Wedding Scenario:**
A planner has contracts with photographer ($4,000), venue ($12,000), caterer ($8,000), florist ($2,500), and DJ ($1,800) for a June wedding. Each has different payment schedules: 50% deposit, 25% at 60 days out, 25% final payment. The photographer requires shot list 30 days prior, venue needs final count 14 days before, caterer needs dietary restrictions 21 days prior. Without contract management, they use spreadsheets and miss the venue payment deadline, causing a $500 late fee and stressed client relationship.

### SPECIFICATION SOURCE
- **Feature ID:** WS-082
- **Original Spec:** Store and track vendor contracts
- **Current Implementation:** 0% complete
- **Files to Modify:**
  - /wedsync/src/app/(dashboard)/layout.tsx (add contracts menu)
- **New Files to Create:**
  - /wedsync/src/app/(dashboard)/contracts/page.tsx
  - /wedsync/src/app/(dashboard)/contracts/[id]/page.tsx
  - /wedsync/src/app/(dashboard)/contracts/upload/page.tsx
  - /wedsync/src/app/api/contracts/route.ts
  - /wedsync/src/app/api/contracts/[id]/route.ts
  - /wedsync/src/app/api/contracts/[id]/milestones/route.ts
  - /wedsync/src/components/contracts/ContractViewer.tsx
  - /wedsync/src/components/contracts/MilestoneTracker.tsx
  - /wedsync/src/components/contracts/ContractUpload.tsx
  - /wedsync/src/lib/services/contractService.ts
  - /wedsync/src/lib/pdf/contractParser.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Contract documents
CREATE TABLE IF NOT EXISTS contracts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  couple_id UUID NOT NULL REFERENCES couples(id),
  vendor_id UUID NOT NULL REFERENCES auth.users(id),
  contract_name VARCHAR(255) NOT NULL,
  vendor_business_name VARCHAR(255) NOT NULL,
  vendor_type VARCHAR(100) NOT NULL, -- 'photographer', 'venue', 'caterer', etc.
  contract_type VARCHAR(50) DEFAULT 'service', -- 'service', 'venue_rental', 'vendor_agreement'
  contract_status VARCHAR(50) DEFAULT 'draft', -- 'draft', 'sent', 'signed', 'completed', 'cancelled'
  
  -- Financial terms
  total_amount DECIMAL(10,2) NOT NULL,
  currency VARCHAR(3) DEFAULT 'USD',
  payment_terms JSONB, -- {deposit: 50%, milestone1: 25%, final: 25%}
  
  -- Dates
  contract_date DATE NOT NULL,
  wedding_date DATE NOT NULL,
  signing_deadline DATE,
  cancellation_deadline DATE,
  
  -- Document storage
  original_file_url VARCHAR(500), -- PDF storage
  signed_file_url VARCHAR(500), -- Signed version
  file_size INTEGER,
  pages_count INTEGER,
  
  -- Contract parsing results
  parsed_content TEXT, -- Extracted text content
  key_terms JSONB, -- Parsed important terms
  auto_extracted_dates JSONB, -- AI-extracted important dates
  
  -- Metadata
  created_by UUID REFERENCES auth.users(id),
  last_modified_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Contract milestones and deadlines
CREATE TABLE IF NOT EXISTS contract_milestones (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  contract_id UUID NOT NULL REFERENCES contracts(id) ON DELETE CASCADE,
  milestone_type VARCHAR(100) NOT NULL, -- 'payment', 'deliverable', 'deadline', 'meeting'
  milestone_name VARCHAR(255) NOT NULL,
  description TEXT,
  
  -- Scheduling
  due_date DATE NOT NULL,
  reminder_days INTEGER DEFAULT 7, -- Days before due date to send reminder
  
  -- Status tracking
  status VARCHAR(50) DEFAULT 'pending', -- 'pending', 'completed', 'overdue', 'cancelled'
  completed_date TIMESTAMP WITH TIME ZONE,
  completed_by UUID REFERENCES auth.users(id),
  
  -- Payment-specific fields
  amount_due DECIMAL(10,2),
  payment_method VARCHAR(50),
  payment_reference VARCHAR(255),
  
  -- Deliverable-specific fields
  deliverable_type VARCHAR(100), -- 'shot_list', 'menu_selection', 'floor_plan'
  attachments JSONB, -- URLs to uploaded files
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Contract revisions and amendments
CREATE TABLE IF NOT EXISTS contract_revisions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  contract_id UUID NOT NULL REFERENCES contracts(id) ON DELETE CASCADE,
  revision_number INTEGER NOT NULL,
  revision_type VARCHAR(50) DEFAULT 'amendment', -- 'amendment', 'full_revision', 'addendum'
  changes_description TEXT NOT NULL,
  revised_file_url VARCHAR(500),
  amount_change DECIMAL(10,2) DEFAULT 0.00,
  
  -- Approval tracking
  requires_approval BOOLEAN DEFAULT true,
  approved_by_couple BOOLEAN DEFAULT false,
  approved_by_vendor BOOLEAN DEFAULT false,
  approved_by_couple_at TIMESTAMP WITH TIME ZONE,
  approved_by_vendor_at TIMESTAMP WITH TIME ZONE,
  
  created_by UUID NOT NULL REFERENCES auth.users(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Contract communications log
CREATE TABLE IF NOT EXISTS contract_communications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  contract_id UUID NOT NULL REFERENCES contracts(id) ON DELETE CASCADE,
  communication_type VARCHAR(50) NOT NULL, -- 'email', 'call', 'meeting', 'text', 'in_person'
  subject VARCHAR(255),
  content TEXT,
  direction VARCHAR(20) NOT NULL, -- 'inbound', 'outbound'
  
  -- Participants
  from_user_id UUID REFERENCES auth.users(id),
  from_email VARCHAR(255),
  to_user_id UUID REFERENCES auth.users(id),
  to_email VARCHAR(255),
  
  -- Attachments and references
  attachments JSONB,
  milestone_references UUID[], -- References to related milestones
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

CREATE INDEX idx_contracts_couple ON contracts(couple_id);
CREATE INDEX idx_contracts_vendor ON contracts(vendor_id);
CREATE INDEX idx_contracts_wedding_date ON contracts(wedding_date);
CREATE INDEX idx_contract_milestones_contract ON contract_milestones(contract_id);
CREATE INDEX idx_contract_milestones_due_date ON contract_milestones(due_date) WHERE status = 'pending';
CREATE INDEX idx_contract_revisions_contract ON contract_revisions(contract_id);
```

#### API Endpoints Required
```typescript
// GET /api/contracts - Get user's contracts with filtering
interface GetContractsRequest {
  status?: string;
  vendorType?: string;
  weddingDate?: string;
  upcomingMilestones?: boolean;
  sortBy?: 'contract_date' | 'wedding_date' | 'total_amount';
}

interface GetContractsResponse {
  contracts: {
    id: string;
    contractName: string;
    vendorBusinessName: string;
    vendorType: string;
    status: string;
    totalAmount: number;
    contractDate: string;
    weddingDate: string;
    upcomingMilestones: number;
    overdueItems: number;
    nextMilestone?: {
      name: string;
      dueDate: string;
      type: string;
    };
  }[];
  summary: {
    totalContracts: number;
    totalValue: number;
    pendingPayments: number;
    upcomingDeadlines: number;
  };
}

// POST /api/contracts - Upload and parse new contract
interface UploadContractRequest {
  file: File; // PDF contract
  vendorId: string;
  vendorBusinessName: string;
  vendorType: string;
  weddingDate: string;
}

interface UploadContractResponse {
  contractId: string;
  parsedData: {
    totalAmount?: number;
    contractDate?: string;
    keyTerms: string[];
    extractedDates: { date: string; description: string }[];
    suggestedMilestones: {
      type: string;
      name: string;
      dueDate: string;
      amount?: number;
    }[];
  };
  requiresReview: boolean;
}

// POST /api/contracts/[id]/milestones - Add milestone to contract
interface CreateMilestoneRequest {
  milestoneType: 'payment' | 'deliverable' | 'deadline' | 'meeting';
  milestoneName: string;
  description?: string;
  dueDate: string;
  reminderDays?: number;
  amountDue?: number;
  deliverableType?: string;
}
```

#### Frontend Components Required
```typescript
// Component: ContractViewer
// Location: /src/components/contracts/ContractViewer.tsx

interface ContractViewerProps {
  contractId: string;
  allowEditing: boolean;
}

// Key functionality:
- PDF viewer with annotation support
- Side-by-side milestone tracking
- Payment schedule visualization
- Contract revision history
- Communication log
- Export contract summary
- Print-friendly view

// Component: MilestoneTracker
// Location: /src/components/contracts/MilestoneTracker.tsx

interface MilestoneTrackerProps {
  contractId: string;
  milestones: Milestone[];
  onMilestoneUpdate: (id: string, status: string) => void;
}

// Key functionality:
- Timeline view of all milestones
- Status indicators with color coding
- Automated reminder scheduling
- Bulk milestone operations
- Integration with calendar
- Mobile notifications
```

### CODE EXAMPLES

#### Example 1: Contract Parser with AI Extraction
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { PDFExtract } from 'pdf-extract';
import { openAI } from '@/lib/ai/openai';

export class ContractParser {
  async parseContractPDF(fileUrl: string, contractMetadata: ContractMetadata): Promise<ParsedContract> {
    try {
      // Step 1: Extract text from PDF
      const pdfText = await this.extractTextFromPDF(fileUrl);
      
      // Step 2: Use AI to extract key information
      const extractedData = await this.extractKeyInformation(pdfText, contractMetadata);
      
      // Step 3: Generate suggested milestones
      const suggestedMilestones = await this.generateMilestones(extractedData, contractMetadata);
      
      return {
        parsedContent: pdfText,
        keyTerms: extractedData.keyTerms,
        totalAmount: extractedData.totalAmount,
        contractDate: extractedData.contractDate,
        extractedDates: extractedData.importantDates,
        suggestedMilestones,
        confidence: extractedData.confidence
      };
      
    } catch (error) {
      console.error('Contract parsing failed:', error);
      return {
        parsedContent: '',
        keyTerms: [],
        suggestedMilestones: [],
        confidence: 0,
        error: error.message
      };
    }
  }
  
  private async extractTextFromPDF(fileUrl: string): Promise<string> {
    const pdfExtractor = new PDFExtract();
    
    return new Promise((resolve, reject) => {
      pdfExtractor.extract(fileUrl, {}, (err, data) => {
        if (err) {
          reject(err);
          return;
        }
        
        const textContent = data.pages
          .map(page => page.content.map(item => item.str).join(' '))
          .join('\n');
        
        resolve(textContent);
      });
    });
  }
  
  private async extractKeyInformation(pdfText: string, metadata: ContractMetadata): Promise<ExtractedData> {
    const prompt = `
      Analyze this wedding vendor contract and extract key information:
      
      Vendor Type: ${metadata.vendorType}
      Wedding Date: ${metadata.weddingDate}
      
      Contract Text:
      ${pdfText}
      
      Please extract and return JSON with:
      1. totalAmount (number): Total contract value
      2. contractDate (ISO date): When contract was signed
      3. keyTerms (array): Important contract terms and conditions
      4. importantDates (array): All dates mentioned with descriptions
      5. paymentSchedule (array): Payment amounts and due dates
      6. cancellationPolicy (string): Cancellation terms
      7. confidence (number 0-1): How confident you are in the extraction
      
      Focus on wedding-specific terms like deposits, final payments, 
      deliverables deadlines, and vendor-specific requirements.
    `;
    
    const response = await openAI.chat.completions.create({
      model: 'gpt-4',
      messages: [{ role: 'user', content: prompt }],
      temperature: 0.1, // Low temperature for consistent extraction
    });
    
    try {
      const extracted = JSON.parse(response.choices[0].message.content);
      return extracted;
    } catch (error) {
      console.error('Failed to parse AI response:', error);
      return {
        keyTerms: [],
        importantDates: [],
        confidence: 0
      };
    }
  }
  
  private async generateMilestones(extractedData: ExtractedData, metadata: ContractMetadata): Promise<SuggestedMilestone[]> {
    const milestones: SuggestedMilestone[] = [];
    const weddingDate = new Date(metadata.weddingDate);
    
    // Generate payment milestones from extracted payment schedule
    if (extractedData.paymentSchedule) {
      extractedData.paymentSchedule.forEach((payment, index) => {
        milestones.push({
          type: 'payment',
          name: `Payment ${index + 1} - ${payment.description || 'Scheduled Payment'}`,
          dueDate: payment.dueDate,
          amount: payment.amount,
          description: `Payment of $${payment.amount} due as per contract terms`
        });
      });
    }
    
    // Generate vendor-specific milestones based on industry standards
    const vendorMilestones = this.getVendorSpecificMilestones(metadata.vendorType, weddingDate);
    milestones.push(...vendorMilestones);
    
    // Generate milestones from extracted dates
    extractedData.importantDates?.forEach(dateItem => {
      if (dateItem.description.toLowerCase().includes('due') || 
          dateItem.description.toLowerCase().includes('deadline') ||
          dateItem.description.toLowerCase().includes('final')) {
        
        milestones.push({
          type: 'deadline',
          name: dateItem.description,
          dueDate: dateItem.date,
          description: `Important deadline extracted from contract`
        });
      }
    });
    
    // Sort by due date and remove duplicates
    return milestones
      .sort((a, b) => new Date(a.dueDate).getTime() - new Date(b.dueDate).getTime())
      .filter((milestone, index, self) => 
        index === self.findIndex(m => m.name === milestone.name && m.dueDate === milestone.dueDate)
      );
  }
  
  private getVendorSpecificMilestones(vendorType: string, weddingDate: Date): SuggestedMilestone[] {
    const milestones: SuggestedMilestone[] = [];
    const daysBefore = (days: number) => new Date(weddingDate.getTime() - (days * 24 * 60 * 60 * 1000));
    
    switch (vendorType.toLowerCase()) {
      case 'photographer':
        milestones.push(
          {
            type: 'deliverable',
            name: 'Provide Shot List',
            dueDate: daysBefore(30).toISOString().split('T')[0],
            deliverableType: 'shot_list',
            description: 'Submit detailed shot list and photography timeline'
          },
          {
            type: 'meeting',
            name: 'Final Photography Meeting',
            dueDate: daysBefore(14).toISOString().split('T')[0],
            description: 'Review timeline, locations, and special requests'
          }
        );
        break;
        
      case 'caterer':
        milestones.push(
          {
            type: 'deliverable',
            name: 'Final Guest Count',
            dueDate: daysBefore(14).toISOString().split('T')[0],
            deliverableType: 'guest_count',
            description: 'Provide final headcount for catering'
          },
          {
            type: 'deliverable',
            name: 'Dietary Restrictions List',
            dueDate: daysBefore(21).toISOString().split('T')[0],
            deliverableType: 'dietary_requirements',
            description: 'Submit complete list of guest dietary needs'
          }
        );
        break;
        
      case 'venue':
        milestones.push(
          {
            type: 'deliverable',
            name: 'Final Floor Plan',
            dueDate: daysBefore(21).toISOString().split('T')[0],
            deliverableType: 'floor_plan',
            description: 'Approve final venue layout and seating arrangement'
          },
          {
            type: 'deadline',
            name: 'Setup Access Confirmation',
            dueDate: daysBefore(7).toISOString().split('T')[0],
            description: 'Confirm vendor setup times and access details'
          }
        );
        break;
    }
    
    return milestones;
  }
}

// Usage in API endpoint
export async function POST(request: Request) {
  const formData = await request.formData();
  const file = formData.get('file') as File;
  const contractData = JSON.parse(formData.get('contractData') as string);
  
  // Upload file to storage
  const fileUrl = await uploadContractFile(file);
  
  // Parse contract
  const parser = new ContractParser();
  const parsedData = await parser.parseContractPDF(fileUrl, contractData);
  
  // Save to database
  const { data: contract, error } = await supabase
    .from('contracts')
    .insert({
      couple_id: contractData.coupleId,
      vendor_id: contractData.vendorId,
      contract_name: file.name,
      vendor_business_name: contractData.vendorBusinessName,
      vendor_type: contractData.vendorType,
      total_amount: parsedData.totalAmount,
      contract_date: parsedData.contractDate,
      wedding_date: contractData.weddingDate,
      original_file_url: fileUrl,
      parsed_content: parsedData.parsedContent,
      key_terms: parsedData.keyTerms,
      auto_extracted_dates: parsedData.extractedDates
    })
    .select()
    .single();
  
  if (error) {
    return Response.json({ error: error.message }, { status: 500 });
  }
  
  // Create suggested milestones
  if (parsedData.suggestedMilestones.length > 0) {
    const milestoneInserts = parsedData.suggestedMilestones.map(milestone => ({
      contract_id: contract.id,
      milestone_type: milestone.type,
      milestone_name: milestone.name,
      description: milestone.description,
      due_date: milestone.dueDate,
      amount_due: milestone.amount,
      deliverable_type: milestone.deliverableType
    }));
    
    await supabase
      .from('contract_milestones')
      .insert(milestoneInserts);
  }
  
  return Response.json({
    contractId: contract.id,
    parsedData,
    requiresReview: parsedData.confidence < 0.8
  });
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [ ] Context7: Load docs for PDF processing, AI extraction
- [ ] Playwright: Test contract upload and milestone tracking
- [ ] Filesystem: Access contract templates and parsers

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/mozilla/pdf.js", "text extraction parsing", 2500);
await mcp__context7__get-library-docs("/openai/openai", "structured data extraction", 3000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('Contract Parser', () => {
  it('should extract payment schedule from contract', async () => {
    const parser = new ContractParser();
    const result = await parser.parseContractPDF(mockPdfUrl, mockMetadata);
    
    expect(result.suggestedMilestones).toContain(
      expect.objectContaining({
        type: 'payment',
        amount: 2000 // 50% deposit
      })
    );
  });
  
  it('should generate vendor-specific milestones', async () => {
    const milestones = await contractService.generateMilestones('photographer', '2025-06-15');
    expect(milestones).toContain(
      expect.objectContaining({
        name: 'Provide Shot List'
      })
    );
  });
});
```

#### E2E Tests Required
```typescript
test('Contract upload and milestone creation', async () => {
  await mcp__playwright__browser_navigate({url: '/contracts/upload'});
  
  // Upload contract PDF
  await mcp__playwright__browser_file_upload({
    paths: ['/path/to/test-photographer-contract.pdf']
  });
  
  // Fill contract details
  await mcp__playwright__browser_type({
    element: "Vendor business name input",
    ref: "input[name='vendorBusinessName']",
    text: "Smith Photography Studio"
  });
  
  await mcp__playwright__browser_select_option({
    element: "Vendor type dropdown",
    ref: "select[name='vendorType']",
    values: ["photographer"]
  });
  
  // Submit and wait for parsing
  await mcp__playwright__browser_click({
    element: "Upload contract button",
    ref: "button[type='submit']"
  });
  
  await mcp__playwright__browser_wait_for({text: "Contract parsed successfully"});
  
  // Verify milestones were created
  await mcp__playwright__browser_wait_for({text: "Provide Shot List"});
  await mcp__playwright__browser_wait_for({text: "Payment 1"});
});
```

### ACCEPTANCE CRITERIA
- [ ] Upload and parse PDF contracts automatically
- [ ] Extract key terms, amounts, and dates using AI
- [ ] Generate vendor-specific milestone suggestions
- [ ] Track payment schedules with automated reminders
- [ ] Store contract revisions and amendments
- [ ] Search contracts by vendor, date, or amount
- [ ] Export contract summaries and reports
- [ ] Integration with calendar for milestone tracking
- [ ] Mobile notifications for upcoming deadlines

### DEPENDENCIES
- Must complete after: WS-081 (Vendor directory for vendor linking)
- Must complete before: Payment processing features
- Shares code with: Document storage, AI services, notifications

### ESTIMATED EFFORT
- Team C Integration: 32 hours (PDF processing, AI extraction, UI)
- Team B Backend: 28 hours (Contract storage, milestone tracking, parsing)
- Total: 60 hours