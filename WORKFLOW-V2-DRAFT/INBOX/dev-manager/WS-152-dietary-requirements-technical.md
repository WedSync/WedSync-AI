# TECHNICAL SPECIFICATION: WS-152 - Dietary Requirements Management
## Generated by Feature Development Session - August 23, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding couple coordinating with their caterer
**I want to:** Track guest dietary requirements and allergen information with severity levels
**So that:** My caterer can prepare appropriate meals and avoid life-threatening allergic reactions

**Real Wedding Scenario:**
A couple currently collects dietary needs via email ("Sarah is vegetarian, Mike has a nut allergy"). The caterer receives unclear information leading to confusion about severity. With this feature, they record "Mike Smith - Peanut allergy (life-threatening) - EpiPen required" which generates a clear matrix for the caterer showing "2 life-threatening nut allergies, 5 vegetarian preferences, 1 gluten intolerance" with guest names for each category.

### SPECIFICATION SOURCE
- **Feature ID:** WS-152
- **Original Spec:** /CORE-SPECIFICATIONS/03-WEDME-COUPLE-PLATFORM/04-Guest-Management/03-dietary-requirements md.md
- **Current Implementation:** 0% complete (new)
- **Files to Modify:** Extend WS-151 guest management system
- **New Files to Create:** 
  - `/src/components/guests/DietaryRequirementsForm.tsx`
  - `/src/components/guests/DietaryMatrix.tsx` 
  - `/src/components/guests/AllergenWarnings.tsx`
  - `/src/lib/services/dietaryService.ts`
  - `/src/types/dietary.ts`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Extend guest management with dietary tracking
CREATE TABLE IF NOT EXISTS dietary_requirements (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  guest_id UUID REFERENCES guests(id) ON DELETE CASCADE,
  couple_id UUID REFERENCES couples(id),
  requirement_type VARCHAR(50) NOT NULL,
  severity VARCHAR(30) CHECK (severity IN ('preference', 'intolerance', 'allergy', 'life_threatening')),
  notes TEXT,
  verified_at TIMESTAMPTZ,
  cross_contamination_risk BOOLEAN DEFAULT false,
  epipen_required BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (guest_id, requirement_type)
);

-- Dietary requirement types lookup
CREATE TABLE IF NOT EXISTS dietary_types (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(50) UNIQUE NOT NULL,
  category VARCHAR(30) CHECK (category IN ('allergy', 'dietary_choice', 'medical')),
  common_names TEXT[], -- Alternative names for the same requirement
  description TEXT,
  default_severity VARCHAR(30)
);

-- Insert common dietary requirements
INSERT INTO dietary_types (name, category, common_names, description, default_severity) VALUES
-- Allergies
('nuts', 'allergy', ARRAY['tree nuts', 'almonds', 'walnuts'], 'Tree nut allergies', 'allergy'),
('peanuts', 'allergy', ARRAY['groundnuts'], 'Peanut allergies', 'allergy'),
('shellfish', 'allergy', ARRAY['crustaceans', 'mollusks'], 'Shellfish and crustacean allergies', 'allergy'),
('fish', 'allergy', ARRAY[], 'Fish allergies', 'allergy'),
('eggs', 'allergy', ARRAY['egg'], 'Egg allergies', 'allergy'),
('dairy', 'allergy', ARRAY['milk', 'lactose'], 'Dairy and milk allergies', 'allergy'),
('gluten', 'allergy', ARRAY['wheat', 'celiac'], 'Gluten allergies and celiac disease', 'allergy'),
-- Dietary Choices
('vegetarian', 'dietary_choice', ARRAY['veggie'], 'Vegetarian diet', 'preference'),
('vegan', 'dietary_choice', ARRAY[], 'Vegan diet', 'preference'),
('pescatarian', 'dietary_choice', ARRAY[], 'Fish-eating vegetarian', 'preference'),
('halal', 'dietary_choice', ARRAY[], 'Halal dietary requirements', 'preference'),
('kosher', 'dietary_choice', ARRAY[], 'Kosher dietary requirements', 'preference'),
-- Medical
('diabetic', 'medical', ARRAY['diabetes'], 'Diabetic dietary needs', 'intolerance'),
('low_sodium', 'medical', ARRAY['low salt'], 'Low sodium requirements', 'intolerance'),
('fodmap', 'medical', ARRAY['low fodmap'], 'Low FODMAP diet', 'intolerance')
ON CONFLICT (name) DO NOTHING;

-- Indexes for performance
CREATE INDEX idx_dietary_requirements_guest_id ON dietary_requirements(guest_id);
CREATE INDEX idx_dietary_requirements_couple_id ON dietary_requirements(couple_id);
CREATE INDEX idx_dietary_requirements_severity ON dietary_requirements(severity);
```

#### API Endpoints Required
```typescript
// POST /api/guests/:guest_id/dietary
interface AddDietaryRequirementRequest {
  requirement_type: string;
  severity: 'preference' | 'intolerance' | 'allergy' | 'life_threatening';
  notes?: string;
  cross_contamination_risk?: boolean;
  epipen_required?: boolean;
}

// GET /api/dietary/matrix/:couple_id
interface DietaryMatrixResponse {
  success: boolean;
  data: {
    summary: {
      total_guests: number;
      guests_with_requirements: number;
      life_threatening_allergies: number;
      dietary_preferences: number;
    };
    requirements: Array<{
      requirement: string;
      category: string;
      count: number;
      severity_breakdown: {
        life_threatening: number;
        allergy: number;
        intolerance: number;
        preference: number;
      };
      guest_details: Array<{
        guest_name: string;
        severity: string;
        notes?: string;
        table_number?: number;
        epipen_required: boolean;
      }>;
    }>;
    critical_alerts: Array<{
      type: 'life_threatening' | 'cross_contamination' | 'kitchen_alert';
      message: string;
      affected_guests: string[];
    }>;
  };
}

// GET /api/dietary/export/:couple_id
interface CatererExportResponse {
  success: boolean;
  data: {
    kitchen_cards: Array<{
      requirement: string;
      severity: string;
      guest_count: number;
      special_instructions: string[];
      cross_contamination_warnings: string[];
    }>;
    allergen_summary: string;
    emergency_contacts?: Array<{
      guest_name: string;
      contact_info: string;
      allergen: string;
    }>;
  };
}
```

#### Frontend Components Required
```typescript
// Component: DietaryRequirementsForm
// Location: /src/components/guests/DietaryRequirementsForm.tsx

interface DietaryRequirementsFormProps {
  guestId: string;
  existingRequirements: DietaryRequirement[];
  onUpdate: (requirements: DietaryRequirement[]) => void;
}

// Key functionality:
- Checkbox groups for common allergies and dietary preferences
- Severity level selection with visual indicators
- Free text area for additional notes
- Cross-contamination risk checkbox
- EpiPen requirement flag
- Auto-save as user makes selections
- Visual warnings for life-threatening allergies

// Component: DietaryMatrix
// Location: /src/components/guests/DietaryMatrix.tsx

// Key functionality:
- Tabular view of all dietary requirements by type and severity
- Export functionality for caterers
- Filter by severity level or requirement type
- Search functionality for specific guests
- Print-optimized layout
- Color coding for severity levels

// Component: AllergenWarnings
// Location: /src/components/guests/AllergenWarnings.tsx

// Key functionality:
- Prominent display of life-threatening allergies
- Kitchen alert cards generation
- Emergency contact information
- Cross-contamination risk indicators
- Integration with seating arrangements
```

#### Integration Points
```typescript
// Service: DietaryService
// Dependencies: Guest service, notification service

class DietaryService {
  async generateDietaryMatrix(coupleId: string): Promise<DietaryMatrix> {
    const { data: requirements } = await supabase
      .from('dietary_requirements')
      .select(`
        *,
        guests!inner(first_name, last_name, table_number),
        dietary_types!inner(name, category)
      `)
      .eq('couple_id', coupleId);

    // Group by requirement type
    const grouped = requirements.reduce((acc, req) => {
      const key = req.requirement_type;
      if (!acc[key]) {
        acc[key] = {
          requirement: key,
          category: req.dietary_types.category,
          count: 0,
          severity_breakdown: {
            life_threatening: 0,
            allergy: 0,
            intolerance: 0,
            preference: 0
          },
          guest_details: []
        };
      }

      acc[key].count++;
      acc[key].severity_breakdown[req.severity]++;
      acc[key].guest_details.push({
        guest_name: `${req.guests.first_name} ${req.guests.last_name}`,
        severity: req.severity,
        notes: req.notes,
        table_number: req.guests.table_number,
        epipen_required: req.epipen_required
      });

      return acc;
    }, {});

    return {
      summary: this.calculateSummary(requirements),
      requirements: Object.values(grouped),
      critical_alerts: this.generateCriticalAlerts(requirements)
    };
  }

  async generateKitchenCards(coupleId: string): Promise<KitchenCard[]> {
    const matrix = await this.generateDietaryMatrix(coupleId);
    
    return matrix.requirements
      .filter(req => req.severity_breakdown.life_threatening > 0 || req.severity_breakdown.allergy > 0)
      .map(req => ({
        requirement: req.requirement,
        severity: req.severity_breakdown.life_threatening > 0 ? 'CRITICAL' : 'CAUTION',
        guest_count: req.count,
        special_instructions: this.generateInstructions(req),
        cross_contamination_warnings: this.getCrossContaminationWarnings(req)
      }));
  }

  private generateCriticalAlerts(requirements: DietaryRequirement[]): CriticalAlert[] {
    const alerts: CriticalAlert[] = [];
    
    // Life-threatening allergy alerts
    const lifeThreatening = requirements.filter(r => r.severity === 'life_threatening');
    if (lifeThreatening.length > 0) {
      alerts.push({
        type: 'life_threatening',
        message: `${lifeThreatening.length} guests have life-threatening allergies requiring special kitchen protocols`,
        affected_guests: lifeThreatening.map(r => r.guests.first_name + ' ' + r.guests.last_name)
      });
    }

    // Cross-contamination risks
    const crossContamination = requirements.filter(r => r.cross_contamination_risk);
    if (crossContamination.length > 0) {
      alerts.push({
        type: 'cross_contamination',
        message: `${crossContamination.length} guests require separate preparation areas`,
        affected_guests: crossContamination.map(r => r.guests.first_name + ' ' + r.guests.last_name)
      });
    }

    return alerts;
  }
}
```

### CODE EXAMPLES

#### Example 1: Dietary Requirements Form Component
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
'use client';

import { useState, useEffect } from 'react';
import { supabase } from '@/lib/supabase';
import { DietaryRequirement, DietaryType } from '@/types/dietary';
import { Checkbox } from '@/components/ui/checkbox';
import { Textarea } from '@/components/ui/textarea';
import { Select } from '@/components/ui/select';
import { Alert } from '@/components/ui/alert';

const SEVERITY_COLORS = {
  preference: 'bg-green-100 text-green-800',
  intolerance: 'bg-yellow-100 text-yellow-800',
  allergy: 'bg-orange-100 text-orange-800',
  life_threatening: 'bg-red-100 text-red-800'
};

export function DietaryRequirementsForm({ 
  guestId, 
  existingRequirements, 
  onUpdate 
}: {
  guestId: string;
  existingRequirements: DietaryRequirement[];
  onUpdate: (requirements: DietaryRequirement[]) => void;
}) {
  const [dietaryTypes, setDietaryTypes] = useState<DietaryType[]>([]);
  const [requirements, setRequirements] = useState<DietaryRequirement[]>(existingRequirements);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchDietaryTypes();
  }, []);

  const fetchDietaryTypes = async () => {
    const { data, error } = await supabase
      .from('dietary_types')
      .select('*')
      .order('category, name');
    
    if (error) throw error;
    setDietaryTypes(data || []);
    setLoading(false);
  };

  const updateRequirement = async (requirementType: string, updates: Partial<DietaryRequirement>) => {
    const existingIndex = requirements.findIndex(r => r.requirement_type === requirementType);
    let updatedRequirements;

    if (existingIndex >= 0) {
      // Update existing requirement
      updatedRequirements = requirements.map((req, index) => 
        index === existingIndex ? { ...req, ...updates } : req
      );
    } else {
      // Add new requirement
      const newRequirement: DietaryRequirement = {
        id: crypto.randomUUID(),
        guest_id: guestId,
        couple_id: '', // Will be set by backend
        requirement_type: requirementType,
        severity: updates.severity || 'preference',
        notes: updates.notes || '',
        cross_contamination_risk: updates.cross_contamination_risk || false,
        epipen_required: updates.epipen_required || false,
        verified_at: null,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };
      updatedRequirements = [...requirements, newRequirement];
    }

    setRequirements(updatedRequirements);

    // Save to database
    const { error } = await supabase
      .from('dietary_requirements')
      .upsert({
        guest_id: guestId,
        requirement_type: requirementType,
        ...updates
      });

    if (!error) {
      onUpdate(updatedRequirements);
    }
  };

  const removeRequirement = async (requirementType: string) => {
    const updatedRequirements = requirements.filter(r => r.requirement_type !== requirementType);
    setRequirements(updatedRequirements);

    const { error } = await supabase
      .from('dietary_requirements')
      .delete()
      .eq('guest_id', guestId)
      .eq('requirement_type', requirementType);

    if (!error) {
      onUpdate(updatedRequirements);
    }
  };

  const isRequirementSelected = (requirementType: string) => {
    return requirements.some(r => r.requirement_type === requirementType);
  };

  const getRequirement = (requirementType: string) => {
    return requirements.find(r => r.requirement_type === requirementType);
  };

  const groupedTypes = dietaryTypes.reduce((acc, type) => {
    if (!acc[type.category]) acc[type.category] = [];
    acc[type.category].push(type);
    return acc;
  }, {} as Record<string, DietaryType[]>);

  const lifeThreatening = requirements.filter(r => r.severity === 'life_threatening');

  if (loading) return <div>Loading dietary options...</div>;

  return (
    <div className="dietary-requirements-form space-y-6">
      {/* Life-threatening alert */}
      {lifeThreatening.length > 0 && (
        <Alert variant="destructive">
          <span className="font-semibold">‚ö†Ô∏è Life-threatening allergies detected:</span>
          <ul className="mt-2 list-disc list-inside">
            {lifeThreatening.map(req => (
              <li key={req.requirement_type}>
                {req.requirement_type} - {req.epipen_required ? 'EpiPen required' : 'Emergency protocol needed'}
              </li>
            ))}
          </ul>
          <p className="mt-2 text-sm">This information will be prominently shared with your caterer.</p>
        </Alert>
      )}

      {/* Allergies Section */}
      <div className="allergies-section">
        <h3 className="text-lg font-semibold mb-4 text-red-700">
          üö® Allergies (Important for Kitchen Safety)
        </h3>
        <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
          {groupedTypes.allergy?.map(type => {
            const selected = isRequirementSelected(type.name);
            const requirement = getRequirement(type.name);
            
            return (
              <div key={type.name} className="allergy-item">
                <div className="flex items-center space-x-2 mb-2">
                  <Checkbox
                    checked={selected}
                    onCheckedChange={(checked) => {
                      if (checked) {
                        updateRequirement(type.name, { 
                          severity: type.default_severity as any 
                        });
                      } else {
                        removeRequirement(type.name);
                      }
                    }}
                  />
                  <label className="font-medium capitalize">
                    {type.name}
                  </label>
                </div>
                
                {selected && (
                  <div className="ml-6 space-y-2">
                    <Select
                      value={requirement?.severity || 'allergy'}
                      onValueChange={(severity) => 
                        updateRequirement(type.name, { severity: severity as any })
                      }
                    >
                      <option value="allergy">Allergy</option>
                      <option value="life_threatening">Life-threatening</option>
                    </Select>
                    
                    {requirement?.severity === 'life_threatening' && (
                      <div className="space-y-1">
                        <div className="flex items-center space-x-2">
                          <Checkbox
                            checked={requirement.epipen_required}
                            onCheckedChange={(checked) => 
                              updateRequirement(type.name, { epipen_required: checked as boolean })
                            }
                          />
                          <label className="text-sm">EpiPen required</label>
                        </div>
                        
                        <div className="flex items-center space-x-2">
                          <Checkbox
                            checked={requirement.cross_contamination_risk}
                            onCheckedChange={(checked) => 
                              updateRequirement(type.name, { cross_contamination_risk: checked as boolean })
                            }
                          />
                          <label className="text-sm">Cross-contamination risk</label>
                        </div>
                      </div>
                    )}
                    
                    <Textarea
                      placeholder="Additional notes (e.g., specific brands to avoid)..."
                      value={requirement?.notes || ''}
                      onChange={(e) => 
                        updateRequirement(type.name, { notes: e.target.value })
                      }
                      className="text-sm"
                      rows={2}
                    />
                  </div>
                )}
              </div>
            );
          })}
        </div>
      </div>

      {/* Dietary Choices Section */}
      <div className="dietary-choices-section">
        <h3 className="text-lg font-semibold mb-4 text-green-700">
          ü•ó Dietary Preferences
        </h3>
        <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
          {groupedTypes.dietary_choice?.map(type => {
            const selected = isRequirementSelected(type.name);
            const requirement = getRequirement(type.name);
            
            return (
              <div key={type.name} className="dietary-item">
                <div className="flex items-center space-x-2 mb-2">
                  <Checkbox
                    checked={selected}
                    onCheckedChange={(checked) => {
                      if (checked) {
                        updateRequirement(type.name, { severity: 'preference' });
                      } else {
                        removeRequirement(type.name);
                      }
                    }}
                  />
                  <label className="font-medium capitalize">
                    {type.name}
                  </label>
                </div>
                
                {selected && (
                  <div className="ml-6">
                    <Textarea
                      placeholder="Special notes (e.g., includes fish, excludes honey)..."
                      value={requirement?.notes || ''}
                      onChange={(e) => 
                        updateRequirement(type.name, { notes: e.target.value })
                      }
                      className="text-sm"
                      rows={2}
                    />
                  </div>
                )}
              </div>
            );
          })}
        </div>
      </div>

      {/* Medical Requirements Section */}
      <div className="medical-section">
        <h3 className="text-lg font-semibold mb-4 text-blue-700">
          üè• Medical Dietary Needs
        </h3>
        <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
          {groupedTypes.medical?.map(type => {
            const selected = isRequirementSelected(type.name);
            const requirement = getRequirement(type.name);
            
            return (
              <div key={type.name} className="medical-item">
                <div className="flex items-center space-x-2 mb-2">
                  <Checkbox
                    checked={selected}
                    onCheckedChange={(checked) => {
                      if (checked) {
                        updateRequirement(type.name, { severity: 'intolerance' });
                      } else {
                        removeRequirement(type.name);
                      }
                    }}
                  />
                  <label className="font-medium capitalize">
                    {type.name}
                  </label>
                </div>
                
                {selected && (
                  <div className="ml-6">
                    <Textarea
                      placeholder="Medical details and restrictions..."
                      value={requirement?.notes || ''}
                      onChange={(e) => 
                        updateRequirement(type.name, { notes: e.target.value })
                      }
                      className="text-sm"
                      rows={2}
                    />
                  </div>
                )}
              </div>
            );
          })}
        </div>
      </div>

      {/* Summary */}
      {requirements.length > 0 && (
        <div className="requirements-summary bg-gray-50 p-4 rounded-lg">
          <h4 className="font-semibold mb-2">Summary for this guest:</h4>
          <div className="space-y-1">
            {requirements.map(req => (
              <div 
                key={req.requirement_type} 
                className={`inline-block px-2 py-1 rounded-full text-xs mr-2 mb-1 ${SEVERITY_COLORS[req.severity]}`}
              >
                {req.requirement_type} ({req.severity})
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for React Hook Form
- [x] Playwright: Test dietary requirements workflows
- [x] Filesystem: Access dietary components

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/react-hook-form/react-hook-form", "checkbox validation", 1500);
await mcp__context7__get-library-docs("/supabase/supabase-js", "upsert operations", 1500);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('DietaryService', () => {
  it('should generate dietary matrix correctly', async () => {
    const matrix = await service.generateDietaryMatrix('couple-id');
    expect(matrix.requirements).toBeDefined();
    expect(matrix.critical_alerts).toBeDefined();
  });

  it('should identify life-threatening allergies', async () => {
    const alerts = service.generateCriticalAlerts(mockRequirements);
    expect(alerts.filter(a => a.type === 'life_threatening')).toHaveLength(1);
  });
});
```

#### E2E Tests Required
```typescript
test('Dietary requirements management', async () => {
  await mcp__playwright__browser_navigate({url: '/guests'});
  
  // Select guest and open dietary form
  await mcp__playwright__browser_click({
    element: 'John Smith guest card',
    ref: '[data-testid="guest-john-smith"]'
  });
  
  // Test allergy selection
  await mcp__playwright__browser_click({
    element: 'Peanuts allergy checkbox',
    ref: 'input[name="allergy-peanuts"]'
  });
  
  // Test severity selection
  await mcp__playwright__browser_select_option({
    element: 'Severity selector',
    ref: 'select[name="severity"]',
    values: ['life_threatening']
  });
  
  // Verify warning appears
  await mcp__playwright__browser_wait_for({
    text: 'Life-threatening allergies detected'
  });
  
  await mcp__playwright__browser_snapshot();
});
```

### ACCEPTANCE CRITERIA
- [x] Track dietary requirements with four severity levels (preference/intolerance/allergy/life-threatening)
- [x] Visual warnings for life-threatening allergies with EpiPen requirements
- [x] Generate caterer-friendly dietary matrix with guest counts by requirement type
- [x] Cross-contamination risk flagging for kitchen protocols
- [x] Export functionality for kitchen preparation cards
- [x] Integration with guest list management system
- [x] Auto-save functionality as users make selections
- [x] Performance: Form loads in <1s, matrix generation <2s
- [x] Security: All dietary data scoped to couple_id with RLS policies
- [x] Accessibility: Screen reader support for severity indicators

### DEPENDENCIES
- Must complete after: WS-151 (Guest List Builder)
- Must complete before: None
- Shares code with: Guest management and catering coordination features

### ESTIMATED EFFORT
- Team A Frontend: 18 hours
- Team B Backend: 14 hours
- Team C Integration: 8 hours
- Total: 40 hours