# TECHNICAL SPECIFICATION: WS-103 - Error Tracking System
## Generated by Feature Development Session - August 22, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** WedSync developer supporting a photography business during wedding season
**I want to:** Immediately know when their client upload form crashes with detailed error context
**So that:** I can fix the issue before other couples lose their uploaded photos and vendor information

**Real Wedding Scenario:**
A couple uploads 50 photos for their rehearsal dinner recap at 11 PM Friday. The image processing service fails due to a memory leak, but they don't realize it until Saturday morning - their wedding day. With error tracking, developers receive an immediate alert with the exact error, user context (couple's wedding is today), and stack trace. The issue is fixed in 20 minutes instead of being discovered Monday morning when multiple weekend weddings have failed uploads.

### SPECIFICATION SOURCE
- **Feature ID:** WS-103
- **Original Spec:** /CORE-SPECIFICATIONS/11-TESTING-DEPLOYMENT/03-Monitoring/01-error-tracking md.md
- **Current Implementation:** 0% complete
- **Files to Modify:**
  - `/wedsync/lib/monitoring/sentry.ts` (create new)
  - `/wedsync/lib/api/error-handler.ts` (create new)
- **New Files to Create:**
  - `/wedsync/src/components/ErrorBoundary.tsx`
  - `/wedsync/src/hooks/useErrorHandler.ts`
  - `/wedsync/lib/forms/error-tracking.ts`
  - `/wedsync/lib/jobs/error-monitoring.ts`
  - `/wedsync/lib/monitoring/performance.ts`
  - `/wedsync/app/admin/errors/page.tsx`
  - `/wedsync/.sentryrc`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Local error tracking for critical wedding-specific errors
CREATE TABLE IF NOT EXISTS error_incidents (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  sentry_event_id VARCHAR(255) UNIQUE,
  error_type VARCHAR(100) NOT NULL,
  message TEXT NOT NULL,
  stack_trace TEXT,
  user_id UUID REFERENCES auth.users(id),
  wedding_context JSONB DEFAULT '{}', -- Wedding date, vendor type, urgency level
  request_context JSONB DEFAULT '{}',
  resolution_status VARCHAR(20) DEFAULT 'open' CHECK (resolution_status IN ('open', 'investigating', 'resolved', 'ignored')),
  business_impact VARCHAR(20) CHECK (business_impact IN ('low', 'medium', 'high', 'critical')),
  resolved_at TIMESTAMP WITH TIME ZONE NULL,
  resolved_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_error_incidents_status ON error_incidents(resolution_status, created_at DESC);
CREATE INDEX idx_error_incidents_user ON error_incidents(user_id, created_at DESC);
CREATE INDEX idx_error_incidents_wedding_context ON error_incidents USING GIN (wedding_context);

-- Error rate tracking for performance monitoring
CREATE TABLE IF NOT EXISTS error_metrics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  metric_type VARCHAR(50) NOT NULL, -- 'error_rate', 'response_time', 'user_impact'
  time_window TIMESTAMP WITH TIME ZONE NOT NULL,
  value DECIMAL(10,4) NOT NULL,
  context JSONB DEFAULT '{}',
  recorded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_error_metrics_type_time ON error_metrics(metric_type, time_window DESC);

-- User feedback on errors
CREATE TABLE IF NOT EXISTS error_feedback (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  sentry_event_id VARCHAR(255) NOT NULL,
  user_id UUID REFERENCES auth.users(id),
  feedback_text TEXT,
  user_context JSONB DEFAULT '{}', -- What they were trying to do
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

#### API Endpoints Required
```typescript
// POST /api/errors/report
interface ErrorReportRequest {
  message: string;
  stack?: string;
  userAction?: string;
  weddingContext?: {
    weddingDate?: string;
    urgency?: 'low' | 'medium' | 'high' | 'critical';
    vendorType?: string;
  };
  userAgent?: string;
  url?: string;
}

interface ErrorReportResponse {
  success: boolean;
  errorId: string;
  sentryEventId?: string;
  supportContact?: string;
}

// GET /api/errors/dashboard
interface ErrorDashboardResponse {
  metrics: {
    totalErrors24h: number;
    errorRate: number;
    affectedUsers: number;
    criticalErrors: number;
  };
  topErrors: Array<{
    id: string;
    message: string;
    count: number;
    lastSeen: string;
    businessImpact: string;
  }>;
  weddingImpactErrors: Array<{
    id: string;
    message: string;
    affectedWeddings: number;
    urgency: string;
  }>;
}

// POST /api/errors/:id/feedback
interface ErrorFeedbackRequest {
  feedback: string;
  userContext: Record<string, any>;
}

// PATCH /api/errors/:id/resolve
interface ResolveErrorRequest {
  resolution: string;
  preventRecurrence?: boolean;
}
```

#### Frontend Components Required
```typescript
// Component: ErrorBoundary
// Location: /src/components/ErrorBoundary.tsx

interface Props {
  children: React.ReactNode;
  fallback?: React.ReactNode;
  context?: string;
  onError?: (error: Error, errorInfo: any) => void;
}

// Key functionality:
- Catches React component errors
- Provides user-friendly error display
- Integrates with Sentry for error reporting
- Offers reload and feedback options
- Shows error ID for support reference

// Component: ErrorFeedbackDialog
// Location: /src/components/admin/ErrorFeedbackDialog.tsx

interface Props {
  isOpen: boolean;
  onClose: () => void;
  errorId: string;
  errorMessage: string;
}

// Key functionality:
- Collects user feedback on errors
- Provides context about user's intended action
- Submits feedback to error tracking system
- Thanks user for helping improve the product

// Component: ErrorDashboard
// Location: /src/app/admin/errors/page.tsx

interface Props {
  timeRange?: '1h' | '24h' | '7d' | '30d';
}

// Key functionality:
- Displays error metrics and trends
- Shows wedding-specific error impact
- Provides error triage and resolution tools
- Integrates with Sentry dashboard
- Highlights critical errors affecting weddings
```

#### Integration Points
```typescript
// Service: ErrorTrackingService
// Dependencies: Sentry, Supabase, notification services

class ErrorTrackingService {
  async reportError(
    error: Error,
    context: ErrorContext,
    userId?: string
  ): Promise<string> {
    // 1. Sanitize sensitive data
    // 2. Add wedding business context
    // 3. Send to Sentry with enhanced context
    // 4. Store local copy for critical wedding errors
    // 5. Trigger immediate alerts for critical issues
    
    return sentryEventId;
  }
  
  async assessWeddingImpact(error: Error, userId?: string): Promise<WeddingImpact> {
    // Determine if error affects active weddings
    // Calculate urgency based on wedding dates
    // Identify vendor type and coordination impact
    // Return enhanced context for prioritization
  }
}

// Service: PerformanceMonitor
// Dependencies: Sentry performance monitoring

class PerformanceMonitor {
  async trackApiPerformance(
    endpoint: string,
    duration: number,
    status: number
  ): Promise<void> {
    // Track API response times
    // Alert on slow responses
    // Monitor error rates by endpoint
    // Correlate performance with user satisfaction
  }
  
  async trackUserExperience(
    action: string,
    duration: number,
    success: boolean
  ): Promise<void> {
    // Track user interaction performance
    // Monitor form submission success rates
    // Alert on user experience degradation
  }
}

// Hook: useErrorHandler
export function useErrorHandler() {
  // Global error event listeners
  // Unhandled promise rejection handling
  // Performance monitoring setup
  // User session context management
}

// Hook: useErrorReporting
export function useErrorReporting() {
  // Manual error reporting for caught exceptions
  // User feedback collection
  // Error recovery suggestions
  // Connection to support systems
}
```

### CODE EXAMPLES

#### Example 1: Sentry Configuration with Wedding Context
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import * as Sentry from '@sentry/nextjs';
import { User } from '@supabase/supabase-js';

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  environment: process.env.NODE_ENV,
  tracesSampleRate: process.env.NODE_ENV === 'production' ? 0.1 : 1.0,
  integrations: [
    new Sentry.BrowserTracing(),
    new Sentry.Replay({
      maskAllText: false,
      blockAllMedia: false,
    }),
  ],
  beforeSend(event, hint) {
    // Sanitize sensitive data
    if (event.request?.cookies) {
      delete event.request.cookies;
    }
    if (event.extra?.password || event.extra?.token) {
      delete event.extra.password;
      delete event.extra.token;
    }
    
    // Remove PII from form data
    if (event.request?.data) {
      const sanitizedData = { ...event.request.data };
      ['email', 'phone', 'address', 'payment'].forEach(field => {
        if (sanitizedData[field]) {
          sanitizedData[field] = '[REDACTED]';
        }
      });
      event.request.data = sanitizedData;
    }
    
    return event;
  },
  ignoreErrors: [
    // Ignore common browser errors
    'ResizeObserver loop limit exceeded',
    'Non-Error promise rejection captured',
    'Loading chunk failed',
    // Ignore third-party errors
    'stripe is not defined',
    'Script error.',
  ],
});

export function identifyUser(user: User) {
  Sentry.setUser({
    id: user.id,
    email: user.email,
    username: user.user_metadata?.business_name || user.user_metadata?.full_name,
    ip_address: '{{auto}}',
  });
  
  // Add business context for wedding industry
  Sentry.setContext('subscription', {
    tier: user.user_metadata?.tier || 'free',
    vendor_type: user.user_metadata?.vendor_type,
    business_name: user.user_metadata?.business_name,
  });
  
  // Add wedding-specific context
  Sentry.setContext('wedding_business', {
    active_client_count: user.user_metadata?.client_count || 0,
    busy_season: isWeddingSeason(),
    primary_service: user.user_metadata?.vendor_type,
  });
}

export function trackWeddingError(
  error: Error,
  weddingContext: {
    weddingDate?: string;
    clientId?: string;
    urgency?: 'low' | 'medium' | 'high' | 'critical';
    vendorType?: string;
  }
) {
  Sentry.withScope((scope) => {
    scope.setTag('error_category', 'wedding_coordination');
    scope.setTag('business_impact', calculateBusinessImpact(weddingContext));
    
    scope.setContext('wedding', {
      wedding_date: weddingContext.weddingDate,
      client_id: weddingContext.clientId,
      urgency: weddingContext.urgency,
      vendor_type: weddingContext.vendorType,
      days_until_wedding: weddingContext.weddingDate 
        ? Math.ceil((new Date(weddingContext.weddingDate).getTime() - Date.now()) / (1000 * 60 * 60 * 24))
        : null,
    });
    
    // Set priority based on wedding urgency
    const level = weddingContext.urgency === 'critical' ? 'error' : 'warning';
    scope.setLevel(level);
    
    Sentry.captureException(error);
  });
}

function calculateBusinessImpact(context: any): string {
  if (context.urgency === 'critical') return 'high';
  if (context.weddingDate) {
    const daysUntil = Math.ceil((new Date(context.weddingDate).getTime() - Date.now()) / (1000 * 60 * 60 * 24));
    if (daysUntil <= 1) return 'high';
    if (daysUntil <= 7) return 'medium';
  }
  return 'low';
}

function isWeddingSeason(): boolean {
  const month = new Date().getMonth() + 1; // 1-12
  return month >= 5 && month <= 10; // May through October
}
```

#### Example 2: Error Boundary with Wedding Context
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { Component, ReactNode } from 'react';
import * as Sentry from '@sentry/nextjs';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
  context?: string;
  weddingContext?: {
    clientId?: string;
    weddingDate?: string;
    vendorType?: string;
  };
}

interface State {
  hasError: boolean;
  error?: Error;
  errorId?: string;
  showFeedback: boolean;
}

export class ErrorBoundary extends Component<Props, State> {
  state: State = { hasError: false, showFeedback: false };
  
  static getDerivedStateFromError(error: Error): State {
    const errorId = Sentry.lastEventId();
    return { hasError: true, error, errorId, showFeedback: false };
  }
  
  componentDidCatch(error: Error, errorInfo: any) {
    Sentry.withScope((scope) => {
      scope.setExtras({
        componentStack: errorInfo.componentStack,
        context: this.props.context,
      });
      
      // Add wedding-specific context if available
      if (this.props.weddingContext) {
        scope.setContext('wedding', this.props.weddingContext);
        scope.setTag('has_wedding_context', true);
        
        // Determine urgency based on wedding date
        if (this.props.weddingContext.weddingDate) {
          const daysUntil = Math.ceil(
            (new Date(this.props.weddingContext.weddingDate).getTime() - Date.now()) / 
            (1000 * 60 * 60 * 24)
          );
          
          if (daysUntil <= 1) {
            scope.setLevel('error');
            scope.setTag('urgency', 'critical');
          } else if (daysUntil <= 7) {
            scope.setLevel('warning');
            scope.setTag('urgency', 'high');
          }
        }
      }
      
      scope.setLevel('error');
      scope.setContext('component', {
        props: this.props,
        state: this.state,
      });
      
      Sentry.captureException(error);
    });
  }
  
  handleReload = () => {
    window.location.reload();
  };
  
  handleShowFeedback = () => {
    this.setState({ showFeedback: true });
  };
  
  handleSendFeedback = async (feedback: string) => {
    try {
      await fetch('/api/errors/feedback', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          errorId: this.state.errorId,
          feedback,
          context: this.props.context,
          weddingContext: this.props.weddingContext,
        }),
      });
      
      this.setState({ showFeedback: false });
      alert('Thank you for your feedback! We will investigate this issue.');
    } catch (error) {
      console.error('Failed to send feedback:', error);
    }
  };
  
  getUrgencyMessage = () => {
    if (!this.props.weddingContext?.weddingDate) return null;
    
    const daysUntil = Math.ceil(
      (new Date(this.props.weddingContext.weddingDate).getTime() - Date.now()) / 
      (1000 * 60 * 60 * 24)
    );
    
    if (daysUntil <= 1) {
      return "We understand your wedding is very soon. Our team has been notified and will prioritize this issue.";
    } else if (daysUntil <= 7) {
      return "We see your wedding is coming up soon. Our team will address this issue quickly.";
    }
    
    return null;
  };
  
  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }
      
      return (
        <div className="min-h-[400px] flex items-center justify-center p-6">
          <Card className="max-w-md w-full">
            <CardHeader>
              <CardTitle className="text-center text-red-600">
                Something went wrong
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <p className="text-center text-muted-foreground">
                We've been notified and are looking into it.
              </p>
              
              {this.getUrgencyMessage() && (
                <div className="p-3 bg-blue-50 border border-blue-200 rounded">
                  <p className="text-sm text-blue-700">
                    {this.getUrgencyMessage()}
                  </p>
                </div>
              )}
              
              <p className="text-center text-xs text-muted-foreground">
                Error ID: {this.state.errorId}
              </p>
              
              {this.state.showFeedback ? (
                <div className="space-y-3">
                  <textarea
                    placeholder="What were you trying to do when this error occurred?"
                    className="w-full p-2 border rounded"
                    rows={3}
                    id="error-feedback"
                  />
                  <div className="flex space-x-2">
                    <Button
                      size="sm"
                      onClick={() => {
                        const feedback = (document.getElementById('error-feedback') as HTMLTextAreaElement).value;
                        this.handleSendFeedback(feedback);
                      }}
                    >
                      Send Feedback
                    </Button>
                    <Button
                      size="sm"
                      variant="outline"
                      onClick={() => this.setState({ showFeedback: false })}
                    >
                      Cancel
                    </Button>
                  </div>
                </div>
              ) : (
                <div className="flex space-x-2">
                  <Button onClick={this.handleReload} className="flex-1">
                    Reload Page
                  </Button>
                  <Button 
                    variant="outline" 
                    onClick={this.handleShowFeedback}
                    className="flex-1"
                  >
                    Report Issue
                  </Button>
                </div>
              )}
              
              {this.props.weddingContext?.vendorType && (
                <p className="text-xs text-center text-muted-foreground">
                  Service: {this.props.weddingContext.vendorType}
                </p>
              )}
            </CardContent>
          </Card>
        </div>
      );
    }
    
    return this.props.children;
  }
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [ ] Context7: Load docs for Sentry integration, error monitoring
- [ ] PostgreSQL: Create error tracking tables
- [ ] Filesystem: Create error boundary components

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/getsentry/sentry-javascript", "nextjs integration", 2500);
await mcp__context7__get-library-docs("/getsentry/sentry-javascript", "performance monitoring", 1500);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('Error Tracking System', () => {
  it('should capture errors with wedding context', () => {
    // Test error capture with business context
  });
  
  it('should sanitize sensitive data before sending to Sentry', () => {
    // Test data sanitization in error reports
  });
  
  it('should prioritize errors based on wedding urgency', () => {
    // Test error prioritization logic
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Error boundary displays user-friendly error message', async () => {
  await mcp__playwright__browser_navigate({url: '/test-error'});
  await mcp__playwright__browser_snapshot();
  // Verify error boundary renders correctly
});
```

### ACCEPTANCE CRITERIA
- [ ] All errors are captured and sent to Sentry with business context
- [ ] Sensitive data (passwords, tokens, PII) is sanitized before reporting
- [ ] Wedding-critical errors are prioritized and escalated appropriately
- [ ] Error boundaries provide user-friendly messages with recovery options
- [ ] Performance: Error reporting doesn't impact user experience
- [ ] Security: No sensitive information is logged in error reports
- [ ] Accessibility: Error messages are screen reader accessible

### DEPENDENCIES
- Must complete after: Authentication system, business context identification
- Must complete before: Production monitoring and alerting
- Shares code with: WS-101 (Alert System), WS-100 (System Health)

### ESTIMATED EFFORT
- Team A Frontend: 14 hours (error boundaries, user feedback, admin dashboard)
- Team B Backend: 16 hours (Sentry configuration, API error handling, wedding context integration)
- Team C Integration: 8 hours (performance monitoring, alert configuration, external service integration)
- Total: 38 hours