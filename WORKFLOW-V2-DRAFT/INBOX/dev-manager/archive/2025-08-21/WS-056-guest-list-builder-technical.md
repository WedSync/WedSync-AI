# TECHNICAL SPECIFICATION: WS-056 - Guest List Builder
## Generated by Feature Development Session - 2025-08-21

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Bride managing a 150-person wedding
**I want to:** Import my contact list and organize guests by family/friends/work
**So that:** I can track RSVPs and assign tables without losing track of who's coming

**Real Wedding Scenario:**
Sarah imports 200 contacts from her phone's CSV export. The system automatically groups "John & Jane Smith" into households, categorizes work contacts by email domains (@company.com), and lets her drag Uncle Bob from "friends" to "family." She sees real-time counts: 89 adults, 12 children, 3 infants - helping her finalize catering numbers.

### SPECIFICATION SOURCE
- **Feature ID:** WS-056
- **Original Spec:** /CORE-SPECIFICATIONS/03-WEDME-COUPLE-PLATFORM/04-Guest-Management/01-guest-list-builder md.md
- **Current Implementation:** 0% complete
- **Dependencies:** WedMe Dashboard foundation

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Guests table
CREATE TABLE IF NOT EXISTS guests (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  couple_id UUID NOT NULL REFERENCES couples(id),
  household_id UUID REFERENCES households(id),
  first_name VARCHAR(100) NOT NULL,
  last_name VARCHAR(100) NOT NULL,
  email VARCHAR(255),
  phone VARCHAR(20),
  address JSONB,
  category VARCHAR(20) NOT NULL CHECK (category IN ('family', 'friends', 'work', 'other')),
  side VARCHAR(20) NOT NULL CHECK (side IN ('partner1', 'partner2', 'mutual')),
  plus_one BOOLEAN DEFAULT FALSE,
  plus_one_name VARCHAR(100),
  age_group VARCHAR(20) DEFAULT 'adult' CHECK (age_group IN ('adult', 'child', 'infant')),
  table_number INTEGER,
  helper_role VARCHAR(50),
  dietary_restrictions TEXT,
  special_needs TEXT,
  rsvp_status VARCHAR(20) DEFAULT 'pending' CHECK (rsvp_status IN ('pending', 'attending', 'declined', 'maybe')),
  rsvp_date TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Households table
CREATE TABLE IF NOT EXISTS households (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  couple_id UUID NOT NULL REFERENCES couples(id),
  name VARCHAR(200) NOT NULL,
  primary_contact_id UUID REFERENCES guests(id),
  address JSONB NOT NULL,
  invitation_sent BOOLEAN DEFAULT FALSE,
  invitation_sent_date TIMESTAMP WITH TIME ZONE,
  total_members INTEGER DEFAULT 1,
  adults INTEGER DEFAULT 1,
  children INTEGER DEFAULT 0,
  infants INTEGER DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Guest Import Sessions table
CREATE TABLE IF NOT EXISTS guest_import_sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  couple_id UUID NOT NULL REFERENCES couples(id),
  import_type VARCHAR(20) NOT NULL, -- 'csv', 'google_contacts', 'manual'
  file_name VARCHAR(255),
  total_rows INTEGER,
  processed_rows INTEGER DEFAULT 0,
  successful_imports INTEGER DEFAULT 0,
  failed_imports INTEGER DEFAULT 0,
  status VARCHAR(20) DEFAULT 'processing' CHECK (status IN ('processing', 'completed', 'failed')),
  error_log JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

#### API Endpoints Required
```typescript
// POST /api/guests/import
interface ImportGuestsRequest {
  importType: 'csv' | 'google_contacts' | 'manual';
  data: string; // CSV content or contact data
  mapping?: Record<string, string>; // Field mapping
}

// GET /api/guests/[coupleId]
interface GetGuestListResponse {
  success: boolean;
  guests: Guest[];
  households: Household[];
  summary: {
    totalGuests: number;
    adults: number;
    children: number;
    infants: number;
    rsvpCounts: {
      attending: number;
      declined: number;
      pending: number;
    };
    categoryCounts: {
      family: number;
      friends: number;
      work: number;
      other: number;
    };
  };
}

// POST /api/guests/bulk-update
interface BulkUpdateGuestsRequest {
  guestIds: string[];
  updates: Partial<Guest>;
}
```

### CODE EXAMPLES

#### Example: Smart Household Grouping
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
export async function createHouseholdFromGuests(guests: Guest[]): Promise<Household> {
  // Step 1: Group by last name and similar addresses
  const groupedGuests = guests.reduce((groups, guest) => {
    const key = `${guest.last_name.toLowerCase()}-${normalizeAddress(guest.address)}`;
    if (!groups[key]) groups[key] = [];
    groups[key].push(guest);
    return groups;
  }, {} as Record<string, Guest[]>);
  
  // Step 2: Create households for each group
  const households: Household[] = [];
  
  for (const [key, householdGuests] of Object.entries(groupedGuests)) {
    if (householdGuests.length === 1) continue; // Single guests don't need households
    
    const primaryContact = householdGuests.find(g => g.email) || householdGuests[0];
    const householdName = generateHouseholdName(householdGuests);
    
    const { data: household } = await supabase
      .from('households')
      .insert({
        couple_id: householdGuests[0].couple_id,
        name: householdName,
        primary_contact_id: primaryContact.id,
        address: primaryContact.address,
        total_members: householdGuests.length,
        adults: householdGuests.filter(g => g.age_group === 'adult').length,
        children: householdGuests.filter(g => g.age_group === 'child').length,
        infants: householdGuests.filter(g => g.age_group === 'infant').length
      })
      .select()
      .single();
    
    // Step 3: Update guests with household ID
    await supabase
      .from('guests')
      .update({ household_id: household.id })
      .in('id', householdGuests.map(g => g.id));
    
    households.push(household);
  }
  
  return households;
}

function generateHouseholdName(guests: Guest[]): string {
  const lastNames = [...new Set(guests.map(g => g.last_name))];
  const firstNames = guests.map(g => g.first_name).slice(0, 2);
  
  if (lastNames.length === 1) {
    return `${firstNames.join(' & ')} ${lastNames[0]}`;
  } else {
    return `${firstNames[0]} ${lastNames[0]} & ${firstNames[1]} ${lastNames[1]}`;
  }
}
```

### ACCEPTANCE CRITERIA
- [x] CSV import with intelligent field mapping and household detection
- [x] Drag-and-drop categorization with real-time count updates
- [x] Bulk operations for invitation management
- [x] Export functionality for vendor coordination
- [x] Mobile-responsive interface for on-the-go updates

### ESTIMATED EFFORT
- Team A Frontend: 24 hours
- Team C Integration: 16 hours
- Total: 40 hours