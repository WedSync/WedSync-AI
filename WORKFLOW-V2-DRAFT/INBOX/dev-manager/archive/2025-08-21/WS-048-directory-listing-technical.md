# TECHNICAL SPECIFICATION: WS-048 - Directory Listing Management
## Generated by Feature Development Session - 2025-08-21

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding photographer wanting to attract new couples
**I want to:** Showcase my business performance and quality on WedSync directory
**So that:** Couples find me based on real responsiveness (2-hour replies) not just advertising budget

**Real Wedding Scenario:**
Anna is a wedding photographer who responds to inquiries within 2 hours and maintains 4.8-star reviews. Her WedSync directory profile shows "Usually responds in 2 hours" and "Last active today" which helps her rank above competitors who paid for advertising but take 2 days to respond. A couple searching for photographers in Miami sees Anna's performance indicators and books a consultation, leading to a $3,500 wedding contract.

### SPECIFICATION SOURCE
- **Feature ID:** WS-048
- **Original Spec:** /CORE-SPECIFICATIONS/02-WEDSYNC-SUPPLIER-PLATFORM/08-Growth-Features/03-directory-listing md.md
- **Current Implementation:** 0% complete
- **Files to Modify:** None - new feature
- **New Files to Create:**
  - `/src/components/directory/SupplierProfile.tsx`
  - `/src/components/directory/DirectorySearch.tsx`
  - `/src/components/directory/ProfileBuilder.tsx`
  - `/src/app/directory/[category]/page.tsx`
  - `/src/app/api/directory/profiles/route.ts`
  - `/src/app/api/directory/search/route.ts`
  - `/src/lib/directory/ranking-engine.ts`
  - `/src/lib/directory/profile-analytics.ts`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Directory Profiles table
CREATE TABLE IF NOT EXISTS directory_profiles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID NOT NULL REFERENCES suppliers(id) UNIQUE,
  business_name VARCHAR(200) NOT NULL,
  category VARCHAR(50) NOT NULL, -- 'photographer', 'venue', 'florist', etc.
  subcategories TEXT[], -- Style tags
  primary_location JSONB NOT NULL, -- {city, state, country, lat, lng}
  service_areas JSONB[], -- Array of location objects with radius
  starting_price DECIMAL(10,2),
  price_range VARCHAR(20), -- '$', '$$', '$$$', '$$$$'
  description TEXT,
  years_in_business INTEGER,
  team_size INTEGER,
  languages TEXT[] DEFAULT '{"English"}',
  travel_available BOOLEAN DEFAULT FALSE,
  max_travel_distance INTEGER, -- miles
  gallery_images TEXT[] DEFAULT '{}', -- URLs to images
  video_showcase_url TEXT,
  profile_completion_score DECIMAL(3,1) DEFAULT 0, -- 0-100
  is_verified BOOLEAN DEFAULT FALSE,
  tier_level VARCHAR(20) DEFAULT 'starter' CHECK (tier_level IN ('starter', 'professional', 'scale')),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Profile Performance Metrics table
CREATE TABLE IF NOT EXISTS profile_performance (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  profile_id UUID NOT NULL REFERENCES directory_profiles(id),
  avg_response_time_hours DECIMAL(5,2), -- Average response time in hours
  last_active_at TIMESTAMP WITH TIME ZONE,
  login_frequency_score DECIMAL(3,1), -- 0-100 based on login patterns
  client_satisfaction_score DECIMAL(3,1), -- 0-100 from reviews and feedback
  collaboration_score DECIMAL(3,1), -- 0-100 from peer reviews
  inquiry_response_rate DECIMAL(5,2), -- Percentage of inquiries responded to
  booking_conversion_rate DECIMAL(5,2), -- Inquiries to bookings
  profile_views_30d INTEGER DEFAULT 0,
  inquiry_count_30d INTEGER DEFAULT 0,
  booking_count_30d INTEGER DEFAULT 0,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Directory Rankings table (cached rankings)
CREATE TABLE IF NOT EXISTS directory_rankings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  profile_id UUID NOT NULL REFERENCES directory_profiles(id),
  category VARCHAR(50) NOT NULL,
  location_key VARCHAR(100) NOT NULL, -- "miami-fl" or "nationwide"
  rank_position INTEGER NOT NULL,
  rank_score DECIMAL(8,3) NOT NULL, -- Computed ranking score
  quality_signals JSONB, -- Breakdown of scoring factors
  last_calculated TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(category, location_key, profile_id)
);

-- Profile Analytics table
CREATE TABLE IF NOT EXISTS profile_analytics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  profile_id UUID NOT NULL REFERENCES directory_profiles(id),
  date DATE NOT NULL,
  views INTEGER DEFAULT 0,
  unique_views INTEGER DEFAULT 0,
  inquiries INTEGER DEFAULT 0,
  bookings INTEGER DEFAULT 0,
  gallery_clicks INTEGER DEFAULT 0,
  contact_info_views INTEGER DEFAULT 0,
  avg_time_on_profile DECIMAL(5,1), -- seconds
  bounce_rate DECIMAL(5,2), -- percentage
  referrer_sources JSONB, -- {google: 10, facebook: 5, direct: 15}
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(profile_id, date)
);

-- Availability Calendar table
CREATE TABLE IF NOT EXISTS supplier_availability (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID NOT NULL REFERENCES suppliers(id),
  available_date DATE NOT NULL,
  status VARCHAR(20) DEFAULT 'available' CHECK (status IN ('available', 'booked', 'unavailable')),
  event_type VARCHAR(50), -- If booked
  notes TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(supplier_id, available_date)
);

-- Create indexes for search performance
CREATE INDEX idx_directory_profiles_category ON directory_profiles(category);
CREATE INDEX idx_directory_profiles_location ON directory_profiles USING GIN(primary_location);
CREATE INDEX idx_directory_rankings_category_location ON directory_rankings(category, location_key, rank_position);
CREATE INDEX idx_profile_performance_scores ON profile_performance(client_satisfaction_score, collaboration_score, avg_response_time_hours);
```

#### API Endpoints Required
```typescript
// GET /api/directory/search
interface DirectorySearchRequest {
  category?: string;
  location?: string;
  lat?: number;
  lng?: number;
  radius?: number; // miles
  priceRange?: string;
  availableDate?: string;
  page?: number;
  limit?: number;
  sortBy?: 'rank' | 'price' | 'rating' | 'distance';
}

interface DirectorySearchResponse {
  success: boolean;
  profiles: Array<{
    id: string;
    businessName: string;
    category: string;
    location: Location;
    startingPrice: number;
    priceRange: string;
    rating: number;
    reviewCount: number;
    responseTime: string; // "Usually responds in 2 hours"
    lastActive: string; // "Last active today"
    availabilityStatus: string;
    gallery: string[]; // First 3 images
    isVerified: boolean;
    tierLevel: string;
    distance?: number; // If location-based search
  }>;
  totalCount: number;
  facets: {
    categories: Record<string, number>;
    priceRanges: Record<string, number>;
    locations: Record<string, number>;
  };
}

// GET /api/directory/profiles/[profileId]
interface ProfileDetailsResponse {
  success: boolean;
  profile: {
    id: string;
    businessName: string;
    category: string;
    description: string;
    location: Location;
    serviceAreas: Location[];
    gallery: string[];
    videoShowcase?: string;
    performance: {
      avgResponseTime: number;
      responseRate: number;
      collaborationScore: number;
      lastActive: string;
    };
    reviews: Review[];
    availability: {
      nextAvailableDate?: string;
      totalAvailableDates: number;
    };
    pricing: {
      startingPrice: number;
      priceRange: string;
      packageExamples?: PackageExample[];
    };
  };
}

// PUT /api/directory/profiles/[profileId]
interface UpdateProfileRequest {
  businessName?: string;
  description?: string;
  startingPrice?: number;
  gallery?: string[];
  videoShowcase?: string;
  serviceAreas?: Location[];
  travelAvailable?: boolean;
  maxTravelDistance?: number;
}

// POST /api/directory/profiles/[profileId]/availability
interface UpdateAvailabilityRequest {
  dates: Array<{
    date: string;
    status: 'available' | 'booked' | 'unavailable';
    notes?: string;
  }>;
}

// GET /api/directory/analytics/[profileId]
interface ProfileAnalyticsResponse {
  success: boolean;
  metrics: {
    profileViews: TimeSeriesData;
    inquiryConversion: number;
    topKeywords: string[];
    competitorComparison: {
      avgResponseTime: number;
      yourResponseTime: number;
      avgRating: number;
      yourRating: number;
    };
    rankingFactors: {
      responseTime: number;
      profileCompleteness: number;
      reviewScore: number;
      activityLevel: number;
      total: number;
    };
  };
}
```

#### Frontend Components Required
```typescript
// Component: DirectorySearch
// Location: /src/components/directory/DirectorySearch.tsx

interface DirectorySearchProps {
  initialCategory?: string;
  initialLocation?: string;
}

// Key functionality:
- Location-based search with map integration
- Category filtering with supplier count indicators
- Price range slider
- Availability date picker
- Real-time search results
- Advanced filters (verified only, response time, etc.)
- Sort options (relevance, price, rating, distance)

// Component: SupplierProfile
// Location: /src/components/directory/SupplierProfile.tsx

interface SupplierProfileProps {
  profileId: string;
  viewMode?: 'card' | 'detailed';
}

// Key functionality:
- Performance indicators (response time, last active)
- Gallery with lightbox
- Availability calendar preview
- Real-time collaboration score
- Contact form integration
- Social proof elements
- Tier-based feature display

// Component: ProfileBuilder
// Location: /src/components/directory/ProfileBuilder.tsx

interface ProfileBuilderProps {
  supplierId: string;
  currentProfile?: DirectoryProfile;
}

// Key functionality:
- Step-by-step profile creation wizard
- Image upload with drag-and-drop
- Service area mapping tool
- Pricing configuration
- Availability calendar setup
- SEO optimization tips
- Profile completion score tracker
```

#### Integration Points
```typescript
// Service: RankingEngine
// Dependencies: PerformanceTracker, ReviewService, AvailabilityService

class RankingEngine {
  async calculateProfileScore(profileId: string): Promise<number> {
    // Weighted scoring: 40% performance, 30% reviews, 20% completeness, 10% activity
  }
  
  async updateRankings(category: string, location: string) {
    // Recalculate and cache rankings for a category/location
  }
  
  async getQualitySignals(profileId: string) {
    // Return breakdown of ranking factors for transparency
  }
}

// Service: PerformanceTracker
// Dependencies: AnalyticsService, CommunicationService

class PerformanceTracker {
  async updateResponseTime(supplierId: string, responseTimeHours: number) {
    // Track rolling average of response times
  }
  
  async trackActivity(supplierId: string, activityType: string) {
    // Record login, client management, form completion activities
  }
  
  async calculateCollaborationScore(supplierId: string): Promise<number> {
    // Score based on peer reviews and vendor network interactions
  }
}

// Service: AvailabilityService
// Dependencies: CalendarIntegration

class AvailabilityService {
  async syncExternalCalendar(supplierId: string, calendarType: 'google' | 'outlook') {
    // Import availability from external calendars
  }
  
  async getAvailabilityStatus(supplierId: string): Promise<string> {
    // Return human-readable availability status
  }
  
  async findAvailableSuppliers(category: string, date: Date, location: Location) {
    // Find suppliers available on specific date
  }
}
```

### CODE EXAMPLES

#### Example 1: Profile Ranking Calculation
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { supabase } from '@/lib/supabase';

export async function calculateProfileRankingScore(profileId: string): Promise<number> {
  // Step 1: Get profile and performance data
  const { data: profile } = await supabase
    .from('directory_profiles')
    .select(`
      *,
      profile_performance(*),
      suppliers(
        reviews(rating, created_at),
        collected_reviews(rating, created_at)
      )
    `)
    .eq('id', profileId)
    .single();
    
  if (!profile) throw new Error('Profile not found');
  
  const performance = profile.profile_performance;
  const allReviews = [
    ...(profile.suppliers.reviews || []),
    ...(profile.suppliers.collected_reviews || [])
  ];
  
  // Step 2: Calculate component scores (0-100 each)
  
  // Performance Score (40% weight)
  const responseTimeScore = Math.max(0, 100 - (performance.avg_response_time_hours * 10));
  const responseRateScore = performance.inquiry_response_rate || 0;
  const activityScore = performance.login_frequency_score || 0;
  const performanceScore = (responseTimeScore + responseRateScore + activityScore) / 3;
  
  // Review Score (30% weight)
  const recentReviews = allReviews.filter(r => 
    new Date(r.created_at) > new Date(Date.now() - 90 * 24 * 60 * 60 * 1000)
  );
  const avgRating = recentReviews.length > 0 
    ? recentReviews.reduce((sum, r) => sum + r.rating, 0) / recentReviews.length
    : 0;
  const reviewScore = (avgRating / 5) * 100;
  
  // Completeness Score (20% weight)
  const completenessScore = profile.profile_completion_score || 0;
  
  // Collaboration Score (10% weight)
  const collaborationScore = performance.collaboration_score || 0;
  
  // Step 3: Calculate weighted final score
  const finalScore = (
    (performanceScore * 0.40) +
    (reviewScore * 0.30) +
    (completenessScore * 0.20) +
    (collaborationScore * 0.10)
  );
  
  // Step 4: Store quality signals for transparency
  const qualitySignals = {
    performance: performanceScore,
    reviews: reviewScore,
    completeness: completenessScore,
    collaboration: collaborationScore,
    breakdown: {
      responseTime: responseTimeScore,
      responseRate: responseRateScore,
      activity: activityScore,
      avgRating: avgRating,
      reviewCount: recentReviews.length
    }
  };
  
  // Step 5: Update ranking record
  await supabase
    .from('directory_rankings')
    .upsert({
      profile_id: profileId,
      category: profile.category,
      location_key: `${profile.primary_location.city}-${profile.primary_location.state}`.toLowerCase(),
      rank_score: finalScore,
      quality_signals: qualitySignals,
      last_calculated: new Date().toISOString()
    }, {
      onConflict: 'profile_id,category,location_key'
    });
  
  return finalScore;
}
```

#### Example 2: Smart Directory Search
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { supabase } from '@/lib/supabase';

export async function searchDirectoryProfiles(params: DirectorySearchRequest) {
  let query = supabase
    .from('directory_profiles')
    .select(`
      id,
      business_name,
      category,
      primary_location,
      starting_price,
      price_range,
      gallery_images,
      is_verified,
      tier_level,
      profile_performance(
        avg_response_time_hours,
        last_active_at,
        client_satisfaction_score
      ),
      directory_rankings(rank_score, rank_position),
      suppliers(
        collected_reviews(rating)
      )
    `);
  
  // Apply category filter
  if (params.category) {
    query = query.eq('category', params.category);
  }
  
  // Apply location filter with radius
  if (params.lat && params.lng) {
    const radiusMiles = params.radius || 25;
    // Use PostGIS for radius search (simplified for example)
    query = query.rpc('profiles_within_radius', {
      center_lat: params.lat,
      center_lng: params.lng,
      radius_miles: radiusMiles
    });
  }
  
  // Apply price range filter
  if (params.priceRange) {
    query = query.eq('price_range', params.priceRange);
  }
  
  // Apply availability filter
  if (params.availableDate) {
    query = query.rpc('profiles_available_on_date', {
      target_date: params.availableDate
    });
  }
  
  // Apply sorting
  switch (params.sortBy) {
    case 'rank':
      query = query.order('rank_score', { 
        ascending: false,
        foreignTable: 'directory_rankings'
      });
      break;
    case 'price':
      query = query.order('starting_price', { ascending: true });
      break;
    case 'rating':
      query = query.order('client_satisfaction_score', { 
        ascending: false,
        foreignTable: 'profile_performance'
      });
      break;
  }
  
  // Apply pagination
  const limit = params.limit || 20;
  const offset = ((params.page || 1) - 1) * limit;
  query = query.range(offset, offset + limit - 1);
  
  const { data: profiles, error } = await query;
  if (error) throw error;
  
  // Transform data for response
  const transformedProfiles = profiles.map(profile => {
    const performance = profile.profile_performance;
    const reviews = profile.suppliers?.collected_reviews || [];
    const avgRating = reviews.length > 0 
      ? reviews.reduce((sum, r) => sum + r.rating, 0) / reviews.length 
      : 0;
    
    return {
      id: profile.id,
      businessName: profile.business_name,
      category: profile.category,
      location: profile.primary_location,
      startingPrice: profile.starting_price,
      priceRange: profile.price_range,
      rating: Number(avgRating.toFixed(1)),
      reviewCount: reviews.length,
      responseTime: formatResponseTime(performance?.avg_response_time_hours),
      lastActive: formatLastActive(performance?.last_active_at),
      availabilityStatus: 'Available', // Would check actual availability
      gallery: profile.gallery_images.slice(0, 3),
      isVerified: profile.is_verified,
      tierLevel: profile.tier_level
    };
  });
  
  return {
    success: true,
    profiles: transformedProfiles,
    totalCount: profiles.length // Would get actual count in real implementation
  };
}

function formatResponseTime(hours?: number): string {
  if (!hours) return 'Response time varies';
  if (hours < 1) return 'Usually responds within 1 hour';
  if (hours < 24) return `Usually responds in ${Math.round(hours)} hours`;
  return `Usually responds in ${Math.round(hours / 24)} days`;
}

function formatLastActive(timestamp?: string): string {
  if (!timestamp) return 'Last active unknown';
  const hoursAgo = (Date.now() - new Date(timestamp).getTime()) / (1000 * 60 * 60);
  if (hoursAgo < 1) return 'Active now';
  if (hoursAgo < 24) return `Last active ${Math.round(hoursAgo)} hours ago`;
  return `Last active ${Math.round(hoursAgo / 24)} days ago`;
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for mapping APIs, search optimization
- [x] Filesystem: Access location data and category taxonomies
- [ ] Playwright: Test search and profile creation flows

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/googlemaps/googlemaps", "places api geocoding", 2500);
await mcp__context7__get-library-docs("/mapbox/mapbox", "search and geocoding", 2000);
await mcp__context7__get-library-docs("/fuse.js/fuse.js", "fuzzy search implementation", 1500);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('Directory Ranking Engine', () => {
  it('should calculate profile scores correctly', async () => {
    const score = await calculateProfileRankingScore('profile-123');
    expect(score).toBeGreaterThan(0);
    expect(score).toBeLessThanOrEqual(100);
  });
  
  it('should prioritize responsive suppliers', async () => {
    const fastResponder = await calculateProfileRankingScore('fast-supplier');
    const slowResponder = await calculateProfileRankingScore('slow-supplier');
    expect(fastResponder).toBeGreaterThan(slowResponder);
  });
  
  it('should handle location-based search accurately', async () => {
    const results = await searchDirectoryProfiles({
      lat: 25.7617,
      lng: -80.1918,
      radius: 10
    });
    expect(results.profiles.length).toBeGreaterThan(0);
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Directory search and profile interaction', async () => {
  // Step 1: Search for photographers in Miami
  await mcp__playwright__browser_navigate({url: '/directory'});
  await mcp__playwright__browser_type({element: 'location search', ref: 'input[name="location"]', text: 'Miami, FL'});
  await mcp__playwright__browser_click({element: 'photographers category', ref: 'button[data-category="photographer"]'});
  
  // Step 2: Verify search results load
  await mcp__playwright__browser_snapshot();
  
  // Step 3: Click on a supplier profile
  await mcp__playwright__browser_click({element: 'first profile', ref: '[data-testid="profile-card"]:first-child'});
  
  // Step 4: Verify profile details load
  await mcp__playwright__browser_snapshot();
  
  // Step 5: Test inquiry form
  await mcp__playwright__browser_click({element: 'contact button', ref: 'button[data-testid="contact-supplier"]'});
  
  // Verify mobile responsiveness and performance
});
```

### ACCEPTANCE CRITERIA
- [x] Suppliers can create comprehensive profiles with 25+ images and performance indicators
- [x] Search returns relevant results within 500ms for any location/category combination
- [x] Ranking algorithm prioritizes response time and quality over paid promotion
- [x] Real-time availability status updates automatically from calendar integrations
- [x] Mobile-optimized profile pages load in <2 seconds on 3G connections
- [x] Performance: Search API <500ms, profile views tracked with 99.9% accuracy
- [x] Security: Profile data encrypted, location coordinates rounded for privacy
- [x] Accessibility: WCAG 2.1 AA compliance for all directory interfaces

### DEPENDENCIES
- Must complete after: Supplier onboarding system - needs basic supplier data
- Must complete before: SEO Optimization Tools (WS-049) - profiles need to exist for SEO
- Shares code with: Analytics system, Review collection system, Availability management

### ESTIMATED EFFORT
- Team A Frontend: 32 hours
- Team B Backend: 28 hours  
- Team C Integration: 20 hours
- Total: 80 hours