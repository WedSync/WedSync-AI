# TECHNICAL SPECIFICATION: WS-019 - Travel Time Calculator
## Generated by Feature Development Session - August 21, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding DJ managing back-to-back events on Saturdays
**I want to:** Know exactly when to leave for venues accounting for traffic and equipment load-in time
**So that:** I never arrive late and miss cocktail hour music, damaging my reputation

**Real Wedding Scenario:**
A DJ underestimates Friday rush hour traffic to a countryside venue.
They arrive 20 minutes late, missing the couple's first dance practice.
With this calculator, they'd receive alerts about heavy traffic 2 hours before departure.

### SPECIFICATION SOURCE
- **Feature ID:** WS-019
- **Original Spec:** /CORE-SPECIFICATIONS/02-WEDSYNC-SUPPLIER-PLATFORM/02-Dashboard/07-travel-time-calculator.md
- **Current Implementation:** 0% complete
- **Files to Modify:** None (new feature)
- **New Files to Create:**
  - /wedsync/src/components/travel/TravelCalculator.tsx
  - /wedsync/src/components/travel/RouteDisplay.tsx
  - /wedsync/src/lib/services/travel-service.ts
  - /wedsync/src/lib/services/google-maps-service.ts
  - /wedsync/src/app/api/travel/route.ts
  - /wedsync/supabase/migrations/020_travel_calculations.sql

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Travel calculation history and patterns
CREATE TABLE IF NOT EXISTS travel_calculations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
  client_id UUID REFERENCES clients(id) ON DELETE CASCADE,
  origin_address JSONB NOT NULL,
  destination_address JSONB NOT NULL,
  arrival_time TIMESTAMPTZ NOT NULL,
  normal_duration_minutes INTEGER NOT NULL,
  traffic_adjusted_minutes INTEGER,
  weather_impact_minutes INTEGER DEFAULT 0,
  buffer_time_minutes INTEGER DEFAULT 30,
  recommended_departure TIMESTAMPTZ NOT NULL,
  alternative_routes JSONB,
  toll_information JSONB,
  actual_duration_minutes INTEGER, -- Filled after trip
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Venue travel patterns for learning
CREATE TABLE IF NOT EXISTS venue_travel_patterns (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID NOT NULL REFERENCES suppliers(id),
  venue_id UUID REFERENCES venues(id),
  venue_address JSONB NOT NULL,
  day_of_week INTEGER CHECK (day_of_week >= 0 AND day_of_week <= 6),
  hour_of_day INTEGER CHECK (hour_of_day >= 0 AND hour_of_day <= 23),
  avg_duration_minutes INTEGER,
  avg_delay_minutes INTEGER,
  sample_count INTEGER DEFAULT 1,
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Supplier travel preferences
CREATE TABLE IF NOT EXISTS travel_preferences (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
  supplier_type TEXT NOT NULL,
  default_buffer_minutes INTEGER DEFAULT 30,
  setup_time_minutes INTEGER DEFAULT 0,
  weather_extra_minutes INTEGER DEFAULT 15,
  rush_hour_extra_minutes INTEGER DEFAULT 20,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(supplier_id)
);

-- Indexes
CREATE INDEX idx_travel_calc_supplier ON travel_calculations(supplier_id, arrival_time DESC);
CREATE INDEX idx_venue_patterns ON venue_travel_patterns(venue_id, day_of_week, hour_of_day);
CREATE INDEX idx_travel_calc_departure ON travel_calculations(recommended_departure);
```

#### API Endpoints Required
```typescript
// POST /api/travel/calculate
interface CalculateTravelRequest {
  origin: {
    address?: string;
    coordinates?: { lat: number; lng: number };
    useCurrentLocation?: boolean;
  };
  destination: {
    address: string;
    venueId?: string;
  };
  arrivalTime: string; // ISO datetime
  supplierType: 'photographer' | 'dj' | 'caterer' | 'florist' | 'other';
}

interface TravelCalculationResponse {
  success: boolean;
  data: {
    recommendedDeparture: string;
    breakdown: {
      baseDuration: number;
      trafficAdjustment: number;
      weatherImpact: number;
      setupTime: number;
      bufferTime: number;
      totalMinutes: number;
    };
    routes: {
      primary: RouteDetails;
      alternatives: RouteDetails[];
    };
    warnings: string[];
    confidence: 'high' | 'medium' | 'low';
  };
}

// GET /api/travel/patterns/{venueId}
interface VenuePatternsResponse {
  success: boolean;
  data: {
    averageDuration: number;
    peakTimes: {
      dayOfWeek: string;
      hour: number;
      expectedDelay: number;
    }[];
    historicalTrips: number;
  };
}
```

#### Frontend Components Required
```typescript
// Component: TravelCalculator
// Location: /src/components/travel/TravelCalculator.tsx

interface TravelCalculatorProps {
  clientId: string;
  venueAddress: Address;
  eventTime: Date;
  onCalculation: (result: TravelCalculation) => void;
}

// Key functionality:
- Auto-detect current location
- Manual origin address input
- Real-time traffic updates
- Weather condition integration
- Setup time configuration
- Alternative route display

// Component: RouteDisplay
// Location: /src/components/travel/RouteDisplay.tsx

interface RouteDisplayProps {
  route: RouteDetails;
  isSelected: boolean;
  onSelect: () => void;
  onNavigate: () => void;
}

// Key functionality:
- Visual route on mini-map
- Turn-by-turn summary
- Toll information display
- One-tap navigation launch
- Save route preference
```

#### Integration Points
```typescript
// Service: TravelService
// Dependencies: GoogleMapsAPI, WeatherAPI, NotificationService

class TravelService {
  async calculateOptimalDeparture(params: TravelCalculationParams) {
    // Get base travel time from Google
    // Apply traffic predictions
    // Add weather adjustments
    // Include setup requirements
    // Learn from historical patterns
  }

  async learnFromTrip(tripData: CompletedTrip) {
    // Update venue patterns
    // Adjust future predictions
    // Improve accuracy over time
  }

  async scheduleAlerts(calculation: TravelCalculation) {
    // 24-hour advance check
    // Morning-of update
    // 2-hour warning
    // Departure reminder
  }
}
```

### CODE EXAMPLES

#### Example 1: Smart Travel Calculation
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { GoogleMapsClient } from '@googlemaps/google-maps-services-js';
import { supabase } from '@/lib/supabase';

export async function calculateSmartDeparture(
  origin: Location,
  destination: Location,
  arrivalTime: Date,
  supplierType: string
) {
  // Step 1: Get supplier preferences
  const { data: preferences } = await supabase
    .from('travel_preferences')
    .select('*')
    .eq('supplier_type', supplierType)
    .single();

  // Step 2: Calculate base travel time
  const maps = new GoogleMapsClient({});
  const directionsResult = await maps.directions({
    params: {
      origin: origin.address,
      destination: destination.address,
      arrival_time: arrivalTime.getTime() / 1000,
      mode: 'driving',
      traffic_model: 'best_guess',
      alternatives: true
    }
  });

  const primaryRoute = directionsResult.data.routes[0];
  const baseDuration = primaryRoute.legs[0].duration_in_traffic?.value || 
                       primaryRoute.legs[0].duration.value;

  // Step 3: Check historical patterns
  const dayOfWeek = arrivalTime.getDay();
  const hourOfDay = arrivalTime.getHours();
  
  const { data: pattern } = await supabase
    .from('venue_travel_patterns')
    .select('avg_delay_minutes')
    .eq('venue_address', destination.address)
    .eq('day_of_week', dayOfWeek)
    .eq('hour_of_day', hourOfDay)
    .single();

  // Step 4: Apply adjustments
  let totalMinutes = Math.ceil(baseDuration / 60);
  
  // Historical pattern adjustment
  if (pattern) {
    totalMinutes += pattern.avg_delay_minutes;
  }
  
  // Weather impact
  const weather = await getWeatherForecast(destination, arrivalTime);
  if (weather.precipitation > 0) {
    totalMinutes += preferences?.weather_extra_minutes || 15;
  }
  
  // Setup time for vendor type
  totalMinutes += preferences?.setup_time_minutes || 0;
  
  // Safety buffer
  totalMinutes += preferences?.default_buffer_minutes || 30;
  
  // Step 5: Calculate departure time
  const departureTime = new Date(
    arrivalTime.getTime() - totalMinutes * 60 * 1000
  );

  return {
    departureTime,
    totalMinutes,
    confidence: pattern ? 'high' : 'medium',
    routes: directionsResult.data.routes
  };
}
```

#### Example 2: Learning from Completed Trips
```typescript
// Pattern learning for improved predictions
export async function learnFromCompletedTrip(
  tripId: string,
  actualDuration: number
) {
  // Get original calculation
  const { data: calculation } = await supabase
    .from('travel_calculations')
    .select('*')
    .eq('id', tripId)
    .single();

  if (!calculation) return;

  // Calculate accuracy
  const predictedMinutes = 
    (calculation.arrival_time - calculation.recommended_departure) / 60000;
  const accuracyDelta = actualDuration - predictedMinutes;

  // Update venue pattern
  const dayOfWeek = new Date(calculation.arrival_time).getDay();
  const hourOfDay = new Date(calculation.arrival_time).getHours();

  const { data: existingPattern } = await supabase
    .from('venue_travel_patterns')
    .select('*')
    .eq('venue_address', calculation.destination_address)
    .eq('day_of_week', dayOfWeek)
    .eq('hour_of_day', hourOfDay)
    .single();

  if (existingPattern) {
    // Update rolling average
    const newAvgDelay = 
      (existingPattern.avg_delay_minutes * existingPattern.sample_count + accuracyDelta) /
      (existingPattern.sample_count + 1);

    await supabase
      .from('venue_travel_patterns')
      .update({
        avg_delay_minutes: Math.round(newAvgDelay),
        sample_count: existingPattern.sample_count + 1
      })
      .eq('id', existingPattern.id);
  } else {
    // Create new pattern
    await supabase
      .from('venue_travel_patterns')
      .insert({
        venue_address: calculation.destination_address,
        day_of_week: dayOfWeek,
        hour_of_day: hourOfDay,
        avg_duration_minutes: actualDuration,
        avg_delay_minutes: accuracyDelta
      });
  }
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load Google Maps API docs
- [x] Filesystem: Access project structure
- [ ] Playwright: Test route calculation UI

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/googlemaps/google-maps-services-js", "directions api", 3000);
await mcp__context7__get-library-docs("/vercel/next.js", "server actions", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('TravelCalculator', () => {
  it('should add weather buffer for rain', async () => {
    const calculation = await calculateDeparture({
      weather: 'rain',
      supplierType: 'photographer'
    });
    expect(calculation.weatherImpact).toBeGreaterThan(0);
  });

  it('should learn from historical patterns', async () => {
    await recordTrip({ venue: 'Church', delay: 10 });
    await recordTrip({ venue: 'Church', delay: 15 });
    const prediction = await predictDelay('Church');
    expect(prediction).toBeCloseTo(12.5, 1);
  });

  it('should suggest earlier departure for rush hour', async () => {
    const rushHour = await calculate({ arrivalTime: '17:00' });
    const offPeak = await calculate({ arrivalTime: '14:00' });
    expect(rushHour.departureTime).toBeBefore(offPeak.departureTime);
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Calculate travel time with alternatives', async () => {
  await mcp__playwright__browser_navigate({url: '/travel/calculate'});
  
  await mcp__playwright__browser_type({
    element: 'Destination input',
    ref: 'input[name="destination"]',
    text: '123 Wedding Venue Rd'
  });
  
  await mcp__playwright__browser_click({
    element: 'Calculate button',
    ref: 'button:has-text("Calculate")'
  });
  
  // Verify routes display
  await mcp__playwright__browser_snapshot();
});
```

### ACCEPTANCE CRITERIA
- [x] Accurate within 5 minutes 80% of the time
- [x] Accounts for vendor-specific setup time
- [x] Weather conditions affect calculations
- [x] Historical patterns improve accuracy
- [x] Alternative routes always shown
- [x] One-tap navigation launch works
- [x] Offline mode with cached calculations
- [x] Performance: Calculations in <2 seconds
- [x] Security: Only supplier's own trips visible
- [x] Accessibility: Voice navigation compatible

### DEPENDENCIES
- Must complete after: None
- Must complete before: WS-018 (Wedding Day Module uses this)
- Shares code with: WS-018 (Wedding Day Module)

### ESTIMATED EFFORT
- Team B Backend: 20 hours
- Team C Integration: 16 hours (APIs)
- Total: 36 hours