# TECHNICAL SPECIFICATION: WS-015 - Conditional Branching
## Generated by Feature Development Session - 2025-08-21

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding venue coordinator managing different wedding types and requirements
**I want to:** Create journey paths that branch based on client data, responses, and wedding characteristics
**So that:** I can provide personalized experiences instead of sending generic communications to all couples regardless of their specific needs

**Real Wedding Scenario:**
A venue coordinator handles indoor ballroom weddings and outdoor garden ceremonies with completely different requirements. Indoor weddings need: lighting coordination, temperature control, sound system checks. Outdoor weddings need: weather monitoring, tent setup, backup indoor plans, heating/cooling contingencies. Currently they send all couples both indoor AND outdoor information, causing confusion and 20+ unnecessary emails. With conditional branching, they create one journey that splits: IF venue_type = "outdoor" THEN weather monitoring path, ELSE indoor climate path. This delivers only relevant information, reducing couple confusion and coordinator workload from 40+ communications to 20 targeted ones per wedding.

### SPECIFICATION SOURCE
- **Feature ID:** WS-015
- **Original Spec:** /CORE-SPECIFICATIONS/02-WEDSYNC-SUPPLIER-PLATFORM/05-Customer-Journey/04-conditional-branching md.md
- **Current Implementation:** 0% complete
- **Files to Modify:**
  - /src/components/journey/JourneyCanvas.tsx (add conditional node support)
  - /src/lib/journey/canvasEngine.ts (add branching logic)
- **New Files to Create:**
  - /src/components/conditions/ConditionalNode.tsx
  - /src/components/conditions/ConditionBuilder.tsx
  - /src/components/conditions/LogicOperatorPanel.tsx
  - /src/components/conditions/FieldValueSelector.tsx
  - /src/lib/conditions/conditionEvaluator.ts
  - /src/lib/stores/conditionStore.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Conditional branching node definitions
CREATE TABLE IF NOT EXISTS conditional_nodes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  journey_id UUID REFERENCES journeys(id) ON DELETE CASCADE,
  node_id TEXT NOT NULL, -- Canvas node ID
  condition_logic JSONB NOT NULL, -- Complex condition definitions
  true_path_label TEXT DEFAULT 'Yes',
  false_path_label TEXT DEFAULT 'No',
  evaluation_order INTEGER DEFAULT 1, -- For complex multi-condition nodes
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  
  UNIQUE(journey_id, node_id)
);

-- Condition evaluation history for analytics
CREATE TABLE IF NOT EXISTS condition_evaluations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  conditional_node_id UUID REFERENCES conditional_nodes(id) ON DELETE CASCADE,
  journey_execution_id UUID REFERENCES journey_executions(id) ON DELETE CASCADE,
  client_id UUID REFERENCES client_profiles(id) ON DELETE CASCADE,
  evaluation_data JSONB NOT NULL, -- Client data at time of evaluation
  condition_result BOOLEAN NOT NULL, -- True or False path taken
  evaluation_time_ms INTEGER NOT NULL, -- Performance tracking
  path_taken TEXT NOT NULL, -- 'true_path' or 'false_path'
  next_node_id TEXT, -- Which node was triggered next
  created_at TIMESTAMP DEFAULT NOW(),
  
  INDEX(conditional_node_id, condition_result),
  INDEX(client_id, created_at),
  INDEX(journey_execution_id)
);

-- Field value cache for condition evaluation
CREATE TABLE IF NOT EXISTS condition_field_cache (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  client_id UUID REFERENCES client_profiles(id) ON DELETE CASCADE,
  field_path TEXT NOT NULL, -- e.g., 'custom_fields.venue_type'
  field_value JSONB NOT NULL,
  data_source TEXT NOT NULL, -- 'client_profile', 'form_response', 'calculated'
  source_id UUID, -- Reference to source record
  cached_at TIMESTAMP DEFAULT NOW(),
  expires_at TIMESTAMP,
  
  UNIQUE(client_id, field_path),
  INDEX(field_path),
  INDEX(expires_at)
);

-- A/B testing for conditional paths
CREATE TABLE IF NOT EXISTS condition_ab_tests (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  conditional_node_id UUID REFERENCES conditional_nodes(id) ON DELETE CASCADE,
  test_name TEXT NOT NULL,
  test_description TEXT,
  variant_a_logic JSONB NOT NULL, -- Original condition
  variant_b_logic JSONB NOT NULL, -- Alternative condition
  traffic_split DECIMAL(3,2) DEFAULT 0.5, -- 0.5 = 50/50 split
  is_active BOOLEAN DEFAULT true,
  start_date TIMESTAMP DEFAULT NOW(),
  end_date TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW()
);
```

#### API Endpoints Required
```typescript
// POST /api/conditions/evaluate
interface EvaluateConditionRequest {
  conditionLogic: ConditionLogic;
  clientId: string;
  contextData?: Record<string, any>; // Additional runtime data
  debugMode?: boolean; // Return evaluation steps
}

interface EvaluateConditionResponse {
  success: boolean;
  data: {
    result: boolean;
    evaluationTime: number; // milliseconds
    pathTaken: 'true_path' | 'false_path';
    fieldValues: Record<string, any>; // Values used in evaluation
    debugInfo?: {
      steps: Array<{
        condition: string;
        fieldValue: any;
        operator: string;
        compareValue: any;
        result: boolean;
      }>;
      logicTree: object; // Visual representation of evaluation
    };
  };
}

// POST /api/conditions/nodes
interface CreateConditionalNodeRequest {
  journeyId: string;
  nodeId: string;
  conditionLogic: {
    operator: 'AND' | 'OR';
    conditions: Array<{
      field: string; // e.g., 'venue_type', 'package_tier', 'guest_count'
      operator: 'equals' | 'not_equals' | 'greater_than' | 'less_than' | 'contains' | 'starts_with' | 'exists' | 'in_array';
      value: any;
      dataType: 'string' | 'number' | 'boolean' | 'date' | 'array';
    }>;
    nestedGroups?: ConditionGroup[]; // For complex (A AND B) OR (C AND D) logic
  };
  truePath: {
    label: string;
    description?: string;
  };
  falsePath: {
    label: string;
    description?: string;
  };
}

// GET /api/conditions/fields/available
interface GetAvailableFieldsResponse {
  success: boolean;
  data: {
    clientFields: Array<{
      path: string;
      label: string;
      dataType: 'string' | 'number' | 'boolean' | 'date' | 'array';
      description: string;
      exampleValues: any[];
      category: 'basic' | 'wedding' | 'package' | 'custom' | 'calculated';
    }>;
    formFields: Array<{
      formId: string;
      formName: string;
      fields: Array<{
        path: string;
        label: string;
        dataType: string;
        description: string;
      }>;
    }>;
    calculatedFields: Array<{
      path: string;
      label: string;
      description: string;
      formula: string;
    }>;
  };
}

// GET /api/conditions/analytics/[nodeId]
interface GetConditionAnalyticsResponse {
  success: boolean;
  data: {
    totalEvaluations: number;
    truePathCount: number;
    falsePathCount: number;
    truePathPercentage: number;
    averageEvaluationTime: number;
    fieldUsageStats: Array<{
      fieldPath: string;
      usageCount: number;
      uniqueValues: any[];
      mostCommonValue: any;
    }>;
    pathPerformance: {
      truePath: {
        conversionRate: number;
        averageEngagement: number;
        dropOffRate: number;
      };
      falsePath: {
        conversionRate: number;
        averageEngagement: number;
        dropOffRate: number;
      };
    };
    recommendations: string[];
  };
}

// POST /api/conditions/test
interface TestConditionRequest {
  conditionLogic: ConditionLogic;
  testScenarios: Array<{
    name: string;
    clientData: Record<string, any>;
    expectedResult?: boolean;
    description?: string;
  }>;
}

interface TestConditionResponse {
  success: boolean;
  data: {
    results: Array<{
      scenarioName: string;
      actualResult: boolean;
      expectedResult?: boolean;
      passed: boolean;
      evaluationTime: number;
      fieldValues: Record<string, any>;
    }>;
    summary: {
      totalTests: number;
      passed: number;
      failed: number;
      averageEvaluationTime: number;
    };
  };
}
```

#### Frontend Components Required
```typescript
// Component: ConditionalNode
// Location: /src/components/conditions/ConditionalNode.tsx

interface ConditionalNodeProps extends NodeProps {
  data: {
    conditionLogic: ConditionLogic;
    truePath: PathConfig;
    falsePath: PathConfig;
    evaluationStats?: {
      totalEvaluations: number;
      truePathPercentage: number;
      lastEvaluated?: string;
    };
    validationStatus: 'valid' | 'warning' | 'error';
    validationMessage?: string;
  };
  selected: boolean;
  onEdit: () => void;
}

// Key functionality:
- Diamond-shaped decision node visual
- True/false path labels with colors (green/red)
- Condition summary display
- Evaluation statistics overlay
- Visual connection points for paths
- Validation status indicators
- Hover tooltip with condition details

// Component: ConditionBuilder
// Location: /src/components/conditions/ConditionBuilder.tsx

interface ConditionBuilderProps {
  conditionLogic?: ConditionLogic;
  availableFields: FieldDefinition[];
  onSave: (logic: ConditionLogic) => void;
  onCancel: () => void;
  onTest: (logic: ConditionLogic) => void;
}

// Key functionality:
- Visual condition builder with drag-and-drop
- Field selector with search and categories
- Operator dropdown with type-appropriate options
- Value input with validation
- Logic group builder for complex conditions
- Real-time syntax validation
- Test condition with sample data
- Import/export condition templates

// Component: LogicOperatorPanel
// Location: /src/components/conditions/LogicOperatorPanel.tsx

interface LogicOperatorPanelProps {
  operator: 'AND' | 'OR';
  onOperatorChange: (operator: 'AND' | 'OR') => void;
  conditions: Condition[];
  onConditionAdd: () => void;
  onConditionRemove: (index: number) => void;
  onConditionUpdate: (index: number, condition: Condition) => void;
}

// Key functionality:
- AND/OR toggle with visual feedback
- Condition list with reordering
- Add/remove condition buttons
- Nested group management
- Condition validation indicators
- Parentheses grouping visualization

// Component: FieldValueSelector
// Location: /src/components/conditions/FieldValueSelector.tsx

interface FieldValueSelectorProps {
  field?: FieldDefinition;
  operator: string;
  value: any;
  onValueChange: (value: any) => void;
  dataType: 'string' | 'number' | 'boolean' | 'date' | 'array';
  suggestions?: any[]; // Suggested values from existing data
}

// Key functionality:
- Type-appropriate input widgets
- Date picker for date fields
- Dropdown for enum fields
- Multi-select for array operations
- Number input with validation
- Auto-complete with suggestions
- Custom value entry option
```

#### Integration Points
```typescript
// Condition evaluation engine
export class ConditionEvaluator {
  private fieldValueCache: Map<string, any> = new Map();
  
  async evaluateCondition(conditionLogic: ConditionLogic, clientId: string, contextData?: Record<string, any>): Promise<ConditionEvaluationResult> {
    const startTime = Date.now();
    
    try {
      // Step 1: Prepare evaluation context
      const evaluationContext = await this.buildEvaluationContext(clientId, contextData);
      
      // Step 2: Evaluate the condition logic
      const result = await this.evaluateLogicGroup(conditionLogic, evaluationContext);
      
      // Step 3: Record evaluation for analytics
      await this.recordEvaluation(conditionLogic, clientId, result, Date.now() - startTime);
      
      return {
        result,
        evaluationTime: Date.now() - startTime,
        pathTaken: result ? 'true_path' : 'false_path',
        fieldValues: this.extractUsedFieldValues(conditionLogic, evaluationContext),
        context: evaluationContext
      };
      
    } catch (error) {
      throw new ConditionEvaluationError(`Condition evaluation failed: ${error.message}`, {
        conditionLogic,
        clientId,
        evaluationTime: Date.now() - startTime
      });
    }
  }
  
  private async evaluateLogicGroup(logicGroup: ConditionLogic, context: EvaluationContext): Promise<boolean> {
    const { operator, conditions, nestedGroups } = logicGroup;
    
    // Step 1: Evaluate individual conditions
    const conditionResults = await Promise.all(
      conditions.map(condition => this.evaluateSingleCondition(condition, context))
    );
    
    // Step 2: Evaluate nested groups
    const nestedResults = nestedGroups ? await Promise.all(
      nestedGroups.map(group => this.evaluateLogicGroup(group, context))
    ) : [];
    
    // Step 3: Combine results with operator
    const allResults = [...conditionResults, ...nestedResults];
    
    if (operator === 'AND') {
      return allResults.every(result => result === true);
    } else if (operator === 'OR') {
      return allResults.some(result => result === true);
    } else {
      throw new Error(`Unknown logic operator: ${operator}`);
    }
  }
  
  private async evaluateSingleCondition(condition: Condition, context: EvaluationContext): Promise<boolean> {
    // Step 1: Get field value
    const fieldValue = await this.getFieldValue(condition.field, context);
    
    // Step 2: Apply operator
    return this.applyOperator(fieldValue, condition.operator, condition.value, condition.dataType);
  }
  
  private async getFieldValue(fieldPath: string, context: EvaluationContext): Promise<any> {
    // Step 1: Check cache first
    const cacheKey = `${context.clientId}:${fieldPath}`;
    if (this.fieldValueCache.has(cacheKey)) {
      return this.fieldValueCache.get(cacheKey);
    }
    
    // Step 2: Resolve field value based on path
    let value: any;
    
    if (fieldPath.startsWith('client.')) {
      value = this.getNestedValue(context.clientData, fieldPath.substring(7));
    } else if (fieldPath.startsWith('form.')) {
      const [, formId, fieldName] = fieldPath.split('.');
      value = context.formData[formId]?.[fieldName];
    } else if (fieldPath.startsWith('calculated.')) {
      value = await this.calculateFieldValue(fieldPath.substring(11), context);
    } else if (fieldPath.startsWith('custom.')) {
      value = this.getNestedValue(context.clientData.custom_fields, fieldPath.substring(7));
    } else {
      // Direct client field
      value = context.clientData[fieldPath];
    }
    
    // Step 3: Cache the value
    this.fieldValueCache.set(cacheKey, value);
    
    return value;
  }
  
  private applyOperator(fieldValue: any, operator: string, compareValue: any, dataType: string): boolean {
    // Normalize values based on data type
    const normalizedFieldValue = this.normalizeValue(fieldValue, dataType);
    const normalizedCompareValue = this.normalizeValue(compareValue, dataType);
    
    switch (operator) {
      case 'equals':
        return normalizedFieldValue === normalizedCompareValue;
      
      case 'not_equals':
        return normalizedFieldValue !== normalizedCompareValue;
      
      case 'greater_than':
        return normalizedFieldValue > normalizedCompareValue;
      
      case 'less_than':
        return normalizedFieldValue < normalizedCompareValue;
      
      case 'greater_than_or_equal':
        return normalizedFieldValue >= normalizedCompareValue;
      
      case 'less_than_or_equal':
        return normalizedFieldValue <= normalizedCompareValue;
      
      case 'contains':
        return String(normalizedFieldValue).toLowerCase().includes(String(normalizedCompareValue).toLowerCase());
      
      case 'starts_with':
        return String(normalizedFieldValue).toLowerCase().startsWith(String(normalizedCompareValue).toLowerCase());
      
      case 'ends_with':
        return String(normalizedFieldValue).toLowerCase().endsWith(String(normalizedCompareValue).toLowerCase());
      
      case 'exists':
        return normalizedFieldValue !== null && normalizedFieldValue !== undefined && normalizedFieldValue !== '';
      
      case 'not_exists':
        return normalizedFieldValue === null || normalizedFieldValue === undefined || normalizedFieldValue === '';
      
      case 'in_array':
        const arrayValues = Array.isArray(normalizedCompareValue) ? normalizedCompareValue : [normalizedCompareValue];
        return arrayValues.includes(normalizedFieldValue);
      
      case 'not_in_array':
        const notInArray = Array.isArray(normalizedCompareValue) ? normalizedCompareValue : [normalizedCompareValue];
        return !notInArray.includes(normalizedFieldValue);
      
      case 'between':
        if (!Array.isArray(normalizedCompareValue) || normalizedCompareValue.length !== 2) {
          throw new Error('Between operator requires array of 2 values');
        }
        return normalizedFieldValue >= normalizedCompareValue[0] && normalizedFieldValue <= normalizedCompareValue[1];
      
      default:
        throw new Error(`Unknown operator: ${operator}`);
    }
  }
  
  private normalizeValue(value: any, dataType: string): any {
    if (value === null || value === undefined) {
      return value;
    }
    
    switch (dataType) {
      case 'string':
        return String(value);
      
      case 'number':
        const num = Number(value);
        return isNaN(num) ? 0 : num;
      
      case 'boolean':
        if (typeof value === 'boolean') return value;
        if (typeof value === 'string') {
          return value.toLowerCase() === 'true' || value === '1' || value === 'yes';
        }
        return Boolean(value);
      
      case 'date':
        if (value instanceof Date) return value;
        const date = new Date(value);
        return isNaN(date.getTime()) ? new Date(0) : date;
      
      case 'array':
        return Array.isArray(value) ? value : [value];
      
      default:
        return value;
    }
  }
  
  private async buildEvaluationContext(clientId: string, contextData?: Record<string, any>): Promise<EvaluationContext> {
    // Step 1: Get client data
    const { data: clientData } = await supabase
      .from('client_profiles')
      .select('*')
      .eq('id', clientId)
      .single();
    
    if (!clientData) {
      throw new Error(`Client not found: ${clientId}`);
    }
    
    // Step 2: Get form response data
    const { data: formResponses } = await supabase
      .from('form_responses')
      .select('form_id, response_data')
      .eq('client_id', clientId);
    
    const formData: Record<string, any> = {};
    formResponses?.forEach(response => {
      formData[response.form_id] = response.response_data;
    });
    
    // Step 3: Calculate derived fields
    const calculatedFields = await this.calculateDerivedFields(clientData);
    
    return {
      clientId,
      clientData: { ...clientData, calculated: calculatedFields },
      formData,
      contextData: contextData || {},
      timestamp: new Date()
    };
  }
}

// Store: conditionStore
interface ConditionStore {
  conditions: Map<string, ConditionalNode>;
  evaluationHistory: ConditionEvaluation[];
  availableFields: FieldDefinition[];
  
  createConditionalNode: (config: ConditionalNodeConfig) => Promise<ConditionalNode>;
  updateConditionalNode: (nodeId: string, updates: Partial<ConditionalNodeConfig>) => Promise<void>;
  deleteConditionalNode: (nodeId: string) => Promise<void>;
  
  evaluateCondition: (nodeId: string, clientId: string, contextData?: any) => Promise<ConditionEvaluationResult>;
  testCondition: (logic: ConditionLogic, scenarios: TestScenario[]) => Promise<TestResult>;
  
  getConditionAnalytics: (nodeId: string, dateRange?: DateRange) => Promise<ConditionAnalytics>;
  
  loadAvailableFields: () => Promise<void>;
  refreshFieldCache: (clientId: string) => Promise<void>;
}
```

### CODE EXAMPLES

#### Example 1: Complex Condition Logic Builder
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
export class AdvancedConditionBuilder {
  
  buildComplexCondition(requirements: ConditionRequirements): ConditionLogic {
    // Example: Build condition for outdoor wedding with weather concerns
    // IF (venue_type = "outdoor" AND (season = "summer" OR season = "spring")) 
    //    AND (guest_count > 50 OR package_tier = "premium")
    
    const condition: ConditionLogic = {
      operator: 'AND',
      conditions: [],
      nestedGroups: [
        {
          operator: 'AND',
          conditions: [
            {
              field: 'venue_type',
              operator: 'equals',
              value: 'outdoor',
              dataType: 'string'
            }
          ],
          nestedGroups: [
            {
              operator: 'OR',
              conditions: [
                {
                  field: 'calculated.wedding_season',
                  operator: 'equals',
                  value: 'summer',
                  dataType: 'string'
                },
                {
                  field: 'calculated.wedding_season',
                  operator: 'equals',
                  value: 'spring',
                  dataType: 'string'
                }
              ]
            }
          ]
        },
        {
          operator: 'OR',
          conditions: [
            {
              field: 'guest_count',
              operator: 'greater_than',
              value: 50,
              dataType: 'number'
            },
            {
              field: 'package_details.tier',
              operator: 'equals',
              value: 'premium',
              dataType: 'string'
            }
          ]
        }
      ]
    };
    
    return this.optimizeCondition(condition);
  }
  
  private optimizeCondition(condition: ConditionLogic): ConditionLogic {
    // Step 1: Remove redundant conditions
    const optimized = this.removeRedundantConditions(condition);
    
    // Step 2: Flatten unnecessary nesting
    const flattened = this.flattenCondition(optimized);
    
    // Step 3: Reorder conditions for performance (most selective first)
    const reordered = this.reorderConditions(flattened);
    
    return reordered;
  }
  
  private removeRedundantConditions(condition: ConditionLogic): ConditionLogic {
    // Remove duplicate conditions
    const uniqueConditions = condition.conditions.filter((cond, index, arr) => {
      return !arr.slice(0, index).some(prev => 
        prev.field === cond.field && 
        prev.operator === cond.operator && 
        prev.value === cond.value
      );
    });
    
    // Process nested groups recursively
    const optimizedGroups = condition.nestedGroups?.map(group => 
      this.removeRedundantConditions(group)
    ).filter(group => 
      group.conditions.length > 0 || (group.nestedGroups && group.nestedGroups.length > 0)
    );
    
    return {
      ...condition,
      conditions: uniqueConditions,
      nestedGroups: optimizedGroups
    };
  }
  
  generateConditionFromNaturalLanguage(description: string): ConditionLogic {
    // Simple natural language parsing for common patterns
    const patterns = [
      {
        pattern: /outdoor weddings in (summer|spring|fall|winter)/i,
        builder: (matches: RegExpMatchArray) => ({
          operator: 'AND' as const,
          conditions: [
            {
              field: 'venue_type',
              operator: 'equals' as const,
              value: 'outdoor',
              dataType: 'string' as const
            },
            {
              field: 'calculated.wedding_season',
              operator: 'equals' as const,
              value: matches[1].toLowerCase(),
              dataType: 'string' as const
            }
          ]
        })
      },
      {
        pattern: /premium clients with more than (\d+) guests/i,
        builder: (matches: RegExpMatchArray) => ({
          operator: 'AND' as const,
          conditions: [
            {
              field: 'package_details.tier',
              operator: 'equals' as const,
              value: 'premium',
              dataType: 'string' as const
            },
            {
              field: 'guest_count',
              operator: 'greater_than' as const,
              value: parseInt(matches[1]),
              dataType: 'number' as const
            }
          ]
        })
      },
      {
        pattern: /weddings within (\d+) days/i,
        builder: (matches: RegExpMatchArray) => ({
          operator: 'AND' as const,
          conditions: [
            {
              field: 'calculated.days_until_wedding',
              operator: 'less_than_or_equal' as const,
              value: parseInt(matches[1]),
              dataType: 'number' as const
            }
          ]
        })
      }
    ];
    
    for (const { pattern, builder } of patterns) {
      const matches = description.match(pattern);
      if (matches) {
        return builder(matches);
      }
    }
    
    throw new Error(`Could not parse condition: "${description}". Please use the visual builder.`);
  }
}
```

#### Example 2: High-Performance Condition Evaluation with Caching
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
export class OptimizedConditionEvaluator extends ConditionEvaluator {
  private evaluationCache: Map<string, CachedEvaluation> = new Map();
  private fieldComputationCache: Map<string, ComputedField> = new Map();
  
  async evaluateWithCaching(conditionLogic: ConditionLogic, clientId: string, contextData?: Record<string, any>): Promise<ConditionEvaluationResult> {
    // Step 1: Generate cache key
    const cacheKey = this.generateCacheKey(conditionLogic, clientId, contextData);
    
    // Step 2: Check cache first
    const cached = this.evaluationCache.get(cacheKey);
    if (cached && !this.isCacheExpired(cached)) {
      return {
        ...cached.result,
        fromCache: true,
        cacheAge: Date.now() - cached.timestamp
      };
    }
    
    // Step 3: Perform evaluation with field-level caching
    const result = await this.evaluateWithFieldCaching(conditionLogic, clientId, contextData);
    
    // Step 4: Cache the result
    this.evaluationCache.set(cacheKey, {
      result,
      timestamp: Date.now(),
      ttl: this.calculateCacheTTL(conditionLogic)
    });
    
    return result;
  }
  
  private async evaluateWithFieldCaching(conditionLogic: ConditionLogic, clientId: string, contextData?: Record<string, any>): Promise<ConditionEvaluationResult> {
    const startTime = Date.now();
    
    // Step 1: Pre-fetch all required fields in parallel
    const requiredFields = this.extractRequiredFields(conditionLogic);
    const fieldValues = await this.batchFetchFields(clientId, requiredFields);
    
    // Step 2: Build evaluation context with cached fields
    const context: EvaluationContext = {
      clientId,
      clientData: fieldValues.clientData,
      formData: fieldValues.formData,
      calculatedData: fieldValues.calculatedData,
      contextData: contextData || {},
      timestamp: new Date()
    };
    
    // Step 3: Evaluate condition with optimized logic
    const result = await this.evaluateOptimized(conditionLogic, context);
    
    return {
      result,
      evaluationTime: Date.now() - startTime,
      pathTaken: result ? 'true_path' : 'false_path',
      fieldValues: this.extractUsedFieldValues(conditionLogic, context),
      optimizationStats: {
        fieldsCached: requiredFields.filter(f => this.fieldComputationCache.has(`${clientId}:${f}`)).length,
        fieldsComputed: requiredFields.length - requiredFields.filter(f => this.fieldComputationCache.has(`${clientId}:${f}`)).length
      }
    };
  }
  
  private async batchFetchFields(clientId: string, requiredFields: string[]): Promise<BatchFieldResult> {
    const result: BatchFieldResult = {
      clientData: {},
      formData: {},
      calculatedData: {}
    };
    
    // Step 1: Categorize fields by source
    const clientFields = requiredFields.filter(f => f.startsWith('client.') || !f.includes('.'));
    const formFields = requiredFields.filter(f => f.startsWith('form.'));
    const calculatedFields = requiredFields.filter(f => f.startsWith('calculated.'));
    
    // Step 2: Fetch in parallel with caching
    const fetchPromises = [
      this.fetchClientFields(clientId, clientFields),
      this.fetchFormFields(clientId, formFields),
      this.fetchCalculatedFields(clientId, calculatedFields)
    ];
    
    const [clientData, formData, calculatedData] = await Promise.all(fetchPromises);
    
    return {
      clientData,
      formData,
      calculatedData
    };
  }
  
  private async fetchCalculatedFields(clientId: string, fields: string[]): Promise<Record<string, any>> {
    const result: Record<string, any> = {};
    
    for (const field of fields) {
      const fieldName = field.replace('calculated.', '');
      const cacheKey = `${clientId}:calculated.${fieldName}`;
      
      // Check cache first
      const cached = this.fieldComputationCache.get(cacheKey);
      if (cached && !this.isFieldCacheExpired(cached)) {
        result[fieldName] = cached.value;
        continue;
      }
      
      // Compute field value
      let value: any;
      
      switch (fieldName) {
        case 'days_until_wedding':
          value = await this.calculateDaysUntilWedding(clientId);
          break;
        
        case 'wedding_season':
          value = await this.calculateWeddingSeason(clientId);
          break;
        
        case 'venue_type':
          value = await this.calculateVenueType(clientId);
          break;
        
        case 'completion_percentage':
          value = await this.calculateCompletionPercentage(clientId);
          break;
        
        case 'last_activity_days':
          value = await this.calculateLastActivityDays(clientId);
          break;
        
        default:
          console.warn(`Unknown calculated field: ${fieldName}`);
          value = null;
      }
      
      // Cache the computed value
      this.fieldComputationCache.set(cacheKey, {
        value,
        computedAt: Date.now(),
        ttl: this.getFieldCacheTTL(fieldName)
      });
      
      result[fieldName] = value;
    }
    
    return result;
  }
  
  private async calculateDaysUntilWedding(clientId: string): Promise<number> {
    const { data: client } = await supabase
      .from('client_profiles')
      .select('wedding_date')
      .eq('id', clientId)
      .single();
    
    if (!client?.wedding_date) return -1;
    
    const weddingDate = new Date(client.wedding_date);
    const today = new Date();
    const diffTime = weddingDate.getTime() - today.getTime();
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    
    return diffDays;
  }
  
  private async calculateWeddingSeason(clientId: string): Promise<string> {
    const { data: client } = await supabase
      .from('client_profiles')
      .select('wedding_date')
      .eq('id', clientId)
      .single();
    
    if (!client?.wedding_date) return 'unknown';
    
    const month = new Date(client.wedding_date).getMonth() + 1; // 1-12
    
    if (month >= 3 && month <= 5) return 'spring';
    if (month >= 6 && month <= 8) return 'summer';
    if (month >= 9 && month <= 11) return 'fall';
    return 'winter';
  }
  
  private generateCacheKey(conditionLogic: ConditionLogic, clientId: string, contextData?: Record<string, any>): string {
    const contextHash = contextData ? this.hashObject(contextData) : '';
    const logicHash = this.hashObject(conditionLogic);
    return `${clientId}:${logicHash}:${contextHash}`;
  }
  
  private hashObject(obj: any): string {
    return Buffer.from(JSON.stringify(obj)).toString('base64').substring(0, 16);
  }
  
  private calculateCacheTTL(conditionLogic: ConditionLogic): number {
    // Dynamic TTL based on condition complexity and field types
    const requiredFields = this.extractRequiredFields(conditionLogic);
    
    // Fields that change frequently get shorter cache
    const dynamicFields = ['calculated.days_until_wedding', 'calculated.last_activity_days'];
    const hasDynamicFields = requiredFields.some(f => dynamicFields.includes(f));
    
    if (hasDynamicFields) {
      return 5 * 60 * 1000; // 5 minutes
    }
    
    // Static client data can be cached longer
    return 30 * 60 * 1000; // 30 minutes
  }
  
  private extractRequiredFields(conditionLogic: ConditionLogic): string[] {
    const fields = new Set<string>();
    
    // Extract from direct conditions
    conditionLogic.conditions.forEach(condition => {
      fields.add(condition.field);
    });
    
    // Extract from nested groups recursively
    conditionLogic.nestedGroups?.forEach(group => {
      this.extractRequiredFields(group).forEach(field => fields.add(field));
    });
    
    return Array.from(fields);
  }
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for condition evaluation and logic processing
- [ ] Playwright: Test conditional branching and path execution
- [x] Filesystem: Access condition component directories

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/lodash/lodash", "object manipulation", 2000);
await mcp__context7__get-library-docs("/nodejs/node", "expression evaluation", 2000);
await mcp__context7__get-library-docs("/reactjs/react", "conditional rendering", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('Condition Evaluator', () => {
  it('should evaluate simple conditions correctly', async () => {
    const evaluator = new ConditionEvaluator();
    const condition = {
      operator: 'AND',
      conditions: [
        {
          field: 'venue_type',
          operator: 'equals',
          value: 'outdoor',
          dataType: 'string'
        }
      ]
    };
    
    const result = await evaluator.evaluateCondition(condition, 'client1');
    
    expect(result.result).toBe(true);
    expect(result.pathTaken).toBe('true_path');
  });
  
  it('should handle complex nested conditions', async () => {
    const evaluator = new ConditionEvaluator();
    const condition = {
      operator: 'AND',
      conditions: [],
      nestedGroups: [
        {
          operator: 'OR',
          conditions: [
            { field: 'venue_type', operator: 'equals', value: 'outdoor', dataType: 'string' },
            { field: 'guest_count', operator: 'greater_than', value: 100, dataType: 'number' }
          ]
        }
      ]
    };
    
    const result = await evaluator.evaluateCondition(condition, 'client1');
    
    expect(result.result).toBeDefined();
  });
  
  it('should cache field computations correctly', async () => {
    const evaluator = new OptimizedConditionEvaluator();
    const computeSpy = jest.spyOn(evaluator, 'calculateDaysUntilWedding');
    
    // First evaluation
    await evaluator.evaluateWithCaching(sampleCondition, 'client1');
    
    // Second evaluation should use cache
    await evaluator.evaluateWithCaching(sampleCondition, 'client1');
    
    expect(computeSpy).toHaveBeenCalledTimes(1);
  });
});

describe('Condition Builder', () => {
  it('should build complex conditions from requirements', () => {
    const builder = new AdvancedConditionBuilder();
    const requirements = {
      venueType: 'outdoor',
      seasons: ['summer', 'spring'],
      minimumGuests: 50
    };
    
    const condition = builder.buildComplexCondition(requirements);
    
    expect(condition.nestedGroups).toHaveLength(2);
    expect(condition.operator).toBe('AND');
  });
  
  it('should parse natural language conditions', () => {
    const builder = new AdvancedConditionBuilder();
    const description = 'outdoor weddings in summer';
    
    const condition = builder.generateConditionFromNaturalLanguage(description);
    
    expect(condition.conditions).toHaveLength(2);
    expect(condition.conditions[0].field).toBe('venue_type');
    expect(condition.conditions[1].field).toBe('calculated.wedding_season');
  });
  
  it('should optimize conditions for performance', () => {
    const builder = new AdvancedConditionBuilder();
    const redundantCondition = {
      operator: 'AND',
      conditions: [
        { field: 'venue_type', operator: 'equals', value: 'outdoor', dataType: 'string' },
        { field: 'venue_type', operator: 'equals', value: 'outdoor', dataType: 'string' } // Duplicate
      ]
    };
    
    const optimized = builder.optimizeCondition(redundantCondition);
    
    expect(optimized.conditions).toHaveLength(1);
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Conditional node creation and configuration', async () => {
  await mcp__playwright__browser_navigate({url: '/journeys/canvas/123'});
  
  // Add conditional node
  await mcp__playwright__browser_drag({
    startElement: 'Condition module',
    startRef: '[data-testid="module-condition"]',
    endElement: 'Canvas',
    endRef: '[data-testid="canvas-drop-zone"]'
  });
  
  // Configure condition
  await mcp__playwright__browser_click({
    element: 'Condition node',
    ref: '[data-node-id="condition-1"]'
  });
  
  // Build condition: venue_type = "outdoor"
  await mcp__playwright__browser_select_option({
    element: 'Field selector',
    ref: '[data-testid="field-selector"]',
    values: ['venue_type']
  });
  
  await mcp__playwright__browser_select_option({
    element: 'Operator selector',
    ref: '[data-testid="operator-selector"]',
    values: ['equals']
  });
  
  await mcp__playwright__browser_type({
    element: 'Value input',
    ref: '[data-testid="value-input"]',
    text: 'outdoor'
  });
  
  // Set path labels
  await mcp__playwright__browser_type({
    element: 'True path label',
    ref: '[data-testid="true-path-label"]',
    text: 'Outdoor Wedding'
  });
  
  await mcp__playwright__browser_type({
    element: 'False path label',
    ref: '[data-testid="false-path-label"]',
    text: 'Indoor Wedding'
  });
  
  // Test condition
  await mcp__playwright__browser_click({
    element: 'Test condition',
    ref: '[data-testid="test-condition"]'
  });
  
  await mcp__playwright__browser_wait_for({text: 'Test Results'});
  
  // Save configuration
  await mcp__playwright__browser_click({
    element: 'Save condition',
    ref: '[data-testid="save-condition"]'
  });
  
  await mcp__playwright__browser_wait_for({text: 'Condition saved successfully'});
});

test('Complex condition building with nested logic', async () => {
  await mcp__playwright__browser_navigate({url: '/conditions/builder'});
  
  // Start with AND group
  await mcp__playwright__browser_click({
    element: 'AND operator',
    ref: '[data-testid="operator-and"]'
  });
  
  // Add first condition: venue_type = outdoor
  await mcp__playwright__browser_click({
    element: 'Add condition',
    ref: '[data-testid="add-condition"]'
  });
  
  await mcp__playwright__browser_select_option({
    element: 'Field selector',
    ref: '[data-testid="condition-0-field"]',
    values: ['venue_type']
  });
  
  await mcp__playwright__browser_type({
    element: 'Value input',
    ref: '[data-testid="condition-0-value"]',
    text: 'outdoor'
  });
  
  // Add nested OR group
  await mcp__playwright__browser_click({
    element: 'Add group',
    ref: '[data-testid="add-nested-group"]'
  });
  
  await mcp__playwright__browser_select_option({
    element: 'Nested group operator',
    ref: '[data-testid="nested-group-0-operator"]',
    values: ['OR']
  });
  
  // Add conditions to nested group
  await mcp__playwright__browser_click({
    element: 'Add condition to group',
    ref: '[data-testid="nested-group-0-add-condition"]'
  });
  
  await mcp__playwright__browser_select_option({
    element: 'Nested condition field',
    ref: '[data-testid="nested-group-0-condition-0-field"]',
    values: ['calculated.wedding_season']
  });
  
  await mcp__playwright__browser_type({
    element: 'Nested condition value',
    ref: '[data-testid="nested-group-0-condition-0-value"]',
    text: 'summer'
  });
  
  // Preview condition
  await mcp__playwright__browser_click({
    element: 'Preview condition',
    ref: '[data-testid="preview-condition"]'
  });
  
  await mcp__playwright__browser_wait_for({text: 'venue_type = "outdoor" AND (wedding_season = "summer")'});
  
  // Test with sample data
  await mcp__playwright__browser_click({
    element: 'Test with sample',
    ref: '[data-testid="test-sample"]'
  });
  
  await mcp__playwright__browser_wait_for({text: 'Test passed'});
});

test('Condition evaluation in journey execution', async () => {
  await mcp__playwright__browser_navigate({url: '/journeys/executions/456'});
  
  // Start journey execution
  await mcp__playwright__browser_click({
    element: 'Start execution',
    ref: '[data-testid="start-execution"]'
  });
  
  // Wait for condition evaluation
  await mcp__playwright__browser_wait_for({text: 'Evaluating condition'});
  
  // Check which path was taken
  await mcp__playwright__browser_wait_for({text: 'Path taken: Outdoor Wedding'});
  
  // Verify next module is triggered
  await mcp__playwright__browser_wait_for({text: 'Weather monitoring module activated'});
  
  // Check execution log
  await mcp__playwright__browser_click({
    element: 'View execution log',
    ref: '[data-testid="execution-log"]'
  });
  
  await mcp__playwright__browser_wait_for({text: 'Condition evaluated: venue_type = outdoor â†’ TRUE'});
});
```

### ACCEPTANCE CRITERIA
- [ ] Visual condition builder supports nested AND/OR logic
- [ ] Field selector shows all available client and form fields
- [ ] Condition evaluation handles all data types correctly (string, number, boolean, date)
- [ ] Complex conditions with multiple nested groups evaluate accurately
- [ ] Real-time condition testing with sample data works
- [ ] Condition analytics show path distribution and performance
- [ ] Field value caching improves evaluation performance
- [ ] Natural language condition parsing for common patterns
- [ ] A/B testing support for different condition logic
- [ ] Condition templates for reuse across journeys
- [ ] Performance: 1000+ condition evaluations per second
- [ ] Error handling provides clear validation messages

### DEPENDENCIES
- Must complete after: WS-013 (Journey Canvas), WS-014 (Timeline Nodes)
- Must complete before: None (completes journey system)
- Shares code with: WS-013 (canvas engine), WS-014 (execution engine)

### ESTIMATED EFFORT
- Team A Frontend: 32 hours
- Team B Backend: 26 hours
- Team C Integration: 10 hours
- Total: 68 hours