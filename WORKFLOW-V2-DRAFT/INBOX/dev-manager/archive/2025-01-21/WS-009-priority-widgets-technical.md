# TECHNICAL SPECIFICATION: WS-009 - Priority Widgets
## Generated by Feature Development Session - 2025-08-21

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding planner managing 15 active weddings with varying urgency levels
**I want to:** See prioritized tasks, activities, and metrics on my dashboard based on urgency and importance
**So that:** I can focus on the most critical items first instead of missing urgent deadlines buried in long task lists

**Real Wedding Scenario:**
A planner starts their day needing to prioritize: 1) Sarah's wedding is in 3 days with missing dietary forms, 2) Mike's venue just sent updated timeline requiring client approval, 3)  4) 5 routine follow-ups. Without prioritization, they might spend 30 minutes on routine tasks while Sarah's urgent dietary requirements (affecting catering count due tomorrow) get overlooked. With priority widgets, urgent items appear at the top with red indicators, the 3-day deadline is highlighted, and one-click actions let them resolve critical issues in 5 minutes - ensuring no deadline is missed.

### SPECIFICATION SOURCE
- **Feature ID:** WS-009
- **Original Spec:** /CORE-SPECIFICATIONS/02-WEDSYNC-SUPPLIER-PLATFORM/02-Dashboard/03-priority-widgets md.md
- **Current Implementation:** 0% complete
- **Files to Modify:**
  - /src/components/dashboard/DashboardGrid.tsx (add priority widgets)
- **New Files to Create:**
  - /src/components/widgets/TodaysTasksWidget.tsx
  - /src/components/widgets/ClientActivityWidget.tsx
  - /src/components/widgets/WeddingCountdownWidget.tsx
  - /src/components/widgets/PerformanceMetricsWidget.tsx
  - /src/lib/widgets/priorityAlgorithm.ts
  - /src/lib/stores/widgetStore.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Task priority calculations and caching
CREATE TABLE IF NOT EXISTS priority_tasks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  task_type TEXT CHECK (task_type IN ('form_due', 'meeting_scheduled', 'journey_milestone', 'manual_task', 'payment_overdue', 'response_needed')) NOT NULL,
  reference_id UUID NOT NULL, -- ID of the related entity
  client_id UUID REFERENCES client_profiles(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  description TEXT,
  priority_score INTEGER NOT NULL, -- 1-100, higher = more urgent
  urgency_factors JSONB DEFAULT '{}', -- What makes this urgent
  due_date TIMESTAMP,
  completion_status TEXT CHECK (completion_status IN ('pending', 'in_progress', 'completed', 'overdue')) DEFAULT 'pending',
  quick_actions JSONB DEFAULT '[]', -- Available one-click actions
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  
  INDEX(user_id, priority_score DESC),
  INDEX(due_date),
  INDEX(completion_status)
);

-- Widget state and real-time updates
CREATE TABLE IF NOT EXISTS widget_states (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  widget_type TEXT NOT NULL,
  state_data JSONB NOT NULL,
  last_updated TIMESTAMP DEFAULT NOW(),
  expires_at TIMESTAMP,
  
  UNIQUE(user_id, widget_type)
);

-- Performance metrics cache
CREATE TABLE IF NOT EXISTS performance_snapshots (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  snapshot_date DATE NOT NULL,
  metrics JSONB NOT NULL, -- Forms completed, response times, satisfaction scores
  created_at TIMESTAMP DEFAULT NOW(),
  
  UNIQUE(user_id, snapshot_date)
);
```

#### API Endpoints Required
```typescript
// GET /api/widgets/priority-tasks
interface GetPriorityTasksResponse {
  success: boolean;
  data: {
    tasks: Array<{
      id: string;
      type: 'form_due' | 'meeting_scheduled' | 'journey_milestone' | 'manual_task' | 'payment_overdue' | 'response_needed';
      title: string;
      description: string;
      priorityScore: number; // 1-100
      urgencyFactors: {
        timeRemaining?: number; // hours
        clientTier?: 'vip' | 'standard';
        businessImpact?: 'high' | 'medium' | 'low';
        dependencies?: string[];
      };
      client: {
        id: string;
        name: string;
        weddingDate: string;
        photoUrl?: string;
      };
      dueDate: string;
      status: 'pending' | 'in_progress' | 'completed' | 'overdue';
      quickActions: Array<{
        label: string;
        action: string;
        href?: string;
        variant: 'primary' | 'secondary' | 'danger';
      }>;
    }>;
    totalCount: number;
    overdueCount: number;
  };
}

// GET /api/widgets/client-activity
interface GetClientActivityResponse {
  success: boolean;
  data: {
    activities: Array<{
      id: string;
      type: 'form_submitted' | 'email_opened' | 'dashboard_login' | 'payment_made' | 'meeting_booked';
      client: {
        id: string;
        name: string;
        photoUrl?: string;
      };
      title: string;
      description: string;
      timestamp: string;
      urgent: boolean;
      metadata: Record<string, any>;
    }>;
    recentLoginCount: number;
    pendingResponseCount: number;
  };
}

// GET /api/widgets/wedding-countdown
interface GetWeddingCountdownResponse {
  success: boolean;
  data: {
    nextWedding: {
      id: string;
      coupleNames: string;
      date: string;
      venue: {
        name: string;
        address: string;
      };
      daysRemaining: number;
      hoursRemaining: number;
      travelTime?: {
        duration: number; // minutes
        withTraffic: number; // minutes with current traffic
      };
      weather?: {
        forecast: string;
        temperature: number;
        precipitation: number;
        alert?: string;
      };
      contacts: Array<{
        name: string;
        role: string;
        phone: string;
      }>;
    };
    upcomingThisWeek: number;
    upcomingThisMonth: number;
  };
}

// GET /api/widgets/performance-metrics
interface GetPerformanceMetricsResponse {
  success: boolean;
  data: {
    thisWeek: {
      formsCompleted: number;
      averageResponseTime: number; // hours
      clientSatisfactionScore: number; // 1-5
      activeJourneys: number;
      completedMilestones: number;
    };
    trends: {
      formsCompletedChange: number; // percentage
      responseTimeChange: number; // percentage
      satisfactionChange: number; // percentage
    };
    goals: {
      weeklyFormTarget: number;
      responseTimeTarget: number; // hours
      satisfactionTarget: number;
    };
  };
}

// POST /api/widgets/complete-task
interface CompleteTaskRequest {
  taskId: string;
  action?: string;
  notes?: string;
}
```

#### Frontend Components Required
```typescript
// Component: TodaysTasksWidget
// Location: /src/components/widgets/TodaysTasksWidget.tsx

interface TodaysTasksWidgetProps {
  tasks: PriorityTask[];
  onTaskComplete: (taskId: string, action?: string) => void;
  onTaskClick: (task: PriorityTask) => void;
  maxVisible?: number;
}

// Key functionality:
- Priority-sorted task list with urgency indicators
- Color coding: Red (urgent), Yellow (important), Green (routine)
- One-click completion actions
- Time remaining indicators
- Client photos and names
- Quick expand/collapse
- Real-time updates via WebSocket

// Component: ClientActivityWidget
// Location: /src/components/widgets/ClientActivityWidget.tsx

interface ClientActivityWidgetProps {
  activities: ClientActivity[];
  onActivityClick: (activity: ClientActivity) => void;
  filterType?: 'all' | 'urgent' | 'recent';
}

// Key functionality:
- Real-time activity stream
- Activity type icons and colors
- Timestamp with relative time
- Urgent activity highlighting
- Filter by activity type
- Infinite scroll for history
- Client photo avatars

// Component: WeddingCountdownWidget
// Location: /src/components/widgets/WeddingCountdownWidget.tsx

interface WeddingCountdownWidgetProps {
  nextWedding: NextWedding;
  onContactClick: (contact: Contact) => void;
  onWeatherClick: () => void;
}

// Key functionality:
- Large countdown display (days, hours)
- Weather integration with alerts
- Travel time with traffic
- Quick contact actions
- Venue map integration
- Weather contingency alerts
- Time zone handling

// Component: PerformanceMetricsWidget
// Location: /src/components/widgets/PerformanceMetricsWidget.tsx

interface PerformanceMetricsWidgetProps {
  metrics: PerformanceMetrics;
  onMetricClick: (metric: string) => void;
  dateRange: DateRange;
}

// Key functionality:
- Key metrics with trend indicators
- Progress bars for goals
- Percentage change indicators
- Quick drill-down to details
- Comparative data (week over week)
- Goal achievement status
```

#### Integration Points
```typescript
// Algorithm: Priority scoring system
export class PriorityAlgorithm {
  calculatePriorityScore(task: TaskInput): number {
    let score = 0;
    
    // Time urgency (40% of score)
    const timeScore = this.calculateTimeUrgency(task.dueDate);
    score += timeScore * 0.4;
    
    // Business impact (30% of score)
    const impactScore = this.calculateBusinessImpact(task);
    score += impactScore * 0.3;
    
    // Client tier (20% of score)
    const tierScore = this.calculateClientTier(task.clientId);
    score += tierScore * 0.2;
    
    // Dependencies (10% of score)
    const dependencyScore = this.calculateDependencies(task);
    score += dependencyScore * 0.1;
    
    return Math.min(100, Math.max(1, score));
  }
  
  private calculateTimeUrgency(dueDate: Date): number {
    const now = new Date();
    const hoursUntilDue = (dueDate.getTime() - now.getTime()) / (1000 * 60 * 60);
    
    if (hoursUntilDue < 0) return 100; // Overdue
    if (hoursUntilDue < 4) return 90;  // Due in 4 hours
    if (hoursUntilDue < 24) return 70; // Due today
    if (hoursUntilDue < 72) return 50; // Due in 3 days
    if (hoursUntilDue < 168) return 30; // Due this week
    
    return 10; // Due later
  }
  
  private calculateBusinessImpact(task: TaskInput): number {
    const impactFactors = {
      payment_overdue: 90,
      form_due: 70,
      meeting_scheduled: 60,
      journey_milestone: 50,
      response_needed: 40,
      manual_task: 30
    };
    
    return impactFactors[task.type] || 20;
  }
}

// Store: widgetStore
interface WidgetStore {
  tasks: PriorityTask[];
  activities: ClientActivity[];
  nextWedding: NextWedding | null;
  metrics: PerformanceMetrics | null;
  loading: Record<string, boolean>;
  lastRefresh: Date | null;
  
  refreshAllWidgets: () => Promise<void>;
  refreshWidget: (widgetType: string) => Promise<void>;
  completeTask: (taskId: string, action?: string) => Promise<void>;
  
  subscribeToRealTimeUpdates: () => void;
  unsubscribeFromRealTimeUpdates: () => void;
}

// Real-time widget updates
export function useWidgetRealTime() {
  const { updateTasks, updateActivities } = useWidgetStore();
  
  useEffect(() => {
    const subscription = supabase
      .channel('widget-updates')
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: 'priority_tasks'
      }, (payload) => {
        if (payload.eventType === 'INSERT') {
          updateTasks(current => [payload.new, ...current]);
        } else if (payload.eventType === 'UPDATE') {
          updateTasks(current => 
            current.map(task => 
              task.id === payload.new.id ? payload.new : task
            )
          );
        }
      })
      .subscribe();
    
    return () => {
      supabase.removeChannel(subscription);
    };
  }, []);
}
```

### CODE EXAMPLES

#### Example 1: Dynamic Priority Score Calculation
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
export async function calculateAndUpdatePriorities(userId: string): Promise<void> {
  // Step 1: Fetch all pending tasks for user
  const { data: rawTasks } = await supabase
    .from('form_responses')
    .select(`
      id,
      form:forms(name),
      client:client_profiles(id, couple_names, wedding_date, package_details),
      due_date,
      status,
      created_at
    `)
    .eq('supplier_id', userId)
    .in('status', ['pending', 'partial'])
    .order('due_date', { ascending: true });
    
  const priorityAlgorithm = new PriorityAlgorithm();
  const priorityTasks: PriorityTask[] = [];
  
  // Step 2: Calculate priority for each task
  for (const task of rawTasks) {
    const taskInput = {
      type: 'form_due' as const,
      dueDate: new Date(task.due_date),
      clientId: task.client.id,
      weddingDate: new Date(task.client.wedding_date),
      packageTier: task.client.package_details?.tier || 'standard'
    };
    
    const priorityScore = priorityAlgorithm.calculatePriorityScore(taskInput);
    
    // Step 3: Determine urgency factors
    const urgencyFactors = {
      timeRemaining: Math.round((new Date(task.due_date).getTime() - Date.now()) / (1000 * 60 * 60)),
      clientTier: taskInput.packageTier === 'premium' ? 'vip' : 'standard',
      businessImpact: priorityScore > 70 ? 'high' : priorityScore > 40 ? 'medium' : 'low'
    };
    
    // Step 4: Generate quick actions
    const quickActions = [
      {
        label: 'Send Reminder',
        action: 'send_reminder',
        variant: 'secondary' as const
      },
      {
        label: 'View Form',
        action: 'view_form',
        href: `/forms/${task.form.id}/responses`,
        variant: 'primary' as const
      }
    ];
    
    if (priorityScore > 80) {
      quickActions.unshift({
        label: 'Call Client',
        action: 'call_client',
        variant: 'danger' as const
      });
    }
    
    priorityTasks.push({
      id: task.id,
      type: 'form_due',
      title: `${task.form.name} - ${task.client.couple_names}`,
      description: `Due ${formatDistanceToNow(new Date(task.due_date), { addSuffix: true })}`,
      priorityScore,
      urgencyFactors,
      client: {
        id: task.client.id,
        name: task.client.couple_names,
        weddingDate: task.client.wedding_date
      },
      dueDate: task.due_date,
      status: task.status === 'partial' ? 'in_progress' : 'pending',
      quickActions
    });
  }
  
  // Step 5: Sort by priority and save to cache
  priorityTasks.sort((a, b) => b.priorityScore - a.priorityScore);
  
  await supabase
    .from('priority_tasks')
    .upsert(
      priorityTasks.map(task => ({
        user_id: userId,
        task_type: task.type,
        reference_id: task.id,
        client_id: task.client.id,
        title: task.title,
        description: task.description,
        priority_score: task.priorityScore,
        urgency_factors: task.urgencyFactors,
        due_date: task.dueDate,
        completion_status: task.status,
        quick_actions: task.quickActions
      })),
      { onConflict: 'user_id,reference_id' }
    );
}
```

#### Example 2: Real-time Widget State Management
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
export function useWidgetState<T>(widgetType: string, refreshFn: () => Promise<T>) {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [lastRefresh, setLastRefresh] = useState<Date | null>(null);
  
  // Step 1: Initial data fetch with caching
  const fetchData = useCallback(async (forceRefresh = false) => {
    try {
      setLoading(true);
      setError(null);
      
      // Check cache first unless force refresh
      if (!forceRefresh && lastRefresh) {
        const cacheAge = Date.now() - lastRefresh.getTime();
        const cacheValidDuration = 5 * 60 * 1000; // 5 minutes
        
        if (cacheAge < cacheValidDuration) {
          setLoading(false);
          return;
        }
      }
      
      const result = await refreshFn();
      setData(result);
      setLastRefresh(new Date());
      
      // Save to widget state cache
      await supabase
        .from('widget_states')
        .upsert({
          user_id: auth.user?.id,
          widget_type: widgetType,
          state_data: result,
          expires_at: new Date(Date.now() + 5 * 60 * 1000).toISOString()
        });
        
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
      console.error(`Widget ${widgetType} refresh failed:`, err);
    } finally {
      setLoading(false);
    }
  }, [widgetType, refreshFn, lastRefresh]);
  
  // Step 2: Set up real-time subscriptions
  useEffect(() => {
    let subscription: RealtimeSubscription | null = null;
    
    const setupRealTimeUpdates = () => {
      subscription = supabase
        .channel(`widget:${widgetType}:${auth.user?.id}`)
        .on('postgres_changes', {
          event: '*',
          schema: 'public',
          table: getTableForWidgetType(widgetType)
        }, (payload) => {
          // Debounce rapid updates
          debounce(() => {
            fetchData(true);
          }, 1000)();
        })
        .subscribe();
    };
    
    if (auth.user?.id) {
      setupRealTimeUpdates();
    }
    
    return () => {
      if (subscription) {
        supabase.removeChannel(subscription);
      }
    };
  }, [widgetType, fetchData]);
  
  // Step 3: Set up periodic refresh
  useEffect(() => {
    const refreshInterval = setInterval(() => {
      fetchData(true);
    }, 5 * 60 * 1000); // Refresh every 5 minutes
    
    return () => clearInterval(refreshInterval);
  }, [fetchData]);
  
  // Step 4: Initial fetch
  useEffect(() => {
    fetchData();
  }, [fetchData]);
  
  return {
    data,
    loading,
    error,
    lastRefresh,
    refresh: () => fetchData(true)
  };
}

// Helper function to determine which table triggers widget updates
function getTableForWidgetType(widgetType: string): string {
  const tableMap = {
    'todays-tasks': 'priority_tasks',
    'client-activity': 'client_activity',
    'wedding-countdown': 'client_profiles',
    'performance-metrics': 'performance_snapshots'
  };
  
  return tableMap[widgetType] || 'priority_tasks';
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for widget patterns and real-time updates
- [ ] Playwright: Test widget interactions and priority updates
- [x] Filesystem: Access widget component directories

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/supabase/supabase", "realtime updates", 2000);
await mcp__context7__get-library-docs("/date-fns/date-fns", "date calculations", 2000);
await mcp__context7__get-library-docs("/recharts/recharts", "performance charts", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('Priority Algorithm', () => {
  it('should calculate correct priority scores', () => {
    const algorithm = new PriorityAlgorithm();
    
    const urgentTask = {
      type: 'payment_overdue',
      dueDate: new Date(Date.now() - 1000 * 60 * 60), // 1 hour overdue
      clientTier: 'vip'
    };
    
    const routineTask = {
      type: 'manual_task',
      dueDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 1 week away
      clientTier: 'standard'
    };
    
    expect(algorithm.calculatePriorityScore(urgentTask)).toBeGreaterThan(80);
    expect(algorithm.calculatePriorityScore(routineTask)).toBeLessThan(40);
  });
  
  it('should generate appropriate quick actions', () => {
    const task = {
      type: 'form_due',
      priorityScore: 85,
      dueDate: new Date(Date.now() + 2 * 60 * 60 * 1000) // 2 hours
    };
    
    const actions = generateQuickActions(task);
    
    expect(actions.some(a => a.action === 'call_client')).toBe(true);
    expect(actions.some(a => a.action === 'send_reminder')).toBe(true);
  });
});

describe('Widget State Management', () => {
  it('should cache widget data correctly', async () => {
    const { result } = renderHook(() => 
      useWidgetState('todays-tasks', () => Promise.resolve(mockTasks))
    );
    
    await waitFor(() => {
      expect(result.current.data).toBeDefined();
      expect(result.current.loading).toBe(false);
    });
    
    // Verify cache was saved
    const cached = await supabase
      .from('widget_states')
      .select('*')
      .eq('widget_type', 'todays-tasks')
      .single();
      
    expect(cached.data).toBeDefined();
  });
  
  it('should handle real-time updates', async () => {
    const { result } = renderHook(() => useWidgetRealTime());
    
    // Simulate database change
    act(() => {
      supabase.channel.emit('postgres_changes', {
        eventType: 'INSERT',
        new: { id: '1', priority_score: 90 }
      });
    });
    
    await waitFor(() => {
      expect(result.current.tasks[0].priorityScore).toBe(90);
    });
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Priority widgets display and update correctly', async () => {
  await mcp__playwright__browser_navigate({url: '/dashboard'});
  
  // Verify today's tasks widget
  await mcp__playwright__browser_wait_for({text: "Today's Focus"});
  
  // Check priority indicators
  await mcp__playwright__browser_wait_for({text: 'URGENT'});
  
  // Test quick action
  await mcp__playwright__browser_click({
    element: 'Send reminder button',
    ref: '[data-testid="quick-action-send-reminder"]'
  });
  
  await mcp__playwright__browser_wait_for({text: 'Reminder sent'});
  
  // Verify task status updated
  await mcp__playwright__browser_wait_for({text: 'In Progress'});
});

test('Wedding countdown widget shows correct information', async () => {
  await mcp__playwright__browser_navigate({url: '/dashboard'});
  
  // Check countdown display
  await mcp__playwright__browser_wait_for({text: '3 days'});
  
  // Test weather integration
  await mcp__playwright__browser_click({
    element: 'Weather forecast',
    ref: '[data-testid="weather-forecast"]'
  });
  
  await mcp__playwright__browser_wait_for({text: 'Sunny, 75°F'});
  
  // Test contact quick action
  await mcp__playwright__browser_click({
    element: 'Call venue button',
    ref: '[data-testid="contact-venue"]'
  });
  
  // Verify phone number displays
  await mcp__playwright__browser_wait_for({text: '+1 (555) 123-4567'});
});

test('Performance metrics widget displays trends', async () => {
  await mcp__playwright__browser_navigate({url: '/dashboard'});
  
  // Verify metrics display
  await mcp__playwright__browser_wait_for({text: 'Forms Completed'});
  await mcp__playwright__browser_wait_for({text: '+15%'});
  
  // Test drill-down
  await mcp__playwright__browser_click({
    element: 'Forms completed metric',
    ref: '[data-testid="metric-forms-completed"]'
  });
  
  await mcp__playwright__browser_wait_for({url: '/analytics/forms'});
});
```

### ACCEPTANCE CRITERIA
- [ ] Priority algorithm scores tasks 1-100 based on urgency and impact
- [ ] Today's tasks widget shows top 10 prioritized items
- [ ] Real-time updates appear within 5 seconds of changes
- [ ] Quick actions execute without page reload
- [ ] Wedding countdown updates daily with weather integration
- [ ] Performance metrics show week-over-week trends
- [ ] Color coding clearly indicates urgency levels
- [ ] All widgets load in under 2 seconds
- [ ] Mobile widgets maintain full functionality
- [ ] Widget state persists across browser sessions
- [ ] Error states handle network failures gracefully
- [ ] Accessibility: Screen reader compatible priority indicators

### DEPENDENCIES
- Must complete after: WS-007 (Main Dashboard Layout)
- Must complete before: WS-010 (Activity Feed integration)
- Shares code with: WS-007 (dashboard grid), WS-010 (activity data)

### ESTIMATED EFFORT
- Team A Frontend: 26 hours
- Team B Backend: 18 hours
- Team C Integration: 6 hours
- Total: 50 hours