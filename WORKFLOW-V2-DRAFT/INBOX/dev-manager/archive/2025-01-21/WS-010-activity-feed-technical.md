# TECHNICAL SPECIFICATION: WS-010 - Activity Feed
## Generated by Feature Development Session - 2025-08-21

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding venue coordinator tracking client engagement across multiple touchpoints
**I want to:** See real-time activity stream of all client interactions and system events
**So that:** I can immediately respond to client actions instead of checking multiple systems throughout the day

**Real Wedding Scenario:**
A venue coordinator manages 50 active couples and needs to track: form completions, email opens, dashboard logins, payment confirmations, and meeting bookings. Currently they check email, payment portal, form responses, and calendar separately every 30 minutes - taking 10+ minutes per check across 8+ hours daily. With real-time activity feed, they see "Sarah opened catering form 2 minutes ago," "Mike's payment processed," "Lisa logged into dashboard" instantly in one stream. This lets them send immediate follow-ups while couples are actively engaged, increasing response rates from 40% to 75% and reducing coordinator monitoring time from 80+ minutes to 15 minutes daily.

### SPECIFICATION SOURCE
- **Feature ID:** WS-010
- **Original Spec:** /CORE-SPECIFICATIONS/02-WEDSYNC-SUPPLIER-PLATFORM/02-Dashboard/04-activity-feed md.md
- **Current Implementation:** 0% complete
- **Files to Modify:**
  - /src/components/widgets/ClientActivityWidget.tsx (use activity feed)
- **New Files to Create:**
  - /src/components/activity/ActivityFeed.tsx
  - /src/components/activity/ActivityItem.tsx
  - /src/components/activity/ActivityFilters.tsx
  - /src/lib/activity/activityTracker.ts
  - /src/lib/stores/activityStore.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Main activity tracking table
CREATE TABLE IF NOT EXISTS client_activity (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  client_id UUID REFERENCES client_profiles(id) ON DELETE CASCADE,
  activity_type TEXT CHECK (activity_type IN (
    'email_opened', 'email_clicked', 'form_started', 'form_completed', 'form_abandoned',
    'dashboard_login', 'document_downloaded', 'meeting_scheduled', 'meeting_rescheduled',
    'payment_processed', 'journey_milestone', 'task_completed', 'message_sent',
    'message_received', 'profile_updated', 'photo_uploaded'
  )) NOT NULL,
  title TEXT NOT NULL,
  description TEXT,
  metadata JSONB DEFAULT '{}',
  importance_level TEXT CHECK (importance_level IN ('low', 'medium', 'high', 'urgent')) DEFAULT 'medium',
  read_status BOOLEAN DEFAULT false,
  created_at TIMESTAMP DEFAULT NOW(),
  
  INDEX(supplier_id, created_at DESC),
  INDEX(client_id, created_at DESC),
  INDEX(activity_type),
  INDEX(importance_level),
  INDEX(read_status)
);

-- Activity aggregation for performance
CREATE TABLE IF NOT EXISTS activity_summary (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  date DATE NOT NULL,
  activity_counts JSONB NOT NULL, -- Count by activity type
  total_activities INTEGER NOT NULL,
  urgent_activities INTEGER DEFAULT 0,
  created_at TIMESTAMP DEFAULT NOW(),
  
  UNIQUE(supplier_id, date)
);

-- Real-time activity subscriptions
CREATE TABLE IF NOT EXISTS activity_subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  client_id UUID REFERENCES client_profiles(id),
  activity_types TEXT[] DEFAULT ARRAY[]::TEXT[], -- Empty = all types
  notification_methods TEXT[] DEFAULT ARRAY['in_app'], -- in_app, email, sms
  enabled BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW()
);
```

#### API Endpoints Required
```typescript
// GET /api/activity/feed
interface GetActivityFeedRequest {
  page?: number;
  limit?: number;
  clientId?: string;
  activityTypes?: string[];
  importanceLevel?: ('low' | 'medium' | 'high' | 'urgent')[];
  dateRange?: {
    start: string;
    end: string;
  };
  unreadOnly?: boolean;
}

interface GetActivityFeedResponse {
  success: boolean;
  data: {
    activities: Array<{
      id: string;
      clientId: string;
      client: {
        name: string;
        photoUrl?: string;
        weddingDate: string;
      };
      type: string;
      title: string;
      description: string;
      importanceLevel: 'low' | 'medium' | 'high' | 'urgent';
      metadata: Record<string, any>;
      readStatus: boolean;
      timestamp: string;
      relativeTime: string;
    }>;
    pagination: {
      page: number;
      limit: number;
      total: number;
      hasMore: boolean;
    };
    summary: {
      totalUnread: number;
      urgentCount: number;
      todayCount: number;
    };
  };
}

// POST /api/activity/track
interface TrackActivityRequest {
  clientId: string;
  activityType: string;
  title: string;
  description?: string;
  metadata?: Record<string, any>;
  importanceLevel?: 'low' | 'medium' | 'high' | 'urgent';
}

// PATCH /api/activity/mark-read
interface MarkActivityReadRequest {
  activityIds: string[];
  readStatus: boolean;
}

// GET /api/activity/summary
interface GetActivitySummaryResponse {
  success: boolean;
  data: {
    today: {
      totalActivities: number;
      byType: Record<string, number>;
      urgentActivities: number;
    };
    thisWeek: {
      totalActivities: number;
      dailyBreakdown: Array<{
        date: string;
        count: number;
      }>;
      trends: {
        changeFromLastWeek: number; // percentage
      };
    };
    mostActiveClients: Array<{
      clientId: string;
      clientName: string;
      activityCount: number;
    }>;
  };
}
```

#### Frontend Components Required
```typescript
// Component: ActivityFeed
// Location: /src/components/activity/ActivityFeed.tsx

interface ActivityFeedProps {
  activities: Activity[];
  loading: boolean;
  onLoadMore: () => void;
  onActivityClick: (activity: Activity) => void;
  onMarkAsRead: (activityId: string) => void;
  filters: ActivityFilters;
  onFiltersChange: (filters: ActivityFilters) => void;
}

// Key functionality:
- Infinite scroll with virtualized rendering
- Real-time updates via WebSocket
- Activity grouping by time periods
- Unread indicators with counts
- Click-to-expand detailed views
- Mark as read/unread actions
- Filter by client, type, importance

// Component: ActivityItem
// Location: /src/components/activity/ActivityItem.tsx

interface ActivityItemProps {
  activity: Activity;
  onMarkAsRead: (id: string) => void;
  onClick: (activity: Activity) => void;
  showClient?: boolean;
}

// Key functionality:
- Activity type icons with colors
- Client photo and name display
- Relative timestamp with tooltips
- Importance level indicators
- Read/unread visual states
- Quick action buttons
- Hover effects with previews

// Component: ActivityFilters
// Location: /src/components/activity/ActivityFilters.tsx

interface ActivityFiltersProps {
  filters: ActivityFilters;
  onChange: (filters: ActivityFilters) => void;
  availableTypes: string[];
  clientOptions: Array<{ id: string; name: string }>;
}

// Key functionality:
- Filter by activity type with multi-select
- Client selection dropdown
- Importance level filter
- Date range picker
- Unread only toggle
- Clear all filters action
- Save filter presets
```

#### Integration Points
```typescript
// Activity tracking service
export class ActivityTracker {
  private supplierId: string;
  
  constructor(supplierId: string) {
    this.supplierId = supplierId;
  }
  
  async trackActivity(event: ActivityEvent): Promise<void> {
    // Step 1: Determine importance level
    const importanceLevel = this.calculateImportance(event);
    
    // Step 2: Create activity record
    const { error } = await supabase
      .from('client_activity')
      .insert({
        supplier_id: this.supplierId,
        client_id: event.clientId,
        activity_type: event.type,
        title: event.title,
        description: event.description,
        metadata: event.metadata,
        importance_level: importanceLevel
      });
      
    if (error) {
      console.error('Failed to track activity:', error);
      return;
    }
    
    // Step 3: Update daily summary
    await this.updateDailySummary(event.type);
    
    // Step 4: Trigger real-time notifications
    await this.triggerNotifications(event, importanceLevel);
  }
  
  private calculateImportance(event: ActivityEvent): ImportanceLevel {
    const urgentTypes = ['payment_processed', 'form_abandoned', 'meeting_rescheduled'];
    const highTypes = ['form_completed', 'dashboard_login', 'email_clicked'];
    const mediumTypes = ['email_opened', 'form_started', 'document_downloaded'];
    
    if (urgentTypes.includes(event.type)) return 'urgent';
    if (highTypes.includes(event.type)) return 'high';
    if (mediumTypes.includes(event.type)) return 'medium';
    
    return 'low';
  }
  
  private async triggerNotifications(event: ActivityEvent, importance: ImportanceLevel): Promise<void> {
    // Check if user has notifications enabled for this activity type
    const { data: subscriptions } = await supabase
      .from('activity_subscriptions')
      .select('*')
      .eq('user_id', this.supplierId)
      .eq('enabled', true);
      
    for (const subscription of subscriptions || []) {
      if (subscription.activity_types.length === 0 || 
          subscription.activity_types.includes(event.type)) {
        
        // Send in-app notification via real-time channel
        if (subscription.notification_methods.includes('in_app')) {
          await supabase.channel(`activity:${this.supplierId}`)
            .send({
              type: 'broadcast',
              event: 'new_activity',
              payload: {
                activity: event,
                importance
              }
            });
        }
        
        // Send email for urgent activities
        if (importance === 'urgent' && subscription.notification_methods.includes('email')) {
          // Queue email notification
          await this.queueEmailNotification(event);
        }
      }
    }
  }
}

// Store: activityStore
interface ActivityStore {
  activities: Activity[];
  loading: boolean;
  filters: ActivityFilters;
  pagination: PaginationInfo;
  unreadCount: number;
  
  fetchActivities: (filters?: ActivityFilters) => Promise<void>;
  loadMoreActivities: () => Promise<void>;
  markAsRead: (activityIds: string[]) => Promise<void>;
  setFilters: (filters: ActivityFilters) => void;
  
  subscribeToRealTime: () => void;
  unsubscribeFromRealTime: () => void;
}

// Real-time activity updates
export function useActivityRealTime() {
  const { addActivity, updateUnreadCount } = useActivityStore();
  
  useEffect(() => {
    const subscription = supabase
      .channel(`activity:${auth.user?.id}`)
      .on('broadcast', { event: 'new_activity' }, (payload) => {
        const newActivity = payload.activity;
        
        // Add to activity feed
        addActivity(newActivity);
        
        // Update unread count
        updateUnreadCount(prev => prev + 1);
        
        // Show toast notification for urgent activities
        if (payload.importance === 'urgent') {
          toast.error(newActivity.title, {
            description: newActivity.description,
            action: {
              label: 'View',
              onClick: () => navigateToActivity(newActivity)
            }
          });
        }
      })
      .subscribe();
      
    return () => {
      supabase.removeChannel(subscription);
    };
  }, []);
}
```

### CODE EXAMPLES

#### Example 1: Intelligent Activity Tracking with Context
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
export class SmartActivityTracker extends ActivityTracker {
  
  async trackFormActivity(formId: string, clientId: string, action: 'started' | 'completed' | 'abandoned'): Promise<void> {
    // Step 1: Get form and client context
    const [formData, clientData] = await Promise.all([
      supabase.from('forms').select('name, form_type').eq('id', formId).single(),
      supabase.from('client_profiles').select('couple_names, wedding_date').eq('id', clientId).single()
    ]);
    
    if (!formData.data || !clientData.data) return;
    
    // Step 2: Calculate context-aware importance
    const weddingDate = new Date(clientData.data.wedding_date);
    const daysUntilWedding = Math.ceil((weddingDate.getTime() - Date.now()) / (1000 * 60 * 60 * 24));
    
    let importanceLevel: ImportanceLevel = 'medium';
    
    if (action === 'abandoned' && daysUntilWedding <= 14) {
      importanceLevel = 'urgent'; // Form abandoned close to wedding
    } else if (action === 'completed' && formData.data.form_type === 'dietary_requirements') {
      importanceLevel = 'high'; // Critical form completed
    } else if (action === 'started' && daysUntilWedding <= 7) {
      importanceLevel = 'high'; // Any activity close to wedding
    }
    
    // Step 3: Generate contextual title and description
    const titles = {
      started: `${clientData.data.couple_names} started ${formData.data.name}`,
      completed: `${clientData.data.couple_names} completed ${formData.data.name}`,
      abandoned: `${clientData.data.couple_names} abandoned ${formData.data.name}`
    };
    
    const descriptions = {
      started: `Form in progress - ${daysUntilWedding} days until wedding`,
      completed: `All questions answered - ready for review`,
      abandoned: `Form left incomplete - may need follow-up`
    };
    
    // Step 4: Track with rich metadata
    await this.trackActivity({
      clientId,
      type: `form_${action}`,
      title: titles[action],
      description: descriptions[action],
      metadata: {
        formId,
        formName: formData.data.name,
        formType: formData.data.form_type,
        daysUntilWedding,
        weddingDate: clientData.data.wedding_date,
        actionContext: this.getActionContext(action, daysUntilWedding)
      },
      importanceLevel
    });
    
    // Step 5: Trigger contextual follow-up actions
    if (action === 'abandoned' && importanceLevel === 'urgent') {
      await this.scheduleFollowUpReminder(clientId, formId, '2 hours');
    } else if (action === 'completed' && formData.data.form_type === 'dietary_requirements') {
      await this.notifyCateringTeam(clientId, formId);
    }
  }
  
  private getActionContext(action: string, daysUntilWedding: number): string {
    if (daysUntilWedding <= 7) return 'wedding_week';
    if (daysUntilWedding <= 30) return 'final_month';
    if (daysUntilWedding <= 90) return 'planning_phase';
    return 'early_planning';
  }
  
  private async scheduleFollowUpReminder(clientId: string, formId: string, delay: string): Promise<void> {
    // Schedule automated follow-up
    await supabase.rpc('schedule_reminder', {
      client_id: clientId,
      form_id: formId,
      delay_interval: delay,
      reminder_type: 'form_completion'
    });
  }
}
```

#### Example 2: Optimized Activity Feed with Intelligent Grouping
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
export function useOptimizedActivityFeed(filters: ActivityFilters) {
  const [activities, setActivities] = useState<GroupedActivity[]>([]);
  const [loading, setLoading] = useState(true);
  const [hasMore, setHasMore] = useState(true);
  
  // Step 1: Fetch activities with intelligent grouping
  const fetchActivities = useCallback(async (offset = 0) => {
    try {
      setLoading(true);
      
      // Build dynamic query based on filters
      let query = supabase
        .from('client_activity')
        .select(`
          *,
          client:client_profiles(id, couple_names, photo_url, wedding_date)
        `)
        .eq('supplier_id', auth.user?.id)
        .order('created_at', { ascending: false });
      
      // Apply filters
      if (filters.clientId) {
        query = query.eq('client_id', filters.clientId);
      }
      
      if (filters.activityTypes?.length) {
        query = query.in('activity_type', filters.activityTypes);
      }
      
      if (filters.importanceLevel?.length) {
        query = query.in('importance_level', filters.importanceLevel);
      }
      
      if (filters.unreadOnly) {
        query = query.eq('read_status', false);
      }
      
      if (filters.dateRange) {
        query = query
          .gte('created_at', filters.dateRange.start)
          .lte('created_at', filters.dateRange.end);
      }
      
      // Pagination
      query = query.range(offset, offset + 24); // 25 items per page
      
      const { data, error } = await query;
      
      if (error) throw error;
      
      // Step 2: Group activities intelligently
      const groupedActivities = groupActivitiesByTime(data || []);
      
      if (offset === 0) {
        setActivities(groupedActivities);
      } else {
        setActivities(prev => mergeActivityGroups(prev, groupedActivities));
      }
      
      setHasMore((data || []).length === 25);
      
    } catch (error) {
      console.error('Failed to fetch activities:', error);
      toast.error('Failed to load activities');
    } finally {
      setLoading(false);
    }
  }, [filters]);
  
  // Step 3: Group activities by time periods
  const groupActivitiesByTime = (activities: Activity[]): GroupedActivity[] => {
    const groups: Record<string, Activity[]> = {};
    const now = new Date();
    
    activities.forEach(activity => {
      const activityDate = new Date(activity.created_at);
      const diffInHours = (now.getTime() - activityDate.getTime()) / (1000 * 60 * 60);
      
      let groupKey: string;
      
      if (diffInHours < 1) {
        groupKey = 'Just now';
      } else if (diffInHours < 24) {
        groupKey = 'Today';
      } else if (diffInHours < 48) {
        groupKey = 'Yesterday';
      } else if (diffInHours < 168) { // 7 days
        groupKey = format(activityDate, 'EEEE'); // Day name
      } else {
        groupKey = format(activityDate, 'MMM d'); // Month day
      }
      
      if (!groups[groupKey]) {
        groups[groupKey] = [];
      }
      
      groups[groupKey].push(activity);
    });
    
    // Step 4: Convert to grouped format with metadata
    return Object.entries(groups).map(([period, periodActivities]) => ({
      period,
      activities: periodActivities,
      urgentCount: periodActivities.filter(a => a.importance_level === 'urgent').length,
      unreadCount: periodActivities.filter(a => !a.read_status).length,
      totalCount: periodActivities.length
    }));
  };
  
  // Step 5: Set up real-time updates
  useEffect(() => {
    const subscription = supabase
      .channel(`activity_feed:${auth.user?.id}`)
      .on('postgres_changes', {
        event: 'INSERT',
        schema: 'public',
        table: 'client_activity',
        filter: `supplier_id=eq.${auth.user?.id}`
      }, (payload) => {
        // Add new activity to the feed
        const newActivity = payload.new as Activity;
        
        setActivities(prev => {
          const updatedGroups = [...prev];
          
          // Add to "Just now" group or create it
          const justNowGroup = updatedGroups.find(g => g.period === 'Just now');
          
          if (justNowGroup) {
            justNowGroup.activities.unshift(newActivity);
            justNowGroup.totalCount++;
            if (newActivity.importance_level === 'urgent') justNowGroup.urgentCount++;
            if (!newActivity.read_status) justNowGroup.unreadCount++;
          } else {
            updatedGroups.unshift({
              period: 'Just now',
              activities: [newActivity],
              urgentCount: newActivity.importance_level === 'urgent' ? 1 : 0,
              unreadCount: newActivity.read_status ? 0 : 1,
              totalCount: 1
            });
          }
          
          return updatedGroups;
        });
      })
      .subscribe();
      
    return () => {
      supabase.removeChannel(subscription);
    };
  }, []);
  
  // Step 6: Initial fetch and filter updates
  useEffect(() => {
    fetchActivities(0);
  }, [fetchActivities]);
  
  return {
    activities,
    loading,
    hasMore,
    loadMore: () => fetchActivities(activities.reduce((total, group) => total + group.activities.length, 0)),
    refresh: () => fetchActivities(0)
  };
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for real-time systems and activity tracking
- [ ] Playwright: Test activity feed interactions and real-time updates
- [x] Filesystem: Access activity component directories

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/supabase/supabase", "realtime channels", 3000);
await mcp__context7__get-library-docs("/tanstack/react-query", "infinite queries", 2000);
await mcp__context7__get-library-docs("/date-fns/date-fns", "time formatting", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('Activity Tracking', () => {
  it('should calculate correct importance levels', () => {
    const tracker = new SmartActivityTracker('user1');
    
    const urgentEvent = {
      type: 'form_abandoned',
      clientId: 'client1',
      daysUntilWedding: 3
    };
    
    const normalEvent = {
      type: 'email_opened',
      clientId: 'client1',
      daysUntilWedding: 60
    };
    
    expect(tracker.calculateImportance(urgentEvent)).toBe('urgent');
    expect(tracker.calculateImportance(normalEvent)).toBe('medium');
  });
  
  it('should group activities by time correctly', () => {
    const activities = [
      { created_at: new Date().toISOString() }, // Just now
      { created_at: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString() }, // 2 hours ago
      { created_at: new Date(Date.now() - 25 * 60 * 60 * 1000).toISOString() } // Yesterday
    ];
    
    const grouped = groupActivitiesByTime(activities);
    
    expect(grouped.find(g => g.period === 'Just now')).toBeDefined();
    expect(grouped.find(g => g.period === 'Today')).toBeDefined();
    expect(grouped.find(g => g.period === 'Yesterday')).toBeDefined();
  });
});

describe('Activity Feed', () => {
  it('should handle real-time updates correctly', async () => {
    const { result } = renderHook(() => useOptimizedActivityFeed({}));
    
    // Simulate new activity
    act(() => {
      supabase.channel.emit('postgres_changes', {
        eventType: 'INSERT',
        new: { id: '1', title: 'New Activity', importance_level: 'high' }
      });
    });
    
    await waitFor(() => {
      expect(result.current.activities[0].activities[0].title).toBe('New Activity');
    });
  });
  
  it('should filter activities correctly', async () => {
    const filters = { activityTypes: ['form_completed'], unreadOnly: true };
    const { result } = renderHook(() => useOptimizedActivityFeed(filters));
    
    await waitFor(() => {
      const allActivities = result.current.activities.flatMap(g => g.activities);
      expect(allActivities.every(a => a.activity_type === 'form_completed')).toBe(true);
      expect(allActivities.every(a => !a.read_status)).toBe(true);
    });
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Activity feed displays and updates in real-time', async () => {
  await mcp__playwright__browser_navigate({url: '/dashboard'});
  
  // Verify activity feed widget
  await mcp__playwright__browser_wait_for({text: 'Client Activity'});
  
  // Check for activities
  await mcp__playwright__browser_wait_for({text: 'completed'});
  
  // Test filtering
  await mcp__playwright__browser_click({
    element: 'Filter activities',
    ref: '[data-testid="activity-filters"]'
  });
  
  await mcp__playwright__browser_click({
    element: 'Urgent only',
    ref: '[data-testid="filter-urgent"]'
  });
  
  // Verify filtered results
  await mcp__playwright__browser_wait_for({text: 'URGENT'});
  
  // Test mark as read
  await mcp__playwright__browser_click({
    element: 'Mark as read',
    ref: '[data-testid="mark-read-1"]'
  });
  
  await mcp__playwright__browser_wait_for({text: 'Activity marked as read'});
});

test('Activity feed infinite scroll works', async () => {
  await mcp__playwright__browser_navigate({url: '/dashboard'});
  
  // Scroll to bottom of activity feed
  await mcp__playwright__browser_evaluate({
    function: () => {
      const activityFeed = document.querySelector('[data-testid="activity-feed"]');
      activityFeed.scrollTop = activityFeed.scrollHeight;
    }
  });
  
  // Verify more activities load
  await mcp__playwright__browser_wait_for({text: 'Loading more activities'});
  await mcp__playwright__browser_wait_for({text: 'Yesterday'});
});

test('Activity notifications appear for urgent events', async () => {
  await mcp__playwright__browser_navigate({url: '/dashboard'});
  
  // Simulate urgent activity via WebSocket
  await mcp__playwright__browser_evaluate({
    function: () => {
      window.supabase.channel('activity_test').send({
        type: 'broadcast',
        event: 'new_activity',
        payload: {
          activity: {
            title: 'Urgent: Payment Failed',
            description: 'Sarah\'s payment was declined'
          },
          importance: 'urgent'
        }
      });
    }
  });
  
  // Verify toast notification appears
  await mcp__playwright__browser_wait_for({text: 'Urgent: Payment Failed'});
  
  // Verify activity appears in feed
  await mcp__playwright__browser_wait_for({text: 'Sarah\'s payment was declined'});
});
```

### ACCEPTANCE CRITERIA
- [ ] Activity feed updates in real-time without page refresh
- [ ] Activities grouped logically by time periods
- [ ] Importance levels clearly indicated with colors
- [ ] Infinite scroll loads additional activities smoothly
- [ ] Filtering by client, type, and importance works correctly
- [ ] Mark as read/unread functionality works
- [ ] Urgent activities trigger toast notifications
- [ ] Feed performance handles 1000+ activities
- [ ] Mobile feed maintains full functionality
- [ ] Activity context includes relevant metadata
- [ ] Unread count badge updates accurately
- [ ] Loading states prevent layout shift

### DEPENDENCIES
- Must complete after: WS-002 (Client Profiles), WS-007 (Dashboard Layout)
- Must complete before: None (enhances dashboard)
- Shares code with: WS-009 (widget integration), WS-007 (dashboard)

### ESTIMATED EFFORT
- Team A Frontend: 22 hours
- Team B Backend: 16 hours
- Team C Integration: 6 hours
- Total: 44 hours