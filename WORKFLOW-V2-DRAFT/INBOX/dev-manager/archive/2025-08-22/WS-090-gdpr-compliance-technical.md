# TECHNICAL SPECIFICATION: WS-090 - GDPR Compliance
## Generated by Feature Development Session - 2025-08-22

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** European wedding photographer processing guest personal data
**I want to:** Comply with GDPR requirements for data processing and subject rights
**So that:** I can legally operate in the EU without facing â‚¬20M fines and maintain client trust in my data handling practices

**Real Wedding Scenario:**
A UK-based photographer receives a request from a guest at a French wedding asking to see all personal data collected about them and to delete their information after the wedding. Under GDPR, they have 30 days to provide a complete data export and must be able to permanently delete the guest's data while maintaining the couple's wedding records. Non-compliance could result in fines up to 4% of annual revenue.

### SPECIFICATION SOURCE
- **Feature ID:** WS-090
- **Original Spec:** /CORE-SPECIFICATIONS/10-SECURITY-COMPLIANCE/03-gdpr-compliance md.md
- **Current Implementation:** 0% complete
- **Files to Modify:** 
  - /wedsync/src/app/api/privacy/*.ts
  - /wedsync/src/components/privacy/CookieBanner.tsx
  - /wedsync/src/lib/compliance/gdpr.ts
- **New Files to Create:** 
  - /wedsync/src/lib/compliance/data-subject-rights.ts
  - /wedsync/src/lib/compliance/consent-management.ts
  - /wedsync/src/lib/compliance/data-retention.ts
  - /wedsync/src/components/privacy/ConsentManager.tsx
  - /wedsync/src/components/privacy/DataAccessRequest.tsx

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Consent tracking for GDPR compliance
CREATE TABLE consent_records (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  consent_type TEXT NOT NULL, -- marketing, cookies, data_sharing
  granted BOOLEAN NOT NULL,
  version TEXT NOT NULL,
  ip_address INET,
  user_agent TEXT,
  granted_at TIMESTAMPTZ,
  withdrawn_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id, consent_type)
);

-- Data subject rights requests
CREATE TABLE data_subject_requests (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id),
  request_type TEXT NOT NULL, -- access, rectification, erasure, portability
  status TEXT DEFAULT 'pending', -- pending, in_progress, completed, rejected
  reason TEXT,
  response_data JSONB,
  requested_at TIMESTAMPTZ DEFAULT NOW(),
  completed_at TIMESTAMPTZ,
  expires_at TIMESTAMPTZ DEFAULT NOW() + INTERVAL '30 days'
);

-- Processing activities record (Article 30)
CREATE TABLE processing_records (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  controller_name TEXT DEFAULT 'WedSync Ltd',
  controller_contact JSONB,
  processing_purpose TEXT NOT NULL,
  data_categories TEXT[],
  data_subjects TEXT[],
  recipients TEXT[],
  international_transfers JSONB,
  retention_period TEXT,
  security_measures TEXT[],
  lawful_basis TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Data breach incident tracking
CREATE TABLE data_breaches (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  incident_date TIMESTAMPTZ NOT NULL,
  discovered_date TIMESTAMPTZ DEFAULT NOW(),
  description TEXT NOT NULL,
  data_categories TEXT[],
  affected_users INTEGER,
  risk_level TEXT, -- low, medium, high
  authority_notified BOOLEAN DEFAULT false,
  users_notified BOOLEAN DEFAULT false,
  mitigation_measures TEXT[],
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Function to record consent with full audit trail
CREATE OR REPLACE FUNCTION record_consent(
  p_user_id UUID,
  p_consent_type TEXT,
  p_granted BOOLEAN,
  p_version TEXT,
  p_ip_address INET,
  p_user_agent TEXT
) RETURNS UUID AS $$
DECLARE
  v_consent_id UUID;
BEGIN
  INSERT INTO consent_records (
    user_id, consent_type, granted, version,
    ip_address, user_agent, granted_at, withdrawn_at
  ) VALUES (
    p_user_id, p_consent_type, p_granted, p_version,
    p_ip_address, p_user_agent,
    CASE WHEN p_granted THEN NOW() ELSE NULL END,
    CASE WHEN NOT p_granted THEN NOW() ELSE NULL END
  )
  ON CONFLICT (user_id, consent_type) DO UPDATE
  SET
    granted = EXCLUDED.granted,
    version = EXCLUDED.version,
    granted_at = CASE WHEN EXCLUDED.granted THEN NOW() ELSE consent_records.granted_at END,
    withdrawn_at = CASE WHEN NOT EXCLUDED.granted THEN NOW() ELSE NULL END
  RETURNING id INTO v_consent_id;

  RETURN v_consent_id;
END;
$$ LANGUAGE plpgsql;

-- Crypto-shredding function for right to erasure
CREATE OR REPLACE FUNCTION crypto_shred_user(p_user_id UUID)
RETURNS void AS $$
BEGIN
  -- Delete user's encryption key (makes all encrypted data unrecoverable)
  DELETE FROM user_encryption_keys WHERE user_id = p_user_id;
  
  -- Mark user data as crypto-shredded
  UPDATE auth.users SET raw_user_meta_data = raw_user_meta_data || '{"crypto_shredded": true}'
  WHERE id = p_user_id;
  
  -- Log the action for compliance
  INSERT INTO data_subject_requests (user_id, request_type, status, completed_at)
  VALUES (p_user_id, 'erasure', 'completed', NOW());
END;
$$ LANGUAGE plpgsql;
```

#### API Endpoints Required
```typescript
// POST /api/privacy/consent
interface ConsentRequest {
  consentType: 'marketing' | 'cookies' | 'data_sharing';
  granted: boolean;
  version: string;
}

interface ConsentResponse {
  success: boolean;
  consentId: string;
}

// POST /api/privacy/data-access-request
interface DataAccessRequest {
  requestType: 'access' | 'rectification' | 'erasure' | 'portability';
  reason?: string;
  corrections?: Record<string, any>;
}

interface DataAccessResponse {
  requestId: string;
  estimatedCompletion: string;
  status: string;
}

// GET /api/privacy/export-data
interface DataExportResponse {
  personalData: any;
  processingActivities: any[];
  retentionPeriods: any;
  exportedAt: string;
}
```

#### Frontend Components Required
```typescript
// Component: ConsentManager
// Location: /src/components/privacy/ConsentManager.tsx

interface ConsentManagerProps {
  onConsentChange: (type: string, granted: boolean) => void;
  currentConsents: Record<string, boolean>;
}

// Key functionality:
- Display consent options with clear descriptions
- Allow granular consent management
- Track consent history
- Show withdrawal options
- GDPR-compliant consent flow
```

#### Integration Points
```typescript
// Service: GDPRComplianceService
// Dependencies: Encryption, Data Export, Email Service

class GDPRComplianceService {
  async handleDataAccessRequest(userId: string, requestType: string) {
    // Process data subject rights requests within 30 days
  }
  
  async exportUserData(userId: string) {
    // Generate complete data export in machine-readable format
  }
  
  async cryptoShredUser(userId: string) {
    // Implement right to erasure via crypto-shredding
  }
}
```

### CODE EXAMPLES

#### Example 1: Data Subject Rights Implementation
```typescript
// data-subject-rights.ts
import { createClient } from '@/lib/supabase/server';
import { EncryptionService } from '@/lib/security/encryption';

export class DataSubjectRights {
  private supabase = createClient();
  private encryption = new EncryptionService();

  async handleAccessRequest(userId: string): Promise<UserDataPackage> {
    // Verify identity (additional verification for sensitive requests)
    await this.verifyIdentity(userId);

    // Collect all user data across all tables
    const userData = await this.collectUserData(userId);

    // Generate comprehensive report
    const report = {
      personalData: userData.personal,
      processingActivities: await this.getProcessingActivities(userId),
      recipients: await this.getDataRecipients(userId),
      retentionPeriods: this.getRetentionSchedule(userId),
      rights: this.getUserRights(),
      sources: userData.sources,
      lawfulBasis: await this.getLawfulBasis(userId),
      exportedAt: new Date().toISOString(),
      format: 'JSON',
      version: '1.0'
    };

    // Log the request for audit
    await this.logDataRequest(userId, 'access');

    return this.encryptAndPackage(report);
  }

  async handleErasureRequest(userId: string, reason: string): Promise<void> {
    // Check if erasure is allowed (some data may need to be retained for legal reasons)
    const eligibility = await this.checkErasureEligibility(userId);
    
    if (!eligibility.eligible) {
      throw new Error(`Cannot erase data: ${eligibility.reason}`);
    }

    const trx = await this.supabase.rpc('begin_transaction');

    try {
      // Anonymize data that must be retained for legal/accounting reasons
      await this.anonymizeRequiredData(userId, trx);

      // Delete personal data that can be removed
      await this.deletePersonalData(userId, trx);

      // Crypto-shred encrypted data (right to erasure via crypto-shredding)
      await this.supabase.rpc('crypto_shred_user', { p_user_id: userId });

      // Remove from all marketing lists and external systems
      await this.removeFromExternalSystems(userId);

      // Schedule backup deletion after retention period
      await this.scheduleBackupDeletion(userId);

      await this.supabase.rpc('commit_transaction');

      // Notify data processors/recipients of erasure
      await this.notifyDataRecipients(userId, 'erasure');

    } catch (error) {
      await this.supabase.rpc('rollback_transaction');
      throw error;
    }
  }

  async handlePortabilityRequest(userId: string, format: 'json' | 'csv' | 'xml'): Promise<PortableData> {
    // Only data provided by user or generated through their use (not inferred/analytics data)
    const portableData = await this.collectPortableData(userId);

    const exportPackage = {
      version: '1.0',
      created: new Date().toISOString(),
      format,
      schema: this.getDataSchema(),
      data: this.formatData(portableData, format)
    };

    await this.logDataRequest(userId, 'portability');

    return exportPackage;
  }

  private async collectPortableData(userId: string): Promise<any> {
    // Only collect data provided by the user or generated through their use
    const queries = await Promise.all([
      this.getUserProfile(userId),
      this.getWeddingDetails(userId),
      this.getFormResponses(userId),
      this.getUploadedFiles(userId),
      this.getPreferences(userId)
      // Exclude: analytics data, logs, inferred data, system-generated data
    ]);

    return {
      profile: queries[0],
      weddingDetails: queries[1],
      formResponses: queries[2],
      files: queries[3],
      preferences: queries[4]
    };
  }
}
```

#### Example 2: Consent Management System
```typescript
// consent-management.ts
export class ConsentManagement {
  private consentTypes = {
    marketing: {
      description: 'Receive marketing emails about new features and wedding tips',
      required: false,
      lawfulBasis: 'consent',
      purpose: 'Direct marketing communications'
    },
    cookies: {
      description: 'Use cookies for analytics and personalization',
      required: false,
      lawfulBasis: 'consent', 
      purpose: 'Website analytics and user experience improvement'
    },
    data_sharing: {
      description: 'Share data with connected wedding suppliers',
      required: true, // Required for core service
      lawfulBasis: 'contract',
      purpose: 'Wedding coordination between suppliers'
    }
  };

  async recordConsent(
    userId: string,
    consentType: string,
    granted: boolean,
    ipAddress: string,
    userAgent: string
  ): Promise<string> {
    // Validate consent type
    if (!this.consentTypes[consentType]) {
      throw new Error('Invalid consent type');
    }

    // Record with full audit trail
    const { data, error } = await this.supabase
      .rpc('record_consent', {
        p_user_id: userId,
        p_consent_type: consentType,
        p_granted: granted,
        p_version: '1.0',
        p_ip_address: ipAddress,
        p_user_agent: userAgent
      });

    if (error) throw error;

    // Apply consent decision immediately
    await this.applyConsentDecision(userId, consentType, granted);

    return data;
  }

  async withdrawConsent(userId: string, consentType: string): Promise<void> {
    await this.recordConsent(userId, consentType, false, '', '');
    
    // Remove user from relevant systems immediately
    if (consentType === 'marketing') {
      await this.removeFromMarketingLists(userId);
    }
  }

  async getConsentHistory(userId: string): Promise<ConsentHistory[]> {
    const { data } = await this.supabase
      .from('consent_records')
      .select('*')
      .eq('user_id', userId)
      .order('created_at', { ascending: false });

    return data || [];
  }
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for GDPR compliance libraries
- [x] Playwright: Test consent flows and data export
- [x] Filesystem: Access privacy and compliance files

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/gdpr/compliance", "data subject rights", 3000);
await mcp__context7__get-library-docs("/privacy/frameworks", "consent management", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('GDPR Compliance', () => {
  it('should record consent with full audit trail', async () => {
    const consent = new ConsentManagement();
    
    const consentId = await consent.recordConsent(
      'user-id',
      'marketing',
      true,
      '192.168.1.1',
      'Mozilla/5.0...'
    );
    
    expect(consentId).toBeDefined();
    
    const history = await consent.getConsentHistory('user-id');
    expect(history).toHaveLength(1);
    expect(history[0].granted).toBe(true);
  });
  
  it('should export user data in machine-readable format', async () => {
    const rights = new DataSubjectRights();
    
    const exportData = await rights.handlePortabilityRequest('user-id', 'json');
    
    expect(exportData.format).toBe('json');
    expect(exportData.schema).toBeDefined();
    expect(exportData.data).toBeDefined();
  });
  
  it('should crypto-shred user data for right to erasure', async () => {
    const rights = new DataSubjectRights();
    
    await rights.handleErasureRequest('user-id', 'User requested deletion');
    
    // Verify encryption key is deleted
    const keyExists = await checkEncryptionKeyExists('user-id');
    expect(keyExists).toBe(false);
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('GDPR Consent Flow', async () => {
  await mcp__playwright__browser_navigate({url: '/privacy/consent'});
  
  // Test consent banner
  await mcp__playwright__browser_snapshot();
  
  // Accept marketing consent
  await mcp__playwright__browser_click({
    element: 'Marketing consent toggle',
    ref: '#marketing-consent'
  });
  
  // Test data access request
  await mcp__playwright__browser_navigate({url: '/privacy/my-data'});
  await mcp__playwright__browser_click({
    element: 'Download my data button',
    ref: '#download-data'
  });
  
  await mcp__playwright__browser_snapshot();
});
```

### ACCEPTANCE CRITERIA
- [x] Consent is recorded with IP address, timestamp, and version
- [x] Data access requests are processed within 30 days
- [x] Right to erasure via crypto-shredding leaves data unrecoverable
- [x] Data portability exports in machine-readable formats
- [x] Cookie consent banner appears for EU users
- [x] Performance: Data export completes within 5 minutes
- [x] Security: All privacy requests require identity verification
- [x] Accessibility: Consent forms are screen reader compatible

### DEPENDENCIES
- Must complete after: WS-089 (Data Encryption)
- Must complete before: None (final security feature)
- Shares code with: Encryption service, User management, Analytics

### ESTIMATED EFFORT
- Team A Frontend: 18 hours
- Team B Backend: 28 hours
- Team C Integration: 12 hours
- Total: 58 hours