# TECHNICAL SPECIFICATION: WS-083 - Budget Tracking
## Generated by Feature Development Session - August 22, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Couple with a $45,000 wedding budget across 12 vendors
**I want to:** Track actual spending vs planned budget in real-time with vendor payments
**So that:** I avoid going over budget and can reallocate funds when needed (70% of couples exceed their original budget by average of $5,300)

**Real Wedding Scenario:**
A couple budgets $45K total: $15K venue, $8K photography, $6K catering, $3K flowers, $2K music, $4K dress/attire, $3K rings, $4K misc. They put down $7,500 venue deposit (50%), then realize they want upgraded photography package (+$2K). The budget tracker shows they're now $2K over, but they have $1K buffer in "misc" and can reduce flowers by $1K. Without tracking, they'd discover the overage at final payment time, causing stress and potential debt.

### SPECIFICATION SOURCE
- **Feature ID:** WS-083
- **Original Spec:** Wedding budget tracking across vendors
- **Current Implementation:** 0% complete
- **Files to Modify:**
  - /wedsync/src/app/(dashboard)/layout.tsx (add budget menu)
- **New Files to Create:**
  - /wedsync/src/app/(dashboard)/budget/page.tsx
  - /wedsync/src/app/(dashboard)/budget/categories/page.tsx
  - /wedsync/src/app/(dashboard)/budget/vendors/page.tsx
  - /wedsync/src/app/api/budget/overview/route.ts
  - /wedsync/src/app/api/budget/categories/route.ts
  - /wedsync/src/app/api/budget/transactions/route.ts
  - /wedsync/src/components/budget/BudgetOverview.tsx
  - /wedsync/src/components/budget/CategoryBreakdown.tsx
  - /wedsync/src/components/budget/VendorSpending.tsx
  - /wedsync/src/lib/services/budgetService.ts
  - /wedsync/src/lib/budget/budgetCalculator.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Wedding budget master
CREATE TABLE IF NOT EXISTS wedding_budgets (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  couple_id UUID NOT NULL REFERENCES couples(id) UNIQUE,
  total_budget DECIMAL(10,2) NOT NULL,
  currency VARCHAR(3) DEFAULT 'USD',
  budget_status VARCHAR(50) DEFAULT 'planning', -- 'planning', 'active', 'final', 'exceeded'
  
  -- Budget allocation method
  allocation_method VARCHAR(50) DEFAULT 'percentage', -- 'percentage', 'fixed_amounts', 'hybrid'
  
  -- Buffer and contingency
  contingency_amount DECIMAL(10,2) DEFAULT 0.00,
  contingency_percentage DECIMAL(5,2) DEFAULT 10.00, -- 10% default buffer
  
  -- Important dates
  wedding_date DATE NOT NULL,
  budget_finalized_date DATE,
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Budget categories (venue, photography, etc.)
CREATE TABLE IF NOT EXISTS budget_categories (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  budget_id UUID NOT NULL REFERENCES wedding_budgets(id) ON DELETE CASCADE,
  category_name VARCHAR(100) NOT NULL, -- 'venue', 'photography', 'catering', etc.
  category_display_name VARCHAR(100) NOT NULL,
  category_order INTEGER DEFAULT 0,
  
  -- Budget allocation
  planned_amount DECIMAL(10,2) NOT NULL,
  planned_percentage DECIMAL(5,2), -- Auto-calculated from planned_amount
  
  -- Spending tracking
  committed_amount DECIMAL(10,2) DEFAULT 0.00, -- Contract amounts
  paid_amount DECIMAL(10,2) DEFAULT 0.00, -- Actually paid
  
  -- Status
  is_required BOOLEAN DEFAULT true,
  is_completed BOOLEAN DEFAULT false, -- All vendors booked and contracts signed
  notes TEXT,
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  
  UNIQUE(budget_id, category_name)
);

-- Budget transactions (payments, deposits, etc.)
CREATE TABLE IF NOT EXISTS budget_transactions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  budget_id UUID NOT NULL REFERENCES wedding_budgets(id),
  category_id UUID NOT NULL REFERENCES budget_categories(id),
  contract_id UUID REFERENCES contracts(id), -- Link to contract if applicable
  vendor_id UUID REFERENCES auth.users(id),
  vendor_business_name VARCHAR(255),
  
  -- Transaction details
  transaction_type VARCHAR(50) NOT NULL, -- 'deposit', 'payment', 'refund', 'adjustment'
  transaction_description VARCHAR(255) NOT NULL,
  amount DECIMAL(10,2) NOT NULL,
  currency VARCHAR(3) DEFAULT 'USD',
  
  -- Payment details
  payment_method VARCHAR(50), -- 'credit_card', 'check', 'bank_transfer', 'cash'
  payment_date DATE NOT NULL,
  payment_reference VARCHAR(255), -- Check number, transaction ID, etc.
  
  -- Status tracking
  status VARCHAR(50) DEFAULT 'pending', -- 'pending', 'confirmed', 'failed', 'refunded'
  confirmed_date TIMESTAMP WITH TIME ZONE,
  
  -- Receipts and documentation
  receipt_url VARCHAR(500),
  receipt_file_name VARCHAR(255),
  
  -- Metadata
  created_by UUID NOT NULL REFERENCES auth.users(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Budget alerts and notifications
CREATE TABLE IF NOT EXISTS budget_alerts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  budget_id UUID NOT NULL REFERENCES wedding_budgets(id),
  category_id UUID REFERENCES budget_categories(id),
  
  -- Alert configuration
  alert_type VARCHAR(50) NOT NULL, -- 'overspend', 'milestone', 'payment_due', 'budget_exceeded'
  alert_threshold DECIMAL(10,2), -- Amount or percentage threshold
  
  -- Alert status
  is_active BOOLEAN DEFAULT true,
  last_triggered TIMESTAMP WITH TIME ZONE,
  trigger_count INTEGER DEFAULT 0,
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Budget comparison and forecasting
CREATE TABLE IF NOT EXISTS budget_snapshots (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  budget_id UUID NOT NULL REFERENCES wedding_budgets(id),
  snapshot_date DATE NOT NULL,
  snapshot_type VARCHAR(50) DEFAULT 'monthly', -- 'monthly', 'milestone', 'manual'
  
  -- Snapshot data
  total_planned DECIMAL(10,2) NOT NULL,
  total_committed DECIMAL(10,2) NOT NULL,
  total_paid DECIMAL(10,2) NOT NULL,
  categories_data JSONB NOT NULL, -- Full category breakdown
  
  -- Analysis
  variance_amount DECIMAL(10,2), -- vs previous snapshot
  variance_percentage DECIMAL(5,2),
  projected_final_amount DECIMAL(10,2),
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

CREATE INDEX idx_wedding_budgets_couple ON wedding_budgets(couple_id);
CREATE INDEX idx_budget_categories_budget ON budget_categories(budget_id);
CREATE INDEX idx_budget_transactions_budget ON budget_transactions(budget_id);
CREATE INDEX idx_budget_transactions_category ON budget_transactions(category_id);
CREATE INDEX idx_budget_transactions_date ON budget_transactions(payment_date);
CREATE INDEX idx_budget_transactions_vendor ON budget_transactions(vendor_id);
```

#### API Endpoints Required
```typescript
// GET /api/budget/overview - Get complete budget overview
interface BudgetOverviewResponse {
  budget: {
    id: string;
    totalBudget: number;
    contingencyAmount: number;
    totalCommitted: number;
    totalPaid: number;
    remainingBudget: number;
    budgetUtilization: number; // percentage used
    projectedFinalAmount: number;
    varianceAmount: number; // over/under budget
    status: 'on_track' | 'at_risk' | 'over_budget';
  };
  categories: {
    id: string;
    name: string;
    displayName: string;
    plannedAmount: number;
    plannedPercentage: number;
    committedAmount: number;
    paidAmount: number;
    remainingAmount: number;
    utilizationPercentage: number;
    status: 'not_started' | 'in_progress' | 'completed' | 'over_budget';
    vendorCount: number;
  }[];
  recentTransactions: Transaction[];
  upcomingPayments: {
    vendorName: string;
    amount: number;
    dueDate: string;
    category: string;
  }[];
  alerts: BudgetAlert[];
}

// POST /api/budget/transactions - Record new transaction
interface CreateTransactionRequest {
  categoryId: string;
  vendorId?: string;
  vendorBusinessName: string;
  transactionType: 'deposit' | 'payment' | 'refund' | 'adjustment';
  description: string;
  amount: number;
  paymentDate: string;
  paymentMethod: string;
  paymentReference?: string;
  receiptFile?: File;
}

// PUT /api/budget/categories/[id] - Update category budget
interface UpdateCategoryRequest {
  plannedAmount: number;
  notes?: string;
}

// GET /api/budget/analytics - Budget analytics and insights
interface BudgetAnalyticsResponse {
  spendingTrends: {
    month: string;
    plannedSpending: number;
    actualSpending: number;
    cumulativeSpending: number;
  }[];
  categoryComparison: {
    categoryName: string;
    industryAverage: number;
    yourBudget: number;
    yourSpending: number;
  }[];
  projections: {
    projectedFinalAmount: number;
    confidenceLevel: number;
    riskFactors: string[];
    recommendations: string[];
  };
}
```

#### Frontend Components Required
```typescript
// Component: BudgetOverview
// Location: /src/components/budget/BudgetOverview.tsx

interface BudgetOverviewProps {
  budget: BudgetData;
  onUpdateBudget: (updates: Partial<BudgetData>) => void;
}

// Key functionality:
- Real-time budget vs spending visualization
- Progress bars for each category
- Alert notifications and warnings
- Quick transaction entry
- Budget reallocation interface
- Export budget reports
- Budget comparison with industry averages

// Component: CategoryBreakdown
// Location: /src/components/budget/CategoryBreakdown.tsx

interface CategoryBreakdownProps {
  categories: BudgetCategory[];
  onCategoryUpdate: (id: string, updates: CategoryUpdate) => void;
  onTransactionAdd: (categoryId: string, transaction: TransactionData) => void;
}

// Key functionality:
- Drag-and-drop budget reallocation
- Category-specific spending analysis
- Vendor cost breakdown within category
- Payment timeline visualization
- Category completion status tracking
```

### CODE EXAMPLES

#### Example 1: Real-time Budget Calculator
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { useEffect, useState, useMemo } from 'react';
import { supabase } from '@/lib/supabase';

export class BudgetCalculator {
  static calculateBudgetStatus(totalBudget: number, totalCommitted: number, totalPaid: number, contingency: number): BudgetStatus {
    const effectiveBudget = totalBudget - contingency;
    const utilizationRate = totalCommitted / effectiveBudget;
    const paymentProgress = totalPaid / totalCommitted;
    
    let status: 'on_track' | 'at_risk' | 'over_budget';
    
    if (totalCommitted > totalBudget) {
      status = 'over_budget';
    } else if (utilizationRate > 0.9) {
      status = 'at_risk';
    } else {
      status = 'on_track';
    }
    
    return {
      status,
      utilizationRate,
      paymentProgress,
      remainingBudget: totalBudget - totalCommitted,
      availableBuffer: Math.max(0, effectiveBudget - totalCommitted),
      projectedOverage: Math.max(0, totalCommitted - totalBudget)
    };
  }
  
  static generateBudgetRecommendations(categories: BudgetCategory[], totalBudget: number): BudgetRecommendation[] {
    const recommendations: BudgetRecommendation[] = [];
    const industryStandards = this.getIndustryStandards();
    
    categories.forEach(category => {
      const currentPercentage = (category.plannedAmount / totalBudget) * 100;
      const industryRange = industryStandards[category.categoryName];
      
      if (industryRange) {
        if (currentPercentage < industryRange.min) {
          recommendations.push({
            type: 'increase',
            categoryId: category.id,
            categoryName: category.categoryName,
            currentAmount: category.plannedAmount,
            suggestedAmount: (industryRange.recommended / 100) * totalBudget,
            reason: `Industry standard is ${industryRange.recommended}% of budget`,
            priority: currentPercentage < industryRange.min * 0.8 ? 'high' : 'medium'
          });
        } else if (currentPercentage > industryRange.max) {
          recommendations.push({
            type: 'decrease',
            categoryId: category.id,
            categoryName: category.categoryName,
            currentAmount: category.plannedAmount,
            suggestedAmount: (industryRange.recommended / 100) * totalBudget,
            reason: `Current allocation (${currentPercentage.toFixed(1)}%) exceeds typical range`,
            priority: 'medium'
          });
        }
      }
      
      // Check for overspending within category
      if (category.committedAmount > category.plannedAmount) {
        const overage = category.committedAmount - category.plannedAmount;
        recommendations.push({
          type: 'reallocate',
          categoryId: category.id,
          categoryName: category.categoryName,
          currentAmount: category.plannedAmount,
          suggestedAmount: category.committedAmount,
          reason: `Category is $${overage.toFixed(2)} over budget. Consider reallocating from other categories.`,
          priority: 'high'
        });
      }
    });
    
    return recommendations.sort((a, b) => {
      const priorityOrder = { high: 3, medium: 2, low: 1 };
      return priorityOrder[b.priority] - priorityOrder[a.priority];
    });
  }
  
  private static getIndustryStandards(): Record<string, BudgetRange> {
    return {
      'venue': { min: 35, max: 50, recommended: 42 },
      'photography': { min: 10, max: 20, recommended: 15 },
      'catering': { min: 25, max: 40, recommended: 32 },
      'flowers': { min: 6, max: 12, recommended: 8 },
      'music': { min: 4, max: 10, recommended: 7 },
      'attire': { min: 6, max: 12, recommended: 9 },
      'rings': { min: 2, max: 8, recommended: 5 },
      'transportation': { min: 1, max: 4, recommended: 2 },
      'miscellaneous': { min: 5, max: 15, recommended: 10 }
    };
  }
}

export function BudgetOverview({ budgetId }: BudgetOverviewProps) {
  const [budgetData, setBudgetData] = useState<BudgetData | null>(null);
  const [loading, setLoading] = useState(true);
  const [realTimeUpdates, setRealTimeUpdates] = useState(true);
  
  const budgetStatus = useMemo(() => {
    if (!budgetData) return null;
    
    return BudgetCalculator.calculateBudgetStatus(
      budgetData.totalBudget,
      budgetData.totalCommitted,
      budgetData.totalPaid,
      budgetData.contingencyAmount
    );
  }, [budgetData]);
  
  const recommendations = useMemo(() => {
    if (!budgetData) return [];
    
    return BudgetCalculator.generateBudgetRecommendations(
      budgetData.categories,
      budgetData.totalBudget
    );
  }, [budgetData]);
  
  useEffect(() => {
    loadBudgetData();
    
    if (realTimeUpdates) {
      const subscription = supabase
        .channel(`budget:${budgetId}`)
        .on('postgres_changes',
          { 
            event: '*', 
            schema: 'public', 
            table: 'budget_transactions',
            filter: `budget_id=eq.${budgetId}`
          }, 
          () => {
            // Reload budget data when transactions change
            loadBudgetData();
          }
        )
        .on('postgres_changes',
          { 
            event: 'UPDATE', 
            schema: 'public', 
            table: 'budget_categories',
            filter: `budget_id=eq.${budgetId}`
          }, 
          () => {
            loadBudgetData();
          }
        )
        .subscribe();
      
      return () => {
        supabase.removeChannel(subscription);
      };
    }
  }, [budgetId, realTimeUpdates]);
  
  const loadBudgetData = async () => {
    try {
      const { data, error } = await supabase
        .from('wedding_budgets')
        .select(`
          *,
          budget_categories (
            *,
            budget_transactions (
              amount,
              transaction_type,
              payment_date,
              status
            )
          )
        `)
        .eq('id', budgetId)
        .single();
      
      if (error) throw error;
      
      // Calculate totals for each category
      const processedCategories = data.budget_categories.map(category => {
        const transactions = category.budget_transactions || [];
        const paidAmount = transactions
          .filter(t => t.status === 'confirmed' && ['deposit', 'payment'].includes(t.transaction_type))
          .reduce((sum, t) => sum + parseFloat(t.amount), 0);
        
        const refundAmount = transactions
          .filter(t => t.status === 'confirmed' && t.transaction_type === 'refund')
          .reduce((sum, t) => sum + parseFloat(t.amount), 0);
        
        return {
          ...category,
          paidAmount: paidAmount - refundAmount,
          utilizationPercentage: (category.committedAmount / category.plannedAmount) * 100
        };
      });
      
      // Calculate budget totals
      const totalCommitted = processedCategories.reduce((sum, cat) => sum + parseFloat(cat.committedAmount), 0);
      const totalPaid = processedCategories.reduce((sum, cat) => sum + parseFloat(cat.paidAmount), 0);
      
      setBudgetData({
        ...data,
        categories: processedCategories,
        totalCommitted,
        totalPaid
      });
      
    } catch (error) {
      console.error('Failed to load budget data:', error);
    } finally {
      setLoading(false);
    }
  };
  
  const handleCategoryReallocation = async (fromCategoryId: string, toCategoryId: string, amount: number) => {
    // Optimistic update
    setBudgetData(prev => {
      if (!prev) return prev;
      
      return {
        ...prev,
        categories: prev.categories.map(cat => {
          if (cat.id === fromCategoryId) {
            return { ...cat, plannedAmount: parseFloat(cat.plannedAmount) - amount };
          } else if (cat.id === toCategoryId) {
            return { ...cat, plannedAmount: parseFloat(cat.plannedAmount) + amount };
          }
          return cat;
        })
      };
    });
    
    // Update database
    try {
      const fromCategory = budgetData?.categories.find(c => c.id === fromCategoryId);
      const toCategory = budgetData?.categories.find(c => c.id === toCategoryId);
      
      if (fromCategory && toCategory) {
        await Promise.all([
          supabase
            .from('budget_categories')
            .update({ planned_amount: parseFloat(fromCategory.plannedAmount) - amount })
            .eq('id', fromCategoryId),
          supabase
            .from('budget_categories')
            .update({ planned_amount: parseFloat(toCategory.plannedAmount) + amount })
            .eq('id', toCategoryId)
        ]);
      }
    } catch (error) {
      console.error('Failed to update category allocations:', error);
      // Revert optimistic update
      loadBudgetData();
    }
  };
  
  if (loading) {
    return <BudgetSkeleton />;
  }
  
  if (!budgetData || !budgetStatus) {
    return <div>Failed to load budget data</div>;
  }
  
  return (
    <div className="space-y-6">
      {/* Budget Status Header */}
      <div className={`p-6 rounded-lg ${
        budgetStatus.status === 'over_budget' ? 'bg-red-50 border-red-200' :
        budgetStatus.status === 'at_risk' ? 'bg-yellow-50 border-yellow-200' :
        'bg-green-50 border-green-200'
      } border`}>
        <div className="flex items-center justify-between">
          <div>
            <h2 className="text-2xl font-bold">
              ${budgetData.totalBudget.toLocaleString()} Wedding Budget
            </h2>
            <p className={`text-lg ${
              budgetStatus.status === 'over_budget' ? 'text-red-700' :
              budgetStatus.status === 'at_risk' ? 'text-yellow-700' :
              'text-green-700'
            }`}>
              {budgetStatus.remainingBudget >= 0 
                ? `$${budgetStatus.remainingBudget.toLocaleString()} remaining`
                : `$${Math.abs(budgetStatus.remainingBudget).toLocaleString()} over budget`
              }
            </p>
          </div>
          
          <div className="text-right">
            <div className="text-sm text-gray-600">Budget Utilization</div>
            <div className="text-3xl font-bold">
              {(budgetStatus.utilizationRate * 100).toFixed(1)}%
            </div>
          </div>
        </div>
        
        {/* Progress Bar */}
        <div className="mt-4">
          <div className="flex justify-between text-sm text-gray-600 mb-1">
            <span>Committed: ${budgetData.totalCommitted.toLocaleString()}</span>
            <span>Paid: ${budgetData.totalPaid.toLocaleString()}</span>
          </div>
          <div className="w-full bg-gray-200 rounded-full h-3">
            <div 
              className={`h-3 rounded-full ${
                budgetStatus.status === 'over_budget' ? 'bg-red-500' :
                budgetStatus.status === 'at_risk' ? 'bg-yellow-500' :
                'bg-green-500'
              }`}
              style={{ width: `${Math.min(budgetStatus.utilizationRate * 100, 100)}%` }}
            />
          </div>
        </div>
      </div>
      
      {/* Recommendations */}
      {recommendations.length > 0 && (
        <RecommendationsPanel 
          recommendations={recommendations}
          onApplyRecommendation={handleCategoryReallocation}
        />
      )}
      
      {/* Category Breakdown */}
      <CategoryBreakdown 
        categories={budgetData.categories}
        totalBudget={budgetData.totalBudget}
        onCategoryUpdate={loadBudgetData}
        onReallocation={handleCategoryReallocation}
      />
    </div>
  );
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [ ] Context7: Load docs for financial calculations, chart libraries
- [ ] Playwright: Test budget tracking and transaction flows
- [ ] Filesystem: Access budget templates and calculators

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/recharts/recharts", "financial charts budget", 2500);
await mcp__context7__get-library-docs("/date-fns/date-fns", "payment scheduling", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('Budget Calculator', () => {
  it('should calculate budget status correctly', () => {
    const status = BudgetCalculator.calculateBudgetStatus(50000, 45000, 25000, 5000);
    expect(status.utilizationRate).toBe(1.0); // 45k committed vs 45k effective budget
    expect(status.status).toBe('at_risk');
  });
  
  it('should generate budget recommendations', () => {
    const recommendations = BudgetCalculator.generateBudgetRecommendations(mockCategories, 50000);
    expect(recommendations).toContain(
      expect.objectContaining({
        type: 'increase',
        categoryName: 'photography'
      })
    );
  });
});
```

#### E2E Tests Required
```typescript
test('Budget tracking and reallocation', async () => {
  await mcp__playwright__browser_navigate({url: '/budget'});
  
  // Add new transaction
  await mcp__playwright__browser_click({
    element: "Add transaction button",
    ref: "button[data-testid='add-transaction']"
  });
  
  // Fill transaction details
  await mcp__playwright__browser_select_option({
    element: "Category dropdown",
    ref: "select[name='categoryId']",
    values: ["photography"]
  });
  
  await mcp__playwright__browser_type({
    element: "Amount input",
    ref: "input[name='amount']",
    text: "4000"
  });
  
  await mcp__playwright__browser_select_option({
    element: "Transaction type",
    ref: "select[name='transactionType']",
    values: ["deposit"]
  });
  
  // Submit transaction
  await mcp__playwright__browser_click({
    element: "Save transaction button",
    ref: "button[type='submit']"
  });
  
  // Verify budget updated
  await mcp__playwright__browser_wait_for({text: "$4,000"});
  await mcp__playwright__browser_wait_for({text: "90.0%"}); // utilization rate
  
  // Test budget reallocation
  await mcp__playwright__browser_click({
    element: "Reallocate budget button",
    ref: "button[data-testid='reallocate']"
  });
  
  // Move $1000 from miscellaneous to photography
  await mcp__playwright__browser_drag({
    startElement: "Misc category allocation",
    startRef: "[data-category='miscellaneous'] .allocation-handle",
    endElement: "Photography category",
    endRef: "[data-category='photography'] .drop-zone"
  });
  
  await mcp__playwright__browser_wait_for({text: "Budget reallocated successfully"});
});
```

### ACCEPTANCE CRITERIA
- [ ] Track planned vs actual spending across all categories
- [ ] Real-time budget utilization calculations
- [ ] Automated overspend alerts and notifications
- [ ] Budget reallocation with drag-and-drop interface
- [ ] Integration with vendor contracts and payments
- [ ] Industry standard budget comparisons
- [ ] Spending trend analysis and projections
- [ ] Export budget reports and summaries
- [ ] Mobile-responsive budget tracking
- [ ] Receipt upload and expense documentation

### DEPENDENCIES
- Must complete after: WS-082 (Contract management for payment linking)
- Must complete before: Payment processing integration
- Shares code with: Contract system, vendor management, notifications

### ESTIMATED EFFORT
- Team C Integration: 26 hours (Budget dashboard, charts, reallocation UI)
- Team B Backend: 22 hours (Budget calculations, analytics, transaction processing)
- Total: 48 hours