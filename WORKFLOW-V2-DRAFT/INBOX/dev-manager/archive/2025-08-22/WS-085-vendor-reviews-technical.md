# TECHNICAL SPECIFICATION: WS-085 - Vendor Reviews
## Generated by Feature Development Session - August 22, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Couple who just had their wedding 2 weeks ago
**I want to:** Leave detailed reviews for each of my 8 vendors to help future couples make better decisions
**So that:** Other couples can find great vendors and avoid bad ones (92% of couples check reviews before booking, bad vendors cost couples average of $3,800 in fixes/rebooking)

**Real Wedding Scenario:**
A couple had an amazing photographer ($4,500) who went above and beyond, capturing unplanned moments. Their florist ($2,800) delivered exactly what was promised but was hard to reach. The DJ ($1,600) showed up late and played wrong music during first dance. Two weeks later, they want to review all vendors but can't find a comprehensive platform. They end up leaving generic Google reviews that don't help couples understand wedding-specific quality like "handled rain backup plan well" or "coordinated with other vendors seamlessly."

### SPECIFICATION SOURCE
- **Feature ID:** WS-085
- **Original Spec:** Post-wedding vendor review system
- **Current Implementation:** 0% complete
- **Files to Modify:**
  - /wedsync/src/app/(dashboard)/layout.tsx (add reviews menu)
- **New Files to Create:**
  - /wedsync/src/app/(dashboard)/reviews/page.tsx
  - /wedsync/src/app/(dashboard)/reviews/write/[vendorId]/page.tsx
  - /wedsync/src/app/(dashboard)/reviews/vendor/[vendorId]/page.tsx
  - /wedsync/src/app/api/reviews/route.ts
  - /wedsync/src/app/api/reviews/[id]/route.ts
  - /wedsync/src/app/api/reviews/vendor/[vendorId]/route.ts
  - /wedsync/src/components/reviews/ReviewForm.tsx
  - /wedsync/src/components/reviews/ReviewCard.tsx
  - /wedsync/src/components/reviews/ReviewAnalytics.tsx
  - /wedsync/src/lib/services/reviewService.ts
  - /wedsync/src/lib/reviews/reviewValidator.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Vendor reviews
CREATE TABLE IF NOT EXISTS vendor_reviews (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  vendor_id UUID NOT NULL REFERENCES auth.users(id),
  reviewer_couple_id UUID NOT NULL REFERENCES couples(id),
  contract_id UUID REFERENCES contracts(id), -- Link to actual service contract
  
  -- Review metadata
  wedding_date DATE NOT NULL,
  service_date_range DATERANGE, -- Actual service period (engagement to wedding)
  review_title VARCHAR(255),
  
  -- Ratings (1-5 scale)
  overall_rating INTEGER NOT NULL CHECK (overall_rating >= 1 AND overall_rating <= 5),
  quality_rating INTEGER NOT NULL CHECK (quality_rating >= 1 AND quality_rating <= 5),
  communication_rating INTEGER NOT NULL CHECK (communication_rating >= 1 AND communication_rating <= 5),
  professionalism_rating INTEGER NOT NULL CHECK (professionalism_rating >= 1 AND professionalism_rating <= 5),
  value_rating INTEGER NOT NULL CHECK (value_rating >= 1 AND value_rating <= 5),
  timeliness_rating INTEGER NOT NULL CHECK (timeliness_rating >= 1 AND timeliness_rating <= 5),
  
  -- Vendor-specific ratings (varies by type)
  vendor_specific_ratings JSONB, -- {creativity: 5, flexibility: 4} for photographers
  
  -- Review content
  review_text TEXT NOT NULL,
  things_done_well TEXT, -- Specific positives
  areas_for_improvement TEXT, -- Constructive feedback
  
  -- Service details
  service_package VARCHAR(255), -- Which package/service they bought
  final_cost DECIMAL(10,2), -- What they actually paid
  would_recommend BOOLEAN NOT NULL,
  would_book_again BOOLEAN NOT NULL,
  
  -- Wedding context
  wedding_size_category VARCHAR(50), -- 'intimate', 'medium', 'large'
  wedding_style VARCHAR(100), -- 'traditional', 'modern', 'rustic', etc.
  venue_type VARCHAR(100), -- Indoor, outdoor, etc.
  season VARCHAR(20), -- Spring, summer, etc.
  
  -- Review authenticity
  is_verified BOOLEAN DEFAULT false, -- Email/contract verification
  verification_method VARCHAR(50), -- 'email', 'contract', 'manual'
  verification_date TIMESTAMP WITH TIME ZONE,
  
  -- Moderation
  is_approved BOOLEAN DEFAULT false,
  is_flagged BOOLEAN DEFAULT false,
  flagged_reason VARCHAR(255),
  moderation_notes TEXT,
  approved_by UUID REFERENCES auth.users(id),
  approved_at TIMESTAMP WITH TIME ZONE,
  
  -- Photos and attachments
  review_photos TEXT[], -- URLs to uploaded photos
  has_portfolio_examples BOOLEAN DEFAULT false,
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  
  -- Ensure one review per couple per vendor
  UNIQUE(vendor_id, reviewer_couple_id)
);

-- Review responses from vendors
CREATE TABLE IF NOT EXISTS review_responses (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  review_id UUID NOT NULL REFERENCES vendor_reviews(id) ON DELETE CASCADE,
  vendor_id UUID NOT NULL REFERENCES auth.users(id),
  
  -- Response content
  response_text TEXT NOT NULL,
  is_public BOOLEAN DEFAULT true,
  
  -- Response metadata
  response_tone VARCHAR(50), -- 'professional', 'defensive', 'grateful'
  addresses_concerns BOOLEAN DEFAULT false,
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Review helpfulness votes
CREATE TABLE IF NOT EXISTS review_votes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  review_id UUID NOT NULL REFERENCES vendor_reviews(id) ON DELETE CASCADE,
  voter_user_id UUID REFERENCES auth.users(id),
  voter_email VARCHAR(255), -- Allow anonymous voting
  
  vote_type VARCHAR(20) NOT NULL, -- 'helpful', 'not_helpful'
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  
  UNIQUE(review_id, voter_email) -- One vote per person per review
);

-- Review analytics aggregations
CREATE TABLE IF NOT EXISTS vendor_review_stats (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  vendor_id UUID NOT NULL REFERENCES auth.users(id) UNIQUE,
  
  -- Overall statistics
  total_reviews INTEGER DEFAULT 0,
  average_overall_rating DECIMAL(3,2) DEFAULT 0.00,
  average_quality_rating DECIMAL(3,2) DEFAULT 0.00,
  average_communication_rating DECIMAL(3,2) DEFAULT 0.00,
  average_professionalism_rating DECIMAL(3,2) DEFAULT 0.00,
  average_value_rating DECIMAL(3,2) DEFAULT 0.00,
  average_timeliness_rating DECIMAL(3,2) DEFAULT 0.00,
  
  -- Rating distribution
  five_star_count INTEGER DEFAULT 0,
  four_star_count INTEGER DEFAULT 0,
  three_star_count INTEGER DEFAULT 0,
  two_star_count INTEGER DEFAULT 0,
  one_star_count INTEGER DEFAULT 0,
  
  -- Recommendation metrics
  recommendation_rate DECIMAL(5,2) DEFAULT 0.00, -- Percentage who would recommend
  repeat_booking_rate DECIMAL(5,2) DEFAULT 0.00, -- Percentage who would book again
  
  -- Common themes (extracted from reviews)
  positive_keywords TEXT[], -- Most mentioned positive aspects
  improvement_keywords TEXT[], -- Most mentioned areas for improvement
  
  -- Review freshness
  last_review_date DATE,
  recent_reviews_trend VARCHAR(20), -- 'improving', 'declining', 'stable'
  
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Review invitations and follow-ups
CREATE TABLE IF NOT EXISTS review_invitations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  couple_id UUID NOT NULL REFERENCES couples(id),
  vendor_id UUID NOT NULL REFERENCES auth.users(id),
  wedding_date DATE NOT NULL,
  
  -- Invitation status
  invitation_sent_at TIMESTAMP WITH TIME ZONE,
  first_reminder_sent_at TIMESTAMP WITH TIME ZONE,
  second_reminder_sent_at TIMESTAMP WITH TIME ZONE,
  review_submitted_at TIMESTAMP WITH TIME ZONE,
  
  -- Response tracking
  invitation_opened BOOLEAN DEFAULT false,
  invitation_clicked BOOLEAN DEFAULT false,
  review_started BOOLEAN DEFAULT false,
  review_completed BOOLEAN DEFAULT false,
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

CREATE INDEX idx_vendor_reviews_vendor ON vendor_reviews(vendor_id);
CREATE INDEX idx_vendor_reviews_reviewer ON vendor_reviews(reviewer_couple_id);
CREATE INDEX idx_vendor_reviews_rating ON vendor_reviews(overall_rating);
CREATE INDEX idx_vendor_reviews_date ON vendor_reviews(wedding_date DESC);
CREATE INDEX idx_vendor_reviews_approved ON vendor_reviews(is_approved) WHERE is_approved = true;
CREATE INDEX idx_review_responses_review ON review_responses(review_id);
CREATE INDEX idx_review_votes_review ON review_votes(review_id);
```

#### API Endpoints Required
```typescript
// GET /api/reviews/vendor/[vendorId] - Get reviews for a vendor
interface GetVendorReviewsRequest {
  sortBy?: 'newest' | 'oldest' | 'highest_rating' | 'lowest_rating' | 'most_helpful';
  filterBy?: {
    rating?: number; // Minimum rating
    weddingSize?: string;
    season?: string;
    verified?: boolean;
  };
  page?: number;
  limit?: number;
}

interface GetVendorReviewsResponse {
  vendor: {
    id: string;
    businessName: string;
    vendorType: string;
    overallStats: VendorReviewStats;
  };
  reviews: {
    id: string;
    reviewTitle: string;
    overallRating: number;
    qualityRating: number;
    communicationRating: number;
    professionalismRating: number;
    valueRating: number;
    timelinessRating: number;
    reviewText: string;
    thingsDoneWell: string;
    areasForImprovement: string;
    servicePackage: string;
    finalCost: number;
    wouldRecommend: boolean;
    wouldBookAgain: boolean;
    weddingDate: string;
    weddingSize: string;
    weddingStyle: string;
    season: string;
    isVerified: boolean;
    reviewPhotos: string[];
    helpfulVotes: number;
    notHelpfulVotes: number;
    vendorResponse?: {
      responseText: string;
      createdAt: string;
    };
    reviewerInfo: {
      coupleNames: string; // Anonymized or full based on privacy settings
      weddingLocation: string;
    };
    createdAt: string;
  }[];
  pagination: {
    total: number;
    page: number;
    totalPages: number;
  };
}

// POST /api/reviews - Submit new review
interface CreateReviewRequest {
  vendorId: string;
  contractId?: string;
  weddingDate: string;
  reviewTitle: string;
  overallRating: number;
  qualityRating: number;
  communicationRating: number;
  professionalismRating: number;
  valueRating: number;
  timelinessRating: number;
  vendorSpecificRatings?: Record<string, number>;
  reviewText: string;
  thingsDoneWell: string;
  areasForImprovement: string;
  servicePackage: string;
  finalCost: number;
  wouldRecommend: boolean;
  wouldBookAgain: boolean;
  weddingSize: string;
  weddingStyle: string;
  venueType: string;
  season: string;
  reviewPhotos?: File[];
}

// POST /api/reviews/[id]/vote - Vote on review helpfulness
interface VoteOnReviewRequest {
  voteType: 'helpful' | 'not_helpful';
}

// POST /api/reviews/[id]/respond - Vendor response to review
interface RespondToReviewRequest {
  responseText: string;
  isPublic: boolean;
}

// GET /api/reviews/analytics/[vendorId] - Detailed review analytics
interface ReviewAnalyticsResponse {
  overviewStats: VendorReviewStats;
  trendAnalysis: {
    month: string;
    averageRating: number;
    reviewCount: number;
  }[];
  ratingDistribution: {
    rating: number;
    count: number;
    percentage: number;
  }[];
  competitorComparison: {
    yourRating: number;
    industryAverage: number;
    topPerformer: number;
  };
  sentimentAnalysis: {
    overallSentiment: 'positive' | 'neutral' | 'negative';
    positiveThemes: { theme: string; mentions: number }[];
    improvementAreas: { area: string; mentions: number }[];
  };
  actionableInsights: string[];
}
```

#### Frontend Components Required
```typescript
// Component: ReviewForm
// Location: /src/components/reviews/ReviewForm.tsx

interface ReviewFormProps {
  vendorId: string;
  vendorInfo: VendorInfo;
  contractInfo?: ContractInfo;
  onSubmit: (review: ReviewData) => void;
}

// Key functionality:
- Multi-step review wizard
- Vendor-specific rating categories
- Photo upload for review evidence
- Auto-save draft functionality
- Review preview before submission
- Anonymous vs public review options
- Integration with contract data

// Component: ReviewCard
// Location: /src/components/reviews/ReviewCard.tsx

interface ReviewCardProps {
  review: Review;
  showVendorResponse: boolean;
  allowVoting: boolean;
  onVote: (reviewId: string, voteType: string) => void;
}

// Key functionality:
- Expandable review content
- Rating visualization
- Photo gallery integration
- Vendor response display
- Helpfulness voting
- Share review functionality
- Verification badges
```

### CODE EXAMPLES

#### Example 1: Review Submission and Validation
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { supabase } from '@/lib/supabase';
import { ReviewValidator } from '@/lib/reviews/reviewValidator';
import { SentimentAnalyzer } from '@/lib/ai/sentimentAnalyzer';
import { PhotoProcessor } from '@/lib/services/photoProcessor';

export class ReviewService {
  private validator = new ReviewValidator();
  private sentimentAnalyzer = new SentimentAnalyzer();
  private photoProcessor = new PhotoProcessor();
  
  async submitReview(reviewData: CreateReviewRequest, reviewerId: string): Promise<{ reviewId: string; requiresModeration: boolean }> {
    // Step 1: Validate review data
    const validationResult = await this.validator.validateReview(reviewData);
    if (!validationResult.isValid) {
      throw new Error(`Validation failed: ${validationResult.errors.join(', ')}`);
    }
    
    // Step 2: Check for duplicate reviews
    const existingReview = await this.checkForExistingReview(reviewData.vendorId, reviewerId);
    if (existingReview) {
      throw new Error('You have already reviewed this vendor');
    }
    
    // Step 3: Verify reviewer worked with vendor
    const contractVerification = await this.verifyContractRelationship(reviewData.vendorId, reviewerId, reviewData.contractId);
    
    // Step 4: Process review photos if provided
    let processedPhotos: string[] = [];
    if (reviewData.reviewPhotos && reviewData.reviewPhotos.length > 0) {
      processedPhotos = await this.processReviewPhotos(reviewData.reviewPhotos);
    }
    
    // Step 5: Analyze review content for sentiment and moderation flags
    const contentAnalysis = await this.analyzeReviewContent(reviewData.reviewText);
    
    // Step 6: Determine if review needs moderation
    const requiresModeration = this.shouldModerateReview(contentAnalysis, reviewData);
    
    // Step 7: Save review to database
    const { data: review, error } = await supabase
      .from('vendor_reviews')
      .insert({
        vendor_id: reviewData.vendorId,
        reviewer_couple_id: reviewerId,
        contract_id: reviewData.contractId,
        wedding_date: reviewData.weddingDate,
        review_title: reviewData.reviewTitle,
        overall_rating: reviewData.overallRating,
        quality_rating: reviewData.qualityRating,
        communication_rating: reviewData.communicationRating,
        professionalism_rating: reviewData.professionalismRating,
        value_rating: reviewData.valueRating,
        timeliness_rating: reviewData.timelinessRating,
        vendor_specific_ratings: reviewData.vendorSpecificRatings,
        review_text: reviewData.reviewText,
        things_done_well: reviewData.thingsDoneWell,
        areas_for_improvement: reviewData.areasForImprovement,
        service_package: reviewData.servicePackage,
        final_cost: reviewData.finalCost,
        would_recommend: reviewData.wouldRecommend,
        would_book_again: reviewData.wouldBookAgain,
        wedding_size_category: reviewData.weddingSize,
        wedding_style: reviewData.weddingStyle,
        venue_type: reviewData.venueType,
        season: reviewData.season,
        review_photos: processedPhotos,
        is_verified: contractVerification.isVerified,
        verification_method: contractVerification.method,
        is_approved: !requiresModeration, // Auto-approve if no moderation needed
        has_portfolio_examples: processedPhotos.length > 0
      })
      .select()
      .single();
    
    if (error) {
      throw new Error(`Failed to save review: ${error.message}`);
    }
    
    // Step 8: Update vendor review statistics
    await this.updateVendorReviewStats(reviewData.vendorId);
    
    // Step 9: Notify vendor of new review (if approved)
    if (!requiresModeration) {
      await this.notifyVendorOfNewReview(reviewData.vendorId, review.id);
    }
    
    // Step 10: Update review invitation status
    await this.markReviewInvitationCompleted(reviewerId, reviewData.vendorId);
    
    return {
      reviewId: review.id,
      requiresModeration
    };
  }
  
  private async verifyContractRelationship(vendorId: string, reviewerId: string, contractId?: string): Promise<{ isVerified: boolean; method: string }> {
    // If contract ID provided, verify it exists and matches
    if (contractId) {
      const { data: contract, error } = await supabase
        .from('contracts')
        .select('id, vendor_id, couple_id')
        .eq('id', contractId)
        .eq('vendor_id', vendorId)
        .eq('couple_id', reviewerId)
        .single();
      
      if (contract && !error) {
        return { isVerified: true, method: 'contract' };
      }
    }
    
    // Look for any contract between reviewer and vendor
    const { data: anyContract, error } = await supabase
      .from('contracts')
      .select('id')
      .eq('vendor_id', vendorId)
      .eq('couple_id', reviewerId)
      .limit(1);
    
    if (anyContract && anyContract.length > 0 && !error) {
      return { isVerified: true, method: 'contract' };
    }
    
    // For now, allow unverified reviews but mark them as such
    return { isVerified: false, method: 'none' };
  }
  
  private async analyzeReviewContent(reviewText: string): Promise<ContentAnalysis> {
    const analysis = await this.sentimentAnalyzer.analyze(reviewText);
    
    return {
      sentiment: analysis.sentiment,
      confidence: analysis.confidence,
      flags: this.detectContentFlags(reviewText),
      keyPhrases: analysis.keyPhrases,
      toxicityScore: analysis.toxicityScore
    };
  }
  
  private detectContentFlags(text: string): string[] {
    const flags: string[] = [];
    const lowerText = text.toLowerCase();
    
    // Check for potentially problematic content
    const offensiveWords = ['scam', 'fraud', 'terrible', 'horrible', 'worst', 'disaster'];
    const personalAttacks = ['stupid', 'idiot', 'incompetent', 'unprofessional'];
    const legalConcerns = ['lawsuit', 'legal action', 'sue', 'contract breach'];
    
    if (offensiveWords.some(word => lowerText.includes(word))) {
      flags.push('potentially_offensive');
    }
    
    if (personalAttacks.some(word => lowerText.includes(word))) {
      flags.push('personal_attack');
    }
    
    if (legalConcerns.some(word => lowerText.includes(word))) {
      flags.push('legal_concern');
    }
    
    // Check for extremely short or generic reviews
    if (text.length < 50) {
      flags.push('too_short');
    }
    
    if (this.isGenericReview(text)) {
      flags.push('generic_content');
    }
    
    return flags;
  }
  
  private shouldModerateReview(contentAnalysis: ContentAnalysis, reviewData: CreateReviewRequest): boolean {
    // Flag for moderation if:
    // 1. Contains problematic content flags
    // 2. Very negative sentiment with low confidence
    // 3. Extreme rating mismatch (1-star with positive text or vice versa)
    // 4. High toxicity score
    
    if (contentAnalysis.flags.length > 0) {
      return true;
    }
    
    if (contentAnalysis.toxicityScore > 0.7) {
      return true;
    }
    
    if (contentAnalysis.sentiment === 'negative' && contentAnalysis.confidence > 0.8 && reviewData.overallRating >= 4) {
      return true; // Suspicious: very negative text but high rating
    }
    
    if (contentAnalysis.sentiment === 'positive' && contentAnalysis.confidence > 0.8 && reviewData.overallRating <= 2) {
      return true; // Suspicious: very positive text but low rating
    }
    
    return false;
  }
  
  private async processReviewPhotos(photos: File[]): Promise<string[]> {
    const processedUrls: string[] = [];
    
    for (const photo of photos) {
      try {
        // Validate image file
        if (!photo.type.startsWith('image/')) {
          continue; // Skip non-image files
        }
        
        if (photo.size > 10 * 1024 * 1024) { // 10MB limit
          continue; // Skip files that are too large
        }
        
        // Process image (resize, optimize)
        const processedImage = await this.photoProcessor.processImage(photo, {
          maxWidth: 1200,
          maxHeight: 1200,
          quality: 0.8,
          format: 'jpeg'
        });
        
        // Upload to storage
        const fileUrl = await this.uploadReviewPhoto(processedImage);
        processedUrls.push(fileUrl);
        
      } catch (error) {
        console.error('Failed to process review photo:', error);
        // Continue with other photos even if one fails
      }
    }
    
    return processedUrls;
  }
  
  private async updateVendorReviewStats(vendorId: string): Promise<void> {
    // Recalculate all review statistics for the vendor
    const { data: reviews } = await supabase
      .from('vendor_reviews')
      .select('*')
      .eq('vendor_id', vendorId)
      .eq('is_approved', true);
    
    if (!reviews || reviews.length === 0) {
      return;
    }
    
    const totalReviews = reviews.length;
    const avgOverallRating = reviews.reduce((sum, r) => sum + r.overall_rating, 0) / totalReviews;
    const avgQualityRating = reviews.reduce((sum, r) => sum + r.quality_rating, 0) / totalReviews;
    const avgCommunicationRating = reviews.reduce((sum, r) => sum + r.communication_rating, 0) / totalReviews;
    const avgProfessionalismRating = reviews.reduce((sum, r) => sum + r.professionalism_rating, 0) / totalReviews;
    const avgValueRating = reviews.reduce((sum, r) => sum + r.value_rating, 0) / totalReviews;
    const avgTimelinessRating = reviews.reduce((sum, r) => sum + r.timeliness_rating, 0) / totalReviews;
    
    // Rating distribution
    const ratingCounts = reviews.reduce((acc, review) => {
      acc[review.overall_rating] = (acc[review.overall_rating] || 0) + 1;
      return acc;
    }, {} as Record<number, number>);
    
    // Recommendation rates
    const recommendationRate = (reviews.filter(r => r.would_recommend).length / totalReviews) * 100;
    const repeatBookingRate = (reviews.filter(r => r.would_book_again).length / totalReviews) * 100;
    
    // Extract common themes
    const positiveThemes = await this.extractPositiveThemes(reviews);
    const improvementAreas = await this.extractImprovementAreas(reviews);
    
    // Upsert vendor stats
    await supabase
      .from('vendor_review_stats')
      .upsert({
        vendor_id: vendorId,
        total_reviews: totalReviews,
        average_overall_rating: Number(avgOverallRating.toFixed(2)),
        average_quality_rating: Number(avgQualityRating.toFixed(2)),
        average_communication_rating: Number(avgCommunicationRating.toFixed(2)),
        average_professionalism_rating: Number(avgProfessionalismRating.toFixed(2)),
        average_value_rating: Number(avgValueRating.toFixed(2)),
        average_timeliness_rating: Number(avgTimelinessRating.toFixed(2)),
        five_star_count: ratingCounts[5] || 0,
        four_star_count: ratingCounts[4] || 0,
        three_star_count: ratingCounts[3] || 0,
        two_star_count: ratingCounts[2] || 0,
        one_star_count: ratingCounts[1] || 0,
        recommendation_rate: Number(recommendationRate.toFixed(2)),
        repeat_booking_rate: Number(repeatBookingRate.toFixed(2)),
        positive_keywords: positiveThemes,
        improvement_keywords: improvementAreas,
        last_review_date: reviews[reviews.length - 1].created_at.split('T')[0],
        updated_at: new Date().toISOString()
      });
  }
  
  private async extractPositiveThemes(reviews: Review[]): Promise<string[]> {
    // Use AI to extract common positive themes from "things done well" sections
    const positiveTexts = reviews
      .map(r => r.things_done_well)
      .filter(text => text && text.length > 10)
      .join(' ');
    
    if (positiveTexts.length === 0) {
      return [];
    }
    
    const themes = await this.sentimentAnalyzer.extractKeyThemes(positiveTexts, 'positive');
    return themes.slice(0, 10); // Top 10 themes
  }
  
  private async extractImprovementAreas(reviews: Review[]): Promise<string[]> {
    // Use AI to extract common improvement areas
    const improvementTexts = reviews
      .map(r => r.areas_for_improvement)
      .filter(text => text && text.length > 10)
      .join(' ');
    
    if (improvementTexts.length === 0) {
      return [];
    }
    
    const areas = await this.sentimentAnalyzer.extractKeyThemes(improvementTexts, 'improvement');
    return areas.slice(0, 10); // Top 10 areas
  }
  
  async voteOnReview(reviewId: string, voteType: 'helpful' | 'not_helpful', voterEmail: string): Promise<void> {
    // Check if user already voted on this review
    const { data: existingVote } = await supabase
      .from('review_votes')
      .select('id, vote_type')
      .eq('review_id', reviewId)
      .eq('voter_email', voterEmail)
      .single();
    
    if (existingVote) {
      if (existingVote.vote_type === voteType) {
        // Same vote - remove it (toggle off)
        await supabase
          .from('review_votes')
          .delete()
          .eq('id', existingVote.id);
      } else {
        // Different vote - update it
        await supabase
          .from('review_votes')
          .update({ vote_type: voteType })
          .eq('id', existingVote.id);
      }
    } else {
      // New vote - insert it
      await supabase
        .from('review_votes')
        .insert({
          review_id: reviewId,
          voter_email: voterEmail,
          vote_type: voteType
        });
    }
  }
}

// API endpoint usage
export async function POST(request: Request) {
  const reviewData = await request.json();
  const reviewerId = await getCurrentUserId(request);
  
  if (!reviewerId) {
    return Response.json({ error: 'Unauthorized' }, { status: 401 });
  }
  
  try {
    const reviewService = new ReviewService();
    const result = await reviewService.submitReview(reviewData, reviewerId);
    
    return Response.json({
      reviewId: result.reviewId,
      requiresModeration: result.requiresModeration,
      message: result.requiresModeration 
        ? 'Review submitted for moderation' 
        : 'Review published successfully'
    });
    
  } catch (error) {
    console.error('Review submission failed:', error);
    return Response.json(
      { error: error.message },
      { status: 400 }
    );
  }
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [ ] Context7: Load docs for sentiment analysis, content moderation
- [ ] Playwright: Test review submission and display
- [ ] Filesystem: Access review templates and validation rules

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/openai/openai", "sentiment analysis moderation", 2500);
await mcp__context7__get-library-docs("/react-hook-form/react-hook-form", "multi step forms", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('Review Service', () => {
  it('should validate review data correctly', async () => {
    const validator = new ReviewValidator();
    const result = await validator.validateReview(mockInvalidReview);
    
    expect(result.isValid).toBe(false);
    expect(result.errors).toContain('Overall rating is required');
  });
  
  it('should detect content that requires moderation', async () => {
    const reviewService = new ReviewService();
    const shouldModerate = reviewService.shouldModerateReview({
      sentiment: 'negative',
      confidence: 0.9,
      flags: ['potentially_offensive'],
      toxicityScore: 0.8
    }, mockReviewData);
    
    expect(shouldModerate).toBe(true);
  });
  
  it('should update vendor statistics after review submission', async () => {
    await reviewService.submitReview(mockReviewData, 'reviewer-123');
    const stats = await reviewService.getVendorStats('vendor-456');
    
    expect(stats.totalReviews).toBeGreaterThan(0);
    expect(stats.averageOverallRating).toBeGreaterThan(0);
  });
});
```

#### E2E Tests Required
```typescript
test('Complete review submission flow', async () => {
  await mcp__playwright__browser_navigate({url: '/reviews/write/vendor-123'});
  
  // Step 1: Basic info
  await mcp__playwright__browser_type({
    element: "Review title input",
    ref: "input[name='reviewTitle']",
    text: "Excellent photographer - exceeded expectations"
  });
  
  // Step 2: Ratings
  await mcp__playwright__browser_click({
    element: "5-star overall rating",
    ref: "[data-rating='5'][data-category='overall']"
  });
  
  await mcp__playwright__browser_click({
    element: "5-star quality rating",
    ref: "[data-rating='5'][data-category='quality']"
  });
  
  // Step 3: Detailed feedback
  await mcp__playwright__browser_type({
    element: "Review text area",
    ref: "textarea[name='reviewText']",
    text: "Sarah was absolutely amazing from start to finish. She captured every moment perfectly and made us feel comfortable throughout the day. The photos exceeded our expectations and she delivered them ahead of schedule."
  });
  
  await mcp__playwright__browser_type({
    element: "Things done well area",
    ref: "textarea[name='thingsDoneWell']",
    text: "Great communication, arrived early, captured candid moments beautifully, delivered ahead of schedule"
  });
  
  // Step 4: Service details
  await mcp__playwright__browser_type({
    element: "Service package input",
    ref: "input[name='servicePackage']",
    text: "Premium Wedding Package"
  });
  
  await mcp__playwright__browser_type({
    element: "Final cost input",
    ref: "input[name='finalCost']",
    text: "4500"
  });
  
  // Step 5: Recommendations
  await mcp__playwright__browser_click({
    element: "Would recommend yes",
    ref: "input[name='wouldRecommend'][value='true']"
  });
  
  await mcp__playwright__browser_click({
    element: "Would book again yes",
    ref: "input[name='wouldBookAgain'][value='true']"
  });
  
  // Step 6: Upload photos (optional)
  await mcp__playwright__browser_file_upload({
    paths: ['/path/to/test-wedding-photo.jpg']
  });
  
  // Submit review
  await mcp__playwright__browser_click({
    element: "Submit review button",
    ref: "button[type='submit']"
  });
  
  await mcp__playwright__browser_wait_for({text: "Review published successfully"});
  
  // Verify review appears in vendor's profile
  await mcp__playwright__browser_navigate({url: '/reviews/vendor/vendor-123'});
  await mcp__playwright__browser_wait_for({text: "Excellent photographer"});
  await mcp__playwright__browser_wait_for({text: "5.0"}); // Rating display
});
```

### ACCEPTANCE CRITERIA
- [ ] Multi-step review form with vendor-specific questions
- [ ] Overall and category-specific ratings (1-5 stars)
- [ ] Photo upload with review evidence
- [ ] Automatic content moderation and flagging
- [ ] Vendor response system for reviews
- [ ] Review helpfulness voting
- [ ] Verified vs unverified review badges
- [ ] Advanced search and filtering of reviews
- [ ] Review analytics dashboard for vendors
- [ ] Integration with vendor profiles and search results

### DEPENDENCIES
- Must complete after: WS-081 (Vendor directory for review targets)
- Must complete before: Advanced recommendation engine
- Shares code with: Vendor management, content moderation, analytics

### ESTIMATED EFFORT
- Team C Integration: 34 hours (Review forms, analytics dashboard, moderation UI)
- Team B Backend: 30 hours (Review processing, sentiment analysis, statistics)
- Total: 64 hours