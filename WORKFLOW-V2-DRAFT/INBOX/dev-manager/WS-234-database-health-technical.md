# TECHNICAL SPECIFICATION: WS-234 - Database Health Monitoring System
## Generated by Feature Development Session - 2025-01-25

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** WedSync platform administrator managing 15,672 active wedding vendors and 28,341 client profiles
**I want to:** Monitor database health in real-time with automated alerts for connection pool exhaustion, storage approaching 5GB Supabase limit, slow queries >1000ms, and table bloat requiring vacuum
**So that:** I can prevent platform outages during peak wedding season (June: 1.6x traffic) when photographers upload ceremony photos, prevent wedding form data loss during venue booking deadlines, and maintain <500ms query response times for time-sensitive RSVP systems

**Real Wedding Scenario:**
"During peak wedding season, a photographer uploads 500 photos from a Saturday ceremony at 11 PM, triggering 847 database connections for thumbnail generation. Without database health monitoring, connection pool exhaustion occurs at 95% utilization, blocking new RSVP submissions for Sunday weddings. Database health system detects 90% pool utilization, automatically kills idle connections from completed photo uploads, and triggers emergency scaling to prevent Saturday night data loss and angry couples on Sunday morning."

### SPECIFICATION SOURCE
- **Feature ID:** WS-234
- **Original Spec:** /CORE-SPECIFICATIONS/07-ADMIN-DASHBOARD/04-Technical-Monitoring/04-database-health md.md
- **Current Implementation:** 0% complete (new feature)
- **Files to Modify:** None (new feature)
- **New Files to Create:**
  - `/src/components/admin/DatabaseHealthDashboard.tsx`
  - `/src/components/admin/QueryOptimizationPanel.tsx`
  - `/src/lib/monitoring/database-health-monitor.ts`
  - `/src/lib/monitoring/query-optimizer.ts`
  - `/src/lib/monitoring/database-maintenance.ts`
  - `/src/app/api/admin/database/health/route.ts`
  - `/src/hooks/useDatabaseHealth.ts`
  - `/supabase/migrations/[TIMESTAMP]_database_health_system.sql`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Database health monitoring tables
CREATE TABLE database_health_metrics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  metric_type TEXT NOT NULL, -- 'connection_pool', 'storage', 'query_performance', 'locks'
  metric_name TEXT NOT NULL,
  current_value DECIMAL NOT NULL,
  threshold_warning DECIMAL,
  threshold_critical DECIMAL,
  status TEXT NOT NULL DEFAULT 'healthy', -- 'healthy', 'warning', 'critical'
  details JSONB,
  measured_at TIMESTAMPTZ DEFAULT NOW(),
  resolved_at TIMESTAMPTZ
);

-- Query performance tracking
CREATE TABLE database_query_stats (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  query_hash TEXT NOT NULL,
  query_text TEXT NOT NULL,
  execution_count INTEGER DEFAULT 0,
  total_time_ms DECIMAL NOT NULL,
  avg_time_ms DECIMAL NOT NULL,
  max_time_ms DECIMAL NOT NULL,
  min_time_ms DECIMAL NOT NULL,
  last_execution TIMESTAMPTZ DEFAULT NOW(),
  optimization_suggestions JSONB,
  status TEXT DEFAULT 'active' -- 'active', 'optimized', 'flagged'
);

-- Database maintenance log
CREATE TABLE database_maintenance_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  maintenance_type TEXT NOT NULL, -- 'vacuum', 'reindex', 'analyze', 'cleanup'
  target_table TEXT,
  target_index TEXT,
  started_at TIMESTAMPTZ DEFAULT NOW(),
  completed_at TIMESTAMPTZ,
  status TEXT DEFAULT 'running', -- 'running', 'completed', 'failed'
  before_stats JSONB,
  after_stats JSONB,
  space_reclaimed_bytes BIGINT,
  error_message TEXT
);

-- Index health tracking
CREATE TABLE database_index_health (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  schema_name TEXT NOT NULL,
  table_name TEXT NOT NULL,
  index_name TEXT NOT NULL,
  index_size_bytes BIGINT NOT NULL,
  usage_count BIGINT DEFAULT 0,
  last_used TIMESTAMPTZ,
  bloat_percentage DECIMAL,
  recommendation TEXT, -- 'drop_unused', 'rebuild_bloated', 'optimize', 'keep'
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_health_metrics_type_status ON database_health_metrics(metric_type, status, measured_at DESC);
CREATE INDEX idx_query_stats_performance ON database_query_stats(avg_time_ms DESC, execution_count DESC);
CREATE INDEX idx_maintenance_log_status ON database_maintenance_log(status, started_at DESC);
CREATE INDEX idx_index_health_recommendation ON database_index_health(recommendation, bloat_percentage DESC);
```

#### API Endpoints Required
```typescript
// GET /api/admin/database/health
interface DatabaseHealthResponse {
  overallStatus: 'healthy' | 'warning' | 'critical';
  connectionPool: {
    active: number;
    idle: number;
    total: number;
    maxConnections: number;
    utilizationPercent: number;
    status: HealthStatus;
  };
  storage: {
    used: number;
    available: number;
    percentage: number;
    largestTables: TableSizeInfo[];
    status: HealthStatus;
  };
  queryPerformance: {
    avgTime: number;
    p95Time: number;
    p99Time: number;
    slowQueries: SlowQuery[];
    status: HealthStatus;
  };
  locks: {
    blockingQueries: BlockingQuery[];
    totalLocks: number;
    status: HealthStatus;
  };
  indexHealth: {
    unusedIndexes: UnusedIndex[];
    bloatedIndexes: BloatedIndex[];
    missingIndexRecommendations: IndexRecommendation[];
  };
  lastUpdated: string;
}

// POST /api/admin/database/optimize
interface OptimizationRequest {
  action: 'vacuum_table' | 'reindex' | 'kill_query' | 'analyze_table';
  target: string;
  parameters?: Record<string, any>;
}

// GET /api/admin/database/maintenance/history
interface MaintenanceHistory {
  recentActions: MaintenanceAction[];
  scheduledActions: ScheduledMaintenance[];
  recommendations: MaintenanceRecommendation[];
}
```

#### Frontend Components Required
```typescript
// Component: DatabaseHealthDashboard
// Location: /src/components/admin/DatabaseHealthDashboard.tsx

interface DatabaseHealthDashboardProps {
  refreshInterval?: number; // seconds, default 30
  showOptimizationPanel?: boolean;
}

// Key functionality:
- Real-time health status overview with traffic light indicators
- Connection pool utilization chart with wedding season context
- Storage usage breakdown by table type (forms, photos, logs)
- Query performance metrics with slow query identification
- Lock monitoring with blocking query details
- Index health analysis with optimization recommendations
- Automated maintenance scheduling and history
- Emergency action buttons (kill queries, vacuum tables, restart connections)

// Component: QueryOptimizationPanel
// Location: /src/components/admin/QueryOptimizationPanel.tsx

interface QueryOptimizationPanelProps {
  slowQueries: SlowQuery[];
  onOptimizeQuery: (queryId: string, optimization: OptimizationSuggestion) => void;
  onKillQuery: (queryId: string) => void;
}

// Key functionality:
- Slow query visualization with execution plans
- Optimization suggestions with estimated performance improvement
- Index recommendation engine for common patterns
- Query rewriting assistance for N+1 problems
- Performance impact calculator for optimization changes
```

#### Integration Points
```typescript
// Service: DatabaseHealthMonitor
// Dependencies: Supabase client, Alert system, Maintenance scheduler

class DatabaseHealthMonitor {
  private static instance: DatabaseHealthMonitor;
  private healthMetrics: DatabaseHealthMetrics;
  private alertThresholds = {
    connectionPool: { warning: 70, critical: 90 },
    storage: { warning: 80, critical: 90 },
    avgQueryTime: { warning: 500, critical: 1000 },
    blockingQueries: { warning: 1, critical: 5 }
  };

  async startRealTimeMonitoring(): Promise<void> {
    // Start background monitoring every 30 seconds
    setInterval(async () => {
      await this.checkDatabaseHealth();
      await this.triggerAlertsIfNeeded();
      await this.performAutomatedMaintenance();
    }, 30000);
  }

  async checkDatabaseHealth(): Promise<DatabaseHealthMetrics> {
    const checks = await Promise.all([
      this.checkConnectionPool(),
      this.checkStorageUsage(),
      this.checkQueryPerformance(),
      this.checkLockContention(),
      this.checkIndexHealth(),
      this.checkTableBloat()
    ]);

    return this.aggregateHealthMetrics(checks);
  }

  private async checkConnectionPool(): Promise<ConnectionPoolMetrics> {
    const query = `
      SELECT
        count(*) FILTER (WHERE state = 'active') as active,
        count(*) FILTER (WHERE state = 'idle') as idle,
        count(*) FILTER (WHERE wait_event_type = 'Client') as waiting
      FROM pg_stat_activity
      WHERE datname = current_database()
        AND pid != pg_backend_pid();
    `;

    const result = await this.executeQuery(query);
    const utilization = ((result.active + result.idle) / 100) * 100;

    // Wedding season adjustment - expect 1.6x traffic in June
    const seasonMultiplier = this.getWeddingSeasonMultiplier();
    const adjustedUtilization = utilization / seasonMultiplier;

    return {
      active: result.active,
      idle: result.idle,
      waiting: result.waiting,
      utilization: utilization,
      adjustedUtilization: adjustedUtilization,
      status: this.getHealthStatus('connectionPool', utilization)
    };
  }

  private getWeddingSeasonMultiplier(): number {
    const month = new Date().getMonth() + 1;
    // Wedding season peaks: May (1.4x), June (1.6x), July (1.5x), September (1.3x), October (1.4x)
    const multipliers = { 5: 1.4, 6: 1.6, 7: 1.5, 9: 1.3, 10: 1.4 };
    return multipliers[month] || 1.0;
  }
}

// Service: QueryOptimizer
// Dependencies: pg_stat_statements extension, Index analyzer

class QueryOptimizer {
  async analyzeSlowQueries(): Promise<OptimizationReport[]> {
    const slowQueries = await this.getSlowQueries();
    const reports: OptimizationReport[] = [];

    for (const query of slowQueries) {
      const plan = await this.getExecutionPlan(query.text);
      const suggestions = this.generateOptimizationSuggestions(plan, query);
      
      reports.push({
        queryId: query.id,
        originalQuery: query.text,
        currentPerformance: {
          avgTime: query.avg_time_ms,
          calls: query.execution_count
        },
        suggestions,
        estimatedImprovement: this.calculatePotentialImprovement(suggestions)
      });
    }

    return reports;
  }

  private generateOptimizationSuggestions(plan: any, query: any): OptimizationSuggestion[] {
    const suggestions: OptimizationSuggestion[] = [];

    // Check for sequential scans on large tables
    if (plan.includes('Seq Scan') && query.execution_count > 100) {
      suggestions.push({
        type: 'missing_index',
        description: 'Sequential scan detected on frequently queried table',
        impact: 'high',
        estimatedImprovement: '70-90% faster',
        action: 'CREATE INDEX on WHERE clause columns'
      });
    }

    // Check for N+1 query patterns
    if (this.detectNPlusOnePattern(query)) {
      suggestions.push({
        type: 'n_plus_one',
        description: 'Multiple similar queries detected - possible N+1 problem',
        impact: 'high',
        estimatedImprovement: '80-95% reduction in queries',
        action: 'Use JOIN or batch query instead'
      });
    }

    // Check for SELECT * queries
    if (query.text.includes('SELECT *')) {
      suggestions.push({
        type: 'select_optimization',
        description: 'Query selects all columns, specify only needed columns',
        impact: 'medium',
        estimatedImprovement: '20-40% less data transfer',
        action: 'Replace SELECT * with specific columns'
      });
    }

    return suggestions;
  }
}
```

### CODE EXAMPLES

#### Example 1: Real-Time Database Health Monitor
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { supabase } from '@/lib/supabase';
import { AlertManager } from '@/lib/monitoring/alert-manager';

export interface DatabaseHealthMetrics {
  status: 'healthy' | 'warning' | 'critical';
  connectionPool: ConnectionPoolMetrics;
  storage: StorageMetrics;
  queryPerformance: QueryPerformanceMetrics;
  locks: LockMetrics;
  indexHealth: IndexHealthMetrics;
  tableBloat: TableBloatMetrics;
  lastChecked: string;
}

export interface ConnectionPoolMetrics {
  active: number;
  idle: number;
  waiting: number;
  total: number;
  maxConnections: number;
  utilizationPercent: number;
  status: 'healthy' | 'warning' | 'critical';
  weddingSeasonAdjusted: boolean;
}

export class DatabaseHealthMonitor {
  private static instance: DatabaseHealthMonitor;
  private alertManager: AlertManager;
  private healthMetrics: DatabaseHealthMetrics;
  
  // Wedding season thresholds - higher tolerance during peak months
  private readonly THRESHOLDS = {
    connectionPool: {
      warning: { normal: 70, peak: 75 },
      critical: { normal: 85, peak: 90 }
    },
    storage: {
      warning: { normal: 4000, peak: 4200 }, // MB
      critical: { normal: 4500, peak: 4600 }
    },
    queryTime: {
      warning: { normal: 500, peak: 750 }, // ms
      critical: { normal: 1000, peak: 1500 }
    }
  };

  static getInstance(): DatabaseHealthMonitor {
    if (!DatabaseHealthMonitor.instance) {
      DatabaseHealthMonitor.instance = new DatabaseHealthMonitor();
    }
    return DatabaseHealthMonitor.instance;
  }

  constructor() {
    this.alertManager = new AlertManager();
    this.healthMetrics = this.initializeHealthMetrics();
  }

  async startRealTimeMonitoring(): Promise<void> {
    console.log('Starting database health monitoring...');
    
    // Initial health check
    await this.checkDatabaseHealth();
    
    // Schedule regular health checks every 30 seconds
    setInterval(async () => {
      try {
        await this.checkDatabaseHealth();
        await this.triggerAlertsIfNeeded();
        await this.performAutomatedMaintenance();
      } catch (error) {
        console.error('Database health check failed:', error);
        await this.handleMonitoringError(error);
      }
    }, 30000);

    // Schedule deep analysis every 5 minutes
    setInterval(async () => {
      await this.performDeepAnalysis();
    }, 300000);

    console.log('Database health monitoring started successfully');
  }

  async checkDatabaseHealth(): Promise<DatabaseHealthMetrics> {
    const startTime = Date.now();
    
    try {
      // Execute health checks in parallel for better performance
      const [
        connectionPool,
        storage,
        queryPerformance,
        locks,
        indexHealth,
        tableBloat
      ] = await Promise.all([
        this.checkConnectionPool(),
        this.checkStorageUsage(),
        this.checkQueryPerformance(),
        this.checkLockContention(),
        this.checkIndexHealth(),
        this.checkTableBloat()
      ]);

      this.healthMetrics = {
        status: this.calculateOverallHealth(connectionPool, storage, queryPerformance, locks),
        connectionPool,
        storage,
        queryPerformance,
        locks,
        indexHealth,
        tableBloat,
        lastChecked: new Date().toISOString()
      };

      // Log health check performance
      const duration = Date.now() - startTime;
      if (duration > 5000) { // Health check taking too long
        console.warn(`Database health check took ${duration}ms - performance degrading`);
      }

      // Store health metrics for historical analysis
      await this.storeHealthMetrics();

      return this.healthMetrics;
    } catch (error) {
      console.error('Database health check failed:', error);
      throw error;
    }
  }

  private async checkConnectionPool(): Promise<ConnectionPoolMetrics> {
    const query = `
      SELECT
        count(*) FILTER (WHERE state = 'active') as active,
        count(*) FILTER (WHERE state = 'idle') as idle,
        count(*) FILTER (WHERE state = 'idle in transaction') as idle_in_transaction,
        count(*) FILTER (WHERE wait_event_type = 'Client') as waiting
      FROM pg_stat_activity
      WHERE datname = current_database()
        AND pid != pg_backend_pid();
    `;

    const { data, error } = await supabase.rpc('execute_sql', { sql: query });
    if (error) throw error;

    const result = data[0];
    const total = result.active + result.idle;
    const maxConnections = 100; // Supabase default
    const utilizationPercent = (total / maxConnections) * 100;

    // Apply wedding season adjustments
    const isWeddingSeason = this.isWeddingSeason();
    const thresholds = isWeddingSeason ? 
      this.THRESHOLDS.connectionPool.warning.peak :
      this.THRESHOLDS.connectionPool.warning.normal;

    const status = this.getConnectionPoolStatus(utilizationPercent, isWeddingSeason);

    // Check for connection leaks (idle in transaction)
    if (result.idle_in_transaction > 5) {
      await this.alertManager.createAlert({
        type: 'database_connection_leak',
        severity: 'warning',
        message: `${result.idle_in_transaction} connections idle in transaction`,
        metadata: { idle_in_transaction: result.idle_in_transaction }
      });
    }

    return {
      active: result.active,
      idle: result.idle,
      waiting: result.waiting,
      total,
      maxConnections,
      utilizationPercent,
      status,
      weddingSeasonAdjusted: isWeddingSeason
    };
  }

  private async checkStorageUsage(): Promise<StorageMetrics> {
    const sizeQuery = `
      SELECT
        pg_database_size(current_database()) as database_size,
        pg_size_pretty(pg_database_size(current_database())) as database_size_pretty
    `;

    const tableSizeQuery = `
      SELECT
        schemaname,
        tablename,
        pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as size,
        pg_total_relation_size(schemaname||'.'||tablename) as size_bytes
      FROM pg_tables
      WHERE schemaname = 'public'
      ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC
      LIMIT 10;
    `;

    const [sizeResult, tableResult] = await Promise.all([
      supabase.rpc('execute_sql', { sql: sizeQuery }),
      supabase.rpc('execute_sql', { sql: tableSizeQuery })
    ]);

    if (sizeResult.error) throw sizeResult.error;
    if (tableResult.error) throw tableResult.error;

    const databaseSize = sizeResult.data[0];
    const largestTables = tableResult.data;

    const maxSize = 5 * 1024 * 1024 * 1024; // 5GB Supabase limit
    const usedBytes = databaseSize.database_size;
    const percentage = (usedBytes / maxSize) * 100;

    const status = this.getStorageStatus(percentage);

    // Check for rapid growth patterns
    await this.checkStorageGrowthRate(usedBytes);

    return {
      used: usedBytes,
      available: maxSize - usedBytes,
      percentage,
      prettySize: databaseSize.database_size_pretty,
      maxSize: '5 GB',
      largestTables,
      status,
      warning: percentage > 80,
      critical: percentage > 90
    };
  }

  private async checkQueryPerformance(): Promise<QueryPerformanceMetrics> {
    // Get slow queries from pg_stat_statements
    const slowQueryQuery = `
      SELECT
        query,
        calls,
        mean_exec_time,
        total_exec_time,
        stddev_exec_time,
        max_exec_time
      FROM pg_stat_statements
      WHERE mean_exec_time > 100
        AND query NOT LIKE '%pg_stat_statements%'
        AND query NOT LIKE '%EXPLAIN%'
      ORDER BY mean_exec_time DESC
      LIMIT 20;
    `;

    const performanceStatsQuery = `
      SELECT
        ROUND(AVG(mean_exec_time)::numeric, 2) as avg_time,
        ROUND(PERCENTILE_CONT(0.50) WITHIN GROUP (ORDER BY mean_exec_time)::numeric, 2) as median_time,
        ROUND(PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY mean_exec_time)::numeric, 2) as p95_time,
        ROUND(PERCENTILE_CONT(0.99) WITHIN GROUP (ORDER BY mean_exec_time)::numeric, 2) as p99_time,
        COUNT(*) as total_queries
      FROM pg_stat_statements
      WHERE query NOT LIKE '%pg_stat_statements%';
    `;

    const [slowQueries, performanceStats] = await Promise.all([
      supabase.rpc('execute_sql', { sql: slowQueryQuery }),
      supabase.rpc('execute_sql', { sql: performanceStatsQuery })
    ]);

    if (slowQueries.error) throw slowQueries.error;
    if (performanceStats.error) throw performanceStats.error;

    const stats = performanceStats.data[0];
    const slow = slowQueries.data;

    const status = this.getQueryPerformanceStatus(stats.avg_time);

    // Wedding-specific query analysis
    const weddingSeasonQueries = slow.filter(q => 
      q.query.includes('form_responses') || 
      q.query.includes('journey_events') || 
      q.query.includes('email_logs')
    );

    return {
      avgTime: stats.avg_time,
      medianTime: stats.median_time,
      p95Time: stats.p95_time,
      p99Time: stats.p99_time,
      totalQueries: stats.total_queries,
      slowQueries: slow.map(q => ({
        query: this.sanitizeQuery(q.query),
        avgTime: q.mean_exec_time,
        calls: q.calls,
        totalTime: q.total_exec_time,
        maxTime: q.max_exec_time,
        optimization: this.suggestOptimization(q)
      })),
      weddingSeasonImpact: weddingSeasonQueries.length,
      status
    };
  }

  private isWeddingSeason(): boolean {
    const month = new Date().getMonth() + 1;
    // Peak months: May, June, July, September, October
    return [5, 6, 7, 9, 10].includes(month);
  }

  private getConnectionPoolStatus(utilization: number, isWeddingSeason: boolean): 'healthy' | 'warning' | 'critical' {
    const thresholds = isWeddingSeason ? 
      { warning: 75, critical: 90 } : 
      { warning: 70, critical: 85 };

    if (utilization >= thresholds.critical) return 'critical';
    if (utilization >= thresholds.warning) return 'warning';
    return 'healthy';
  }

  private getStorageStatus(percentage: number): 'healthy' | 'warning' | 'critical' {
    if (percentage >= 90) return 'critical';
    if (percentage >= 80) return 'warning';
    return 'healthy';
  }

  private getQueryPerformanceStatus(avgTime: number): 'healthy' | 'warning' | 'critical' {
    const isWeddingSeason = this.isWeddingSeason();
    const thresholds = isWeddingSeason ? 
      { warning: 750, critical: 1500 } : 
      { warning: 500, critical: 1000 };

    if (avgTime >= thresholds.critical) return 'critical';
    if (avgTime >= thresholds.warning) return 'warning';
    return 'healthy';
  }

  private calculateOverallHealth(...metrics: any[]): 'healthy' | 'warning' | 'critical' {
    const statuses = metrics.map(m => m.status);
    
    if (statuses.includes('critical')) return 'critical';
    if (statuses.includes('warning')) return 'warning';
    return 'healthy';
  }

  private async storeHealthMetrics(): Promise<void> {
    const { error } = await supabase
      .from('database_health_metrics')
      .insert([
        {
          metric_type: 'connection_pool',
          metric_name: 'utilization_percent',
          current_value: this.healthMetrics.connectionPool.utilizationPercent,
          threshold_warning: this.isWeddingSeason() ? 75 : 70,
          threshold_critical: this.isWeddingSeason() ? 90 : 85,
          status: this.healthMetrics.connectionPool.status,
          details: this.healthMetrics.connectionPool
        },
        {
          metric_type: 'storage',
          metric_name: 'percentage_used',
          current_value: this.healthMetrics.storage.percentage,
          threshold_warning: 80,
          threshold_critical: 90,
          status: this.healthMetrics.storage.status,
          details: this.healthMetrics.storage
        },
        {
          metric_type: 'query_performance',
          metric_name: 'avg_time_ms',
          current_value: this.healthMetrics.queryPerformance.avgTime,
          threshold_warning: this.isWeddingSeason() ? 750 : 500,
          threshold_critical: this.isWeddingSeason() ? 1500 : 1000,
          status: this.healthMetrics.queryPerformance.status,
          details: this.healthMetrics.queryPerformance
        }
      ]);

    if (error) {
      console.error('Failed to store health metrics:', error);
    }
  }

  async getHealthMetrics(): Promise<DatabaseHealthMetrics> {
    return this.healthMetrics;
  }
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Supabase: Complex database queries, health monitoring operations
- [x] PostgreSQL: Direct database access for maintenance operations
- [x] Filesystem: Log file access and monitoring configuration

#### Supabase MCP Queries Needed
```typescript
await mcp__supabase__execute_sql({
  query: "SELECT * FROM pg_stat_activity WHERE state != 'idle'"
});

await mcp__supabase__get_logs({
  service: "postgres"
});

await mcp__supabase__get_advisors({
  type: "performance"
});
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('DatabaseHealthMonitor', () => {
  it('should detect critical connection pool utilization', async () => {
    const monitor = DatabaseHealthMonitor.getInstance();
    const mockConnectionData = { active: 85, idle: 10, waiting: 5 };
    
    const metrics = await monitor.checkConnectionPool();
    expect(metrics.status).toBe('critical');
    expect(metrics.utilizationPercent).toBe(95);
  });

  it('should apply wedding season adjustments to thresholds', () => {
    const monitor = DatabaseHealthMonitor.getInstance();
    const juneThreshold = monitor.getWeddingSeasonThreshold('connection_pool');
    const januaryThreshold = monitor.getNormalThreshold('connection_pool');
    
    expect(juneThreshold).toBeGreaterThan(januaryThreshold);
  });

  it('should identify slow queries exceeding thresholds', async () => {
    const optimizer = new QueryOptimizer();
    const mockSlowQuery = {
      query: 'SELECT * FROM form_responses WHERE created_at > NOW() - INTERVAL \'1 day\'',
      mean_exec_time: 1500,
      calls: 100
    };
    
    const suggestions = optimizer.analyzeQuery(mockSlowQuery);
    expect(suggestions).toContainEqual(
      expect.objectContaining({
        type: 'missing_index',
        impact: 'high'
      })
    );
  });

  it('should recommend vacuum for bloated tables', async () => {
    const maintenance = new DatabaseMaintenance();
    const mockBloatedTable = {
      tablename: 'activity_logs',
      dead_tuple_percent: 35,
      size_bytes: 500000000
    };
    
    const recommendation = maintenance.getMaintenanceRecommendation(mockBloatedTable);
    expect(recommendation.action).toBe('VACUUM FULL');
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Admin can monitor database health and trigger maintenance', async () => {
  await mcp__playwright__browser_navigate({url: '/admin/database-health'});
  await mcp__playwright__browser_snapshot();
  
  // Check health dashboard loads with real-time metrics
  await mcp__playwright__browser_wait_for({text: 'Connection Pool'});
  await mcp__playwright__browser_wait_for({text: 'Storage Usage'});
  await mcp__playwright__browser_wait_for({text: 'Query Performance'});
  
  // Verify critical alert display
  const criticalAlert = '[data-testid="critical-health-alert"]';
  const alertExists = await mcp__playwright__browser_evaluate({
    function: `() => document.querySelector('${criticalAlert}') !== null`
  });
  
  if (alertExists) {
    // Test emergency action - kill slow queries
    await mcp__playwright__browser_click({
      element: 'Kill slow queries button',
      ref: '[data-testid="kill-slow-queries"]'
    });
    
    await mcp__playwright__browser_wait_for({text: 'Queries terminated successfully'});
  }
  
  // Test query optimization panel
  await mcp__playwright__browser_click({
    element: 'Query optimization tab',
    ref: '[data-testid="optimization-panel"]'
  });
  
  await mcp__playwright__browser_wait_for({text: 'Slow Queries'});
  await mcp__playwright__browser_snapshot();
});

test('Database maintenance can be triggered manually', async () => {
  await mcp__playwright__browser_navigate({url: '/admin/database-health'});
  
  // Navigate to maintenance section
  await mcp__playwright__browser_click({
    element: 'Maintenance tab',
    ref: '[data-testid="maintenance-tab"]'
  });
  
  // Trigger vacuum on bloated table
  await mcp__playwright__browser_click({
    element: 'Vacuum table button',
    ref: '[data-testid="vacuum-activity-logs"]'
  });
  
  // Verify maintenance job started
  await mcp__playwright__browser_wait_for({text: 'Maintenance job started'});
  await mcp__playwright__browser_wait_for({text: 'Vacuuming activity_logs'});
  
  await mcp__playwright__browser_snapshot();
});
```

### ACCEPTANCE CRITERIA
- [x] Real-time monitoring with <30 second update intervals
- [x] Connection pool monitoring with wedding season adjustments  
- [x] Storage usage tracking with 5GB Supabase limit awareness
- [x] Query performance analysis with >1000ms slow query detection
- [x] Index health monitoring with unused/bloated index identification
- [x] Automated maintenance scheduling for vacuum/reindex operations
- [x] Emergency actions: kill queries, terminate connections, trigger cleanup
- [x] Historical health metrics storage for trend analysis
- [x] Integration with alert system for critical conditions
- [x] Wedding industry specific optimizations (form_responses, journey_events)

### DEPENDENCIES
- Must complete after: Alert system (WS-228), Database infrastructure setup
- Must complete before: Performance optimization features, Automated scaling
- Shares code with: System monitoring dashboard, Alert management

### ESTIMATED EFFORT
- Team A Frontend: 20 hours (Health dashboard, optimization panel)
- Team B Backend: 28 hours (Health monitoring service, query optimizer, maintenance automation)
- Team C Integration: 16 hours (Alert integration, automated response system)
- Team D Platform: 12 hours (Database schema, monitoring queries, performance optimization)
- Team E General: 14 hours (Comprehensive testing, validation scenarios)
- Total: 90 hours