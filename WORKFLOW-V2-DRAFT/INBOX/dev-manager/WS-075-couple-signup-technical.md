# TECHNICAL SPECIFICATION: WS-075 - Couple Signup
## Generated by Feature Development Session - August 22, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Couple who clicked "Sign Up" from a supplier's invitation landing page
**I want to:** Complete registration quickly with minimal friction while my wedding details are automatically pre-filled
**So that:** I can immediately start using the wedding dashboard without re-entering information my photographer already has

**Real Wedding Scenario:**
Sarah and Mike click "Sign up with Google" from their photographer's invitation. The system creates their couple account, automatically links them to their photographer, pre-fills their wedding date and venue from the invitation, creates their core wedding details form, and takes them straight to their personalized dashboard - all in under 60 seconds without typing passwords or duplicate information.

### SPECIFICATION SOURCE
- **Feature ID:** WS-075
- **Original Spec:** /CORE-SPECIFICATIONS/03-WEDME-COUPLE-PLATFORM/01-Onboarding/02-couple-signup md.md
- **Current Implementation:** 0% complete
- **Files to Modify:**
  - /wedsync/src/app/(auth)/layout.tsx (add signup routing)
- **New Files to Create:**
  - /wedsync/src/app/signup/page.tsx
  - /wedsync/src/app/signup/verify/page.tsx
  - /wedsync/src/app/api/auth/signup/route.ts
  - /wedsync/src/app/api/auth/oauth/callback/route.ts
  - /wedsync/src/app/api/couples/create/route.ts
  - /wedsync/src/components/auth/CoupleSignupForm.tsx
  - /wedsync/src/components/auth/OAuthSignupButtons.tsx
  - /wedsync/src/components/auth/PartnerDetailsForm.tsx
  - /wedsync/src/lib/services/coupleAuthService.ts
  - /wedsync/src/lib/services/coupleOnboardingService.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Couples table (main couple account)
CREATE TABLE IF NOT EXISTS couples (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  partner1_name VARCHAR(255) NOT NULL,
  partner1_email VARCHAR(255) NOT NULL UNIQUE,
  partner1_auth_user_id UUID REFERENCES auth.users(id), -- Supabase auth user
  partner2_name VARCHAR(255),
  partner2_email VARCHAR(255),
  partner2_auth_user_id UUID REFERENCES auth.users(id),
  wedding_date DATE,
  created_via VARCHAR(50) DEFAULT 'direct', -- 'invitation', 'direct', 'referral'
  invitation_supplier_id UUID REFERENCES suppliers(id),
  signup_completed_at TIMESTAMP WITH TIME ZONE,
  last_active_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Core wedding fields (auto-created with couple)
CREATE TABLE IF NOT EXISTS core_fields (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  couple_id UUID NOT NULL REFERENCES couples(id),
  wedding_date DATE,
  ceremony_venue VARCHAR(500),
  reception_venue VARCHAR(500),
  guest_count INTEGER,
  wedding_style VARCHAR(100),
  budget_range VARCHAR(50),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  
  UNIQUE(couple_id)
);

-- Couple-supplier connections
CREATE TABLE IF NOT EXISTS couple_supplier_connections (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  couple_id UUID NOT NULL REFERENCES couples(id),
  supplier_id UUID NOT NULL REFERENCES suppliers(id),
  connection_type VARCHAR(50) DEFAULT 'invited', -- 'invited', 'connected', 'completed'
  connected_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  invitation_id UUID REFERENCES couple_invitations(id),
  
  UNIQUE(couple_id, supplier_id)
);

-- Signup progress tracking
CREATE TABLE IF NOT EXISTS couple_signup_progress (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  couple_id UUID NOT NULL REFERENCES couples(id),
  step_name VARCHAR(100) NOT NULL,
  completed_at TIMESTAMP WITH TIME ZONE,
  data JSONB, -- Store step-specific data
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  
  UNIQUE(couple_id, step_name)
);

-- Create indexes
CREATE INDEX idx_couples_partner1_email ON couples(partner1_email);
CREATE INDEX idx_couples_partner2_email ON couples(partner2_email) WHERE partner2_email IS NOT NULL;
CREATE INDEX idx_couples_invitation_supplier ON couples(invitation_supplier_id) WHERE invitation_supplier_id IS NOT NULL;
CREATE INDEX idx_couple_supplier_connections_couple ON couple_supplier_connections(couple_id);
```

#### API Endpoints Required
```typescript
// POST /api/auth/signup - Create couple account
interface CoupleSignupRequest {
  partner1Name: string;
  partner1Email: string;
  partner2Name?: string;
  partner2Email?: string;
  password?: string; // Not required for OAuth
  weddingDate?: string;
  invitationCode?: string;
  signupMethod: 'email' | 'google' | 'apple';
}

interface CoupleSignupResponse {
  success: boolean;
  couple: {
    id: string;
    partner1Name: string;
    partner2Name?: string;
    weddingDate?: string;
    supplierConnections: string[];
  };
  session?: AuthSession;
  requiresVerification?: boolean;
}

// POST /api/auth/oauth/callback - Handle OAuth signup completion
interface OAuthCallbackRequest {
  provider: 'google' | 'apple';
  authCode: string;
  invitationCode?: string;
  partner2Name?: string;
  partner2Email?: string;
}

// GET /api/couples/onboarding-status - Check onboarding progress
interface OnboardingStatusResponse {
  couple: CoupleData;
  completedSteps: string[];
  nextStep: string;
  supplierConnections: SupplierConnection[];
  prefilledData?: Record<string, any>;
}

// POST /api/couples/complete-step - Mark onboarding step as complete
interface CompleteStepRequest {
  stepName: string;
  stepData?: Record<string, any>;
}
```

#### Frontend Components Required
```typescript
// Component: CoupleSignupForm
// Location: /src/components/auth/CoupleSignupForm.tsx

interface CoupleSignupFormProps {
  invitationCode?: string;
  prefilledData?: PrefilledData;
  onSignupComplete: (couple: CoupleData) => void;
}

// Key functionality:
- Partner 1 and Partner 2 name/email inputs
- Optional wedding date picker
- Password field for email signup
- Form validation with real-time feedback
- Progress saving if user leaves mid-signup
- Mobile-optimized layout

// Component: OAuthSignupButtons
// Location: /src/components/auth/OAuthSignupButtons.tsx

interface OAuthSignupButtonsProps {
  invitationCode?: string;
  onSignupStart: (provider: 'google' | 'apple') => void;
  disabled?: boolean;
}

// Key functionality:
- Large, prominent Google and Apple buttons
- Loading states during OAuth flow
- Error handling for OAuth failures
- Accessibility compliance
- Mobile touch-friendly sizing

// Component: PartnerDetailsForm
// Location: /src/components/auth/PartnerDetailsForm.tsx

interface PartnerDetailsFormProps {
  partner1Data: PartnerData;
  onPartner2Add: (partner2: PartnerData) => void;
  onSkip: () => void;
}

// Key functionality:
- Add second partner form (optional)
- Relationship type selection
- Skip option for single-partner planning
- Clear explanation of benefits
- Progress indicator
```

#### Integration Points
```typescript
// Service: CoupleAuthService
// Dependencies: Supabase Auth, OAuth providers

class CoupleAuthService {
  async signupWithEmail(signupData: CoupleSignupRequest) {
    // Step 1: Create Supabase auth user for partner 1
    const { data: authUser, error: authError } = await supabase.auth.signUp({
      email: signupData.partner1Email,
      password: signupData.password!,
      options: {
        data: {
          full_name: signupData.partner1Name,
          user_type: 'couple'
        }
      }
    });
    
    if (authError) throw authError;
    
    // Step 2: Create couple record
    const coupleData = await this.createCoupleRecord({
      ...signupData,
      partner1AuthUserId: authUser.user!.id
    });
    
    // Step 3: Handle invitation linking
    if (signupData.invitationCode) {
      await this.linkInvitationToCouple(signupData.invitationCode, coupleData.id);
    }
    
    return { couple: coupleData, requiresVerification: true };
  }
  
  async signupWithOAuth(provider: 'google' | 'apple', oauthData: OAuthCallbackRequest) {
    // Step 1: Complete OAuth flow
    const { data: authSession, error } = await supabase.auth.signInWithOAuth({
      provider,
      options: {
        redirectTo: `${process.env.NEXT_PUBLIC_APP_URL}/auth/callback`
      }
    });
    
    if (error) throw error;
    
    // Step 2: Extract user data from OAuth
    const userData = this.extractOAuthUserData(authSession, provider);
    
    // Step 3: Create couple record
    const coupleData = await this.createCoupleRecord({
      partner1Name: userData.name,
      partner1Email: userData.email,
      partner1AuthUserId: authSession.user.id,
      partner2Name: oauthData.partner2Name,
      partner2Email: oauthData.partner2Email,
      invitationCode: oauthData.invitationCode,
      signupMethod: provider
    });
    
    return { couple: coupleData, session: authSession };
  }
  
  private async createCoupleRecord(data: CreateCoupleData) {
    // Create couple
    const { data: couple } = await supabase
      .from('couples')
      .insert({
        partner1_name: data.partner1Name,
        partner1_email: data.partner1Email,
        partner1_auth_user_id: data.partner1AuthUserId,
        partner2_name: data.partner2Name,
        partner2_email: data.partner2Email,
        wedding_date: data.weddingDate,
        created_via: data.invitationCode ? 'invitation' : 'direct',
        invitation_supplier_id: data.invitationSupplierId
      })
      .select()
      .single();
    
    // Auto-create core fields record
    await supabase
      .from('core_fields')
      .insert({
        couple_id: couple.id,
        wedding_date: data.weddingDate
      });
    
    return couple;
  }
  
  async linkInvitationToCouple(invitationCode: string, coupleId: string) {
    // Get invitation details
    const { data: invitation } = await supabase
      .from('couple_invitations')
      .select('*')
      .eq('invitation_code', invitationCode)
      .single();
    
    if (!invitation) throw new Error('Invalid invitation code');
    
    // Create supplier connection
    await supabase
      .from('couple_supplier_connections')
      .insert({
        couple_id: coupleId,
        supplier_id: invitation.supplier_id,
        connection_type: 'invited',
        invitation_id: invitation.id
      });
    
    // Mark invitation as used
    await supabase
      .from('couple_invitations')
      .update({
        status: 'signed_up',
        signed_up_at: new Date().toISOString()
      })
      .eq('id', invitation.id);
    
    // Sync any pre-filled data
    await this.syncInvitationData(invitation.id, coupleId);
  }
}
```

### CODE EXAMPLES

#### Example 1: Complete Signup Flow Implementation
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { useState } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import { supabase } from '@/lib/supabase';

export default function CoupleSignupPage() {
  const [signupMethod, setSignupMethod] = useState<'email' | 'oauth' | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();
  const searchParams = useSearchParams();
  
  const invitationCode = searchParams.get('invitation');
  const preferredMethod = searchParams.get('method');
  
  // Step 1: Handle OAuth signup
  const handleOAuthSignup = async (provider: 'google' | 'apple') => {
    setLoading(true);
    setError(null);
    
    try {
      // Initiate OAuth flow with invitation context
      const redirectUrl = new URL('/auth/callback', window.location.origin);
      if (invitationCode) redirectUrl.searchParams.set('invitation', invitationCode);
      
      const { error } = await supabase.auth.signInWithOAuth({
        provider,
        options: {
          redirectTo: redirectUrl.toString(),
          queryParams: {
            invitation_code: invitationCode || ''
          }
        }
      });
      
      if (error) throw error;
      
    } catch (err) {
      setError(err.message);
      setLoading(false);
    }
  };
  
  // Step 2: Handle email signup
  const handleEmailSignup = async (formData: CoupleSignupFormData) => {
    setLoading(true);
    setError(null);
    
    try {
      const coupleAuthService = new CoupleAuthService();
      
      // Create account
      const result = await coupleAuthService.signupWithEmail({
        ...formData,
        invitationCode
      });
      
      if (result.requiresVerification) {
        // Redirect to email verification
        router.push(`/signup/verify?email=${encodeURIComponent(formData.partner1Email)}`);
      } else {
        // Direct to onboarding
        router.push('/onboarding');
      }
      
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <div className="min-h-screen bg-gradient-to-br from-rose-50 to-pink-50 flex items-center justify-center p-4">
      <div className="max-w-md w-full space-y-8 bg-white rounded-xl shadow-lg p-8">
        {/* Header */}
        <div className="text-center">
          <h1 className="text-3xl font-bold text-gray-900 mb-2">
            Create Your Wedding Dashboard
          </h1>
          <p className="text-gray-600">
            {invitationCode ? 'Complete your invitation signup' : 'Start planning your perfect day'}
          </p>
        </div>
        
        {error && (
          <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-md">
            {error}
          </div>
        )}
        
        {/* OAuth Buttons */}
        <div className="space-y-3">
          <button
            onClick={() => handleOAuthSignup('google')}
            disabled={loading}
            className="w-full flex items-center justify-center px-4 py-3 border border-gray-300 rounded-md shadow-sm bg-white text-sm font-medium text-gray-700 hover:bg-gray-50 disabled:opacity-50"
          >
            <svg className="w-5 h-5 mr-2" viewBox="0 0 24 24">
              {/* Google icon SVG */}
            </svg>
            Continue with Google
          </button>
          
          <button
            onClick={() => handleOAuthSignup('apple')}
            disabled={loading}
            className="w-full flex items-center justify-center px-4 py-3 border border-gray-300 rounded-md shadow-sm bg-black text-sm font-medium text-white hover:bg-gray-800 disabled:opacity-50"
          >
            <svg className="w-5 h-5 mr-2 fill-white" viewBox="0 0 24 24">
              {/* Apple icon SVG */}
            </svg>
            Continue with Apple
          </button>
        </div>
        
        {/* Divider */}
        <div className="relative">
          <div className="absolute inset-0 flex items-center">
            <div className="w-full border-t border-gray-300" />
          </div>
          <div className="relative flex justify-center text-sm">
            <span className="px-2 bg-white text-gray-500">or continue with email</span>
          </div>
        </div>
        
        {/* Email Signup Form */}
        <CoupleSignupForm
          invitationCode={invitationCode}
          onSignupComplete={handleEmailSignup}
          loading={loading}
        />
        
        {/* Trust Signals */}
        <div className="text-center">
          <div className="flex items-center justify-center space-x-4 text-sm text-gray-500">
            <span className="flex items-center">
              <svg className="w-4 h-4 mr-1 text-green-500" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
              </svg>
              100% Free
            </span>
            <span className="flex items-center">
              <svg className="w-4 h-4 mr-1 text-blue-500" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clipRule="evenodd" />
              </svg>
              Secure & Private
            </span>
          </div>
        </div>
      </div>
    </div>
  );
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [ ] Context7: Load docs for Supabase Auth, OAuth providers
- [ ] Playwright: Test signup flow and form validation
- [ ] Filesystem: Access signup templates and verification emails

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/supabase/auth-js", "oauth signup", 3000);
await mcp__context7__get-library-docs("/react-hook-form/react-hook-form", "validation", 2000);
await mcp__context7__get-library-docs("/vercel/next.js", "searchParams", 1500);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('Couple Auth Service', () => {
  it('should create couple record with OAuth data', async () => {
    const mockOAuthData = {
      provider: 'google',
      authCode: 'auth123',
      invitationCode: 'invite456'
    };
    
    const result = await coupleAuthService.signupWithOAuth('google', mockOAuthData);
    
    expect(result.couple.id).toBeTruthy();
    expect(result.couple.partner1_email).toBe('test@gmail.com');
    expect(result.couple.created_via).toBe('invitation');
  });
  
  it('should link invitation to couple correctly', async () => {
    const coupleId = 'couple-123';
    const invitationCode = 'abc123def';
    
    await coupleAuthService.linkInvitationToCouple(invitationCode, coupleId);
    
    // Check connection created
    const connection = await getSupplierConnection(coupleId);
    expect(connection).toBeTruthy();
    expect(connection.connection_type).toBe('invited');
    
    // Check invitation marked as used
    const invitation = await getInvitation(invitationCode);
    expect(invitation.status).toBe('signed_up');
  });
  
  it('should handle missing second partner gracefully', async () => {
    const signupData = {
      partner1Name: 'John Doe',
      partner1Email: 'john@example.com',
      password: 'password123',
      signupMethod: 'email' as const
    };
    
    const result = await coupleAuthService.signupWithEmail(signupData);
    expect(result.couple.partner2_name).toBeNull();
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Complete couple signup flow', async () => {
  // Test landing on signup page with invitation
  await mcp__playwright__browser_navigate({url: '/signup?invitation=abc123&method=google'});
  await mcp__playwright__browser_snapshot();
  
  // Test Google OAuth signup
  await mcp__playwright__browser_click({
    element: "Continue with Google button",
    ref: "button:has-text('Continue with Google')"
  });
  
  // Mock OAuth success and return to app
  // (This would be mocked in test environment)
  
  // Test email signup fallback
  await mcp__playwright__browser_navigate({url: '/signup'});
  
  await mcp__playwright__browser_type({
    element: "Partner 1 name input",
    ref: "input[name='partner1Name']",
    text: "Sarah Johnson"
  });
  
  await mcp__playwright__browser_type({
    element: "Partner 1 email input",
    ref: "input[name='partner1Email']",
    text: "sarah@example.com"
  });
  
  // Test form validation
  await mcp__playwright__browser_click({
    element: "Create Account button",
    ref: "button[type='submit']"
  });
  
  await mcp__playwright__browser_wait_for({text: "Password is required"});
  
  // Complete signup
  await mcp__playwright__browser_type({
    element: "Password input",
    ref: "input[name='password']",
    text: "StrongPassword123!"
  });
  
  await mcp__playwright__browser_click({
    element: "Create Account button",
    ref: "button[type='submit']"
  });
  
  // Should redirect to verification or onboarding
  await mcp__playwright__browser_wait_for({text: "verify"});
});

test('Mobile signup experience', async () => {
  await mcp__playwright__browser_resize({width: 375, height: 667});
  await mcp__playwright__browser_navigate({url: '/signup'});
  await mcp__playwright__browser_snapshot();
  
  // Test touch-friendly buttons
  const googleButton = await mcp__playwright__browser_evaluate({
    function: "() => document.querySelector('[data-testid=\"google-signup\"]').offsetHeight"
  });
  expect(googleButton).toBeGreaterThan(44); // Minimum touch target
});
```

### ACCEPTANCE CRITERIA
- [ ] Couple signup completes in under 3 steps (method selection, details, confirmation)
- [ ] OAuth signup with Google and Apple works seamlessly on mobile and desktop
- [ ] Partner 2 details are optional and can be added later
- [ ] Invitation context automatically pre-fills supplier connection and wedding details
- [ ] Email verification required for email signups, optional for OAuth
- [ ] Core wedding fields record auto-created with couple account
- [ ] Performance: Signup form loads and responds within 1 second
- [ ] Security: Passwords meet complexity requirements, OAuth tokens handled securely
- [ ] Accessibility: Full keyboard navigation, screen reader compatible

### DEPENDENCIES
- Must complete after: WS-074 (Invitation Landing) - signup flow follows invitation landing
- Must complete before: WedMe dashboard and core features
- Shares code with: WedMe authentication system, couple data management

### ESTIMATED EFFORT
- Team A Frontend: 18 hours (Signup forms, OAuth integration, mobile optimization)
- Team B Backend: 16 hours (Couple account creation, invitation linking, auth endpoints)
- Team C Integration: 6 hours (OAuth provider setup, email verification system)
- Total: 40 hours