# TECHNICAL SPECIFICATION: WS-013 - Journey Canvas
## Generated by Feature Development Session - 2025-08-21

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding photographer creating systematic client onboarding workflows
**I want to:** Design visual automated journeys with drag-and-drop timeline nodes and communication modules
**So that:** I can create repeatable wedding preparation workflows instead of manually coordinating 50+ touchpoints per couple

**Real Wedding Scenario:**
A photographer needs to coordinate: initial questionnaire (booking day), engagement session planning (2 months before), timeline discussion (6 weeks before), final details (1 week before), day-of coordination. Currently managed with manual reminders and scattered notes, taking 30+ minutes per client to track and coordinate. With journey canvas, they visually design the workflow once: drag email modules to timeline anchors, set conditions for outdoor venues, create branching paths for different packages. This automated system manages all 50+ couples consistently, reducing coordination time from 25+ hours weekly to 5 hours weekly of monitoring and refinement.

### SPECIFICATION SOURCE
- **Feature ID:** WS-013
- **Original Spec:** /CORE-SPECIFICATIONS/02-WEDSYNC-SUPPLIER-PLATFORM/05-Customer-Journey/01-journey-canvas md.md
- **Current Implementation:** 0% complete
- **Files to Modify:** None - new feature
- **New Files to Create:**
  - /src/app/(dashboard)/journeys/canvas/page.tsx
  - /src/components/journey/JourneyCanvas.tsx
  - /src/components/journey/TimelineAxis.tsx
  - /src/components/journey/ModuleLibrary.tsx
  - /src/components/journey/NodeEditor.tsx
  - /src/lib/journey/canvasEngine.ts
  - /src/lib/stores/journeyCanvasStore.ts
  - /src/app/api/journeys/canvas/route.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Journey definitions and canvas layout
CREATE TABLE IF NOT EXISTS journeys (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  description TEXT,
  canvas_data JSONB NOT NULL, -- React Flow nodes and edges
  timeline_config JSONB NOT NULL, -- Timeline settings and anchors
  is_template BOOLEAN DEFAULT false,
  is_published BOOLEAN DEFAULT false,
  category TEXT CHECK (category IN ('onboarding', 'planning', 'coordination', 'follow_up', 'custom')) DEFAULT 'custom',
  usage_count INTEGER DEFAULT 0,
  last_modified_at TIMESTAMP DEFAULT NOW(),
  created_at TIMESTAMP DEFAULT NOW(),
  
  INDEX(supplier_id, is_published),
  INDEX(category),
  INDEX(usage_count DESC)
);

-- Journey execution instances for clients
CREATE TABLE IF NOT EXISTS journey_executions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  journey_id UUID REFERENCES journeys(id) ON DELETE CASCADE,
  client_id UUID REFERENCES client_profiles(id) ON DELETE CASCADE,
  status TEXT CHECK (status IN ('active', 'paused', 'completed', 'failed')) DEFAULT 'active',
  current_node_id TEXT, -- Current position in journey
  execution_data JSONB DEFAULT '{}', -- Runtime variables and state
  started_at TIMESTAMP DEFAULT NOW(),
  completed_at TIMESTAMP,
  paused_at TIMESTAMP,
  
  INDEX(journey_id, status),
  INDEX(client_id, status),
  INDEX(started_at)
);

-- Module execution history
CREATE TABLE IF NOT EXISTS module_executions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  journey_execution_id UUID REFERENCES journey_executions(id) ON DELETE CASCADE,
  node_id TEXT NOT NULL,
  module_type TEXT NOT NULL,
  module_data JSONB NOT NULL,
  execution_status TEXT CHECK (execution_status IN ('pending', 'executing', 'completed', 'failed', 'skipped')) DEFAULT 'pending',
  scheduled_for TIMESTAMP,
  executed_at TIMESTAMP,
  result_data JSONB DEFAULT '{}',
  error_message TEXT,
  
  INDEX(journey_execution_id, node_id),
  INDEX(execution_status),
  INDEX(scheduled_for)
);

-- Canvas collaboration and versioning
CREATE TABLE IF NOT EXISTS journey_versions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  journey_id UUID REFERENCES journeys(id) ON DELETE CASCADE,
  version_number INTEGER NOT NULL,
  canvas_data JSONB NOT NULL,
  timeline_config JSONB NOT NULL,
  change_summary TEXT,
  created_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMP DEFAULT NOW(),
  
  UNIQUE(journey_id, version_number)
);
```

#### API Endpoints Required
```typescript
// GET /api/journeys/canvas/[id]
interface GetJourneyCanvasResponse {
  success: boolean;
  data: {
    journey: {
      id: string;
      name: string;
      description: string;
      canvasData: {
        nodes: ReactFlowNode[];
        edges: ReactFlowEdge[];
        viewport: { x: number; y: number; zoom: number };
      };
      timelineConfig: {
        anchors: Array<{
          id: string;
          type: 'wedding_date' | 'booking_date' | 'fixed_date';
          offset: { value: number; unit: 'days' | 'weeks' | 'months'; direction: 'before' | 'after' };
          label: string;
        }>;
        settings: {
          skipWeekends: boolean;
          businessHoursOnly: boolean;
          timezone: string;
        };
      };
      isPublished: boolean;
      category: string;
      lastModified: string;
    };
    versions: Array<{
      version: number;
      changeSummary: string;
      createdAt: string;
      createdBy: string;
    }>;
    executionStats: {
      activeExecutions: number;
      completedExecutions: number;
      averageCompletionTime: number; // days
      successRate: number; // percentage
    };
  };
}

// PUT /api/journeys/canvas/[id]
interface UpdateJourneyCanvasRequest {
  name?: string;
  description?: string;
  canvasData?: {
    nodes: ReactFlowNode[];
    edges: ReactFlowEdge[];
    viewport: { x: number; y: number; zoom: number };
  };
  timelineConfig?: {
    anchors: TimelineAnchor[];
    settings: TimelineSettings;
  };
  changeSummary?: string;
}

// POST /api/journeys/canvas/[id]/publish
interface PublishJourneyRequest {
  publishNotes?: string;
  migrateActiveExecutions?: boolean;
}

interface PublishJourneyResponse {
  success: boolean;
  data: {
    publishedVersion: number;
    affectedExecutions: number;
    warnings: string[];
  };
}

// POST /api/journeys/canvas/[id]/test
interface TestJourneyRequest {
  testClientId?: string;
  simulationMode: 'fast' | 'real_time' | 'step_by_step';
  testData?: Record<string, any>;
}

interface TestJourneyResponse {
  success: boolean;
  data: {
    testExecutionId: string;
    estimatedDuration: number; // minutes for full test
    firstNodeId: string;
    warnings: Array<{
      nodeId: string;
      message: string;
      severity: 'warning' | 'error';
    }>;
  };
}

// GET /api/journeys/modules/library
interface GetModuleLibraryResponse {
  success: boolean;
  data: {
    categories: Array<{
      id: string;
      name: string;
      description: string;
      modules: Array<{
        id: string;
        name: string;
        description: string;
        icon: string;
        inputs: ModuleInput[];
        outputs: ModuleOutput[];
        tier: 'starter' | 'professional' | 'enterprise';
        estimatedDuration: number; // minutes
      }>;
    }>;
  };
}
```

#### Frontend Components Required
```typescript
// Component: JourneyCanvas
// Location: /src/components/journey/JourneyCanvas.tsx

interface JourneyCanvasProps {
  journeyId: string;
  journey: Journey;
  onSave: (canvasData: CanvasData) => void;
  onPublish: () => void;
  readonly?: boolean;
}

// Key functionality:
- React Flow canvas with drag-and-drop
- Node and edge creation/editing
- Timeline axis overlay
- Zoom and pan controls
- Mini-map for navigation
- Auto-layout algorithms
- Keyboard shortcuts (Ctrl+S, Delete, etc.)
- Real-time collaboration indicators

// Component: TimelineAxis
// Location: /src/components/journey/TimelineAxis.tsx

interface TimelineAxisProps {
  anchors: TimelineAnchor[];
  settings: TimelineSettings;
  onAnchorAdd: (position: Position) => void;
  onAnchorEdit: (anchorId: string) => void;
  selectedDateRange?: { start: Date; end: Date };
}

// Key functionality:
- Horizontal timeline with labeled anchors
- Drag-and-drop anchor positioning
- Visual date/time calculations
- Weekend and holiday indicators
- Business hours overlay
- Snap-to-grid functionality
- Timeline zoom and scroll

// Component: ModuleLibrary
// Location: /src/components/journey/ModuleLibrary.tsx

interface ModuleLibraryProps {
  modules: ModuleDefinition[];
  onModuleDrag: (module: ModuleDefinition) => void;
  searchTerm: string;
  onSearchChange: (term: string) => void;
  categoryFilter: string;
  onCategoryChange: (category: string) => void;
}

// Key functionality:
- Categorized module browser
- Search and filter modules
- Drag handles for canvas insertion
- Module preview with inputs/outputs
- Tier-based availability indicators
- Usage statistics display
- Custom module creation

// Component: NodeEditor
// Location: /src/components/journey/NodeEditor.tsx

interface NodeEditorProps {
  node: CanvasNode | null;
  onUpdate: (nodeId: string, updates: Partial<CanvasNode>) => void;
  onClose: () => void;
  availableModules: ModuleDefinition[];
}

// Key functionality:
- Module configuration panel
- Input/output mapping
- Condition builder for branching
- Preview of node execution
- Validation and error checking
- Template and preset selection
- Advanced settings panel
```

#### Integration Points
```typescript
// Canvas engine with React Flow integration
export class JourneyCanvasEngine {
  private reactFlowInstance: ReactFlowInstance | null = null;
  
  constructor() {
    this.setupDefaultNodeTypes();
  }
  
  private setupDefaultNodeTypes(): void {
    // Register custom node types
    this.registerNodeType('timeline', TimelineNode);
    this.registerNodeType('email', EmailModuleNode);
    this.registerNodeType('form', FormModuleNode);
    this.registerNodeType('condition', ConditionalNode);
    this.registerNodeType('delay', DelayNode);
  }
  
  async loadJourney(journeyId: string): Promise<JourneyCanvas> {
    const { data: journey } = await supabase
      .from('journeys')
      .select('*')
      .eq('id', journeyId)
      .single();
      
    if (!journey) {
      throw new Error('Journey not found');
    }
    
    return {
      id: journey.id,
      name: journey.name,
      nodes: journey.canvas_data.nodes || [],
      edges: journey.canvas_data.edges || [],
      viewport: journey.canvas_data.viewport || { x: 0, y: 0, zoom: 1 },
      timelineConfig: journey.timeline_config
    };
  }
  
  async saveJourney(journeyId: string, canvasData: CanvasData, changeSummary?: string): Promise<void> {
    // Step 1: Validate canvas structure
    const validationErrors = this.validateCanvas(canvasData);
    if (validationErrors.length > 0) {
      throw new Error(`Canvas validation failed: ${validationErrors.join(', ')}`);
    }
    
    // Step 2: Create new version
    const currentVersion = await this.getCurrentVersion(journeyId);
    const newVersion = currentVersion + 1;
    
    // Step 3: Save canvas data
    await supabase
      .from('journeys')
      .update({
        canvas_data: {
          nodes: canvasData.nodes,
          edges: canvasData.edges,
          viewport: canvasData.viewport
        },
        timeline_config: canvasData.timelineConfig,
        last_modified_at: new Date().toISOString()
      })
      .eq('id', journeyId);
    
    // Step 4: Create version history entry
    await supabase
      .from('journey_versions')
      .insert({
        journey_id: journeyId,
        version_number: newVersion,
        canvas_data: canvasData,
        timeline_config: canvasData.timelineConfig,
        change_summary: changeSummary || 'Canvas updated'
      });
  }
  
  private validateCanvas(canvasData: CanvasData): string[] {
    const errors: string[] = [];
    
    // Check for start node
    const startNodes = canvasData.nodes.filter(node => node.type === 'start');
    if (startNodes.length === 0) {
      errors.push('Journey must have a start node');
    } else if (startNodes.length > 1) {
      errors.push('Journey can only have one start node');
    }
    
    // Check for orphaned nodes
    const connectedNodeIds = new Set();
    canvasData.edges.forEach(edge => {
      connectedNodeIds.add(edge.source);
      connectedNodeIds.add(edge.target);
    });
    
    const orphanedNodes = canvasData.nodes.filter(node => 
      node.type !== 'start' && !connectedNodeIds.has(node.id)
    );
    
    if (orphanedNodes.length > 0) {
      errors.push(`Found ${orphanedNodes.length} disconnected nodes`);
    }
    
    // Check for circular dependencies
    if (this.hasCircularDependencies(canvasData.nodes, canvasData.edges)) {
      errors.push('Journey contains circular dependencies');
    }
    
    // Validate timeline anchors
    const anchors = canvasData.timelineConfig?.anchors || [];
    const timelineNodes = canvasData.nodes.filter(node => node.type === 'timeline');
    
    for (const node of timelineNodes) {
      const anchorId = node.data.anchorId;
      if (anchorId && !anchors.find(a => a.id === anchorId)) {
        errors.push(`Timeline node ${node.id} references non-existent anchor ${anchorId}`);
      }
    }
    
    return errors;
  }
  
  async publishJourney(journeyId: string, options: PublishOptions): Promise<PublishResult> {
    // Step 1: Final validation
    const journey = await this.loadJourney(journeyId);
    const validationErrors = this.validateCanvas(journey);
    
    if (validationErrors.length > 0) {
      throw new Error(`Cannot publish journey with validation errors: ${validationErrors.join(', ')}`);
    }
    
    // Step 2: Check for breaking changes
    const breakingChanges = await this.detectBreakingChanges(journeyId);
    
    // Step 3: Handle active executions
    let affectedExecutions = 0;
    if (options.migrateActiveExecutions && breakingChanges.length > 0) {
      affectedExecutions = await this.migrateActiveExecutions(journeyId, breakingChanges);
    }
    
    // Step 4: Publish journey
    await supabase
      .from('journeys')
      .update({
        is_published: true,
        last_modified_at: new Date().toISOString()
      })
      .eq('id', journeyId);
    
    return {
      publishedVersion: await this.getCurrentVersion(journeyId),
      affectedExecutions,
      warnings: breakingChanges.map(change => change.warning)
    };
  }
  
  private async detectBreakingChanges(journeyId: string): Promise<BreakingChange[]> {
    const changes: BreakingChange[] = [];
    
    // Get current published version
    const publishedJourney = await this.getPublishedVersion(journeyId);
    const currentJourney = await this.loadJourney(journeyId);
    
    if (!publishedJourney) return changes; // First publish
    
    // Check for removed nodes
    const publishedNodeIds = publishedJourney.nodes.map(n => n.id);
    const currentNodeIds = currentJourney.nodes.map(n => n.id);
    const removedNodes = publishedNodeIds.filter(id => !currentNodeIds.includes(id));
    
    if (removedNodes.length > 0) {
      changes.push({
        type: 'nodes_removed',
        nodeIds: removedNodes,
        warning: `${removedNodes.length} nodes removed - active executions may be affected`
      });
    }
    
    // Check for modified module types
    for (const currentNode of currentJourney.nodes) {
      const publishedNode = publishedJourney.nodes.find(n => n.id === currentNode.id);
      if (publishedNode && publishedNode.type !== currentNode.type) {
        changes.push({
          type: 'node_type_changed',
          nodeIds: [currentNode.id],
          warning: `Node ${currentNode.id} type changed from ${publishedNode.type} to ${currentNode.type}`
        });
      }
    }
    
    return changes;
  }
}

// Store: journeyCanvasStore
interface JourneyCanvasStore {
  currentJourney: Journey | null;
  nodes: Node[];
  edges: Edge[];
  selectedNodes: string[];
  selectedEdges: string[];
  
  loadJourney: (journeyId: string) => Promise<void>;
  saveJourney: (changeSummary?: string) => Promise<void>;
  
  addNode: (nodeType: string, position: Position, data?: any) => void;
  updateNode: (nodeId: string, updates: Partial<Node>) => void;
  deleteNode: (nodeId: string) => void;
  
  addEdge: (edge: Partial<Edge>) => void;
  deleteEdge: (edgeId: string) => void;
  
  setSelection: (nodeIds: string[], edgeIds: string[]) => void;
  clearSelection: () => void;
  
  undo: () => void;
  redo: () => void;
  
  publishJourney: (options: PublishOptions) => Promise<void>;
  testJourney: (testOptions: TestOptions) => Promise<void>;
}
```

### CODE EXAMPLES

#### Example 1: Dynamic Node Creation and Timeline Integration
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
export class TimelineIntegratedCanvas extends JourneyCanvasEngine {
  
  async createTimelineNode(position: Position, anchorConfig: TimelineAnchorConfig): Promise<TimelineNode> {
    // Step 1: Calculate timeline position
    const timelinePosition = await this.calculateTimelinePosition(anchorConfig);
    
    // Step 2: Create node with timeline data
    const nodeId = `timeline_${Date.now()}`;
    const timelineNode: TimelineNode = {
      id: nodeId,
      type: 'timeline',
      position,
      data: {
        anchorId: anchorConfig.anchorId,
        offset: anchorConfig.offset,
        calculatedDate: timelinePosition.date,
        businessDayAdjustment: timelinePosition.businessDayAdjustment,
        label: anchorConfig.label || `${anchorConfig.offset.value} ${anchorConfig.offset.unit} ${anchorConfig.offset.direction} ${anchorConfig.anchorType}`,
        settings: {
          skipWeekends: anchorConfig.skipWeekends ?? true,
          businessHoursOnly: anchorConfig.businessHoursOnly ?? false,
          timeOfDay: anchorConfig.timeOfDay || '09:00',
          timezone: anchorConfig.timezone || 'client_local'
        }
      },
      style: {
        background: this.getTimelineNodeColor(anchorConfig.offset.direction),
        border: '2px solid #3B82F6',
        borderRadius: '8px',
        fontSize: '12px'
      }
    };
    
    // Step 3: Validate timeline positioning
    const validationResult = await this.validateTimelineNode(timelineNode);
    if (!validationResult.valid) {
      throw new Error(`Timeline node validation failed: ${validationResult.errors.join(', ')}`);
    }
    
    // Step 4: Add to canvas
    this.addNodeToCanvas(timelineNode);
    
    // Step 5: Auto-connect to nearest compatible nodes
    await this.autoConnectTimelineNode(nodeId);
    
    return timelineNode;
  }
  
  private async calculateTimelinePosition(config: TimelineAnchorConfig): Promise<TimelinePosition> {
    // Get anchor date (wedding date, booking date, or fixed date)
    let anchorDate: Date;
    
    switch (config.anchorType) {
      case 'wedding_date':
        anchorDate = await this.getWeddingDate(config.clientId);
        break;
      case 'booking_date':
        anchorDate = await this.getBookingDate(config.clientId);
        break;
      case 'fixed_date':
        anchorDate = new Date(config.fixedDate!);
        break;
      default:
        throw new Error(`Unknown anchor type: ${config.anchorType}`);
    }
    
    // Calculate offset
    const offsetMs = this.convertOffsetToMilliseconds(config.offset);
    const targetDate = new Date(anchorDate.getTime() + offsetMs);
    
    // Apply business day adjustments
    let adjustedDate = targetDate;
    let businessDayAdjustment = '';
    
    if (config.skipWeekends) {
      const dayOfWeek = adjustedDate.getDay();
      if (dayOfWeek === 0) { // Sunday
        adjustedDate = new Date(adjustedDate.getTime() + 24 * 60 * 60 * 1000); // Move to Monday
        businessDayAdjustment = 'Moved from Sunday to Monday';
      } else if (dayOfWeek === 6) { // Saturday
        adjustedDate = new Date(adjustedDate.getTime() + 2 * 24 * 60 * 60 * 1000); // Move to Monday
        businessDayAdjustment = 'Moved from Saturday to Monday';
      }
    }
    
    // Check for holidays
    if (await this.isHoliday(adjustedDate)) {
      adjustedDate = await this.getNextBusinessDay(adjustedDate);
      businessDayAdjustment = (businessDayAdjustment ? businessDayAdjustment + '; ' : '') + 'Moved due to holiday';
    }
    
    return {
      date: adjustedDate,
      businessDayAdjustment,
      originalDate: targetDate,
      anchorDate
    };
  }
  
  private convertOffsetToMilliseconds(offset: TimelineOffset): number {
    const multiplier = offset.direction === 'before' ? -1 : 1;
    
    switch (offset.unit) {
      case 'days':
        return multiplier * offset.value * 24 * 60 * 60 * 1000;
      case 'weeks':
        return multiplier * offset.value * 7 * 24 * 60 * 60 * 1000;
      case 'months':
        return multiplier * offset.value * 30 * 24 * 60 * 60 * 1000; // Approximate
      default:
        throw new Error(`Unknown time unit: ${offset.unit}`);
    }
  }
  
  private async autoConnectTimelineNode(nodeId: string): Promise<void> {
    const timelineNode = this.getNode(nodeId);
    if (!timelineNode) return;
    
    // Find potential connections based on timeline sequence
    const allTimelineNodes = this.getNodesByType('timeline');
    const sortedNodes = allTimelineNodes
      .filter(node => node.id !== nodeId)
      .sort((a, b) => {
        const dateA = new Date(a.data.calculatedDate);
        const dateB = new Date(b.data.calculatedDate);
        return dateA.getTime() - dateB.getTime();
      });
    
    const currentDate = new Date(timelineNode.data.calculatedDate);
    
    // Connect to previous timeline node
    const previousNode = sortedNodes
      .reverse()
      .find(node => new Date(node.data.calculatedDate) < currentDate);
      
    if (previousNode) {
      this.addEdge({
        id: `${previousNode.id}_to_${nodeId}`,
        source: previousNode.id,
        target: nodeId,
        type: 'smoothstep',
        style: { stroke: '#10B981' }
      });
    }
    
    // Connect to next timeline node
    const nextNode = sortedNodes
      .reverse()
      .find(node => new Date(node.data.calculatedDate) > currentDate);
      
    if (nextNode) {
      this.addEdge({
        id: `${nodeId}_to_${nextNode.id}`,
        source: nodeId,
        target: nextNode.id,
        type: 'smoothstep',
        style: { stroke: '#10B981' }
      });
    }
  }
}
```

#### Example 2: Advanced Canvas Validation and Testing
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
export class JourneyCanvasValidator {
  
  async performComprehensiveValidation(canvas: CanvasData): Promise<ValidationResult> {
    const errors: ValidationError[] = [];
    const warnings: ValidationWarning[] = [];
    const suggestions: ValidationSuggestion[] = [];
    
    // Step 1: Structural validation
    const structuralIssues = this.validateStructure(canvas);
    errors.push(...structuralIssues.errors);
    warnings.push(...structuralIssues.warnings);
    
    // Step 2: Timeline validation
    const timelineIssues = this.validateTimeline(canvas);
    errors.push(...timelineIssues.errors);
    warnings.push(...timelineIssues.warnings);
    
    // Step 3: Module configuration validation
    const moduleIssues = await this.validateModuleConfigurations(canvas);
    errors.push(...moduleIssues.errors);
    warnings.push(...moduleIssues.warnings);
    
    // Step 4: Performance analysis
    const performanceIssues = this.analyzePerformance(canvas);
    warnings.push(...performanceIssues.warnings);
    suggestions.push(...performanceIssues.suggestions);
    
    // Step 5: Best practices check
    const bestPracticesSuggestions = this.checkBestPractices(canvas);
    suggestions.push(...bestPracticesSuggestions);
    
    return {
      valid: errors.length === 0,
      errors,
      warnings,
      suggestions,
      score: this.calculateQualityScore(canvas, errors, warnings, suggestions)
    };
  }
  
  private validateStructure(canvas: CanvasData): StructuralValidation {
    const errors: ValidationError[] = [];
    const warnings: ValidationWarning[] = [];
    
    // Check for start node
    const startNodes = canvas.nodes.filter(node => node.type === 'start');
    if (startNodes.length === 0) {
      errors.push({
        type: 'missing_start_node',
        message: 'Journey must have a start node',
        severity: 'error',
        nodeId: null
      });
    } else if (startNodes.length > 1) {
      errors.push({
        type: 'multiple_start_nodes',
        message: 'Journey can only have one start node',
        severity: 'error',
        nodeIds: startNodes.map(n => n.id)
      });
    }
    
    // Check for end conditions
    const endNodes = canvas.nodes.filter(node => 
      node.type === 'end' || this.isTerminalNode(node)
    );
    
    if (endNodes.length === 0) {
      warnings.push({
        type: 'no_end_condition',
        message: 'Journey has no clear end condition - clients may get stuck',
        severity: 'warning'
      });
    }
    
    // Check for unreachable nodes
    const reachableNodes = this.findReachableNodes(canvas, startNodes[0]?.id);
    const unreachableNodes = canvas.nodes.filter(node => 
      node.type !== 'start' && !reachableNodes.includes(node.id)
    );
    
    if (unreachableNodes.length > 0) {
      warnings.push({
        type: 'unreachable_nodes',
        message: `${unreachableNodes.length} nodes are not reachable from start`,
        severity: 'warning',
        nodeIds: unreachableNodes.map(n => n.id)
      });
    }
    
    // Check for infinite loops
    const loops = this.detectInfiniteLoops(canvas);
    if (loops.length > 0) {
      errors.push({
        type: 'infinite_loops',
        message: 'Journey contains potential infinite loops',
        severity: 'error',
        loops
      });
    }
    
    return { errors, warnings };
  }
  
  private async validateModuleConfigurations(canvas: CanvasData): Promise<ModuleValidation> {
    const errors: ValidationError[] = [];
    const warnings: ValidationWarning[] = [];
    
    for (const node of canvas.nodes) {
      if (node.type === 'timeline') continue; // Skip timeline nodes
      
      const moduleDefinition = await this.getModuleDefinition(node.type);
      if (!moduleDefinition) {
        errors.push({
          type: 'unknown_module_type',
          message: `Unknown module type: ${node.type}`,
          severity: 'error',
          nodeId: node.id
        });
        continue;
      }
      
      // Validate required inputs
      for (const requiredInput of moduleDefinition.requiredInputs) {
        if (!node.data[requiredInput.name]) {
          errors.push({
            type: 'missing_required_input',
            message: `Missing required input '${requiredInput.name}' for ${node.type} module`,
            severity: 'error',
            nodeId: node.id,
            field: requiredInput.name
          });
        }
      }
      
      // Validate input types and formats
      for (const [inputName, inputValue] of Object.entries(node.data)) {
        const inputDefinition = moduleDefinition.inputs.find(i => i.name === inputName);
        if (inputDefinition) {
          const validationResult = this.validateInputValue(inputValue, inputDefinition);
          if (!validationResult.valid) {
            errors.push({
              type: 'invalid_input_value',
              message: `Invalid value for '${inputName}': ${validationResult.error}`,
              severity: 'error',
              nodeId: node.id,
              field: inputName
            });
          }
        }
      }
      
      // Check for common configuration issues
      if (node.type === 'email' && !node.data.templateId && !node.data.content) {
        warnings.push({
          type: 'incomplete_email_config',
          message: 'Email module has no template or content specified',
          severity: 'warning',
          nodeId: node.id
        });
      }
      
      if (node.type === 'condition' && !node.data.condition) {
        errors.push({
          type: 'missing_condition',
          message: 'Conditional node has no condition specified',
          severity: 'error',
          nodeId: node.id
        });
      }
    }
    
    return { errors, warnings };
  }
  
  private analyzePerformance(canvas: CanvasData): PerformanceAnalysis {
    const warnings: ValidationWarning[] = [];
    const suggestions: ValidationSuggestion[] = [];
    
    // Check for excessive complexity
    const nodeCount = canvas.nodes.length;
    const edgeCount = canvas.edges.length;
    const complexity = (nodeCount * 2) + edgeCount;
    
    if (complexity > 100) {
      warnings.push({
        type: 'high_complexity',
        message: `Journey complexity score ${complexity} is high - consider breaking into smaller journeys`,
        severity: 'warning'
      });
    }
    
    // Check for bottlenecks
    const bottlenecks = this.findBottleneckNodes(canvas);
    if (bottlenecks.length > 0) {
      suggestions.push({
        type: 'optimize_bottlenecks',
        message: 'Consider parallelizing or optimizing high-traffic nodes',
        nodeIds: bottlenecks.map(b => b.nodeId),
        priority: 'medium'
      });
    }
    
    // Check for execution time estimates
    const estimatedDuration = this.estimateJourneyDuration(canvas);
    if (estimatedDuration > 365) { // Over a year
      warnings.push({
        type: 'long_duration',
        message: `Estimated journey duration is ${estimatedDuration} days - very long journeys may confuse clients`,
        severity: 'warning'
      });
    }
    
    return { warnings, suggestions };
  }
  
  private checkBestPractices(canvas: CanvasData): ValidationSuggestion[] {
    const suggestions: ValidationSuggestion[] = [];
    
    // Check for proper module spacing
    const timelineNodes = canvas.nodes.filter(n => n.type === 'timeline');
    if (timelineNodes.length >= 2) {
      const avgSpacing = this.calculateAverageTimelineSpacing(timelineNodes);
      if (avgSpacing < 3) { // Less than 3 days
        suggestions.push({
          type: 'timeline_spacing',
          message: 'Consider spacing timeline nodes at least 3 days apart to avoid overwhelming clients',
          priority: 'low'
        });
      }
    }
    
    // Check for communication balance
    const communicationNodes = canvas.nodes.filter(n => 
      ['email', 'sms', 'notification'].includes(n.type)
    );
    
    if (communicationNodes.length > timelineNodes.length * 2) {
      suggestions.push({
        type: 'communication_frequency',
        message: 'High communication frequency - consider if all messages add value for clients',
        priority: 'medium'
      });
    }
    
    // Check for personalization opportunities
    const emailNodes = canvas.nodes.filter(n => n.type === 'email');
    const personalizedEmails = emailNodes.filter(n => 
      n.data.content?.includes('{{') || n.data.templateId
    );
    
    if (personalizedEmails.length < emailNodes.length * 0.8) {
      suggestions.push({
        type: 'personalization',
        message: 'Consider adding more personalization to email communications',
        priority: 'low'
      });
    }
    
    return suggestions;
  }
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for React Flow and canvas libraries
- [ ] Playwright: Test journey canvas interactions and workflow execution
- [x] Filesystem: Access journey canvas components

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/xyflow/xyflow", "react flow canvas", 4000);
await mcp__context7__get-library-docs("/dnd-kit/dnd-kit", "drag and drop", 2000);
await mcp__context7__get-library-docs("/reactjs/react", "canvas performance", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('Journey Canvas Engine', () => {
  it('should validate canvas structure correctly', () => {
    const invalidCanvas = {
      nodes: [{ id: '1', type: 'email' }], // No start node
      edges: []
    };
    
    const validation = engine.validateStructure(invalidCanvas);
    
    expect(validation.errors).toHaveLength(1);
    expect(validation.errors[0].type).toBe('missing_start_node');
  });
  
  it('should calculate timeline positions correctly', async () => {
    const config = {
      anchorType: 'wedding_date',
      offset: { value: 30, unit: 'days', direction: 'before' },
      skipWeekends: true
    };
    
    const position = await engine.calculateTimelinePosition(config);
    
    expect(position.date).toBeDefined();
    expect(position.businessDayAdjustment).toBeDefined();
  });
  
  it('should detect infinite loops', () => {
    const canvasWithLoop = {
      nodes: [
        { id: 'start', type: 'start' },
        { id: 'node1', type: 'email' },
        { id: 'node2', type: 'condition' }
      ],
      edges: [
        { source: 'start', target: 'node1' },
        { source: 'node1', target: 'node2' },
        { source: 'node2', target: 'node1' } // Creates loop
      ]
    };
    
    const loops = engine.detectInfiniteLoops(canvasWithLoop);
    
    expect(loops).toHaveLength(1);
  });
});

describe('Canvas Validation', () => {
  it('should validate module configurations', async () => {
    const canvas = {
      nodes: [
        {
          id: 'email1',
          type: 'email',
          data: {} // Missing required template or content
        }
      ],
      edges: []
    };
    
    const validation = await validator.validateModuleConfigurations(canvas);
    
    expect(validation.warnings.some(w => w.type === 'incomplete_email_config')).toBe(true);
  });
  
  it('should calculate performance metrics', () => {
    const complexCanvas = {
      nodes: Array.from({ length: 50 }, (_, i) => ({ id: `node${i}`, type: 'email' })),
      edges: Array.from({ length: 100 }, (_, i) => ({ source: `node${i % 50}`, target: `node${(i + 1) % 50}` }))
    };
    
    const analysis = validator.analyzePerformance(complexCanvas);
    
    expect(analysis.warnings.some(w => w.type === 'high_complexity')).toBe(true);
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Journey canvas creation and editing', async () => {
  await mcp__playwright__browser_navigate({url: '/journeys/canvas/new'});
  
  // Create new journey
  await mcp__playwright__browser_type({
    element: 'Journey name',
    ref: '[data-testid="journey-name"]',
    text: 'Wedding Coordination Journey'
  });
  
  // Add start node
  await mcp__playwright__browser_drag({
    startElement: 'Start node',
    startRef: '[data-testid="module-start"]',
    endElement: 'Canvas',
    endRef: '[data-testid="canvas-drop-zone"]'
  });
  
  // Add timeline node
  await mcp__playwright__browser_drag({
    startElement: 'Timeline node',
    startRef: '[data-testid="module-timeline"]',
    endElement: 'Canvas position',
    endRef: '[data-canvas-x="300"][data-canvas-y="200"]'
  });
  
  // Configure timeline node
  await mcp__playwright__browser_click({
    element: 'Timeline node',
    ref: '[data-node-id="timeline-1"]'
  });
  
  await mcp__playwright__browser_select_option({
    element: 'Anchor type',
    ref: '[data-testid="anchor-type"]',
    values: ['wedding_date']
  });
  
  await mcp__playwright__browser_type({
    element: 'Offset value',
    ref: '[data-testid="offset-value"]',
    text: '30'
  });
  
  // Save configuration
  await mcp__playwright__browser_click({
    element: 'Save node',
    ref: '[data-testid="save-node"]'
  });
  
  // Add email module
  await mcp__playwright__browser_drag({
    startElement: 'Email module',
    startRef: '[data-testid="module-email"]',
    endElement: 'Canvas position',
    endRef: '[data-canvas-x="500"][data-canvas-y="200"]'
  });
  
  // Connect nodes
  await mcp__playwright__browser_drag({
    startElement: 'Timeline output',
    startRef: '[data-testid="timeline-1-output"]',
    endElement: 'Email input',
    endRef: '[data-testid="email-1-input"]'
  });
  
  // Save journey
  await mcp__playwright__browser_click({
    element: 'Save journey',
    ref: '[data-testid="save-journey"]'
  });
  
  await mcp__playwright__browser_wait_for({text: 'Journey saved successfully'});
});

test('Journey validation and testing', async () => {
  await mcp__playwright__browser_navigate({url: '/journeys/canvas/123'});
  
  // Run validation
  await mcp__playwright__browser_click({
    element: 'Validate journey',
    ref: '[data-testid="validate-journey"]'
  });
  
  // Check validation results
  await mcp__playwright__browser_wait_for({text: 'Validation Results'});
  
  // Should show any errors or warnings
  const hasErrors = await mcp__playwright__browser_evaluate({
    function: () => document.querySelector('[data-testid="validation-errors"]')?.textContent?.includes('error')
  });
  
  if (!hasErrors) {
    // Test journey execution
    await mcp__playwright__browser_click({
      element: 'Test journey',
      ref: '[data-testid="test-journey"]'
    });
    
    await mcp__playwright__browser_select_option({
      element: 'Test mode',
      ref: '[data-testid="test-mode"]',
      values: ['fast']
    });
    
    await mcp__playwright__browser_click({
      element: 'Start test',
      ref: '[data-testid="start-test"]'
    });
    
    // Monitor test execution
    await mcp__playwright__browser_wait_for({text: 'Test completed'});
  }
});

test('Journey publishing and collaboration', async () => {
  await mcp__playwright__browser_navigate({url: '/journeys/canvas/123'});
  
  // Publish journey
  await mcp__playwright__browser_click({
    element: 'Publish journey',
    ref: '[data-testid="publish-journey"]'
  });
  
  // Add publish notes
  await mcp__playwright__browser_type({
    element: 'Publish notes',
    ref: '[data-testid="publish-notes"]',
    text: 'Initial version with email and timeline modules'
  });
  
  // Confirm publish
  await mcp__playwright__browser_click({
    element: 'Confirm publish',
    ref: '[data-testid="confirm-publish"]'
  });
  
  await mcp__playwright__browser_wait_for({text: 'Journey published successfully'});
  
  // Check version history
  await mcp__playwright__browser_click({
    element: 'Version history',
    ref: '[data-testid="version-history"]'
  });
  
  await mcp__playwright__browser_wait_for({text: 'Version 1'});
});
```

### ACCEPTANCE CRITERIA
- [ ] Drag-and-drop canvas with React Flow supports 10+ node types
- [ ] Timeline integration calculates dates accurately with business day logic
- [ ] Node connections create valid workflow paths
- [ ] Real-time validation shows errors and warnings
- [ ] Journey testing simulates execution with sample data
- [ ] Auto-layout organizes nodes intelligently
- [ ] Undo/redo functionality preserves 20 actions
- [ ] Canvas saves automatically every 30 seconds
- [ ] Publishing handles active journey executions safely
- [ ] Version control tracks all changes with rollback
- [ ] Performance handles 100+ nodes smoothly
- [ ] Keyboard shortcuts improve efficiency

### DEPENDENCIES
- Must complete after: WS-014 (Timeline Nodes), WS-015 (Conditional Branching)
- Must complete before: None (integrates other journey features)
- Shares code with: WS-014, WS-015 (journey execution engine)

### ESTIMATED EFFORT
- Team A Frontend: 40 hours
- Team B Backend: 28 hours
- Team C Integration: 12 hours
- Total: 80 hours