# TECHNICAL SPECIFICATION: WS-006 - Photo Management
## Generated by Feature Development Session - 2025-08-21

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding photographer managing 80+ couples with visual identification needs
**I want to:** Upload, organize, and display couple photos throughout the platform for instant visual recognition
**So that:** I can immediately identify "Sarah & Mike" from their profile photo instead of reading names and forgetting faces, saving 5+ seconds per client lookup across 200+ daily interactions

**Real Wedding Scenario:**
A photographer arrives at a wedding venue with 4 other vendors present. When the florist asks "Who's handling Sarah & Mike's timeline?", instead of checking notes and asking "which couple is that?", they instantly recognize Sarah & Mike from their profile photo in the WedSync app, know it's their 2pm ceremony, and coordinate seamlessly. Without visual recognition, these conversations require 30+ seconds of clarification. With photos, recognition is instant - saving 100+ seconds daily across vendor coordination and creating more professional client interactions.

### SPECIFICATION SOURCE
- **Feature ID:** WS-006
- **Original Spec:** /CORE-SPECIFICATIONS/02-WEDSYNC-SUPPLIER-PLATFORM/03-Client-Management/09-photo-management md.md
- **Current Implementation:** 0% complete
- **Files to Modify:**
  - /src/components/clients/ClientListView.tsx (add photo thumbnails)
  - /src/components/clients/ClientGridView.tsx (enhance photo display)
  - /src/components/clients/profile/ClientProfileHeader.tsx (add photo management)
- **New Files to Create:**
  - /src/components/photos/PhotoUpload.tsx
  - /src/components/photos/PhotoCropper.tsx
  - /src/components/photos/PhotoGallery.tsx
  - /src/components/photos/PhotoFallback.tsx
  - /src/lib/photos/imageProcessing.ts
  - /src/lib/photos/photoStorage.ts
  - /src/lib/stores/photoStore.ts
  - /src/app/api/photos/upload/route.ts
  - /src/app/api/photos/[id]/route.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Client photos and metadata
CREATE TABLE IF NOT EXISTS client_photos (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  client_id UUID REFERENCES client_profiles(id) ON DELETE CASCADE,
  photo_url TEXT NOT NULL,
  thumbnail_url TEXT NOT NULL,
  original_filename TEXT NOT NULL,
  file_size INTEGER NOT NULL, -- bytes
  width INTEGER NOT NULL,
  height INTEGER NOT NULL,
  mime_type TEXT NOT NULL,
  upload_source TEXT CHECK (upload_source IN ('direct', 'social', 'url', 'mobile', 'gallery', 'wedme_sync')) DEFAULT 'direct',
  is_primary BOOLEAN DEFAULT false,
  crop_data JSONB, -- x, y, width, height for crop coordinates
  alt_text TEXT,
  privacy_level TEXT CHECK (privacy_level IN ('public', 'team', 'private')) DEFAULT 'team',
  uploaded_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  
  -- Ensure only one primary photo per client
  CONSTRAINT unique_primary_photo EXCLUDE (client_id WITH =) WHERE (is_primary = true)
);

-- Photo processing jobs
CREATE TABLE IF NOT EXISTS photo_processing_jobs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  photo_id UUID REFERENCES client_photos(id) ON DELETE CASCADE,
  job_type TEXT CHECK (job_type IN ('resize', 'crop', 'optimize', 'face_detect')) NOT NULL,
  status TEXT CHECK (status IN ('queued', 'processing', 'completed', 'failed')) DEFAULT 'queued',
  input_params JSONB NOT NULL,
  output_data JSONB,
  error_message TEXT,
  started_at TIMESTAMP,
  completed_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Photo import sources and sync
CREATE TABLE IF NOT EXISTS photo_import_sources (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  client_id UUID REFERENCES client_profiles(id) ON DELETE CASCADE,
  source_type TEXT CHECK (source_type IN ('instagram', 'facebook', 'google_photos', 'icloud', 'gravatar')) NOT NULL,
  source_url TEXT NOT NULL,
  access_token TEXT, -- Encrypted OAuth token
  last_sync_at TIMESTAMP,
  sync_enabled BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Photo analytics and usage
CREATE TABLE IF NOT EXISTS photo_analytics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  photo_id UUID REFERENCES client_photos(id) ON DELETE CASCADE,
  view_count INTEGER DEFAULT 0,
  last_viewed_at TIMESTAMP,
  usage_contexts JSONB DEFAULT '{}', -- Track where photo is displayed
  performance_score DECIMAL(3,2), -- Recognition effectiveness rating
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_client_photos_client_id ON client_photos(client_id);
CREATE INDEX idx_client_photos_primary ON client_photos(client_id, is_primary);
CREATE INDEX idx_photo_processing_status ON photo_processing_jobs(status);
CREATE INDEX idx_photo_import_sources_client ON photo_import_sources(client_id);
```

#### API Endpoints Required
```typescript
// POST /api/photos/upload
interface PhotoUploadRequest {
  clientId: string;
  file: File; // FormData
  cropData?: {
    x: number;
    y: number;
    width: number;
    height: number;
  };
  altText?: string;
  privacyLevel?: 'public' | 'team' | 'private';
  setPrimary?: boolean;
}

interface PhotoUploadResponse {
  success: boolean;
  data: {
    photo: {
      id: string;
      photoUrl: string;
      thumbnailUrl: string;
      originalFilename: string;
      fileSize: number;
      dimensions: { width: number; height: number };
      isPrimary: boolean;
    };
    processingJobId?: string; // For async processing
  };
}

// GET /api/photos/[clientId]
interface GetClientPhotosResponse {
  success: boolean;
  data: {
    photos: Array<{
      id: string;
      photoUrl: string;
      thumbnailUrl: string;
      isPrimary: boolean;
      uploadSource: string;
      cropData?: CropData;
      privacyLevel: string;
      uploadedAt: string;
    }>;
    primaryPhoto?: ClientPhoto;
    totalCount: number;
  };
}

// PATCH /api/photos/[id]
interface UpdatePhotoRequest {
  altText?: string;
  privacyLevel?: 'public' | 'team' | 'private';
  cropData?: CropData;
  setPrimary?: boolean;
}

// POST /api/photos/import/social
interface SocialImportRequest {
  clientId: string;
  platform: 'instagram' | 'facebook';
  profileUrl?: string;
  accessToken?: string; // OAuth token
}

interface SocialImportResponse {
  success: boolean;
  data: {
    importedCount: number;
    photos: ClientPhoto[];
    errors: string[];
  };
}

// POST /api/photos/generate-fallback
interface GenerateFallbackRequest {
  clientId: string;
  coupleNames: string;
  style?: 'initials' | 'silhouette' | 'gradient';
  colors?: string[];
}

interface GenerateFallbackResponse {
  success: boolean;
  data: {
    fallbackUrl: string;
    generatedSvg: string;
  };
}
```

#### Frontend Components Required
```typescript
// Component: PhotoUpload
// Location: /src/components/photos/PhotoUpload.tsx

interface PhotoUploadProps {
  clientId: string;
  existingPhotos: ClientPhoto[];
  onUploadComplete: (photo: ClientPhoto) => void;
  maxFileSize?: number; // MB
  acceptedFormats?: string[];
}

// Key functionality:
- Drag-and-drop photo upload with preview
- Multiple file selection and batch upload
- Image format validation (JPEG, PNG, WebP)
- File size validation and compression
- Real-time upload progress
- Automatic thumbnail generation
- Error handling for unsupported formats

// Component: PhotoCropper
// Location: /src/components/photos/PhotoCropper.tsx

interface PhotoCropperProps {
  imageUrl: string;
  aspectRatio?: number; // 1 for square, 16/9 for wide
  onCropComplete: (cropData: CropData) => void;
  onCancel: () => void;
}

// Key functionality:
- Interactive crop tool with handles
- Aspect ratio constraints
- Zoom and pan controls
- Face detection for smart centering
- Preview of cropped result
- Mobile touch gesture support
- Keyboard shortcuts for fine adjustment

// Component: PhotoGallery
// Location: /src/components/photos/PhotoGallery.tsx

interface PhotoGalleryProps {
  photos: ClientPhoto[];
  primaryPhotoId?: string;
  onPhotoSelect: (photo: ClientPhoto) => void;
  onSetPrimary: (photoId: string) => void;
  onDeletePhoto: (photoId: string) => void;
  editable?: boolean;
}

// Key functionality:
- Grid layout with responsive columns
- Primary photo indicator and selection
- Hover effects with action buttons
- Lightbox view for full-size photos
- Drag-and-drop reordering
- Bulk selection and operations
- Lazy loading for performance

// Component: PhotoFallback
// Location: /src/components/photos/PhotoFallback.tsx

interface PhotoFallbackProps {
  coupleNames: string;
  size: 'sm' | 'md' | 'lg' | 'xl';
  style?: 'initials' | 'silhouette' | 'gradient';
  className?: string;
}

// Key functionality:
- Generate initials from couple names
- Color generation based on name hash
- Multiple fallback styles
- Consistent sizing system
- Accessibility with proper alt text
- SVG-based for crisp rendering at any size
```

#### Integration Points
```typescript
// Library: imageProcessing
// Dependencies: Canvas API, WebWorker, Sharp (server-side)

export class ImageProcessor {
  private canvas: HTMLCanvasElement;
  private ctx: CanvasRenderingContext2D;
  
  constructor() {
    this.canvas = document.createElement('canvas');
    this.ctx = this.canvas.getContext('2d')!;
  }
  
  async resizeImage(file: File, maxWidth: number, maxHeight: number): Promise<Blob> {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        // Calculate new dimensions maintaining aspect ratio
        const { width, height } = this.calculateDimensions(
          img.width, 
          img.height, 
          maxWidth, 
          maxHeight
        );
        
        this.canvas.width = width;
        this.canvas.height = height;
        
        // Draw and compress
        this.ctx.drawImage(img, 0, 0, width, height);
        this.canvas.toBlob(resolve, 'image/webp', 0.8);
      };
      
      img.src = URL.createObjectURL(file);
    });
  }
  
  async cropImage(imageUrl: string, cropData: CropData): Promise<string> {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    
    return new Promise((resolve) => {
      img.onload = () => {
        this.canvas.width = cropData.width;
        this.canvas.height = cropData.height;
        
        this.ctx.drawImage(
          img,
          cropData.x, cropData.y, cropData.width, cropData.height,
          0, 0, cropData.width, cropData.height
        );
        
        resolve(this.canvas.toDataURL('image/webp', 0.9));
      };
      
      img.src = imageUrl;
    });
  }
  
  generateInitialsAvatar(names: string, size: number = 200): string {
    // Extract initials
    const initials = names
      .split(/[&,\s]+/)
      .map(name => name.charAt(0).toUpperCase())
      .slice(0, 2)
      .join('');
    
    // Generate color from name
    const color = this.generateColorFromString(names);
    
    // Create SVG
    const svg = `
      <svg width="${size}" height="${size}" xmlns="http://www.w3.org/2000/svg">
        <circle cx="${size/2}" cy="${size/2}" r="${size/2}" fill="${color}"/>
        <text x="50%" y="50%" text-anchor="middle" dy="0.35em" 
              fill="white" font-family="Arial, sans-serif" 
              font-size="${size * 0.4}" font-weight="bold">
          ${initials}
        </text>
      </svg>
    `;
    
    return `data:image/svg+xml;base64,${btoa(svg)}`;
  }
}

// Store: photoStore
interface PhotoStore {
  photos: Record<string, ClientPhoto[]>; // clientId -> photos
  loading: boolean;
  uploading: boolean;
  
  fetchClientPhotos: (clientId: string) => Promise<void>;
  uploadPhoto: (clientId: string, file: File, options?: UploadOptions) => Promise<ClientPhoto>;
  updatePhoto: (photoId: string, updates: Partial<ClientPhoto>) => Promise<void>;
  deletePhoto: (photoId: string) => Promise<void>;
  setPrimaryPhoto: (clientId: string, photoId: string) => Promise<void>;
  
  generateFallback: (coupleNames: string, style?: string) => string;
  importFromSocial: (clientId: string, platform: string, profileUrl: string) => Promise<void>;
}
```

### CODE EXAMPLES

#### Example 1: Optimized Photo Upload with Compression
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { imageProcessor } from '@/lib/photos/imageProcessing';

export async function uploadClientPhoto(
  clientId: string, 
  file: File,
  options: PhotoUploadOptions = {}
): Promise<PhotoUploadResult> {
  
  // Step 1: Validate file
  if (!file.type.startsWith('image/')) {
    throw new Error('Please select a valid image file');
  }
  
  if (file.size > 5 * 1024 * 1024) { // 5MB limit
    throw new Error('Image file too large. Please select a file under 5MB.');
  }
  
  // Step 2: Generate optimized versions
  const [optimizedImage, thumbnail] = await Promise.all([
    imageProcessor.resizeImage(file, 800, 800), // Profile size
    imageProcessor.resizeImage(file, 200, 200)  // Thumbnail size
  ]);
  
  // Step 3: Upload to Supabase Storage
  const timestamp = Date.now();
  const fileExt = file.name.split('.').pop();
  
  const [profileUpload, thumbnailUpload] = await Promise.all([
    supabase.storage
      .from('client-photos')
      .upload(`${clientId}/profile-${timestamp}.webp`, optimizedImage),
    supabase.storage
      .from('client-photos')
      .upload(`${clientId}/thumb-${timestamp}.webp`, thumbnail)
  ]);
  
  if (profileUpload.error || thumbnailUpload.error) {
    throw new Error('Failed to upload image to storage');
  }
  
  // Step 4: Get public URLs
  const { data: profileUrl } = supabase.storage
    .from('client-photos')
    .getPublicUrl(profileUpload.data.path);
    
  const { data: thumbnailUrl } = supabase.storage
    .from('client-photos')
    .getPublicUrl(thumbnailUpload.data.path);
  
  // Step 5: Save to database
  const { data: photo, error } = await supabase
    .from('client_photos')
    .insert({
      client_id: clientId,
      photo_url: profileUrl.publicUrl,
      thumbnail_url: thumbnailUrl.publicUrl,
      original_filename: file.name,
      file_size: file.size,
      width: 800,
      height: 800,
      mime_type: 'image/webp',
      upload_source: options.source || 'direct',
      is_primary: options.setPrimary || false,
      privacy_level: options.privacyLevel || 'team',
      alt_text: options.altText || `Photo of ${options.coupleNames || 'couple'}`
    })
    .select()
    .single();
    
  if (error) {
    throw new Error(`Failed to save photo: ${error.message}`);
  }
  
  // Step 6: Update photo analytics
  await supabase
    .from('photo_analytics')
    .insert({
      photo_id: photo.id,
      view_count: 0,
      usage_contexts: { upload: true }
    });
  
  return {
    photo,
    processingTime: Date.now() - timestamp
  };
}
```

#### Example 2: Smart Photo Fallback Generation
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
export function generatePhotoFallback(
  coupleNames: string,
  options: FallbackOptions = {}
): FallbackResult {
  
  // Step 1: Clean and parse names
  const cleanNames = coupleNames
    .replace(/[^\w\s&,]/g, '') // Remove special chars except &,
    .trim();
    
  if (!cleanNames) {
    return {
      type: 'silhouette',
      url: '/images/default-couple-silhouette.svg',
      alt: 'Couple silhouette'
    };
  }
  
  // Step 2: Extract initials intelligently
  const nameWords = cleanNames.split(/[&,\s]+/).filter(word => word.length > 0);
  let initials = '';
  
  if (nameWords.length >= 2) {
    // Take first letter of first and last meaningful words
    initials = nameWords[0].charAt(0) + nameWords[nameWords.length - 1].charAt(0);
  } else if (nameWords.length === 1) {
    // Single name, take first two letters
    initials = nameWords[0].substring(0, 2);
  }
  
  initials = initials.toUpperCase();
  
  // Step 3: Generate consistent color from name
  const colors = [
    '#3B82F6', '#EF4444', '#10B981', '#F59E0B', 
    '#8B5CF6', '#EC4899', '#06B6D4', '#84CC16'
  ];
  
  const nameHash = cleanNames
    .split('')
    .reduce((hash, char) => hash + char.charCodeAt(0), 0);
    
  const primaryColor = colors[nameHash % colors.length];
  const secondaryColor = colors[(nameHash + 3) % colors.length];
  
  // Step 4: Create SVG based on style
  const size = options.size || 200;
  
  if (options.style === 'gradient') {
    const svg = `
      <svg width="${size}" height="${size}" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <linearGradient id="grad-${nameHash}" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" style="stop-color:${primaryColor};stop-opacity:1" />
            <stop offset="100%" style="stop-color:${secondaryColor};stop-opacity:1" />
          </linearGradient>
        </defs>
        <circle cx="${size/2}" cy="${size/2}" r="${size/2}" fill="url(#grad-${nameHash})"/>
        <text x="50%" y="50%" text-anchor="middle" dy="0.35em" 
              fill="white" font-family="Inter, Arial, sans-serif" 
              font-size="${size * 0.35}" font-weight="600">
          ${initials}
        </text>
      </svg>
    `;
    
    return {
      type: 'gradient',
      url: `data:image/svg+xml;base64,${btoa(svg)}`,
      alt: `${cleanNames} initials`,
      colors: [primaryColor, secondaryColor]
    };
  }
  
  // Step 5: Default initials style
  const svg = `
    <svg width="${size}" height="${size}" xmlns="http://www.w3.org/2000/svg">
      <circle cx="${size/2}" cy="${size/2}" r="${size/2}" fill="${primaryColor}"/>
      <text x="50%" y="50%" text-anchor="middle" dy="0.35em" 
            fill="white" font-family="Inter, Arial, sans-serif" 
            font-size="${size * 0.4}" font-weight="600">
        ${initials}
      </text>
    </svg>
  `;
  
  return {
    type: 'initials',
    url: `data:image/svg+xml;base64,${btoa(svg)}`,
    alt: `${cleanNames} initials`,
    colors: [primaryColor]
  };
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for image processing libraries
- [ ] Playwright: Test photo upload and management
- [x] Filesystem: Access photo component directories

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/supabase/supabase", "storage file upload", 3000);
await mcp__context7__get-library-docs("/fengyuanchen/cropperjs", "image cropping", 2000);
await mcp__context7__get-library-docs("/mozilla/pdf.js", "canvas image processing", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('Photo Management', () => {
  it('should upload and process photos correctly', async () => {
    const mockFile = new File([''], 'test.jpg', { type: 'image/jpeg' });
    const result = await uploadClientPhoto('client1', mockFile);
    
    expect(result.photo.photoUrl).toBeDefined();
    expect(result.photo.thumbnailUrl).toBeDefined();
    expect(result.photo.fileSize).toBeLessThan(mockFile.size); // Compressed
  });
  
  it('should generate consistent fallback avatars', () => {
    const fallback1 = generatePhotoFallback('John & Jane Smith');
    const fallback2 = generatePhotoFallback('John & Jane Smith');
    
    expect(fallback1.url).toBe(fallback2.url); // Consistent generation
    expect(fallback1.type).toBe('initials');
  });
  
  it('should handle different name formats', () => {
    const cases = [
      'John & Jane Smith',
      'John Smith & Jane Doe', 
      'John Smith',
      'J & J'
    ];
    
    cases.forEach(names => {
      const fallback = generatePhotoFallback(names);
      expect(fallback.url).toContain('data:image/svg+xml');
    });
  });
  
  it('should crop images correctly', async () => {
    const cropData = { x: 10, y: 10, width: 100, height: 100 };
    const croppedUrl = await imageProcessor.cropImage('/test-image.jpg', cropData);
    
    expect(croppedUrl).toContain('data:image');
  });
});

describe('Photo Analytics', () => {
  it('should track photo usage and views', async () => {
    await trackPhotoView('photo1', 'client_list');
    
    const analytics = await getPhotoAnalytics('photo1');
    expect(analytics.viewCount).toBeGreaterThan(0);
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Photo upload and management flow', async () => {
  await mcp__playwright__browser_navigate({url: '/clients/123'});
  
  // Upload photo
  await mcp__playwright__browser_file_upload({
    paths: ['/test-fixtures/couple-photo.jpg']
  });
  
  // Verify photo appears
  await mcp__playwright__browser_wait_for({text: 'Photo uploaded successfully'});
  
  // Test cropping
  await mcp__playwright__browser_click({
    element: 'Edit photo',
    ref: '[data-testid="edit-photo"]'
  });
  
  // Verify crop tool appears
  await mcp__playwright__browser_wait_for({text: 'Crop Photo'});
  
  // Save crop
  await mcp__playwright__browser_click({
    element: 'Save crop',
    ref: '[data-testid="save-crop"]'
  });
});

test('Photo fallback generation', async () => {
  await mcp__playwright__browser_navigate({url: '/clients'});
  
  // Find client without photo
  await mcp__playwright__browser_wait_for({text: 'JS'}); // Initials fallback
  
  // Take screenshot to verify appearance
  await mcp__playwright__browser_take_screenshot({
    filename: 'photo-fallback-test.png'
  });
});

test('Photo gallery management', async () => {
  await mcp__playwright__browser_navigate({url: '/clients/123'});
  
  // Open photo gallery
  await mcp__playwright__browser_click({
    element: 'View all photos',
    ref: '[data-testid="photo-gallery"]'
  });
  
  // Set primary photo
  await mcp__playwright__browser_click({
    element: 'Set as primary',
    ref: '[data-testid="set-primary-2"]'
  });
  
  // Verify primary photo changed
  await mcp__playwright__browser_wait_for({text: 'Primary photo updated'});
  
  // Delete photo
  await mcp__playwright__browser_click({
    element: 'Delete photo',
    ref: '[data-testid="delete-photo-3"]'
  });
  
  // Confirm deletion
  await mcp__playwright__browser_click({
    element: 'Confirm delete',
    ref: '[data-testid="confirm-delete"]'
  });
});
```

### ACCEPTANCE CRITERIA
- [ ] Upload photos up to 5MB with automatic compression to <100KB
- [ ] Generate 200x200 thumbnails and 800x800 profile images
- [ ] Interactive crop tool with face detection centering
- [ ] Consistent fallback avatars with initials and colors
- [ ] Primary photo selection per client
- [ ] Multiple photos per client with gallery view
- [ ] Import from social media (Instagram, Facebook)
- [ ] Privacy controls (public, team, private)
- [ ] Photo analytics tracking views and usage
- [ ] Mobile-optimized photo capture and upload
- [ ] CDN delivery for fast loading
- [ ] Lazy loading for performance in lists

### DEPENDENCIES
- Must complete after: WS-002 (Client Profiles)
- Must complete before: None (enhances existing features)
- Shares code with: WS-001 (list views), WS-002 (profile display)

### ESTIMATED EFFORT
- Team A Frontend: 22 hours
- Team B Backend: 16 hours
- Team C Integration: 6 hours
- Total: 44 hours