# TECHNICAL SPECIFICATION: WS-005 - Tagging System
## Generated by Feature Development Session - 2025-08-21

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding photographer managing different client types and workflows
**I want to:** Organize clients with flexible tags beyond standard fields (VIP, referral, outdoor, luxury, etc.)
**So that:** I can instantly filter my 80 active clients by "luxury outdoor summer" tags and send appropriate seasonal advice in 30 seconds instead of manually reviewing each profile for 40+ minutes

**Real Wedding Scenario:**
A photographer categorizes clients as: "VIP" (higher service), "referral" (from past clients), "luxury" (premium packages), "outdoor" (venue type), "summer" (season). When wildfire smoke affects the area, they need to contact all "outdoor summer" weddings with contingency plans. Currently they manually check 80 client profiles looking for outdoor summer weddings - taking 45 minutes. With the tagging system, they filter by two tags, see 12 matching couples, and send targeted advice in 2 minutes - saving 43 minutes and ensuring no outdoor couples are missed.

### SPECIFICATION SOURCE
- **Feature ID:** WS-005
- **Original Spec:** /CORE-SPECIFICATIONS/02-WEDSYNC-SUPPLIER-PLATFORM/03-Client-Management/07-tagging-system md.md
- **Current Implementation:** 0% complete
- **Files to Modify:**
  - /src/components/clients/ClientListView.tsx (add tag filters)
  - /src/components/clients/ClientGridView.tsx (add tag displays)
  - /src/components/clients/profile/ClientProfileHeader.tsx (add tag management)
- **New Files to Create:**
  - /src/components/tags/TagManager.tsx
  - /src/components/tags/TagInput.tsx
  - /src/components/tags/TagFilter.tsx
  - /src/components/tags/TagCloud.tsx
  - /src/components/tags/TagAnalytics.tsx
  - /src/lib/stores/tagStore.ts
  - /src/app/api/tags/route.ts
  - /src/app/api/clients/[id]/tags/route.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Tag definitions and metadata
CREATE TABLE IF NOT EXISTS tags (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  slug TEXT NOT NULL, -- URL-friendly version
  description TEXT,
  color TEXT DEFAULT '#3B82F6', -- Hex color code
  icon TEXT, -- Icon name from icon library
  category TEXT CHECK (category IN ('system', 'relationship', 'style', 'venue', 'service', 'custom')) DEFAULT 'custom',
  is_system BOOLEAN DEFAULT false, -- Auto-generated by system
  usage_count INTEGER DEFAULT 0,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  archived_at TIMESTAMP,
  
  UNIQUE(supplier_id, slug)
);

-- Client-tag relationships (many-to-many)
CREATE TABLE IF NOT EXISTS client_tags (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  client_id UUID REFERENCES client_profiles(id) ON DELETE CASCADE,
  tag_id UUID REFERENCES tags(id) ON DELETE CASCADE,
  assigned_by UUID REFERENCES auth.users(id),
  assigned_at TIMESTAMP DEFAULT NOW(),
  
  UNIQUE(client_id, tag_id)
);

-- Tag analytics and insights
CREATE TABLE IF NOT EXISTS tag_analytics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  tag_id UUID REFERENCES tags(id) ON DELETE CASCADE,
  metric_name TEXT NOT NULL, -- 'usage', 'conversion_rate', 'revenue_per_tag'
  metric_value DECIMAL(10,2) NOT NULL,
  period_start DATE NOT NULL,
  period_end DATE NOT NULL,
  calculated_at TIMESTAMP DEFAULT NOW()
);

-- Tag suggestions based on ML/patterns
CREATE TABLE IF NOT EXISTS tag_suggestions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  client_id UUID REFERENCES client_profiles(id) ON DELETE CASCADE,
  suggested_tag_id UUID REFERENCES tags(id) ON DELETE CASCADE,
  confidence_score DECIMAL(3,2) NOT NULL, -- 0.00-1.00
  suggestion_reason TEXT,
  created_at TIMESTAMP DEFAULT NOW(),
  applied_at TIMESTAMP,
  dismissed_at TIMESTAMP
);

-- Indexes for performance
CREATE INDEX idx_tags_supplier_id ON tags(supplier_id);
CREATE INDEX idx_tags_category ON tags(category);
CREATE INDEX idx_client_tags_client_id ON client_tags(client_id);
CREATE INDEX idx_client_tags_tag_id ON client_tags(tag_id);
CREATE INDEX idx_tag_analytics_supplier_tag ON tag_analytics(supplier_id, tag_id);
```

#### API Endpoints Required
```typescript
// GET /api/tags
interface GetTagsResponse {
  success: boolean;
  data: {
    tags: Array<{
      id: string;
      name: string;
      slug: string;
      description: string;
      color: string;
      icon?: string;
      category: 'system' | 'relationship' | 'style' | 'venue' | 'service' | 'custom';
      usageCount: number;
      createdAt: string;
    }>;
    categories: Record<string, number>; // Count per category
    totalUsage: number;
  };
}

// POST /api/tags
interface CreateTagRequest {
  name: string;
  description?: string;
  color?: string;
  icon?: string;
  category?: string;
}

interface CreateTagResponse {
  success: boolean;
  data: {
    tag: Tag;
    suggestions?: string[]; // Similar existing tags
  };
}

// PATCH /api/tags/[id]
interface UpdateTagRequest {
  name?: string;
  description?: string;
  color?: string;
  icon?: string;
  category?: string;
}

// POST /api/clients/[id]/tags
interface AssignTagsRequest {
  tagIds: string[];
  createTags?: Array<{
    name: string;
    color?: string;
    category?: string;
  }>; // Create tags on the fly
}

interface AssignTagsResponse {
  success: boolean;
  data: {
    assignedTags: Tag[];
    createdTags: Tag[];
    suggestions: Array<{
      tagId: string;
      reason: string;
      confidence: number;
    }>;
  };
}

// GET /api/tags/suggestions/[clientId]
interface TagSuggestionsResponse {
  success: boolean;
  data: {
    suggestions: Array<{
      tag: Tag;
      confidence: number;
      reason: string;
    }>;
    autoApplied: Tag[]; // High confidence auto-applied tags
  };
}

// GET /api/tags/analytics
interface TagAnalyticsResponse {
  success: boolean;
  data: {
    topTags: Array<{
      tag: Tag;
      usageCount: number;
      growthRate: number;
    }>;
    tagCombinations: Array<{
      tags: string[];
      frequency: number;
      conversionRate: number;
    }>;
    unusedTags: Tag[];
    recommendations: string[];
  };
}
```

#### Frontend Components Required
```typescript
// Component: TagInput
// Location: /src/components/tags/TagInput.tsx

interface TagInputProps {
  selectedTags: Tag[];
  availableTags: Tag[];
  onTagsChange: (tags: Tag[]) => void;
  maxTags?: number;
  allowCreate?: boolean;
  placeholder?: string;
}

// Key functionality:
- Autocomplete dropdown with tag search
- Create new tags inline with color picker
- Drag to reorder selected tags
- Keyboard navigation (arrow keys, enter, backspace)
- Tag suggestions based on client data
- Visual feedback for tag categories
- Mobile: Touch-friendly tag pills with swipe to remove

// Component: TagFilter
// Location: /src/components/tags/TagFilter.tsx

interface TagFilterProps {
  availableTags: Tag[];
  selectedTags: string[];
  onFilterChange: (tagIds: string[], operator: 'AND' | 'OR') => void;
  groupByCategory?: boolean;
}

// Key functionality:
- Multi-select tag filtering with AND/OR logic
- Category-based grouping and filtering
- Search within tags for large tag lists
- Save/load filter presets
- Clear all filters action
- Visual indication of active filters
- Tag usage count indicators

// Component: TagCloud
// Location: /src/components/tags/TagCloud.tsx

interface TagCloudProps {
  tags: Array<Tag & { weight: number }>;
  onTagClick: (tag: Tag) => void;
  colorMode: 'category' | 'usage' | 'custom';
  layout: 'cloud' | 'grid' | 'list';
}

// Key functionality:
- Size tags by usage frequency
- Color coding by category or custom colors
- Interactive click-to-filter behavior
- Responsive layout with text wrapping
- Hover effects showing tag details
- Export tag cloud as image

// Component: TagAnalytics
// Location: /src/components/tags/TagAnalytics.tsx

interface TagAnalyticsProps {
  supplierId: string;
  dateRange: DateRange;
}

// Key functionality:
- Usage trends over time
- Tag combination analysis
- Conversion rate by tag
- Unused tag identification
- Tag performance comparison
- Export analytics data
```

#### Integration Points
```typescript
// Store: tagStore
// Dependencies: zustand, supabase client

interface TagStore {
  tags: Tag[];
  loading: boolean;
  selectedTags: string[];
  filterOperator: 'AND' | 'OR';
  
  fetchTags: () => Promise<void>;
  createTag: (tagData: CreateTagRequest) => Promise<Tag>;
  updateTag: (id: string, updates: UpdateTagRequest) => Promise<void>;
  deleteTag: (id: string) => Promise<void>;
  
  assignTagsToClient: (clientId: string, tagIds: string[]) => Promise<void>;
  removeTagsFromClient: (clientId: string, tagIds: string[]) => Promise<void>;
  
  setTagFilter: (tagIds: string[], operator: 'AND' | 'OR') => void;
  clearTagFilter: () => void;
  
  getTagSuggestions: (clientId: string) => Promise<TagSuggestion[]>;
  applyTagSuggestion: (clientId: string, tagId: string) => Promise<void>;
}

// Auto-tagging system
export class AutoTaggingEngine {
  private rules: TaggingRule[] = [
    {
      condition: (client) => client.venue_name?.toLowerCase().includes('outdoor'),
      tagName: 'outdoor',
      confidence: 0.9
    },
    {
      condition: (client) => client.wedding_date && isSeasonSummer(client.wedding_date),
      tagName: 'summer',
      confidence: 0.95
    },
    {
      condition: (client) => client.package_details?.tier === 'premium',
      tagName: 'luxury',
      confidence: 0.8
    }
  ];
  
  async suggestTags(client: ClientProfile): Promise<TagSuggestion[]> {
    const suggestions: TagSuggestion[] = [];
    
    for (const rule of this.rules) {
      if (rule.condition(client)) {
        const tag = await this.findOrCreateTag(rule.tagName);
        suggestions.push({
          tag,
          confidence: rule.confidence,
          reason: rule.reason || `Auto-detected from ${rule.field}`
        });
      }
    }
    
    return suggestions;
  }
}
```

### CODE EXAMPLES

#### Example 1: Smart Tag Search with Autocomplete
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { useState, useEffect, useMemo } from 'react';
import { useDebounce } from '@/hooks/useDebounce';

export function useTagSearch(availableTags: Tag[]) {
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedTags, setSelectedTags] = useState<Tag[]>([]);
  const debouncedSearch = useDebounce(searchTerm, 300);
  
  // Step 1: Filter and rank tags based on search
  const filteredTags = useMemo(() => {
    if (!debouncedSearch) return availableTags;
    
    const searchLower = debouncedSearch.toLowerCase();
    
    return availableTags
      .filter(tag => 
        tag.name.toLowerCase().includes(searchLower) ||
        tag.description?.toLowerCase().includes(searchLower) ||
        tag.category.toLowerCase().includes(searchLower)
      )
      .sort((a, b) => {
        // Step 2: Rank by relevance
        const aExact = a.name.toLowerCase() === searchLower;
        const bExact = b.name.toLowerCase() === searchLower;
        
        if (aExact && !bExact) return -1;
        if (!aExact && bExact) return 1;
        
        // Prioritize starts-with matches
        const aStarts = a.name.toLowerCase().startsWith(searchLower);
        const bStarts = b.name.toLowerCase().startsWith(searchLower);
        
        if (aStarts && !bStarts) return -1;
        if (!aStarts && bStarts) return 1;
        
        // Then by usage count
        return b.usageCount - a.usageCount;
      })
      .slice(0, 10); // Limit results for performance
  }, [availableTags, debouncedSearch]);
  
  // Step 3: Handle tag selection
  const addTag = async (tag: Tag) => {
    if (!selectedTags.find(t => t.id === tag.id)) {
      const newSelectedTags = [...selectedTags, tag];
      setSelectedTags(newSelectedTags);
      
      // Update usage count
      await supabase
        .from('tags')
        .update({ 
          usage_count: tag.usageCount + 1,
          updated_at: new Date().toISOString()
        })
        .eq('id', tag.id);
    }
    setSearchTerm('');
  };
  
  // Step 4: Create new tag on the fly
  const createAndAddTag = async (name: string) => {
    const newTag = await supabase
      .from('tags')
      .insert({
        name: name.trim(),
        slug: slugify(name.trim()),
        color: generateRandomColor(),
        category: 'custom'
      })
      .select()
      .single();
      
    if (newTag.data) {
      addTag(newTag.data);
    }
  };
  
  return {
    searchTerm,
    setSearchTerm,
    filteredTags,
    selectedTags,
    addTag,
    createAndAddTag,
    removeTag: (tagId: string) => {
      setSelectedTags(tags => tags.filter(t => t.id !== tagId));
    }
  };
}
```

#### Example 2: Advanced Tag Filtering with Boolean Logic
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { supabase } from '@/lib/supabase';

export async function filterClientsByTags(
  tagFilters: TagFilter[],
  operator: 'AND' | 'OR' = 'AND'
): Promise<string[]> {
  
  if (tagFilters.length === 0) {
    // No filters, return all clients
    const { data } = await supabase
      .from('client_profiles')
      .select('id');
    return data?.map(c => c.id) || [];
  }
  
  // Step 1: Build complex query based on operator
  if (operator === 'AND') {
    // All tags must be present
    let clientIds: string[] | null = null;
    
    for (const filter of tagFilters) {
      // Get clients with this specific tag
      const { data } = await supabase
        .from('client_tags')
        .select('client_id')
        .eq('tag_id', filter.tagId);
        
      const currentIds = data?.map(ct => ct.client_id) || [];
      
      if (clientIds === null) {
        clientIds = currentIds;
      } else {
        // Intersection with previous results
        clientIds = clientIds.filter(id => currentIds.includes(id));
      }
      
      // Short circuit if no matches
      if (clientIds.length === 0) break;
    }
    
    return clientIds || [];
    
  } else {
    // OR: Any tag matches (union)
    const allTagIds = tagFilters.map(f => f.tagId);
    
    const { data } = await supabase
      .from('client_tags')
      .select('client_id')
      .in('tag_id', allTagIds);
      
    // Remove duplicates
    const uniqueClientIds = [...new Set(data?.map(ct => ct.client_id) || [])];
    return uniqueClientIds;
  }
}

// Advanced filtering with exclusions
export async function filterClientsAdvanced(filters: {
  includeTags?: string[];  // Must have these tags
  excludeTags?: string[];  // Must NOT have these tags
  includeOperator?: 'AND' | 'OR';
  anyOf?: string[];        // Has any of these tags
}) {
  let clientIds: string[] = [];
  
  // Step 1: Get clients with required tags
  if (filters.includeTags?.length) {
    clientIds = await filterClientsByTags(
      filters.includeTags.map(id => ({ tagId: id })),
      filters.includeOperator || 'AND'
    );
  }
  
  // Step 2: Add clients with "any of" tags
  if (filters.anyOf?.length) {
    const anyOfIds = await filterClientsByTags(
      filters.anyOf.map(id => ({ tagId: id })),
      'OR'
    );
    
    if (clientIds.length === 0) {
      clientIds = anyOfIds;
    } else {
      // Union with existing results
      clientIds = [...new Set([...clientIds, ...anyOfIds])];
    }
  }
  
  // Step 3: Remove clients with excluded tags
  if (filters.excludeTags?.length) {
    const excludedIds = await filterClientsByTags(
      filters.excludeTags.map(id => ({ tagId: id })),
      'OR'
    );
    
    clientIds = clientIds.filter(id => !excludedIds.includes(id));
  }
  
  return clientIds;
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for tag libraries and autocomplete
- [ ] Playwright: Test tag creation and filtering
- [x] Filesystem: Access tag component directories

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/downshift-js/downshift", "autocomplete patterns", 2000);
await mcp__context7__get-library-docs("/supabase/supabase", "array operations", 2000);
await mcp__context7__get-library-docs("/radix-ui/primitives", "tags input component", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('Tag System', () => {
  it('should create and assign tags to clients', async () => {
    const tag = await createTag({ name: 'VIP', color: '#FF0000' });
    await assignTagsToClient('client1', [tag.id]);
    
    const clientTags = await getClientTags('client1');
    expect(clientTags).toContain(tag.id);
  });
  
  it('should filter clients by tags with AND logic', async () => {
    const clientIds = await filterClientsByTags([
      { tagId: 'vip-tag' },
      { tagId: 'summer-tag' }
    ], 'AND');
    
    // Should only return clients with BOTH tags
    expect(clientIds.length).toBeGreaterThanOrEqual(0);
  });
  
  it('should suggest tags based on client data', async () => {
    const client = { venue_name: 'Outdoor Garden', wedding_date: '2024-07-15' };
    const suggestions = await suggestTags(client);
    
    expect(suggestions.some(s => s.tag.name === 'outdoor')).toBe(true);
    expect(suggestions.some(s => s.tag.name === 'summer')).toBe(true);
  });
  
  it('should handle tag search and autocomplete', () => {
    const tags = [
      { name: 'VIP', category: 'relationship' },
      { name: 'Venue - Outdoor', category: 'venue' }
    ];
    
    const filtered = searchTags(tags, 'vip');
    expect(filtered[0].name).toBe('VIP');
  });
});

describe('Tag Analytics', () => {
  it('should calculate tag usage statistics', async () => {
    const analytics = await getTagAnalytics('supplier1');
    
    expect(analytics.topTags).toBeDefined();
    expect(analytics.tagCombinations).toBeDefined();
    expect(analytics.unusedTags).toBeDefined();
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Tag creation and assignment flow', async () => {
  await mcp__playwright__browser_navigate({url: '/clients/123'});
  
  // Open tag input
  await mcp__playwright__browser_click({
    element: 'Add tags button',
    ref: '[data-testid="add-tags"]'
  });
  
  // Type new tag name
  await mcp__playwright__browser_type({
    element: 'Tag input',
    ref: '[data-testid="tag-input"]',
    text: 'VIP Client'
  });
  
  // Select color
  await mcp__playwright__browser_click({
    element: 'Color picker',
    ref: '[data-testid="color-red"]'
  });
  
  // Create tag
  await mcp__playwright__browser_press_key({key: 'Enter'});
  
  // Verify tag appears
  await mcp__playwright__browser_wait_for({text: 'VIP Client'});
});

test('Tag filtering in client list', async () => {
  await mcp__playwright__browser_navigate({url: '/clients'});
  
  // Open tag filter
  await mcp__playwright__browser_click({
    element: 'Filter by tags',
    ref: '[data-testid="tag-filter"]'
  });
  
  // Select multiple tags
  await mcp__playwright__browser_click({
    element: 'VIP tag',
    ref: '[data-testid="tag-vip"]'
  });
  
  await mcp__playwright__browser_click({
    element: 'Summer tag', 
    ref: '[data-testid="tag-summer"]'
  });
  
  // Change to OR logic
  await mcp__playwright__browser_click({
    element: 'OR operator',
    ref: '[data-testid="filter-or"]'
  });
  
  // Apply filter
  await mcp__playwright__browser_click({
    element: 'Apply filters',
    ref: '[data-testid="apply-filters"]'
  });
  
  // Verify filtered results
  await mcp__playwright__browser_wait_for({text: 'Showing clients with VIP OR Summer tags'});
});
```

### ACCEPTANCE CRITERIA
- [ ] Create custom tags with colors, icons, and categories
- [ ] Auto-complete tag input with search and creation
- [ ] Filter clients by single or multiple tags with AND/OR logic
- [ ] Tag suggestions based on client data patterns
- [ ] Bulk tag assignment/removal operations
- [ ] Tag analytics showing usage and combinations
- [ ] Save and load tag filter presets
- [ ] Tag cloud visualization with usage weighting
- [ ] System tags auto-applied (season, year, venue type)
- [ ] Tag merge and cleanup tools
- [ ] Export tag data and client lists by tags
- [ ] Mobile-optimized tag interface

### DEPENDENCIES
- Must complete after: WS-001 (Client List Views), WS-002 (Client Profiles)
- Must complete before: WS-004 (Bulk Operations - enhanced filtering)
- Shares code with: WS-004 (filtering logic), WS-001 (list views)

### ESTIMATED EFFORT
- Team A Frontend: 18 hours
- Team B Backend: 14 hours
- Team C Integration: 2 hours
- Total: 34 hours