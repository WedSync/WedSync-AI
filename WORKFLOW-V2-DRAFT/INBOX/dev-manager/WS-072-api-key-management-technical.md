# TECHNICAL SPECIFICATION: WS-072 - API Key Management
## Generated by Feature Development Session - August 22, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Photography business owner who uses third-party tools like Zapier, HubSpot, or custom integrations
**I want to:** Generate secure API keys to connect WedSync data with my existing business tools
**So that:** I can automate workflows like adding new clients to my CRM or triggering emails when forms are completed

**Real Wedding Scenario:**
A photographer uses Zapier to automatically add new WedSync clients to their HubSpot CRM and create Monday.com project boards for each wedding. They generate an API key with "read:clients" and "read:forms" scopes, configure it in Zapier, and now client onboarding is fully automated, saving 30 minutes per booking while ensuring no client data is missed.

### SPECIFICATION SOURCE
- **Feature ID:** WS-072
- **Original Spec:** /CORE-SPECIFICATIONS/02-WEDSYNC-SUPPLIER-PLATFORM/11-Billing-Settings/02-api-key-management md.md
- **Current Implementation:** 0% complete
- **Files to Modify:**
  - /wedsync/src/app/(dashboard)/settings/page.tsx (add API management tab)
  - /wedsync/src/middleware.ts (add API key validation middleware)
- **New Files to Create:**
  - /wedsync/src/app/(dashboard)/api-keys/page.tsx
  - /wedsync/src/app/(dashboard)/api-keys/create/page.tsx
  - /wedsync/src/app/api/api-keys/route.ts
  - /wedsync/src/app/api/api-keys/[id]/route.ts
  - /wedsync/src/app/api/api-keys/[id]/rotate/route.ts
  - /wedsync/src/components/api-keys/APIKeyManager.tsx
  - /wedsync/src/components/api-keys/CreateAPIKeyDialog.tsx
  - /wedsync/src/components/api-keys/APIKeyDisplay.tsx
  - /wedsync/src/lib/services/apiKeyService.ts
  - /wedsync/src/lib/auth/apiKeyAuth.ts
  - /wedsync/src/lib/rate-limiting/apiRateLimit.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- API keys table
CREATE TABLE IF NOT EXISTS api_keys (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID NOT NULL REFERENCES suppliers(id),
  key_hash TEXT NOT NULL, -- SHA-256 of the actual key
  key_prefix TEXT NOT NULL, -- First 12 chars for identification (ws_prod_abc123...)
  name TEXT NOT NULL, -- User-friendly name
  scopes TEXT[] NOT NULL, -- ['read:clients', 'write:forms', 'read:analytics']
  rate_limit INTEGER DEFAULT 1000, -- Requests per hour
  last_used_at TIMESTAMP WITH TIME ZONE,
  usage_count INTEGER DEFAULT 0,
  expires_at TIMESTAMP WITH TIME ZONE, -- NULL for no expiration
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  revoked_at TIMESTAMP WITH TIME ZONE,
  
  UNIQUE(key_hash),
  UNIQUE(supplier_id, name) -- Unique names per supplier
);

-- API key usage logs for audit trail
CREATE TABLE IF NOT EXISTS api_key_usage_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  api_key_id UUID NOT NULL REFERENCES api_keys(id),
  supplier_id UUID NOT NULL REFERENCES suppliers(id),
  endpoint TEXT NOT NULL,
  method VARCHAR(10) NOT NULL,
  ip_address INET,
  user_agent TEXT,
  status_code INTEGER NOT NULL,
  response_time_ms INTEGER,
  requested_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Rate limiting tracking
CREATE TABLE IF NOT EXISTS api_rate_limits (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  api_key_id UUID NOT NULL REFERENCES api_keys(id),
  window_start TIMESTAMP WITH TIME ZONE NOT NULL,
  request_count INTEGER DEFAULT 1,
  
  UNIQUE(api_key_id, window_start)
);

-- Create indexes for performance
CREATE INDEX idx_api_keys_supplier_id ON api_keys(supplier_id);
CREATE INDEX idx_api_keys_key_hash ON api_keys(key_hash);
CREATE INDEX idx_api_key_usage_logs_api_key_id ON api_key_usage_logs(api_key_id);
CREATE INDEX idx_api_rate_limits_key_window ON api_rate_limits(api_key_id, window_start);
```

#### API Endpoints Required
```typescript
// GET /api/api-keys - List all API keys for supplier
interface GetAPIKeysResponse {
  keys: {
    id: string;
    name: string;
    keyPrefix: string; // ws_prod_abc123...
    scopes: string[];
    rateLimit: number;
    lastUsed: string | null;
    usageCount: number;
    expiresAt: string | null;
    createdAt: string;
    isActive: boolean;
  }[];
}

// POST /api/api-keys - Create new API key
interface CreateAPIKeyRequest {
  name: string;
  scopes: string[];
  rateLimit?: number; // Default based on subscription tier
  expiresAt?: string; // ISO date string
}

interface CreateAPIKeyResponse {
  success: boolean;
  key: string; // Full key shown only once
  keyData: {
    id: string;
    name: string;
    keyPrefix: string;
    scopes: string[];
    rateLimit: number;
  };
}

// POST /api/api-keys/[id]/rotate - Rotate API key
interface RotateAPIKeyResponse {
  success: boolean;
  newKey: string; // New key shown only once
  keyPrefix: string;
  rotatedAt: string;
}

// DELETE /api/api-keys/[id] - Revoke API key
interface RevokeAPIKeyResponse {
  success: boolean;
  revokedAt: string;
}
```

#### Frontend Components Required
```typescript
// Component: APIKeyManager
// Location: /src/components/api-keys/APIKeyManager.tsx

interface APIKeyManagerProps {
  supplierId: string;
}

// Key functionality:
- List all API keys with usage statistics
- Create new API keys with scope selection
- Rotate existing keys with confirmation
- Revoke keys with cascade impact warning
- Usage analytics per key (requests, errors)

// Component: CreateAPIKeyDialog
// Location: /src/components/api-keys/CreateAPIKeyDialog.tsx

interface CreateAPIKeyDialogProps {
  onCreateKey: (keyData: CreateAPIKeyRequest) => Promise<void>;
  availableScopes: Scope[];
  maxKeys: number;
}

// Key functionality:
- Scope selection with explanations
- Rate limit configuration based on tier
- Expiration date picker
- Preview of key permissions
- Validation and error handling

// Component: APIKeyDisplay
// Location: /src/components/api-keys/APIKeyDisplay.tsx

interface APIKeyDisplayProps {
  apiKey: APIKey;
  showUsageStats?: boolean;
}

// Key functionality:
- Secure key prefix display (never full key)
- Copy key prefix functionality
- Usage metrics visualization
- Last used timestamp and IP
- Scope badges with tooltips
```

#### Integration Points
```typescript
// Service: APIKeyService
// Dependencies: crypto, bcrypt, rate limiter

class APIKeyService {
  async generateAPIKey(supplierId: string, keyData: CreateAPIKeyRequest) {
    // Step 1: Validate subscription allows API access
    const subscription = await subscriptionService.getCurrentSubscription(supplierId);
    if (!subscription.tier.features.includes('api_access')) {
      throw new Error('API access not available in current plan');
    }
    
    // Step 2: Check key limits per tier
    const currentKeyCount = await this.getKeyCount(supplierId);
    if (currentKeyCount >= this.getMaxKeysForTier(subscription.tier.id)) {
      throw new Error('Maximum API keys limit reached');
    }
    
    // Step 3: Generate secure key
    const env = process.env.NODE_ENV === 'production' ? 'prod' : 'dev';
    const randomBytes = crypto.randomBytes(32).toString('hex');
    const fullKey = `ws_${env}_${randomBytes}`;
    const keyHash = crypto.createHash('sha256').update(fullKey).digest('hex');
    const keyPrefix = fullKey.substring(0, 12) + '...';
    
    // Step 4: Store in database
    const { data: apiKey } = await supabase
      .from('api_keys')
      .insert({
        supplier_id: supplierId,
        key_hash: keyHash,
        key_prefix: keyPrefix,
        name: keyData.name,
        scopes: keyData.scopes,
        rate_limit: keyData.rateLimit || this.getDefaultRateLimit(subscription.tier.id),
        expires_at: keyData.expiresAt
      })
      .select()
      .single();
    
    // Return key only once
    return { apiKey, fullKey };
  }
  
  async validateAPIKey(keyString: string) {
    const keyHash = crypto.createHash('sha256').update(keyString).digest('hex');
    
    const { data: apiKey } = await supabase
      .from('api_keys')
      .select('*, suppliers(*)')
      .eq('key_hash', keyHash)
      .is('revoked_at', null)
      .single();
    
    if (!apiKey || (apiKey.expires_at && new Date(apiKey.expires_at) < new Date())) {
      throw new Error('Invalid or expired API key');
    }
    
    // Check rate limit
    await this.checkRateLimit(apiKey.id, apiKey.rate_limit);
    
    // Update last used
    await supabase
      .from('api_keys')
      .update({ 
        last_used_at: new Date().toISOString(),
        usage_count: apiKey.usage_count + 1
      })
      .eq('id', apiKey.id);
    
    return apiKey;
  }
  
  async checkRateLimit(apiKeyId: string, limit: number) {
    const windowStart = new Date();
    windowStart.setMinutes(0, 0, 0); // Start of current hour
    
    const { data: usage } = await supabase
      .from('api_rate_limits')
      .select('request_count')
      .eq('api_key_id', apiKeyId)
      .eq('window_start', windowStart.toISOString())
      .single();
    
    const currentCount = usage?.request_count || 0;
    if (currentCount >= limit) {
      throw new Error('Rate limit exceeded');
    }
    
    // Increment counter
    await supabase
      .from('api_rate_limits')
      .upsert({
        api_key_id: apiKeyId,
        window_start: windowStart.toISOString(),
        request_count: currentCount + 1
      }, {
        onConflict: 'api_key_id, window_start'
      });
  }
}
```

### CODE EXAMPLES

#### Example 1: API Key Middleware Implementation
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { NextRequest, NextResponse } from 'next/server';
import { APIKeyService } from '@/lib/services/apiKeyService';

export async function apiKeyMiddleware(request: NextRequest) {
  // Step 1: Check if this is an API route requiring authentication
  if (!request.nextUrl.pathname.startsWith('/api/v1/')) {
    return NextResponse.next();
  }
  
  // Step 2: Extract API key from headers
  const apiKey = request.headers.get('x-api-key') || 
                 request.headers.get('authorization')?.replace('Bearer ', '');
  
  if (!apiKey) {
    return NextResponse.json(
      { error: 'API key required' },
      { status: 401 }
    );
  }
  
  try {
    // Step 3: Validate API key and get permissions
    const apiKeyService = new APIKeyService();
    const keyData = await apiKeyService.validateAPIKey(apiKey);
    
    // Step 4: Check if key has required scope for this endpoint
    const requiredScope = getRequiredScope(request.nextUrl.pathname, request.method);
    if (requiredScope && !keyData.scopes.includes(requiredScope)) {
      return NextResponse.json(
        { error: `Missing required scope: ${requiredScope}` },
        { status: 403 }
      );
    }
    
    // Step 5: Add supplier context to request headers
    const response = NextResponse.next();
    response.headers.set('x-supplier-id', keyData.supplier_id);
    response.headers.set('x-api-key-id', keyData.id);
    
    // Step 6: Log API usage
    await logAPIUsage(keyData.id, request);
    
    return response;
    
  } catch (error) {
    return NextResponse.json(
      { error: error.message },
      { status: error.message.includes('Rate limit') ? 429 : 401 }
    );
  }
}

function getRequiredScope(pathname: string, method: string): string | null {
  const scopeMap: Record<string, Record<string, string>> = {
    '/api/v1/clients': {
      'GET': 'read:clients',
      'POST': 'write:clients',
      'PUT': 'write:clients',
      'DELETE': 'write:clients'
    },
    '/api/v1/forms': {
      'GET': 'read:forms',
      'POST': 'write:forms'
    },
    '/api/v1/analytics': {
      'GET': 'read:analytics'
    }
  };
  
  return scopeMap[pathname]?.[method] || null;
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [ ] Context7: Load docs for crypto, rate limiting, API authentication patterns
- [ ] Playwright: Test API key creation flow and authentication
- [ ] Filesystem: Access API documentation templates

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/nodejs/crypto", "hash functions", 2000);
await mcp__context7__get-library-docs("/vercel/next.js", "middleware api routes", 2500);
await mcp__context7__get-library-docs("/upstash/ratelimit", "rate limiting", 1500);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('API Key Service', () => {
  it('should generate secure API key with correct format', async () => {
    const result = await apiKeyService.generateAPIKey('supplier-123', {
      name: 'Test Key',
      scopes: ['read:clients'],
      rateLimit: 1000
    });
    
    expect(result.fullKey).toMatch(/^ws_(prod|dev)_[a-f0-9]{64}$/);
    expect(result.apiKey.key_prefix).toMatch(/^ws_(prod|dev)_[a-f0-9]{8}\.\.\.$/);
  });
  
  it('should enforce rate limits correctly', async () => {
    // Make requests up to limit
    for (let i = 0; i < 1000; i++) {
      await apiKeyService.checkRateLimit('key-123', 1000);
    }
    
    // Should throw on limit exceeded
    await expect(
      apiKeyService.checkRateLimit('key-123', 1000)
    ).rejects.toThrow('Rate limit exceeded');
  });
  
  it('should validate scopes for API endpoints', async () => {
    const hasAccess = await apiKeyService.checkScope(['read:clients'], '/api/v1/clients', 'GET');
    expect(hasAccess).toBe(true);
    
    const noAccess = await apiKeyService.checkScope(['read:clients'], '/api/v1/clients', 'POST');
    expect(noAccess).toBe(false);
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('API key management workflow', async () => {
  await mcp__playwright__browser_navigate({url: '/api-keys'});
  await mcp__playwright__browser_snapshot();
  
  // Test creating new API key
  await mcp__playwright__browser_click({
    element: "Create API Key button",
    ref: "button[data-testid='create-api-key']"
  });
  
  await mcp__playwright__browser_type({
    element: "Key name input",
    ref: "input[name='keyName']",
    text: "Test Integration Key"
  });
  
  // Select scopes
  await mcp__playwright__browser_click({
    element: "Read clients scope checkbox",
    ref: "input[value='read:clients']"
  });
  
  // Test key display (should show only once)
  await mcp__playwright__browser_click({
    element: "Generate key button",
    ref: "button[data-testid='generate-key']"
  });
  
  const keyDisplay = await mcp__playwright__browser_wait_for({text: "ws_"});
  expect(keyDisplay).toBeTruthy();
  
  // Test copying key prefix
  await mcp__playwright__browser_click({
    element: "Copy key prefix button",
    ref: "button[data-testid='copy-prefix']"
  });
});
```

### ACCEPTANCE CRITERIA
- [ ] Suppliers can generate API keys with configurable scopes and rate limits
- [ ] Keys are securely hashed and never stored in plaintext
- [ ] Rate limiting enforces per-hour request limits per key
- [ ] API authentication middleware validates keys and scopes
- [ ] Usage logging tracks all API requests for audit purposes
- [ ] Key rotation generates new keys while maintaining access
- [ ] Performance: API key validation completes within 100ms
- [ ] Security: Keys follow secure generation practices (SHA-256, 64-char entropy)
- [ ] Accessibility: API management interface supports screen readers

### DEPENDENCIES
- Must complete after: WS-071 (Subscription Tiers) - needs subscription validation for API access
- Must complete before: WS-073 (Team Management) - team members need API key permissions
- Shares code with: All API endpoints requiring authentication

### ESTIMATED EFFORT
- Team B Backend: 18 hours (API key generation, validation middleware, rate limiting)
- Team E Full-stack: 16 hours (API key management UI, usage analytics)
- Team C Integration: 6 hours (API documentation, webhook integration)
- Total: 40 hours