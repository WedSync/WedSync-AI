# TECHNICAL SPECIFICATION: WS-232 - Predictive Modeling System
## Generated by Feature Development Session - 2025-01-25

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** WedSync platform data scientist managing growth optimization
**I want to:** Deploy sophisticated machine learning models predicting churn, revenue, and viral growth with wedding industry-specific features
**So that:** I can proactively intervene when photographers show early churn signals (like 14+ days since login + no new clients), accurately forecast MRR accounting for wedding seasonality peaks (June: 1.6x multiplier), and optimize viral loops by predicting which vendor types have highest viral coefficients

**Real Wedding Scenario:**
"A photographer joins in March (off-season) with baseline churn risk, but ML model detects unusual pattern: no forms created + 3 failed logins + competitor mentions in support tickets = 85% churn probability. Model triggers immediate founder outreach, offering free onboarding call and client import assistance. Similarly, model predicts June MRR will increase 60% based on historical patterns, prompting infrastructure scaling and customer success preparation."

### SPECIFICATION SOURCE
- **Feature ID:** WS-232
- **Original Spec:** /CORE-SPECIFICATIONS/07-ADMIN-DASHBOARD/03-Growth-Metrics/04-predictive-modeling md.md
- **Current Implementation:** 0% complete
- **Files to Modify:** None (new feature)
- **New Files to Create:**
  - `/src/components/admin/PredictiveAnalyticsDashboard.tsx`
  - `/src/lib/ml/churn-prediction-model.ts`
  - `/src/lib/ml/revenue-forecaster.ts`
  - `/src/lib/ml/viral-growth-predictor.ts`
  - `/src/lib/ml/ltv-predictor.ts`
  - `/src/lib/ml/anomaly-detector.ts`
  - `/src/lib/ml/model-monitor.ts`
  - `/src/app/api/admin/ml/predictions/route.ts`
  - `/src/hooks/usePredictions.ts`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Feature store for ML
CREATE TABLE ml_feature_store (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  entity_type TEXT NOT NULL, -- 'supplier', 'couple', 'transaction'
  entity_id UUID NOT NULL,
  feature_set TEXT NOT NULL,
  features JSONB NOT NULL,
  feature_version INTEGER DEFAULT 1,
  calculated_at TIMESTAMPTZ DEFAULT NOW(),
  expires_at TIMESTAMPTZ,
  UNIQUE(entity_type, entity_id, feature_set, feature_version)
);

-- Model registry
CREATE TABLE ml_models (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  model_name TEXT NOT NULL,
  model_type TEXT NOT NULL, -- 'churn', 'ltv', 'viral', 'revenue'
  version TEXT NOT NULL,
  algorithm TEXT NOT NULL,
  hyperparameters JSONB,
  training_metrics JSONB,
  validation_metrics JSONB,
  feature_importance JSONB,
  training_data_snapshot JSONB,
  trained_at TIMESTAMPTZ DEFAULT NOW(),
  deployed_at TIMESTAMPTZ,
  retired_at TIMESTAMPTZ,
  status TEXT DEFAULT 'training',
  UNIQUE(model_name, version)
);

-- Predictions log
CREATE TABLE ml_predictions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  model_id UUID REFERENCES ml_models(id),
  prediction_type TEXT NOT NULL,
  entity_id UUID,
  entity_type TEXT,
  prediction JSONB NOT NULL,
  confidence DECIMAL(3,2),
  features_used JSONB,
  predicted_at TIMESTAMPTZ DEFAULT NOW(),
  prediction_for_date DATE,
  actual_outcome JSONB,
  outcome_recorded_at TIMESTAMPTZ
);

-- Anomaly detection log
CREATE TABLE ml_anomalies (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  anomaly_type TEXT NOT NULL,
  severity TEXT NOT NULL, -- 'low', 'medium', 'high', 'critical'
  detected_at TIMESTAMPTZ DEFAULT NOW(),
  metrics JSONB NOT NULL,
  description TEXT,
  auto_action_taken BOOLEAN DEFAULT FALSE,
  action_taken TEXT,
  resolved_at TIMESTAMPTZ,
  false_positive BOOLEAN,
  impact_assessment JSONB
);

CREATE INDEX idx_feature_store_lookup ON ml_feature_store(entity_type, entity_id, feature_set);
CREATE INDEX idx_predictions_model ON ml_predictions(model_id, predicted_at DESC);
CREATE INDEX idx_anomalies_unresolved ON ml_anomalies(severity, detected_at DESC) WHERE resolved_at IS NULL;
```

#### API Endpoints Required
```typescript
// GET /api/admin/ml/predictions
interface PredictionsResponse {
  churn: ChurnPredictions;
  revenue: RevenueForecast;
  viral: ViralPredictions;
  ltv: LTVPredictions;
  anomalies: Anomaly[];
}

// POST /api/admin/ml/predictions/churn
interface ChurnPredictionRequest {
  supplierIds?: string[];
  riskThreshold?: number;
}

interface ChurnPredictionResponse {
  predictions: ChurnPrediction[];
  totalAtRisk: number;
  mrrAtRisk: number;
  interventions: Intervention[];
}

// POST /api/admin/ml/forecast/revenue
interface RevenueForecastRequest {
  horizonMonths: number;
  scenarios?: 'baseline' | 'optimistic' | 'pessimistic';
}

interface RevenueForecastResponse {
  baseline: number[];
  optimistic: number[];
  pessimistic: number[];
  keyDrivers: string[];
  confidence: number;
}
```

#### Frontend Components Required
```typescript
// Component: PredictiveAnalyticsDashboard
// Location: /src/components/admin/PredictiveAnalyticsDashboard.tsx

interface PredictiveAnalyticsDashboardProps {
  timeHorizon: number; // days
  refreshInterval?: number; // minutes
}

// Key functionality:
- Revenue forecast chart with confidence intervals
- Churn risk matrix with intervention suggestions
- Viral growth predictor with optimization recommendations
- LTV distribution by cohort and segment
- Real-time anomaly alerts and auto-actions
- Model performance monitoring grid

// Component: ChurnRiskMatrix
// Location: /src/components/admin/ChurnRiskMatrix.tsx

interface ChurnRiskMatrixProps {
  suppliers: ChurnPrediction[];
  totalMRRAtRisk: number;
  interventions: Intervention[];
}

// Key functionality:
- Risk level visualization (Low/Medium/High/Critical)
- Supplier details with churn factors
- One-click intervention execution
- Historical intervention success rates
```

#### Integration Points
```typescript
// Service: WeddingSupplierChurnPredictor
// Dependencies: ML Feature Store, Email Service, Support System

class WeddingSupplierChurnPredictor {
  async predictChurn(supplierId: string): Promise<ChurnPrediction> {
    // Extract wedding-specific features and run ensemble prediction
  }
  
  async generateInterventions(
    prediction: ChurnPrediction,
    features: SupplierFeatures
  ): Promise<Intervention[]> {
    // Generate personalized retention strategies
  }
}

// Service: RevenueForecaster
// Dependencies: Historical Data, Seasonality Models, External Market Data

class RevenueForecaster {
  async forecastMRR(horizonMonths: number): Promise<RevenueForecast> {
    // Apply wedding seasonality and generate multi-scenario forecasts
  }
  
  private applyWeddingSeasonality(streams: RevenueStreams): AdjustedStreams {
    // Wedding season multipliers: June (1.6x), December (0.6x)
  }
}
```

### CODE EXAMPLES

#### Example 1: Churn Prediction Model Implementation
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { supabase } from '@/lib/supabase';

export interface ChurnPrediction {
  supplierId: string;
  churnProbability: number;
  churnDate: Date;
  confidence: number;
  riskLevel: 'low' | 'medium' | 'high' | 'critical';
  monthlyRevenueLoss: number;
  lifetimeValueLoss: number;
  interventions: Intervention[];
  factors: ChurnFactor[];
}

export interface ChurnFactor {
  factor: string;
  impact: number; // -1 to 1
  description: string;
}

export interface Intervention {
  type: 'immediate_outreach' | 'engagement_campaign' | 'growth_assistance' | 'viral_optimization';
  action: string;
  priority: 'critical' | 'high' | 'medium' | 'low';
  expectedImpact: number; // % reduction in churn probability
  script?: string;
  incentive?: string;
}

export class WeddingSupplierChurnPredictor {
  private readonly CHURN_SIGNALS = {
    // Engagement metrics
    lastLogin: { weight: 0.25, threshold: 14 }, // days
    formsCreated: { weight: 0.15, threshold: 2 },
    clientsActive: { weight: 0.20, threshold: 5 },

    // Wedding-specific signals
    seasonalityFactor: { weight: 0.10 }, // Off-season risk
    vendorTypeRisk: { weight: 0.08 }, // Some vendors churn more
    competitorMentions: { weight: 0.05 }, // Support ticket analysis

    // Financial signals
    paymentFailures: { weight: 0.10, threshold: 1 },
    downgradeBehavior: { weight: 0.07, threshold: 1 }
  };

  async predictChurn(supplierId: string): Promise<ChurnPrediction> {
    // Gather comprehensive features
    const features = await this.extractSupplierFeatures(supplierId);

    // Apply wedding seasonality adjustments
    const seasonAdjusted = this.adjustForWeddingSeason(features);

    // Run ensemble prediction (simplified for example)
    const predictions = await Promise.all([
      this.logisticRegression(seasonAdjusted),
      this.randomForest(seasonAdjusted),
      this.gradientBoosting(seasonAdjusted)
    ]);

    // Weighted ensemble
    const ensemblePrediction = this.weightedEnsemble(predictions);

    // Generate intervention recommendations
    const interventions = await this.generateInterventions(
      ensemblePrediction,
      features
    );

    return {
      supplierId,
      churnProbability: ensemblePrediction.probability,
      churnDate: ensemblePrediction.estimatedDate,
      confidence: ensemblePrediction.confidence,
      riskLevel: this.getRiskLevel(ensemblePrediction.probability),
      monthlyRevenueLoss: features.mrr,
      lifetimeValueLoss: features.ltv,
      interventions,
      factors: this.explainPrediction(features, ensemblePrediction)
    };
  }

  private async extractSupplierFeatures(supplierId: string): Promise<SupplierFeatures> {
    const { data, error } = await supabase.rpc('extract_churn_features', {
      supplier_id: supplierId
    });

    if (error) throw error;

    return {
      supplierId,
      vendorType: data.vendor_type,
      daysSinceLogin: data.days_since_login,
      totalForms: data.total_forms,
      recentForms: data.recent_forms,
      totalClients: data.total_clients,
      activeClients: data.active_clients,
      couplesInvited: data.couples_invited,
      couplesActivated: data.couples_activated,
      avgSessionDuration: data.avg_session_duration,
      activeDaysLastMonth: data.active_days_last_month,
      negativeTickets: data.negative_tickets,
      failedPayments: data.failed_payments,
      competitorMentions: data.competitor_mentions,
      mrr: data.mrr,
      ltv: data.estimated_ltv
    };
  }

  private getRiskLevel(probability: number): 'low' | 'medium' | 'high' | 'critical' {
    if (probability >= 0.8) return 'critical';
    if (probability >= 0.6) return 'high';
    if (probability >= 0.3) return 'medium';
    return 'low';
  }

  private async generateInterventions(
    prediction: { probability: number },
    features: SupplierFeatures
  ): Promise<Intervention[]> {
    const interventions: Intervention[] = [];

    if (prediction.probability > 0.7) {
      // High risk - immediate action
      interventions.push({
        type: 'immediate_outreach',
        action: 'Schedule founder call within 24 hours',
        priority: 'critical',
        expectedImpact: 0.4, // 40% churn reduction
        script: this.generateOutreachScript(features),
        incentive: this.calculateRetentionOffer(features.mrr)
      });
    }

    if (features.daysSinceLogin > 14) {
      interventions.push({
        type: 'engagement_campaign',
        action: 'Send re-engagement email sequence',
        priority: 'high',
        expectedImpact: 0.25
      });
    }

    if (features.activeClients < 5) {
      interventions.push({
        type: 'growth_assistance',
        action: 'Offer free onboarding call',
        priority: 'medium',
        expectedImpact: 0.2
      });
    }

    return interventions;
  }

  private generateOutreachScript(features: SupplierFeatures): string {
    return `Hi [Name], I noticed you haven't logged into WedSync in ${features.daysSinceLogin} days. 
As a ${features.vendorType}, I know wedding season can be busy. 
Would a quick 15-minute call help optimize your workflow? 
We've helped similar ${features.vendorType}s increase their client bookings by 40%.`;
  }

  private calculateRetentionOffer(mrr: number): string {
    if (mrr > 100) return '3 months free Premium features';
    if (mrr > 50) return '2 months free + priority support';
    return '1 month free + onboarding session';
  }
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for TensorFlow.js, scikit-learn patterns, ML visualization libraries
- [x] Supabase: Complex analytical queries, feature store operations
- [x] Filesystem: Access ML model files and training data

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/tensorflow/tfjs", "prediction models", 3000);
await mcp__context7__get-library-docs("/supabase/supabase", "complex queries", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('WeddingSupplierChurnPredictor', () => {
  it('should predict high churn for inactive suppliers with failed payments', async () => {
    const predictor = new WeddingSupplierChurnPredictor();
    const features = {
      daysSinceLogin: 30,
      failedPayments: 2,
      activeClients: 0,
      competitorMentions: 1,
      vendorType: 'photographer'
    };
    
    const prediction = await predictor.predictChurn('test-supplier-id');
    expect(prediction.riskLevel).toBe('critical');
    expect(prediction.interventions.length).toBeGreaterThan(0);
  });

  it('should adjust predictions for wedding seasonality', () => {
    const offSeasonMultiplier = predictor.getSeasonalMultiplier('January');
    const peakSeasonMultiplier = predictor.getSeasonalMultiplier('June');
    expect(peakSeasonMultiplier).toBeGreaterThan(offSeasonMultiplier);
  });

  it('should generate appropriate interventions by risk level', async () => {
    const criticalRisk = await predictor.generateInterventions({ probability: 0.85 }, mockFeatures);
    expect(criticalRisk.some(i => i.priority === 'critical')).toBe(true);
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Admin can view predictive analytics and trigger interventions', async () => {
  await mcp__playwright__browser_navigate({url: '/admin/predictive-analytics'});
  await mcp__playwright__browser_snapshot();
  
  // Check churn risk matrix loads
  await mcp__playwright__browser_wait_for({text: 'Critical Risk'});
  
  // Click on high-risk supplier
  await mcp__playwright__browser_click({
    element: 'High risk supplier row',
    ref: '[data-testid="supplier-risk-critical"]'
  });
  
  // Trigger intervention
  await mcp__playwright__browser_click({
    element: 'Send retention email button',
    ref: '[data-testid="trigger-intervention"]'
  });
  
  await mcp__playwright__browser_snapshot();
});
```

### ACCEPTANCE CRITERIA
- [x] Churn prediction accuracy >85% on validation set
- [x] Revenue forecast accuracy ±10% at 30-day horizon
- [x] Viral coefficient prediction ±0.1 accuracy
- [x] Real-time anomaly detection with <5% false positive rate
- [x] Automated intervention triggers for critical risk suppliers
- [x] Performance: Predictions generate under 3 seconds
- [x] Security: ML model access restricted to admin roles
- [x] Interpretability: Clear factor explanations for all predictions

### DEPENDENCIES
- Must complete after: Data collection infrastructure, user analytics
- Must complete before: Automated intervention system, growth optimization
- Shares code with: Advanced analytics dashboard, business intelligence

### ESTIMATED EFFORT
- Team A Frontend: 24 hours (Predictive dashboard, visualization components)
- Team B Backend: 16 hours (API endpoints, feature store integration)
- Team C Integration: 12 hours (ML model deployment, monitoring integration)
- Team D Platform: 8 hours (Database schema, performance optimization)
- Team E General: 20 hours (Comprehensive ML testing, model validation)
- Team F Workflows: 6 hours (Automated retraining pipelines)
- Team G Performance: 8 hours (ML inference optimization, caching)
- **Team D AI/ML: 48 hours** (Core ML models, algorithms, feature engineering)
- Total: 142 hours