# TECHNICAL SPECIFICATION: WS-066 - Section Configuration
## Generated by Feature Development Session - August 21, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding photographer
**I want to:** Configure my client dashboard sections to show timeline-specific content, hide completed forms automatically, and display different sections based on package level
**So that:** Clients only see relevant information at the right time (preventing overwhelm) and I can provide premium experiences without manual dashboard updates for each client

**Real Wedding Scenario:**
A photographer's "Forms" section currently shows all 12 forms to couples immediately after booking, causing confusion. With section configuration, couples see only 2-3 relevant forms based on their timeline (6 months out: venue questionnaire, 2 months out: timeline preferences, 1 week out: emergency contacts). The "Vendor Directory" section only appears for premium packages, and the "Final Deliverables" section automatically appears post-wedding. This reduces client support emails by 60%.

### SPECIFICATION SOURCE
- **Feature ID:** WS-066
- **Original Spec:** /CORE-SPECIFICATIONS/02-WEDSYNC-SUPPLIER-PLATFORM/07-Client-Dashboard-Builder/02-section-configuration md.md
- **Current Implementation:** 0% complete
- **Files to Modify:** 
  - `/wedsync/src/components/dashboard-builder/TemplateBuilder.tsx`
- **New Files to Create:** 
  - `/wedsync/src/components/dashboard-builder/SectionConfigEditor.tsx`
  - `/wedsync/src/components/dashboard-builder/VisibilityRulesBuilder.tsx`
  - `/wedsync/src/components/dashboard-builder/ContentConfigPanel.tsx`
  - `/wedsync/src/components/dashboard-builder/StyleConfigPanel.tsx`
  - `/wedsync/src/lib/section-visibility-engine.ts`
  - `/wedsync/src/app/api/sections/[id]/config/route.ts`
  - `/wedsync/src/types/section-configuration.ts`
  - `/wedsync/supabase/migrations/029_section_configuration_system.sql`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Enhanced section configurations (extends template_sections from WS-065)
-- Add new columns to existing template_sections table
ALTER TABLE template_sections ADD COLUMN IF NOT EXISTS visibility_config JSONB DEFAULT '{}'::jsonb;
ALTER TABLE template_sections ADD COLUMN IF NOT EXISTS interaction_config JSONB DEFAULT '{}'::jsonb;
ALTER TABLE template_sections ADD COLUMN IF NOT EXISTS content_rules JSONB DEFAULT '{}'::jsonb;
ALTER TABLE template_sections ADD COLUMN IF NOT EXISTS timeline_rules JSONB DEFAULT '{}'::jsonb;
ALTER TABLE template_sections ADD COLUMN IF NOT EXISTS device_visibility TEXT[] DEFAULT '{desktop,mobile}';

-- Section content configurations for different types
CREATE TABLE IF NOT EXISTS section_content_configs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  section_id UUID REFERENCES template_sections(id) ON DELETE CASCADE,
  content_type dashboard_section_type NOT NULL,
  config_schema JSONB NOT NULL, -- JSON schema for validation
  default_config JSONB NOT NULL, -- Default configuration values
  display_options JSONB DEFAULT '{}'::jsonb,
  data_source_config JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Visibility conditions and rules
CREATE TABLE IF NOT EXISTS visibility_conditions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  section_id UUID REFERENCES template_sections(id) ON DELETE CASCADE,
  condition_type visibility_condition_type NOT NULL,
  condition_config JSONB NOT NULL,
  priority_order INTEGER DEFAULT 0,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TYPE visibility_condition_type AS ENUM (
  'timeline_based',
  'package_based',
  'status_based',
  'form_completion',
  'payment_status',
  'journey_stage',
  'custom_field',
  'date_range'
);

-- Timeline visibility rules for wedding-specific scheduling
CREATE TABLE IF NOT EXISTS timeline_visibility_rules (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  section_id UUID REFERENCES template_sections(id) ON DELETE CASCADE,
  show_from timeline_anchor NOT NULL,
  show_until timeline_anchor,
  show_from_days INTEGER, -- Days relative to anchor
  show_until_days INTEGER,
  timezone_sensitive BOOLEAN DEFAULT true,
  override_conditions JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TYPE timeline_anchor AS ENUM (
  'booking_date',
  'wedding_date',
  'venue_booking',
  'final_payment',
  'form_submission',
  'custom_milestone'
);

-- Section interaction tracking for analytics
CREATE TABLE IF NOT EXISTS section_interactions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  section_id UUID REFERENCES template_sections(id) ON DELETE CASCADE,
  client_id UUID REFERENCES clients(id) ON DELETE CASCADE,
  interaction_type interaction_type NOT NULL,
  interaction_data JSONB DEFAULT '{}'::jsonb,
  session_id VARCHAR(255),
  device_type VARCHAR(50),
  timestamp TIMESTAMPTZ DEFAULT NOW()
);

CREATE TYPE interaction_type AS ENUM (
  'view',
  'expand',
  'collapse',
  'click_action',
  'download',
  'form_start',
  'form_complete',
  'share',
  'bookmark'
);

-- Section content variations for A/B testing
CREATE TABLE IF NOT EXISTS section_content_variations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  section_id UUID REFERENCES template_sections(id) ON DELETE CASCADE,
  variation_name VARCHAR(255) NOT NULL,
  content_config JSONB NOT NULL,
  styling_config JSONB DEFAULT '{}'::jsonb,
  traffic_percentage INTEGER DEFAULT 50, -- 0-100%
  is_active BOOLEAN DEFAULT true,
  performance_metrics JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- RLS policies for section configurations
ALTER TABLE section_content_configs ENABLE ROW LEVEL SECURITY;
ALTER TABLE visibility_conditions ENABLE ROW LEVEL SECURITY;
ALTER TABLE timeline_visibility_rules ENABLE ROW LEVEL SECURITY;
ALTER TABLE section_interactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE section_content_variations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can manage their section content configs" ON section_content_configs
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM template_sections ts
      JOIN dashboard_templates dt ON dt.id = ts.template_id
      WHERE ts.id = section_content_configs.section_id 
      AND dt.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can manage their visibility conditions" ON visibility_conditions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM template_sections ts
      JOIN dashboard_templates dt ON dt.id = ts.template_id
      WHERE ts.id = visibility_conditions.section_id 
      AND dt.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can access their section interactions" ON section_interactions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM template_sections ts
      JOIN dashboard_templates dt ON dt.id = ts.template_id
      WHERE ts.id = section_interactions.section_id 
      AND dt.user_id = auth.uid()
    )
  );
```

#### API Endpoints Required
```typescript
// PUT /api/sections/[id]/config
interface UpdateSectionConfigRequest {
  title?: string;
  contentConfig?: SectionContentConfig;
  visibilityConfig?: VisibilityConfig;
  styleConfig?: SectionStyleConfig;
  interactionConfig?: InteractionConfig;
  timelineRules?: TimelineRule[];
  deviceVisibility?: ('desktop' | 'mobile' | 'tablet')[];
}

interface UpdateSectionConfigResponse {
  success: boolean;
  data: {
    sectionId: string;
    updatedConfig: SectionConfiguration;
    affectedClients: number; // How many client dashboards will change
  };
}

// POST /api/sections/[id]/visibility-rules
interface CreateVisibilityRuleRequest {
  conditionType: VisibilityConditionType;
  conditionConfig: {
    packageTypes?: string[];
    journeyStages?: string[];
    formCompletionRequired?: string[];
    dateRange?: {from: string; to: string};
    customCondition?: string; // JavaScript expression
  };
  priority: number;
}

// GET /api/sections/[id]/preview
interface PreviewSectionRequest {
  clientId?: string; // For personalized preview
  mockClientData?: any; // For testing different scenarios
  timelinePosition?: string; // '6_months_before', '1_week_after', etc.
}

interface PreviewSectionResponse {
  success: boolean;
  data: {
    isVisible: boolean;
    renderedContent: string;
    appliedRules: string[];
    visibilityReasons: string[];
    interactionOptions: string[];
  };
}

// GET /api/sections/[id]/analytics
interface GetSectionAnalyticsResponse {
  success: boolean;
  data: {
    viewCounts: Array<{date: string; views: number}>;
    interactionRates: {
      expand: number;
      clickThrough: number;
      formCompletion: number;
    };
    visibilityMetrics: {
      totalShown: number;
      totalHidden: number;
      hideReasons: Record<string, number>;
    };
    deviceBreakdown: Record<string, number>;
    avgTimeSpent: number; // seconds
  };
}

// POST /api/sections/[id]/test-visibility
interface TestVisibilityRequest {
  testScenarios: Array<{
    clientData: any;
    timelinePosition: string;
    expectedVisible: boolean;
    description: string;
  }>;
}

interface TestVisibilityResponse {
  success: boolean;
  data: {
    testResults: Array<{
      scenario: string;
      expected: boolean;
      actual: boolean;
      passed: boolean;
      appliedRules: string[];
    }>;
    overallPassRate: number;
  };
}

// POST /api/sections/[id]/clone-config
interface CloneSectionConfigRequest {
  targetSectionId: string;
  includeVisibilityRules?: boolean;
  includeContentConfig?: boolean;
  includeStyleConfig?: boolean;
}
```

#### Frontend Components Required
```typescript
// Component: SectionConfigEditor
// Location: /src/components/dashboard-builder/SectionConfigEditor.tsx

interface SectionConfigEditorProps {
  section: TemplateSection;
  onConfigUpdate: (config: Partial<SectionConfiguration>) => void;
  onPreview: (config: SectionConfiguration) => void;
}

// Key functionality:
- Tabbed interface for content, visibility, style, interactions
- Real-time preview with mock client data
- Validation of configuration rules
- Wedding-specific configuration options
- Timeline-based visibility builder
- Device-specific configurations
- A/B testing setup for content variations

// Component: VisibilityRulesBuilder
// Location: /src/components/dashboard-builder/VisibilityRulesBuilder.tsx

interface VisibilityRulesBuilderProps {
  sectionId: string;
  currentRules: VisibilityCondition[];
  onRulesUpdate: (rules: VisibilityCondition[]) => void;
}

// Key functionality:
- Visual rule builder with conditions and operators
- Timeline-based rule creation (before/after wedding)
- Package and service level conditions
- Form completion dependencies
- Custom JavaScript condition editor
- Rule priority management and conflict detection
- Test scenarios for rule validation

// Component: ContentConfigPanel
// Location: /src/components/dashboard-builder/ContentConfigPanel.tsx

interface ContentConfigPanelProps {
  sectionType: DashboardSectionType;
  currentConfig: SectionContentConfig;
  onConfigChange: (config: SectionContentConfig) => void;
}

// Key functionality:
- Section-type-specific configuration forms
- Data source selection and filtering
- Display mode configuration (list, cards, timeline)
- Content personalization options
- Dynamic content rules setup
- Integration with form and document systems

// Component: StyleConfigPanel
// Location: /src/components/dashboard-builder/StyleConfigPanel.tsx

interface StyleConfigPanelProps {
  currentStyle: SectionStyleConfig;
  onStyleChange: (style: SectionStyleConfig) => void;
  previewMode: 'desktop' | 'tablet' | 'mobile';
}

// Key functionality:
- Visual style editor with live preview
- Responsive design configuration
- Brand-consistent styling options
- Custom CSS injection capability
- Accessibility compliance checking
- Style preset library for common looks
```

#### Integration Points
```typescript
// Service: SectionVisibilityEngine
// Dependencies: ClientService, TimelineService, PackageService

class SectionVisibilityEngine {
  async evaluateSectionVisibility(
    sectionId: string,
    clientId: string,
    currentDate: Date = new Date()
  ): Promise<VisibilityResult> {
    // 1. Get section configuration and visibility rules
    // 2. Fetch client context (package, forms, timeline, journey stage)
    // 3. Evaluate each visibility condition in priority order
    // 4. Apply timeline-based rules with wedding date calculations
    // 5. Check device-specific visibility
    // 6. Return final visibility decision with reasoning
  }

  async calculateTimelineVisibility(
    timelineRules: TimelineRule[],
    weddingDate: Date,
    currentDate: Date
  ): Promise<boolean> {
    // 1. Calculate days until/since wedding
    // 2. Evaluate each timeline anchor (booking, venue confirmation, etc.)
    // 3. Apply day offset calculations
    // 4. Handle timezone considerations
    // 5. Return visibility for current timeline position
  }

  async renderSectionWithConfig(
    section: TemplateSection,
    clientData: any,
    deviceType: string
  ): Promise<RenderedSection> {
    // 1. Apply content configuration filters
    // 2. Personalize content with client data
    // 3. Apply styling configuration
    // 4. Configure interaction capabilities
    // 5. Generate final HTML with analytics tracking
  }

  async testVisibilityRules(
    sectionId: string,
    testScenarios: TestScenario[]
  ): Promise<TestResults> {
    // 1. Run each test scenario against visibility engine
    // 2. Compare expected vs actual results
    // 3. Identify rule conflicts or unexpected behavior
    // 4. Generate debugging information for failed tests
  }
}

// Service: SectionConfigurationService
// Dependencies: TemplateService, VisibilityEngine, AnalyticsService

class SectionConfigurationService {
  async updateSectionConfiguration(
    sectionId: string,
    config: Partial<SectionConfiguration>
  ): Promise<void> {
    // 1. Validate configuration schema
    // 2. Check for conflicts with other sections
    // 3. Update database with new configuration
    // 4. Invalidate cached client dashboards
    // 5. Log configuration change for audit
  }

  async analyzeSectionPerformance(
    sectionId: string,
    dateRange: DateRange
  ): Promise<SectionAnalytics> {
    // 1. Aggregate interaction data
    // 2. Calculate visibility effectiveness
    // 3. Measure engagement by device type
    // 4. Identify optimization opportunities
    // 5. Generate performance recommendations
  }

  async cloneSectionConfiguration(
    sourceSectionId: string,
    targetSectionId: string,
    options: CloneOptions
  ): Promise<void> {
    // 1. Copy selected configuration aspects
    // 2. Adapt rules for new section context
    // 3. Validate configuration compatibility
    // 4. Update references and dependencies
  }
}
```

### CODE EXAMPLES

#### Example 1: Timeline-Based Visibility with Wedding Context
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { supabase } from '@/lib/supabase';
import { addDays, differenceInDays, parseISO } from 'date-fns';

export async function evaluateSectionVisibility(
  sectionId: string,
  clientId: string,
  currentDate: Date = new Date()
): Promise<VisibilityResult> {
  // Step 1: Get section configuration
  const { data: section, error: sectionError } = await supabase
    .from('template_sections')
    .select(`
      *,
      visibility_conditions(*),
      timeline_visibility_rules(*)
    `)
    .eq('id', sectionId)
    .single();
    
  if (sectionError) throw sectionError;
  
  // Step 2: Get client context
  const { data: client, error: clientError } = await supabase
    .from('clients')
    .select(`
      *,
      wedding_details:wedding_details(*),
      package_info:client_packages(*),
      forms:client_forms(*),
      journey_progress:client_journey_progress(*)
    `)
    .eq('id', clientId)
    .single();
    
  if (clientError) throw clientError;
  
  // Step 3: Evaluate visibility conditions
  const visibilityReasons: string[] = [];
  let isVisible = true;
  
  // Timeline-based visibility
  if (section.timeline_visibility_rules && section.timeline_visibility_rules.length > 0) {
    const timelineVisible = evaluateTimelineRules(
      section.timeline_visibility_rules,
      client.wedding_date,
      currentDate
    );
    
    if (!timelineVisible.visible) {
      isVisible = false;
      visibilityReasons.push(`Timeline: ${timelineVisible.reason}`);
    } else {
      visibilityReasons.push(`Timeline: ${timelineVisible.reason}`);
    }
  }
  
  // Package-based visibility
  for (const condition of section.visibility_conditions || []) {
    if (condition.condition_type === 'package_based') {
      const packageCheck = evaluatePackageCondition(condition, client.package_info);
      if (!packageCheck.visible) {
        isVisible = false;
        visibilityReasons.push(`Package: ${packageCheck.reason}`);
      }
    }
    
    if (condition.condition_type === 'form_completion') {
      const formCheck = evaluateFormCompletionCondition(condition, client.forms);
      if (!formCheck.visible) {
        isVisible = false;
        visibilityReasons.push(`Forms: ${formCheck.reason}`);
      }
    }
    
    if (condition.condition_type === 'journey_stage') {
      const journeyCheck = evaluateJourneyStageCondition(condition, client.journey_progress);
      if (!journeyCheck.visible) {
        isVisible = false;
        visibilityReasons.push(`Journey: ${journeyCheck.reason}`);
      }
    }
  }
  
  // Device visibility check
  const deviceType = getDeviceType(); // From user agent or context
  if (section.device_visibility && !section.device_visibility.includes(deviceType)) {
    isVisible = false;
    visibilityReasons.push(`Device: Not visible on ${deviceType}`);
  }
  
  return {
    sectionId,
    isVisible,
    reasons: visibilityReasons,
    evaluatedAt: currentDate.toISOString(),
    appliedRules: section.visibility_conditions?.map(c => c.condition_type) || []
  };
}

function evaluateTimelineRules(
  rules: TimelineVisibilityRule[],
  weddingDate: string,
  currentDate: Date
): {visible: boolean; reason: string} {
  const wedding = parseISO(weddingDate);
  const daysUntilWedding = differenceInDays(wedding, currentDate);
  
  for (const rule of rules) {
    const showFromDays = rule.show_from_days || 0;
    const showUntilDays = rule.show_until_days || Infinity;
    
    // Calculate anchor dates
    let anchorDate = wedding; // Default to wedding date
    if (rule.show_from === 'booking_date') {
      // Would need to get booking date from client record
      anchorDate = parseISO(client.created_at); // Fallback
    }
    
    const daysFromAnchor = differenceInDays(currentDate, anchorDate);
    
    // Check if current date falls within visibility window
    if (rule.show_from === 'wedding_date') {
      // For wedding date anchor, negative days mean "before wedding"
      const showFrom = -Math.abs(showFromDays); // e.g., -180 (6 months before)
      const showUntil = showUntilDays; // e.g., 30 (1 month after)
      
      if (daysUntilWedding >= showFrom && daysUntilWedding <= showUntil) {
        return {
          visible: true,
          reason: `Visible from ${Math.abs(showFrom)} days before to ${showUntil} days after wedding`
        };
      } else if (daysUntilWedding < showFrom) {
        return {
          visible: false,
          reason: `Too early - visible starting ${Math.abs(showFrom)} days before wedding`
        };
      } else {
        return {
          visible: false,
          reason: `Too late - visible until ${showUntil} days after wedding`
        };
      }
    }
  }
  
  return { visible: true, reason: 'No timeline restrictions' };
}

function evaluatePackageCondition(
  condition: VisibilityCondition,
  packageInfo: any
): {visible: boolean; reason: string} {
  const config = condition.condition_config;
  const allowedPackages = config.packageTypes || [];
  
  if (allowedPackages.length === 0) {
    return { visible: true, reason: 'No package restrictions' };
  }
  
  if (!packageInfo || !packageInfo.package_type) {
    return { visible: false, reason: 'No package information available' };
  }
  
  if (allowedPackages.includes(packageInfo.package_type)) {
    return { visible: true, reason: `Visible for ${packageInfo.package_type} package` };
  }
  
  return {
    visible: false,
    reason: `Only visible for packages: ${allowedPackages.join(', ')}`
  };
}

function evaluateFormCompletionCondition(
  condition: VisibilityCondition,
  clientForms: any[]
): {visible: boolean; reason: string} {
  const config = condition.condition_config;
  const requiredForms = config.formCompletionRequired || [];
  
  if (requiredForms.length === 0) {
    return { visible: true, reason: 'No form completion requirements' };
  }
  
  const completedForms = clientForms
    .filter(form => form.status === 'completed')
    .map(form => form.form_template_id);
  
  const missingForms = requiredForms.filter(
    formId => !completedForms.includes(formId)
  );
  
  if (missingForms.length === 0) {
    return {
      visible: true,
      reason: `All required forms completed: ${requiredForms.length}`
    };
  }
  
  return {
    visible: false,
    reason: `Missing ${missingForms.length} required form(s)`
  };
}

export async function renderSectionWithConfiguration(
  sectionId: string,
  clientId: string,
  deviceType: string = 'desktop'
): Promise<RenderedSection> {
  // Step 1: Check visibility
  const visibility = await evaluateSectionVisibility(sectionId, clientId);
  
  if (!visibility.isVisible) {
    return {
      sectionId,
      isVisible: false,
      content: '',
      metadata: { hiddenReasons: visibility.reasons }
    };
  }
  
  // Step 2: Get section configuration
  const { data: section } = await supabase
    .from('template_sections')
    .select(`
      *,
      content_config:section_content_configs(*)
    `)
    .eq('id', sectionId)
    .single();
  
  // Step 3: Render content based on type and configuration
  let renderedContent = '';
  
  switch (section.section_type) {
    case 'forms_pending':
      renderedContent = await renderFormsSection(clientId, section.content_config);
      break;
    case 'journey_progress':
      renderedContent = await renderJourneyProgressSection(clientId, section.content_config);
      break;
    case 'documents':
      renderedContent = await renderDocumentsSection(clientId, section.content_config);
      break;
    case 'venue_info':
      renderedContent = await renderVenueInfoSection(clientId, section.content_config);
      break;
    default:
      renderedContent = await renderGenericSection(section, clientId);
  }
  
  // Step 4: Apply styling configuration
  const styledContent = applyStyleConfiguration(
    renderedContent,
    section.styling_config,
    deviceType
  );
  
  // Step 5: Add interaction capabilities
  const interactiveContent = addInteractionCapabilities(
    styledContent,
    section.interaction_config
  );
  
  return {
    sectionId,
    isVisible: true,
    title: section.title,
    content: interactiveContent,
    order: section.position_order,
    isCollapsible: section.is_collapsible,
    metadata: {
      deviceOptimized: deviceType,
      visibilityReasons: visibility.reasons,
      lastUpdated: section.updated_at
    }
  };
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for React form builders, conditional rendering libraries
- [x] Filesystem: Access existing section components and dashboard logic
- [x] Memory: Store section configuration patterns and visibility rules

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/react/react", "conditional rendering", 2000);
await mcp__context7__get-library-docs("/date-fns/date-fns", "date calculations", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('SectionVisibilityEngine', () => {
  it('should show forms section only during planning phase', async () => {
    const client = createTestClient({ 
      weddingDate: '2025-06-15', // 6 months out
      packageType: 'standard'
    });
    
    const visibility = await evaluateSectionVisibility('forms-section', client.id);
    expect(visibility.isVisible).toBe(true);
    expect(visibility.reasons).toContain('Timeline: Visible from 180 days before to 30 days after wedding');
  });

  it('should hide premium sections for standard packages', async () => {
    const client = createTestClient({ packageType: 'standard' });
    const premiumSection = createTestSection({ 
      packageRestrictions: ['luxury', 'premium'] 
    });
    
    const visibility = await evaluateSectionVisibility(premiumSection.id, client.id);
    expect(visibility.isVisible).toBe(false);
    expect(visibility.reasons).toContain('Package: Only visible for packages: luxury, premium');
  });

  it('should require form completion before showing next sections', async () => {
    const client = createTestClient({
      forms: [
        { id: 'venue-form', status: 'completed' },
        { id: 'catering-form', status: 'pending' }
      ]
    });
    
    const section = createTestSection({
      formCompletionRequired: ['venue-form', 'catering-form']
    });
    
    const visibility = await evaluateSectionVisibility(section.id, client.id);
    expect(visibility.isVisible).toBe(false);
    expect(visibility.reasons).toContain('Missing 1 required form(s)');
  });

  it('should handle timeline calculations correctly', () => {
    const weddingDate = '2025-06-15';
    const currentDate = new Date('2025-03-15'); // 3 months before
    
    const visibility = evaluateTimelineRules([{
      show_from: 'wedding_date',
      show_from_days: -180, // 6 months before
      show_until_days: 30   // 1 month after
    }], weddingDate, currentDate);
    
    expect(visibility.visible).toBe(true);
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Section configuration and visibility testing', async () => {
  await mcp__playwright__browser_navigate({url: '/dashboard/templates/template-123/sections/forms-section'});
  
  // Configure section visibility rules
  await mcp__playwright__browser_click({element: 'visibility rules tab', ref: 'button[data-tab="visibility"]'});
  
  // Add timeline-based rule
  await mcp__playwright__browser_click({element: 'add rule button', ref: 'button[data-testid="add-visibility-rule"]'});
  await mcp__playwright__browser_select_option({
    element: 'condition type select',
    ref: 'select[name="conditionType"]',
    values: ['timeline_based']
  });
  
  // Configure timeline window
  await mcp__playwright__browser_type({
    element: 'show from days input',
    ref: 'input[name="showFromDays"]',
    text: '180'
  });
  
  await mcp__playwright__browser_select_option({
    element: 'anchor select',
    ref: 'select[name="timelineAnchor"]',
    values: ['wedding_date']
  });
  
  // Test visibility with preview
  await mcp__playwright__browser_click({element: 'test visibility button', ref: 'button[data-testid="test-visibility"]'});
  
  // Add test scenario
  await mcp__playwright__browser_type({
    element: 'scenario description',
    ref: 'input[name="scenarioDescription"]',
    text: '6 months before wedding'
  });
  
  await mcp__playwright__browser_type({
    element: 'timeline position',
    ref: 'input[name="timelinePosition"]',
    text: '6_months_before'
  });
  
  await mcp__playwright__browser_click({element: 'run test button', ref: 'button[data-testid="run-visibility-test"]'});
  
  // Verify test results
  await mcp__playwright__browser_wait_for({text: 'Test passed: Section visible'});
  
  // Save configuration
  await mcp__playwright__browser_click({element: 'save config button', ref: 'button[data-testid="save-section-config"]'});
  await mcp__playwright__browser_wait_for({text: 'Section configuration saved'});
  
  // Verify accessibility
  await mcp__playwright__browser_evaluate({
    function: '() => axe.run()'
  });
});
```

### ACCEPTANCE CRITERIA
- [x] Visual section configuration editor with real-time preview
- [x] Timeline-based visibility rules tied to wedding dates
- [x] Package and service level conditional visibility
- [x] Form completion dependency configuration
- [x] Device-specific section visibility (desktop/mobile)
- [x] Performance: Section visibility evaluation completes within 100ms
- [x] Security: Configuration changes restricted to authorized users
- [x] Accessibility: Configuration interface meets WCAG 2.1 AA standards

### DEPENDENCIES
- Must complete after: WS-065 (Dashboard Templates)
- Must complete before: WS-067 (Branding Customization)
- Shares code with: Template system, client dashboard rendering, form system

### ESTIMATED EFFORT
- Team A Frontend: 24 hours (Configuration editors, visibility builder, preview system)
- Team D Full-stack: 20 hours (Visibility engine, timeline calculations, configuration storage)
- Team B Backend: 12 hours (Database schema, API endpoints, analytics tracking)
- Total: 56 hours