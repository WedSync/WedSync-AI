# TECHNICAL SPECIFICATION: WS-161 - Supplier Schedules
## Generated by Feature Development Session - August 23, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding couple coordinating with multiple suppliers
**I want to:** Generate individual schedules for each supplier based on the master timeline
**So that:** Each vendor knows exactly when they need to arrive, set up, perform, and break down

**Real Wedding Scenario:**
A couple currently emails separate timeline PDFs to their photographer, DJ, florist, and caterer, leading to version control issues. With this feature, when they update the master timeline from "Ceremony 4:00pm" to "Ceremony 4:30pm", all supplier schedules automatically update showing "Photographer: Arrive 3:00pm for prep shots, Ceremony coverage 4:30-5:00pm" ensuring everyone has synchronized, current information.

### SPECIFICATION SOURCE
- **Feature ID:** WS-161
- **Original Spec:** /CORE-SPECIFICATIONS/03-WEDME-COUPLE-PLATFORM/07-Timeline-Builder/02-supplier-schedules md.md
- **Current Implementation:** 0% complete (new)
- **Files to Modify:** Extend WS-160 master timeline system
- **New Files to Create:** 
  - `/src/components/timeline/SupplierScheduleGenerator.tsx`
  - `/src/components/timeline/SupplierScheduleView.tsx` 
  - `/src/lib/services/supplierScheduleService.ts`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Extend timeline system with supplier-specific schedules
CREATE TABLE IF NOT EXISTS supplier_schedules (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  timeline_id UUID REFERENCES master_timelines(id) ON DELETE CASCADE,
  supplier_id UUID REFERENCES suppliers(id),
  couple_id UUID REFERENCES couples(id),
  schedule_version INTEGER DEFAULT 1,
  arrival_time TIME NOT NULL,
  departure_time TIME,
  setup_duration INTEGER DEFAULT 0, -- minutes before first event
  breakdown_duration INTEGER DEFAULT 0, -- minutes after last event
  special_notes TEXT,
  access_instructions TEXT, -- Venue access, parking, etc.
  emergency_contact VARCHAR(255),
  last_sent_at TIMESTAMPTZ,
  schedule_accepted BOOLEAN,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS supplier_schedule_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_schedule_id UUID REFERENCES supplier_schedules(id) ON DELETE CASCADE,
  timeline_event_id UUID REFERENCES timeline_events(id),
  supplier_role VARCHAR(100), -- 'photographer', 'dj', 'caterer', etc.
  event_priority VARCHAR(20) CHECK (event_priority IN ('critical', 'important', 'optional')),
  prep_time_minutes INTEGER DEFAULT 0,
  involvement_level VARCHAR(30) CHECK (involvement_level IN ('primary', 'secondary', 'standby')),
  special_requirements TEXT,
  equipment_needed TEXT[],
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Supplier schedule templates for common vendor types
CREATE TABLE IF NOT EXISTS supplier_schedule_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_type VARCHAR(50) NOT NULL, -- 'photographer', 'dj', 'florist'
  template_name VARCHAR(255),
  default_events JSONB, -- Standard events this supplier type covers
  setup_duration INTEGER DEFAULT 30,
  breakdown_duration INTEGER DEFAULT 30,
  buffer_time INTEGER DEFAULT 15, -- Extra time between events
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Insert common supplier schedule templates
INSERT INTO supplier_schedule_templates (supplier_type, template_name, default_events, setup_duration, breakdown_duration) VALUES
('photographer', 'Wedding Photography Standard', '[
  {"event_type": "prep", "involvement": "primary", "prep_time": 60},
  {"event_type": "ceremony", "involvement": "primary", "prep_time": 30},
  {"event_type": "cocktail", "involvement": "primary", "prep_time": 0},
  {"event_type": "reception", "involvement": "primary", "prep_time": 15}
]', 60, 30),
('dj', 'DJ/Entertainment Standard', '[
  {"event_type": "ceremony", "involvement": "primary", "prep_time": 45},
  {"event_type": "cocktail", "involvement": "primary", "prep_time": 0},
  {"event_type": "reception", "involvement": "primary", "prep_time": 15}
]', 90, 45),
('florist', 'Floral Decoration Standard', '[
  {"event_type": "ceremony", "involvement": "primary", "prep_time": 120},
  {"event_type": "reception", "involvement": "primary", "prep_time": 60}
]', 180, 60)
ON CONFLICT DO NOTHING;

-- Indexes for performance
CREATE INDEX idx_supplier_schedules_timeline_id ON supplier_schedules(timeline_id);
CREATE INDEX idx_supplier_schedules_supplier_id ON supplier_schedules(supplier_id);
CREATE INDEX idx_supplier_schedule_events_schedule_id ON supplier_schedule_events(supplier_schedule_id);
```

#### API Endpoints Required
```typescript
// POST /api/timeline/:timeline_id/supplier-schedules
interface GenerateSupplierSchedulesRequest {
  supplier_ids: string[];
  auto_assign_events: boolean;
  include_buffer_time: boolean;
}

interface GenerateSupplierSchedulesResponse {
  success: boolean;
  data: {
    schedules: SupplierSchedule[];
    conflicts: Array<{
      supplier_id: string;
      conflict_type: string;
      description: string;
    }>;
  };
}

// GET /api/supplier-schedules/:supplier_id
interface SupplierScheduleResponse {
  success: boolean;
  data: {
    schedule: SupplierSchedule;
    events: Array<{
      event: TimelineEvent;
      supplier_role: string;
      prep_time: number;
      requirements: string[];
    }>;
    timeline_view: Array<{
      time: string;
      activity: string;
      location: string;
      notes?: string;
    }>;
  };
}

// PUT /api/supplier-schedules/:id/send
interface SendScheduleRequest {
  message?: string;
  include_venue_info: boolean;
  include_emergency_contacts: boolean;
}

// POST /api/supplier-schedules/:id/accept
interface AcceptScheduleRequest {
  supplier_confirmation_code: string;
  notes?: string;
}
```

#### Integration Points
```typescript
// Service: SupplierScheduleService
// Dependencies: Timeline service, supplier service, notification service

class SupplierScheduleService {
  async generateScheduleForSupplier(timelineId: string, supplierId: string): Promise<SupplierSchedule> {
    const timeline = await this.getTimeline(timelineId);
    const supplier = await this.getSupplier(supplierId);
    const template = await this.getSupplierTemplate(supplier.type);
    
    // Get events relevant to this supplier
    const relevantEvents = await this.getRelevantEvents(timeline, supplier.type);
    
    // Calculate arrival/departure times
    const firstEvent = relevantEvents[0];
    const lastEvent = relevantEvents[relevantEvents.length - 1];
    
    const arrivalTime = this.subtractMinutes(
      firstEvent.start_time, 
      template.setup_duration + (firstEvent.prep_time || 0)
    );
    
    const departureTime = this.addMinutes(
      lastEvent.end_time,
      template.breakdown_duration
    );
    
    const schedule = await this.createSupplierSchedule({
      timeline_id: timelineId,
      supplier_id: supplierId,
      arrival_time: arrivalTime,
      departure_time: departureTime,
      setup_duration: template.setup_duration,
      breakdown_duration: template.breakdown_duration
    });
    
    // Create schedule events
    for (const event of relevantEvents) {
      await this.createScheduleEvent({
        supplier_schedule_id: schedule.id,
        timeline_event_id: event.id,
        supplier_role: this.getSupplierRole(supplier.type, event.category),
        event_priority: this.calculateEventPriority(supplier.type, event),
        prep_time_minutes: this.getRequiredPrepTime(supplier.type, event),
        involvement_level: this.getInvolvementLevel(supplier.type, event)
      });
    }
    
    return schedule;
  }
  
  async sendScheduleToSupplier(scheduleId: string, options: SendOptions): Promise<void> {
    const schedule = await this.getScheduleWithEvents(scheduleId);
    const supplier = await this.getSupplier(schedule.supplier_id);
    
    // Generate PDF schedule
    const scheduleData = {
      supplier_name: supplier.name,
      wedding_date: schedule.timeline.wedding_date,
      venue_info: options.include_venue_info ? await this.getVenueInfo(schedule.couple_id) : null,
      timeline_events: schedule.events.map(event => ({
        time: event.timeline_event.start_time,
        duration: event.timeline_event.duration,
        title: event.timeline_event.title,
        location: event.timeline_event.location,
        supplier_role: event.supplier_role,
        prep_time: event.prep_time_minutes,
        requirements: event.special_requirements
      })),
      arrival_time: schedule.arrival_time,
      departure_time: schedule.departure_time,
      special_notes: schedule.special_notes,
      access_instructions: schedule.access_instructions,
      emergency_contacts: options.include_emergency_contacts ? 
        await this.getEmergencyContacts(schedule.couple_id) : null
    };
    
    const pdfBuffer = await this.generateSchedulePDF(scheduleData);
    
    // Send email with PDF attachment
    await this.sendEmail({
      to: supplier.email,
      subject: `Your Wedding Schedule - ${scheduleData.wedding_date}`,
      template: 'supplier-schedule',
      attachments: [{
        filename: `${supplier.name}-Wedding-Schedule.pdf`,
        content: pdfBuffer
      }],
      data: {
        supplier_name: supplier.name,
        couple_names: await this.getCoupleNames(schedule.couple_id),
        wedding_date: scheduleData.wedding_date,
        arrival_time: schedule.arrival_time,
        message: options.message
      }
    });
    
    // Update last sent timestamp
    await supabase
      .from('supplier_schedules')
      .update({ 
        last_sent_at: new Date().toISOString(),
        schedule_version: schedule.schedule_version + 1 
      })
      .eq('id', scheduleId);
  }
  
  async updateSchedulesFromTimeline(timelineId: string): Promise<void> {
    // When master timeline changes, update all supplier schedules
    const schedules = await this.getSchedulesByTimeline(timelineId);
    
    for (const schedule of schedules) {
      // Regenerate schedule based on updated timeline
      const updatedSchedule = await this.generateScheduleForSupplier(
        timelineId, 
        schedule.supplier_id
      );
      
      // Notify supplier if there are significant changes
      const changes = this.compareSchedules(schedule, updatedSchedule);
      if (changes.length > 0) {
        await this.notifySupplierOfChanges(schedule.supplier_id, changes);
      }
    }
  }
}
```

### CODE EXAMPLES

#### Example 1: Supplier Schedule Generator Component
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
'use client';

import { useState, useEffect } from 'react';
import { supabase } from '@/lib/supabase';
import { SupplierSchedule, Supplier } from '@/types/suppliers';
import { MasterTimeline } from '@/types/timeline';
import { Button } from '@/components/ui/button';
import { Checkbox } from '@/components/ui/checkbox';
import { Textarea } from '@/components/ui/textarea';

export function SupplierScheduleGenerator({ 
  timeline, 
  onSchedulesGenerated 
}: {
  timeline: MasterTimeline;
  onSchedulesGenerated: (schedules: SupplierSchedule[]) => void;
}) {
  const [suppliers, setSuppliers] = useState<Supplier[]>([]);
  const [selectedSuppliers, setSelectedSuppliers] = useState<string[]>([]);
  const [existingSchedules, setExistingSchedules] = useState<SupplierSchedule[]>([]);
  const [generating, setGenerating] = useState(false);
  const [conflicts, setConflicts] = useState<any[]>([]);

  useEffect(() => {
    fetchSuppliers();
    fetchExistingSchedules();
  }, [timeline.id]);

  const fetchSuppliers = async () => {
    const { data, error } = await supabase
      .from('suppliers')
      .select('*')
      .eq('couple_id', timeline.couple_id)
      .eq('status', 'confirmed')
      .order('type, name');
    
    if (error) throw error;
    setSuppliers(data || []);
  };

  const fetchExistingSchedules = async () => {
    const { data, error } = await supabase
      .from('supplier_schedules')
      .select(`
        *,
        suppliers!inner(name, type, email)
      `)
      .eq('timeline_id', timeline.id);
    
    if (error) throw error;
    setExistingSchedules(data || []);
  };

  const generateSchedules = async () => {
    if (selectedSuppliers.length === 0) return;
    
    setGenerating(true);
    
    try {
      const { data, error } = await supabase
        .rpc('generate_supplier_schedules', {
          timeline_id_param: timeline.id,
          supplier_ids_param: selectedSuppliers,
          auto_assign_events_param: true,
          include_buffer_time_param: true
        });
      
      if (error) throw error;
      
      if (data.conflicts && data.conflicts.length > 0) {
        setConflicts(data.conflicts);
      }
      
      const newSchedules = data.schedules;
      setExistingSchedules([...existingSchedules, ...newSchedules]);
      onSchedulesGenerated(newSchedules);
      
      // Clear selection
      setSelectedSuppliers([]);
      
    } catch (error) {
      console.error('Error generating schedules:', error);
    } finally {
      setGenerating(false);
    }
  };

  const sendScheduleToSupplier = async (scheduleId: string, supplierEmail: string) => {
    try {
      const response = await fetch(`/api/supplier-schedules/${scheduleId}/send`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          include_venue_info: true,
          include_emergency_contacts: true,
          message: `Please review your wedding schedule and confirm your availability.`
        })
      });
      
      if (response.ok) {
        // Update UI to show schedule was sent
        const updatedSchedules = existingSchedules.map(schedule => 
          schedule.id === scheduleId 
            ? { ...schedule, last_sent_at: new Date().toISOString() }
            : schedule
        );
        setExistingSchedules(updatedSchedules);
      }
    } catch (error) {
      console.error('Error sending schedule:', error);
    }
  };

  const regenerateSchedule = async (scheduleId: string, supplierId: string) => {
    try {
      // Delete existing schedule
      await supabase
        .from('supplier_schedules')
        .delete()
        .eq('id', scheduleId);
      
      // Generate new schedule
      await generateSchedules();
      
    } catch (error) {
      console.error('Error regenerating schedule:', error);
    }
  };

  const suppliersWithoutSchedules = suppliers.filter(supplier => 
    !existingSchedules.some(schedule => schedule.supplier_id === supplier.id)
  );

  const getSupplierIcon = (type: string) => {
    const icons = {
      photographer: '📸',
      dj: '🎵',
      florist: '🌸',
      caterer: '🍽️',
      videographer: '🎥',
      officiant: '👨‍💼',
      venue: '🏛️'
    };
    return icons[type as keyof typeof icons] || '📋';
  };

  return (
    <div className="supplier-schedule-generator space-y-6">
      {/* Header */}
      <div className="generator-header">
        <h2 className="text-xl font-semibold mb-2">Supplier Schedule Generator</h2>
        <p className="text-gray-600">
          Create individual schedules for your wedding suppliers based on your master timeline.
        </p>
      </div>

      {/* Existing Schedules */}
      {existingSchedules.length > 0 && (
        <div className="existing-schedules">
          <h3 className="font-semibold mb-3">Generated Schedules ({existingSchedules.length})</h3>
          <div className="space-y-3">
            {existingSchedules.map(schedule => (
              <div key={schedule.id} className="schedule-card bg-white border rounded-lg p-4">
                <div className="flex justify-between items-start">
                  <div className="flex items-center space-x-3">
                    <span className="text-2xl">
                      {getSupplierIcon(schedule.suppliers.type)}
                    </span>
                    <div>
                      <div className="font-medium">{schedule.suppliers.name}</div>
                      <div className="text-sm text-gray-600 capitalize">
                        {schedule.suppliers.type}
                      </div>
                      <div className="text-sm text-gray-500">
                        Arrive: {schedule.arrival_time}
                        {schedule.departure_time && ` • Depart: ${schedule.departure_time}`}
                      </div>
                    </div>
                  </div>
                  
                  <div className="flex items-center space-x-2">
                    {schedule.last_sent_at && (
                      <div className="text-xs text-green-600">
                        Sent {new Date(schedule.last_sent_at).toLocaleDateString()}
                      </div>
                    )}
                    
                    {schedule.schedule_accepted && (
                      <div className="bg-green-100 text-green-800 text-xs px-2 py-1 rounded">
                        ✓ Confirmed
                      </div>
                    )}
                    
                    <Button
                      size="sm"
                      variant="outline"
                      onClick={() => sendScheduleToSupplier(schedule.id, schedule.suppliers.email)}
                    >
                      {schedule.last_sent_at ? 'Resend' : 'Send'}
                    </Button>
                    
                    <Button
                      size="sm"
                      variant="ghost"
                      onClick={() => regenerateSchedule(schedule.id, schedule.supplier_id)}
                    >
                      Regenerate
                    </Button>
                  </div>
                </div>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Generate New Schedules */}
      {suppliersWithoutSchedules.length > 0 && (
        <div className="generate-new">
          <h3 className="font-semibold mb-3">Generate Schedules</h3>
          
          <div className="suppliers-selection mb-4">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
              {suppliersWithoutSchedules.map(supplier => (
                <div key={supplier.id} className="supplier-option">
                  <label className="flex items-center space-x-3 p-3 border rounded hover:bg-gray-50 cursor-pointer">
                    <Checkbox
                      checked={selectedSuppliers.includes(supplier.id)}
                      onCheckedChange={(checked) => {
                        if (checked) {
                          setSelectedSuppliers([...selectedSuppliers, supplier.id]);
                        } else {
                          setSelectedSuppliers(selectedSuppliers.filter(id => id !== supplier.id));
                        }
                      }}
                    />
                    <span className="text-xl">
                      {getSupplierIcon(supplier.type)}
                    </span>
                    <div className="flex-1">
                      <div className="font-medium">{supplier.name}</div>
                      <div className="text-sm text-gray-600 capitalize">
                        {supplier.type}
                      </div>
                    </div>
                  </label>
                </div>
              ))}
            </div>
          </div>
          
          <Button
            onClick={generateSchedules}
            disabled={selectedSuppliers.length === 0 || generating}
            className="w-full"
          >
            {generating ? 'Generating Schedules...' : `Generate Schedules for ${selectedSuppliers.length} Supplier${selectedSuppliers.length !== 1 ? 's' : ''}`}
          </Button>
        </div>
      )}

      {/* Conflicts */}
      {conflicts.length > 0 && (
        <div className="conflicts-section bg-yellow-50 border border-yellow-200 rounded-lg p-4">
          <h4 className="font-medium text-yellow-800 mb-3">⚠️ Schedule Conflicts Detected</h4>
          <div className="space-y-2">
            {conflicts.map((conflict, index) => (
              <div key={index} className="text-sm text-yellow-700">
                <strong>{conflict.supplier_name}:</strong> {conflict.description}
              </div>
            ))}
          </div>
          <p className="text-xs text-yellow-600 mt-3">
            Review and adjust timeline or supplier assignments to resolve conflicts.
          </p>
        </div>
      )}

      {/* No Suppliers Message */}
      {suppliers.length === 0 && (
        <div className="no-suppliers text-center py-8 text-gray-500">
          <p>No confirmed suppliers found. Add suppliers to your wedding first.</p>
        </div>
      )}

      {suppliersWithoutSchedules.length === 0 && existingSchedules.length > 0 && (
        <div className="all-complete text-center py-4 text-green-600">
          <p>✓ All suppliers have generated schedules</p>
        </div>
      )}
    </div>
  );
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for PDF generation, email templates
- [x] Playwright: Test supplier schedule workflows
- [x] Filesystem: Access schedule components

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/jspdf/jspdf", "pdf generation", 2000);
await mcp__context7__get-library-docs("/nodemailer/nodemailer", "email attachments", 1500);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('SupplierScheduleService', () => {
  it('should generate schedule with correct timing', async () => {
    const schedule = await service.generateScheduleForSupplier('timeline-id', 'photographer-id');
    expect(schedule.arrival_time).toBe('14:00'); // 2 hours before ceremony
    expect(schedule.departure_time).toBe('23:00'); // After reception ends
  });

  it('should update schedules when timeline changes', async () => {
    await service.updateSchedulesFromTimeline('timeline-id');
    // Verify notifications sent for changes
  });
});
```

#### E2E Tests Required
```typescript
test('Supplier schedule generation', async () => {
  await mcp__playwright__browser_navigate({url: '/timeline'});
  
  // Generate supplier schedules
  await mcp__playwright__browser_click({
    element: 'Generate Supplier Schedules button',
    ref: 'button[data-testid="generate-schedules"]'
  });
  
  // Select suppliers
  await mcp__playwright__browser_click({
    element: 'Photographer checkbox',
    ref: 'input[name="supplier-photographer"]'
  });
  
  // Send schedule
  await mcp__playwright__browser_click({
    element: 'Send Schedule button',
    ref: 'button[data-testid="send-schedule"]'
  });
  
  await mcp__playwright__browser_snapshot();
});
```

### ACCEPTANCE CRITERIA
- [x] Generate individual schedules for each supplier from master timeline
- [x] Auto-calculate arrival/departure times based on supplier type and events
- [x] PDF schedule generation with venue information and contact details
- [x] Email delivery system with schedule attachments
- [x] Schedule versioning and change notifications
- [x] Supplier confirmation system for schedule acceptance
- [x] Conflict detection for overlapping supplier requirements
- [x] Integration with master timeline updates
- [x] Performance: Schedule generation <3s, PDF creation <2s
- [x] Security: All schedules scoped to couple_id with RLS policies
- [x] Accessibility: Screen reader support for schedule status

### DEPENDENCIES
- Must complete after: WS-160 (Master Timeline)
- Must complete before: None
- Shares code with: Timeline management and supplier coordination

### ESTIMATED EFFORT
- Team A Frontend: 20 hours
- Team B Backend: 24 hours
- Team C Integration: 16 hours
- Total: 60 hours