# TECHNICAL SPECIFICATION: WS-102 - Admin Quick Actions
## Generated by Feature Development Session - August 22, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** WedSync support admin helping a photographer during a wedding emergency
**I want to:** Quickly reset their password, clear their cache, and impersonate their account in under 30 seconds
**So that:** They regain access to critical timeline updates before missing key wedding moments

**Real Wedding Scenario:**
A photographer calls at 1:45 PM - the ceremony starts at 2:00 PM. They can't log in to access the venue's timeline updates after the couple changed the processional order. Without quick actions, an admin would need to navigate through multiple screens, taking 3-5 minutes. With quick actions, the admin types the photographer's email, clicks "Reset Password" and "Clear User Cache," and confirms account access in 25 seconds. The photographer receives timeline updates and captures the processional correctly.

### SPECIFICATION SOURCE
- **Feature ID:** WS-102
- **Original Spec:** /CORE-SPECIFICATIONS/07-ADMIN-DASHBOARD/01-Overview/04-quick-actions md.md
- **Current Implementation:** 0% complete
- **Files to Modify:**
  - `/wedsync/app/api/admin/actions/route.ts` (create new)
  - `/wedsync/lib/admin/quick-actions.ts` (create new)
- **New Files to Create:**
  - `/wedsync/src/components/admin/QuickActionsPanel.tsx`
  - `/wedsync/src/components/admin/ActionButton.tsx`
  - `/wedsync/src/components/admin/BulkOperations.tsx`
  - `/wedsync/src/components/admin/EmergencyActions.tsx`
  - `/wedsync/src/hooks/useAdminAuth.ts`
  - `/wedsync/lib/admin/audit-logger.ts`
  - `/wedsync/supabase/migrations/20250822000005_admin_actions_log.sql`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Admin actions audit log
CREATE TABLE IF NOT EXISTS admin_actions_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  admin_id UUID NOT NULL REFERENCES auth.users(id),
  action_type VARCHAR(100) NOT NULL,
  action_category VARCHAR(50) CHECK (action_category IN ('user', 'system', 'financial', 'support', 'data', 'emergency')),
  target_type VARCHAR(50), -- 'user', 'supplier', 'client', 'system'
  target_id VARCHAR(255),
  parameters JSONB DEFAULT '{}',
  result JSONB DEFAULT '{}',
  success BOOLEAN DEFAULT true,
  error_message TEXT,
  ip_address INET,
  user_agent TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_admin_actions_admin_time ON admin_actions_log(admin_id, created_at DESC);
CREATE INDEX idx_admin_actions_type ON admin_actions_log(action_type, created_at DESC);
CREATE INDEX idx_admin_actions_target ON admin_actions_log(target_type, target_id);

-- Quick action templates for reusable actions
CREATE TABLE IF NOT EXISTS quick_action_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255) NOT NULL,
  category VARCHAR(50) NOT NULL,
  action_type VARCHAR(100) NOT NULL,
  parameters JSONB DEFAULT '{}',
  permissions TEXT[] DEFAULT '{}',
  keyboard_shortcut VARCHAR(50),
  is_emergency BOOLEAN DEFAULT false,
  requires_confirmation BOOLEAN DEFAULT true,
  created_by UUID REFERENCES auth.users(id),
  is_public BOOLEAN DEFAULT false,
  usage_count INTEGER DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Bulk operation queue for background processing
CREATE TABLE IF NOT EXISTS bulk_operations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  admin_id UUID NOT NULL REFERENCES auth.users(id),
  operation_type VARCHAR(100) NOT NULL,
  target_count INTEGER NOT NULL,
  processed_count INTEGER DEFAULT 0,
  success_count INTEGER DEFAULT 0,
  error_count INTEGER DEFAULT 0,
  status VARCHAR(20) DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
  parameters JSONB DEFAULT '{}',
  results JSONB DEFAULT '{}',
  started_at TIMESTAMP WITH TIME ZONE,
  completed_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Rate limiting for admin actions
CREATE TABLE IF NOT EXISTS admin_action_rate_limits (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  admin_id UUID NOT NULL REFERENCES auth.users(id),
  action_type VARCHAR(100) NOT NULL,
  action_count INTEGER DEFAULT 1,
  window_start TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(admin_id, action_type, window_start)
);
```

#### API Endpoints Required
```typescript
// POST /api/admin/actions/execute
interface ExecuteActionRequest {
  actionType: string;
  category: string;
  parameters: Record<string, any>;
  targetId?: string;
  targetType?: string;
  confirmation?: string; // Required for critical actions
}

interface ExecuteActionResponse {
  success: boolean;
  result?: any;
  message: string;
  actionId: string;
  canUndo?: boolean;
  undoActionType?: string;
}

// POST /api/admin/actions/bulk
interface BulkActionRequest {
  operationType: string;
  targetIds: string[];
  parameters: Record<string, any>;
}

interface BulkActionResponse {
  success: boolean;
  operationId: string;
  estimatedDuration: number; // seconds
  targetCount: number;
}

// GET /api/admin/actions/history
interface ActionHistoryResponse {
  actions: Array<{
    id: string;
    actionType: string;
    category: string;
    targetType: string;
    targetId: string;
    success: boolean;
    createdAt: string;
    canUndo: boolean;
  }>;
  pagination: {
    page: number;
    limit: number;
    total: number;
  };
}

// POST /api/admin/actions/undo/:actionId
interface UndoActionResponse {
  success: boolean;
  message: string;
  originalActionId: string;
}

// GET /api/admin/actions/templates
interface ActionTemplatesResponse {
  templates: QuickActionTemplate[];
  categories: string[];
}
```

#### Frontend Components Required
```typescript
// Component: QuickActionsPanel
// Location: /src/components/admin/QuickActionsPanel.tsx

interface Props {
  defaultCategory?: string;
  showSearch?: boolean;
  maxRecent?: number;
}

// Key functionality:
- Command palette style search interface
- Keyboard shortcuts for power users
- Permission-based action filtering
- Recent actions history display
- Rate limiting feedback

// Component: ActionButton
// Location: /src/components/admin/ActionButton.tsx

interface Props {
  action: QuickAction;
  onClick: () => void;
  disabled?: boolean;
  showShortcut?: boolean;
  size?: 'sm' | 'md' | 'lg';
}

// Key functionality:
- Icon and label display
- Keyboard shortcut indicators
- Permission state handling
- Loading states during execution
- Danger styling for emergency actions

// Component: BulkOperations
// Location: /src/components/admin/BulkOperations.tsx

interface Props {
  availableOperations: BulkOperation[];
  onExecute: (operation: string, targets: string[], params: any) => void;
  maxBatchSize?: number;
}

// Key functionality:
- Multi-select target management
- Batch size validation and warnings
- Progress tracking for long operations
- Rollback capability for failed operations
- Export results and error reports

// Component: EmergencyActions
// Location: /src/components/admin/EmergencyActions.tsx

interface Props {
  actions: EmergencyAction[];
  onExecute: (action: EmergencyAction) => void;
}

// Key functionality:
- High-contrast danger styling
- Mandatory confirmation dialogs
- Typed confirmation requirements
- Automatic audit logging
- Cooldown periods between emergency actions
```

#### Integration Points
```typescript
// Service: QuickActionsService
// Dependencies: Supabase, rate limiter, audit logger

class QuickActionsService {
  async executeAction(
    adminId: string,
    actionType: string,
    parameters: Record<string, any>
  ): Promise<ActionResult> {
    // 1. Check rate limits
    await this.checkRateLimit(adminId, actionType);
    
    // 2. Verify permissions
    await this.verifyPermissions(adminId, actionType);
    
    // 3. Execute action with transaction
    const result = await this.executeWithAudit(adminId, actionType, parameters);
    
    // 4. Log result and update metrics
    await this.logActionResult(adminId, actionType, result);
    
    return result;
  }
  
  async executeBulkOperation(
    adminId: string,
    operationType: string,
    targetIds: string[],
    parameters: Record<string, any>
  ): Promise<string> {
    // Create bulk operation record
    // Queue background job for processing
    // Return operation ID for tracking
  }
}

// Service: AuditLogger
// Dependencies: Database, security monitoring

class AuditLogger {
  async logAdminAction(
    adminId: string,
    actionType: string,
    category: string,
    targetType: string,
    targetId: string,
    parameters: Record<string, any>,
    result: any,
    success: boolean,
    ipAddress?: string,
    userAgent?: string
  ): Promise<void> {
    // Store detailed audit trail
    // Calculate action impact metrics
    // Trigger security monitoring if needed
  }
  
  async getActionHistory(
    adminId?: string,
    actionType?: string,
    limit: number = 50
  ): Promise<AdminAction[]> {
    // Retrieve filtered action history
    // Include undo capability information
    // Respect data retention policies
  }
}

// Hook: useAdminAuth
export function useAdminAuth() {
  // Admin role and permission checking
  // Rate limit status tracking
  // Action execution state management
  // Keyboard shortcut handling
}

// Hook: useQuickActions
export function useQuickActions() {
  // Available actions based on permissions
  // Recent actions history
  // Bulk operation progress tracking
  // Real-time execution feedback
}
```

### CODE EXAMPLES

#### Example 1: Quick Actions Service Implementation
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { createClient } from '@supabase/supabase-js';

interface QuickAction {
  id: string;
  category: 'user' | 'system' | 'financial' | 'support' | 'emergency';
  label: string;
  actionType: string;
  permissions: string[];
  requiresConfirmation: boolean;
  keyboardShortcut?: string;
}

export class QuickActionsService {
  private supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_KEY!
  );
  
  private actions: QuickAction[] = [
    {
      id: 'reset_password',
      category: 'user',
      label: 'Reset User Password',
      actionType: 'auth.reset_password',
      permissions: ['user_management'],
      requiresConfirmation: false,
      keyboardShortcut: 'cmd+r'
    },
    {
      id: 'clear_user_cache',
      category: 'system',
      label: 'Clear User Cache',
      actionType: 'cache.clear_user',
      permissions: ['system_admin'],
      requiresConfirmation: false
    },
    {
      id: 'impersonate_user',
      category: 'user',
      label: 'Impersonate User',
      actionType: 'auth.impersonate',
      permissions: ['super_admin'],
      requiresConfirmation: true,
      keyboardShortcut: 'cmd+shift+i'
    },
    {
      id: 'emergency_maintenance',
      category: 'emergency',
      label: 'Enable Maintenance Mode',
      actionType: 'system.maintenance_mode',
      permissions: ['super_admin'],
      requiresConfirmation: true
    }
  ];
  
  async executeAction(
    adminId: string,
    actionType: string,
    parameters: Record<string, any>,
    ipAddress?: string,
    userAgent?: string
  ): Promise<{ success: boolean; result?: any; message: string; actionId: string }> {
    const startTime = Date.now();
    let actionLogId: string;
    
    try {
      // Find action definition
      const action = this.actions.find(a => a.actionType === actionType);
      if (!action) {
        throw new Error(`Unknown action type: ${actionType}`);
      }
      
      // Check rate limits
      await this.checkRateLimit(adminId, actionType);
      
      // Verify admin permissions
      await this.verifyPermissions(adminId, action.permissions);
      
      // Create audit log entry
      const { data: auditLog } = await this.supabase
        .from('admin_actions_log')
        .insert({
          admin_id: adminId,
          action_type: actionType,
          action_category: action.category,
          target_type: parameters.targetType,
          target_id: parameters.targetId,
          parameters,
          ip_address: ipAddress,
          user_agent: userAgent
        })
        .select()
        .single();
      
      actionLogId = auditLog.id;
      
      // Execute the actual action
      const result = await this.executeActionByType(actionType, parameters);
      
      // Update audit log with success
      await this.supabase
        .from('admin_actions_log')
        .update({
          result,
          success: true
        })
        .eq('id', actionLogId);
      
      return {
        success: true,
        result,
        message: `${action.label} completed successfully`,
        actionId: actionLogId
      };
      
    } catch (error) {
      // Update audit log with error
      if (actionLogId!) {
        await this.supabase
          .from('admin_actions_log')
          .update({
            success: false,
            error_message: error.message
          })
          .eq('id', actionLogId);
      }
      
      return {
        success: false,
        message: `Action failed: ${error.message}`,
        actionId: actionLogId!
      };
    }
  }
  
  private async executeActionByType(actionType: string, parameters: any) {
    switch (actionType) {
      case 'auth.reset_password':
        return await this.resetUserPassword(parameters.email);
        
      case 'cache.clear_user':
        return await this.clearUserCache(parameters.userId);
        
      case 'auth.impersonate':
        return await this.impersonateUser(parameters.userId);
        
      case 'system.maintenance_mode':
        return await this.toggleMaintenanceMode(parameters.enabled);
        
      default:
        throw new Error(`Action handler not implemented: ${actionType}`);
    }
  }
  
  private async resetUserPassword(email: string) {
    const { data, error } = await this.supabase.auth.admin.generateLink({
      type: 'recovery',
      email
    });
    
    if (error) throw error;
    
    // Send password reset email (implementation depends on email service)
    await this.sendPasswordResetEmail(email, data.properties.action_link);
    
    return { email, linkSent: true };
  }
  
  private async clearUserCache(userId: string) {
    // Clear Redis cache for specific user
    const redis = new Redis({
      url: process.env.UPSTASH_REDIS_URL!,
      token: process.env.UPSTASH_REDIS_TOKEN!
    });
    
    const keys = await redis.keys(`user:${userId}:*`);
    if (keys.length > 0) {
      await redis.del(...keys);
    }
    
    return { userId, keysCleared: keys.length };
  }
  
  private async impersonateUser(userId: string) {
    // Create impersonation session token
    const { data, error } = await this.supabase.auth.admin.createUser({
      user_id: userId,
      email_confirm: true
    });
    
    if (error) throw error;
    
    // Log impersonation for security
    await this.supabase
      .from('admin_actions_log')
      .insert({
        action_type: 'impersonation_started',
        target_id: userId,
        parameters: { impersonated_at: new Date().toISOString() }
      });
    
    return { userId, sessionCreated: true };
  }
  
  private async checkRateLimit(adminId: string, actionType: string) {
    const windowMinutes = 1;
    const maxActions = 10;
    
    const windowStart = new Date();
    windowStart.setMinutes(windowStart.getMinutes() - windowMinutes);
    
    const { count } = await this.supabase
      .from('admin_actions_log')
      .select('id', { count: 'exact' })
      .eq('admin_id', adminId)
      .eq('action_type', actionType)
      .gte('created_at', windowStart.toISOString());
    
    if (count && count >= maxActions) {
      throw new Error(`Rate limit exceeded: max ${maxActions} actions per ${windowMinutes} minute(s)`);
    }
  }
  
  private async verifyPermissions(adminId: string, requiredPermissions: string[]) {
    // In a real implementation, this would check admin role permissions
    // For now, assume all admins have basic permissions
    const { data: admin } = await this.supabase
      .from('admin_users')
      .select('permissions')
      .eq('id', adminId)
      .single();
    
    if (!admin) {
      throw new Error('Admin user not found');
    }
    
    const hasPermission = requiredPermissions.some(perm => 
      admin.permissions?.includes(perm) || admin.permissions?.includes('super_admin')
    );
    
    if (!hasPermission) {
      throw new Error('Insufficient permissions for this action');
    }
  }
}
```

#### Example 2: Quick Actions Panel Component
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Badge } from '@/components/ui/badge';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';

interface QuickAction {
  id: string;
  category: string;
  label: string;
  icon: string;
  keyboardShortcut?: string;
  requiresConfirmation: boolean;
}

export function QuickActionsPanel() {
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedAction, setSelectedAction] = useState<QuickAction | null>(null);
  const [recentActions, setRecentActions] = useState<any[]>([]);
  const [loading, setLoading] = useState(false);
  
  const quickActions: QuickAction[] = [
    {
      id: 'reset_password',
      category: 'user',
      label: 'Reset User Password',
      icon: 'üîë',
      keyboardShortcut: 'Cmd+R',
      requiresConfirmation: false
    },
    {
      id: 'clear_cache',
      category: 'system',
      label: 'Clear User Cache',
      icon: 'üóëÔ∏è',
      requiresConfirmation: false
    },
    {
      id: 'impersonate',
      category: 'user',
      label: 'Impersonate User',
      icon: 'üë§',
      keyboardShortcut: 'Cmd+Shift+I',
      requiresConfirmation: true
    },
    {
      id: 'maintenance',
      category: 'emergency',
      label: 'Maintenance Mode',
      icon: '‚ö†Ô∏è',
      requiresConfirmation: true
    }
  ];
  
  // Filter actions based on search
  const filteredActions = quickActions.filter(action =>
    action.label.toLowerCase().includes(searchQuery.toLowerCase())
  );
  
  // Group actions by category
  const groupedActions = filteredActions.reduce((groups, action) => {
    const category = action.category;
    if (!groups[category]) {
      groups[category] = [];
    }
    groups[category].push(action);
    return groups;
  }, {} as Record<string, QuickAction[]>);
  
  const executeAction = async (action: QuickAction) => {
    if (action.requiresConfirmation) {
      setSelectedAction(action);
      return;
    }
    
    await performAction(action);
  };
  
  const performAction = async (action: QuickAction, params?: any) => {
    setLoading(true);
    try {
      const response = await fetch('/api/admin/actions/execute', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          actionType: action.id,
          category: action.category,
          parameters: params || {}
        })
      });
      
      const result = await response.json();
      
      if (result.success) {
        // Add to recent actions
        setRecentActions(prev => [
          { ...action, executedAt: new Date(), result: result.message },
          ...prev.slice(0, 9) // Keep last 10 actions
        ]);
        
        // Show success toast
        alert(`‚úÖ ${result.message}`);
      } else {
        alert(`‚ùå ${result.message}`);
      }
    } catch (error) {
      alert(`‚ùå Action failed: ${error.message}`);
    } finally {
      setLoading(false);
      setSelectedAction(null);
    }
  };
  
  const getCategoryColor = (category: string) => {
    switch (category) {
      case 'emergency': return 'bg-red-500';
      case 'system': return 'bg-blue-500';
      case 'user': return 'bg-green-500';
      case 'financial': return 'bg-yellow-500';
      default: return 'bg-gray-500';
    }
  };
  
  // Keyboard shortcut handling
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === '/' && !searchQuery) {
        event.preventDefault();
        // Focus search input
        document.getElementById('action-search')?.focus();
      }
      
      // Handle action shortcuts
      const shortcutPressed = event.metaKey || event.ctrlKey;
      if (shortcutPressed) {
        const action = quickActions.find(a => 
          a.keyboardShortcut === `${event.metaKey ? 'Cmd' : 'Ctrl'}+${event.key.toUpperCase()}`
        );
        
        if (action) {
          event.preventDefault();
          executeAction(action);
        }
      }
    };
    
    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [searchQuery]);
  
  return (
    <div className="space-y-6 p-6">
      {/* Search Bar */}
      <div className="relative">
        <Input
          id="action-search"
          type="text"
          placeholder="Search actions or press '/' to focus"
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
          className="w-full"
        />
        <div className="absolute right-3 top-2.5 text-sm text-muted-foreground">
          Press / to search
        </div>
      </div>
      
      {/* Recent Actions */}
      {recentActions.length > 0 && (
        <Card>
          <CardHeader>
            <CardTitle className="text-sm">Recent Actions</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="space-y-2">
              {recentActions.slice(0, 5).map((action, index) => (
                <div key={index} className="flex items-center justify-between text-sm">
                  <span>{action.label}</span>
                  <span className="text-muted-foreground">
                    {action.executedAt.toLocaleTimeString()}
                  </span>
                </div>
              ))}
            </div>
          </CardContent>
        </Card>
      )}
      
      {/* Action Categories */}
      {Object.entries(groupedActions).map(([category, actions]) => (
        <Card key={category}>
          <CardHeader>
            <CardTitle className="flex items-center gap-2 capitalize">
              {category}
              <Badge className={getCategoryColor(category)}>
                {actions.length}
              </Badge>
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
              {actions.map(action => (
                <Button
                  key={action.id}
                  variant={action.category === 'emergency' ? 'destructive' : 'outline'}
                  className="h-auto p-4 flex flex-col items-start text-left"
                  onClick={() => executeAction(action)}
                  disabled={loading}
                >
                  <div className="flex items-center gap-2 w-full">
                    <span className="text-lg">{action.icon}</span>
                    <span className="font-medium">{action.label}</span>
                  </div>
                  {action.keyboardShortcut && (
                    <span className="text-xs text-muted-foreground mt-1">
                      {action.keyboardShortcut}
                    </span>
                  )}
                </Button>
              ))}
            </div>
          </CardContent>
        </Card>
      ))}
      
      {/* Confirmation Modal */}
      {selectedAction && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <Card className="w-full max-w-md">
            <CardHeader>
              <CardTitle className="text-red-600">Confirm Action</CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <p>Are you sure you want to execute:</p>
              <p className="font-bold">{selectedAction.label}</p>
              
              {selectedAction.category === 'emergency' && (
                <div className="p-3 bg-red-50 border border-red-200 rounded">
                  <p className="text-sm text-red-700">
                    ‚ö†Ô∏è This is an emergency action that will be logged and may affect system availability.
                  </p>
                </div>
              )}
              
              <div className="flex space-x-2">
                <Button
                  variant="destructive"
                  onClick={() => performAction(selectedAction)}
                  disabled={loading}
                >
                  {loading ? 'Executing...' : 'Confirm'}
                </Button>
                <Button
                  variant="outline"
                  onClick={() => setSelectedAction(null)}
                  disabled={loading}
                >
                  Cancel
                </Button>
              </div>
            </CardContent>
          </Card>
        </div>
      )}
      
      {filteredActions.length === 0 && searchQuery && (
        <div className="text-center py-8 text-muted-foreground">
          No actions found for "{searchQuery}"
        </div>
      )}
    </div>
  );
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [ ] Context7: Load docs for admin interfaces, command palettes
- [ ] PostgreSQL: Create audit logging tables
- [ ] Filesystem: Create admin components

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/headlessui/headlessui", "command palette", 1500);
await mcp__context7__get-library-docs("/upstash/upstash-redis", "rate limiting", 1000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('Admin Quick Actions', () => {
  it('should execute actions with proper audit logging', () => {
    // Test action execution and audit trail creation
  });
  
  it('should enforce rate limits correctly', () => {
    // Test rate limiting prevents action spam
  });
  
  it('should verify permissions before execution', () => {
    // Test permission checking for different admin levels
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Admin can execute quick actions via keyboard shortcuts', async () => {
  await mcp__playwright__browser_navigate({url: '/admin/actions'});
  await mcp__playwright__browser_press_key({key: 'cmd+r'});
  // Verify password reset action is triggered
});
```

### ACCEPTANCE CRITERIA
- [ ] Actions execute within 2 seconds for single operations
- [ ] All actions create detailed audit logs with IP and user agent
- [ ] Rate limiting prevents more than 10 actions per minute per admin
- [ ] Keyboard shortcuts work for power user efficiency
- [ ] Emergency actions require explicit confirmation with typed text
- [ ] Performance: Quick actions panel loads under 1 second
- [ ] Security: All actions verify admin permissions before execution
- [ ] Accessibility: Keyboard navigation and screen reader support

### DEPENDENCIES
- Must complete after: Admin authentication, role-based permissions
- Must complete before: Admin training and documentation
- Shares code with: WS-101 (Alert System), audit logging system

### ESTIMATED EFFORT
- Team A Frontend: 18 hours (quick actions UI, keyboard shortcuts, bulk operations interface)
- Team B Backend: 16 hours (actions service, audit logging, rate limiting, permission system)
- Team C Integration: 6 hours (external service actions, email integration)
- Total: 40 hours