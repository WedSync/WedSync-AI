# TECHNICAL SPECIFICATION: WS-065 - Dashboard Templates
## Generated by Feature Development Session - August 21, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding venue manager
**I want to:** Create different client dashboard templates for luxury vs. standard packages and specific venue locations
**So that:** I can automatically provide the right level of information and branding without manually customizing each client's experience (saving 45+ minutes per client setup)

**Real Wedding Scenario:**
A venue has three locations (The Barn, Garden Estate, Historic Mansion) and two package tiers (Standard, Luxury). Currently, they manually configure each client's dashboard with location-specific maps, parking instructions, preferred vendor lists, and package-appropriate features. With templates, luxury clients automatically get premium content sections, exclusive vendor access, and enhanced branding, while Barn clients see rustic theming and barn-specific logistics. Setup time drops from 45 minutes to 2 minutes per client.

### SPECIFICATION SOURCE
- **Feature ID:** WS-065
- **Original Spec:** /CORE-SPECIFICATIONS/02-WEDSYNC-SUPPLIER-PLATFORM/07-Client-Dashboard-Builder/01-dashboard-templates md.md
- **Current Implementation:** 0% complete
- **Files to Modify:** 
  - `/wedsync/src/app/(dashboard)/clients/[id]/page.tsx`
- **New Files to Create:** 
  - `/wedsync/src/components/dashboard-builder/TemplateBuilder.tsx`
  - `/wedsync/src/components/dashboard-builder/TemplateLibrary.tsx`
  - `/wedsync/src/components/dashboard-builder/SectionPalette.tsx`
  - `/wedsync/src/components/dashboard-builder/TemplatePreview.tsx`
  - `/wedsync/src/app/api/dashboard-templates/route.ts`
  - `/wedsync/src/app/api/dashboard-templates/[id]/assign/route.ts`
  - `/wedsync/src/types/dashboard-templates.ts`
  - `/wedsync/supabase/migrations/028_dashboard_templates_system.sql`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Dashboard templates for different client types
CREATE TABLE IF NOT EXISTS dashboard_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  name VARCHAR(255) NOT NULL,
  description TEXT,
  category template_category NOT NULL DEFAULT 'custom',
  layout_type dashboard_layout NOT NULL DEFAULT 'sidebar',
  is_default BOOLEAN DEFAULT false,
  is_active BOOLEAN DEFAULT true,
  branding_config JSONB DEFAULT '{}'::jsonb,
  visibility_rules JSONB DEFAULT '{}'::jsonb, -- Assignment conditions
  version INTEGER DEFAULT 1,
  parent_template_id UUID REFERENCES dashboard_templates(id) ON DELETE SET NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TYPE template_category AS ENUM (
  'default',
  'package_based',
  'venue_specific',
  'service_type',
  'custom'
);

CREATE TYPE dashboard_layout AS ENUM (
  'single_column',
  'sidebar',
  'grid',
  'tabbed'
);

-- Dashboard sections within templates
CREATE TABLE IF NOT EXISTS template_sections (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id UUID REFERENCES dashboard_templates(id) ON DELETE CASCADE,
  section_type dashboard_section_type NOT NULL,
  title VARCHAR(255) NOT NULL,
  content_config JSONB NOT NULL DEFAULT '{}'::jsonb,
  position_order INTEGER NOT NULL,
  is_required BOOLEAN DEFAULT false,
  is_collapsible BOOLEAN DEFAULT true,
  visibility_conditions JSONB DEFAULT '{}'::jsonb,
  styling_config JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TYPE dashboard_section_type AS ENUM (
  'welcome',
  'journey_progress',
  'forms_pending',
  'forms_completed',
  'documents',
  'faqs',
  'articles',
  'progress_charts',
  'activity_feed',
  'venue_info',
  'vendor_directory',
  'photo_gallery',
  'timeline',
  'custom_content'
);

-- Template assignments to clients
CREATE TABLE IF NOT EXISTS client_dashboard_assignments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  client_id UUID REFERENCES clients(id) ON DELETE CASCADE,
  template_id UUID REFERENCES dashboard_templates(id) ON DELETE CASCADE,
  assigned_at TIMESTAMPTZ DEFAULT NOW(),
  assigned_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  assignment_reason TEXT, -- auto, manual, package_upgrade, etc.
  customizations JSONB DEFAULT '{}'::jsonb, -- Client-specific overrides
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(client_id, is_active) -- Only one active assignment per client
);

-- Template usage analytics
CREATE TABLE IF NOT EXISTS template_usage_analytics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id UUID REFERENCES dashboard_templates(id) ON DELETE CASCADE,
  usage_date DATE NOT NULL,
  assignments_count INTEGER DEFAULT 0,
  client_engagement_score DECIMAL(3,2), -- 0.00 to 1.00
  section_views JSONB DEFAULT '{}'::jsonb, -- Per section view counts
  form_completion_rate DECIMAL(3,2),
  document_access_rate DECIMAL(3,2),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(template_id, usage_date)
);

-- Pre-built content library for sections
CREATE TABLE IF NOT EXISTS section_content_library (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  section_type dashboard_section_type NOT NULL,
  title VARCHAR(255) NOT NULL,
  content TEXT NOT NULL,
  content_type content_type NOT NULL DEFAULT 'text',
  tags TEXT[] DEFAULT '{}',
  is_global BOOLEAN DEFAULT false, -- Available to all users vs. private
  usage_count INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TYPE content_type AS ENUM (
  'text',
  'html',
  'markdown',
  'embedded_form',
  'image_gallery',
  'video',
  'document_list'
);

-- RLS policies
ALTER TABLE dashboard_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE template_sections ENABLE ROW LEVEL SECURITY;
ALTER TABLE client_dashboard_assignments ENABLE ROW LEVEL SECURITY;
ALTER TABLE template_usage_analytics ENABLE ROW LEVEL SECURITY;
ALTER TABLE section_content_library ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can manage their own dashboard templates" ON dashboard_templates
  FOR ALL USING (auth.uid() = user_id);

CREATE POLICY "Users can manage sections for their templates" ON template_sections
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM dashboard_templates 
      WHERE dashboard_templates.id = template_sections.template_id 
      AND dashboard_templates.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can manage their client assignments" ON client_dashboard_assignments
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM clients 
      WHERE clients.id = client_dashboard_assignments.client_id 
      AND clients.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can access their template analytics" ON template_usage_analytics
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM dashboard_templates 
      WHERE dashboard_templates.id = template_usage_analytics.template_id 
      AND dashboard_templates.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can manage their own content library" ON section_content_library
  FOR ALL USING (auth.uid() = user_id);

-- Global content library access
CREATE POLICY "Users can view global content library" ON section_content_library
  FOR SELECT USING (is_global = true);
```

#### API Endpoints Required
```typescript
// GET /api/dashboard-templates
interface GetDashboardTemplatesResponse {
  success: boolean;
  data: {
    templates: DashboardTemplate[];
    categories: Array<{category: string; count: number}>;
    defaultTemplateId?: string;
  };
}

// POST /api/dashboard-templates
interface CreateDashboardTemplateRequest {
  name: string;
  description: string;
  category: TemplateCategory;
  layoutType: DashboardLayout;
  isDefault?: boolean;
  brandingConfig?: BrandingConfig;
  visibilityRules?: VisibilityRules;
}

interface CreateDashboardTemplateResponse {
  success: boolean;
  data: DashboardTemplate;
}

// PUT /api/dashboard-templates/[id]
interface UpdateDashboardTemplateRequest {
  name?: string;
  description?: string;
  layoutType?: DashboardLayout;
  brandingConfig?: BrandingConfig;
  visibilityRules?: VisibilityRules;
  sections?: TemplateSection[];
}

// POST /api/dashboard-templates/[id]/clone
interface CloneTemplateRequest {
  newName: string;
  includeContent?: boolean;
  targetCategory?: TemplateCategory;
}

interface CloneTemplateResponse {
  success: boolean;
  data: DashboardTemplate;
}

// POST /api/dashboard-templates/[id]/assign
interface AssignTemplateRequest {
  clientIds: string[];
  reason?: string;
  preserveCustomizations?: boolean;
}

interface AssignTemplateResponse {
  success: boolean;
  data: {
    assignedCount: number;
    skippedCount: number;
    assignments: ClientDashboardAssignment[];
  };
}

// GET /api/dashboard-templates/[id]/preview
interface PreviewTemplateRequest {
  clientId?: string; // For personalized preview
  sampleData?: boolean; // Use sample wedding data
}

interface PreviewTemplateResponse {
  success: boolean;
  data: {
    renderedSections: Array<{
      id: string;
      title: string;
      htmlContent: string;
      position: number;
    }>;
    layoutConfig: DashboardLayout;
    brandingApplied: BrandingConfig;
  };
}

// GET /api/dashboard-templates/auto-assign
interface AutoAssignRequest {
  clientId: string;
  packageType?: string;
  venueType?: string;
  serviceCategory?: string;
}

interface AutoAssignResponse {
  success: boolean;
  data: {
    recommendedTemplate: DashboardTemplate;
    matchingRules: string[];
    confidence: number; // 0-100%
  };
}

// GET /api/section-content-library
interface GetContentLibraryResponse {
  success: boolean;
  data: {
    personalContent: SectionContent[];
    globalContent: SectionContent[];
    popularContent: SectionContent[];
  };
}

// POST /api/section-content-library
interface CreateSectionContentRequest {
  sectionType: DashboardSectionType;
  title: string;
  content: string;
  contentType: ContentType;
  tags: string[];
  isGlobal?: boolean;
}
```

#### Frontend Components Required
```typescript
// Component: TemplateBuilder
// Location: /src/components/dashboard-builder/TemplateBuilder.tsx

interface TemplateBuilderProps {
  template?: DashboardTemplate;
  onSave: (template: Partial<DashboardTemplate>) => Promise<void>;
  onPreview: (template: DashboardTemplate) => void;
}

// Key functionality:
- Drag-and-drop section builder interface
- Real-time template preview with sample data
- Layout selection (sidebar, grid, single column)
- Section configuration and content editing
- Branding customization (colors, fonts, logo)
- Visibility rules builder for auto-assignment
- Template versioning and rollback
- Import/export template configurations

// Component: TemplateLibrary
// Location: /src/components/dashboard-builder/TemplateLibrary.tsx

interface TemplateLibraryProps {
  onSelectTemplate: (template: DashboardTemplate) => void;
  onCloneTemplate: (template: DashboardTemplate) => void;
  filterCategory?: TemplateCategory;
}

// Key functionality:
- Grid view of templates with thumbnails
- Category filtering and search
- Template usage analytics display
- Quick actions (clone, edit, assign, delete)
- Default template designation
- Bulk operations for client assignments
- Template performance metrics

// Component: SectionPalette
// Location: /src/components/dashboard-builder/SectionPalette.tsx

interface SectionPaletteProps {
  onAddSection: (sectionType: DashboardSectionType, config: any) => void;
  availableSections: DashboardSectionType[];
}

// Key functionality:
- Draggable section components
- Section type descriptions and previews
- Wedding-specific section options
- Content library integration
- Custom section creation wizard
- Section requirement indicators
- Popular sections recommendations

// Component: TemplatePreview
// Location: /src/components/dashboard-builder/TemplatePreview.tsx

interface TemplatePreviewProps {
  template: DashboardTemplate;
  sampleClientData?: any;
  viewMode: 'desktop' | 'tablet' | 'mobile';
}

// Key functionality:
- Responsive design preview
- Sample data population
- Interactive section testing
- Branding application preview
- Performance impact estimation
- Client experience simulation
```

#### Integration Points
```typescript
// Service: DashboardTemplateService
// Dependencies: ClientService, ContentService, BrandingService

class DashboardTemplateService {
  async createTemplate(
    templateData: CreateDashboardTemplateRequest
  ): Promise<DashboardTemplate> {
    // 1. Validate template configuration
    // 2. Create template record with versioning
    // 3. Set up default sections based on category
    // 4. Apply branding configuration
    // 5. Generate thumbnail preview
  }

  async autoAssignTemplate(
    clientId: string,
    packageType?: string,
    venueType?: string
  ): Promise<DashboardTemplate> {
    // 1. Get client details and context
    // 2. Evaluate visibility rules for all templates
    // 3. Score templates based on matching criteria
    // 4. Assign highest scoring template
    // 5. Log assignment reasoning for analytics
  }

  async renderTemplateForClient(
    templateId: string,
    clientId: string
  ): Promise<RenderedDashboard> {
    // 1. Get template configuration and sections
    // 2. Fetch client-specific data for personalization
    // 3. Apply content customizations and overrides
    // 4. Render sections with wedding context
    // 5. Apply branding and layout configuration
  }

  async analyzeTemplatePerformance(
    templateId: string,
    dateRange: DateRange
  ): Promise<TemplateAnalytics> {
    // 1. Aggregate client engagement metrics
    // 2. Calculate form completion rates by section
    // 3. Measure document access patterns
    // 4. Track user satisfaction indicators
    // 5. Generate optimization recommendations
  }

  async cloneTemplateWithCustomizations(
    sourceTemplateId: string,
    targetConfig: Partial<DashboardTemplate>
  ): Promise<DashboardTemplate> {
    // 1. Deep copy template structure
    // 2. Apply configuration changes
    // 3. Update section content references
    // 4. Preserve or reset analytics data
    // 5. Version control new template
  }
}
```

### CODE EXAMPLES

#### Example 1: Auto-Template Assignment with Wedding Context
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { supabase } from '@/lib/supabase';
import { DashboardTemplate, ClientContext } from '@/types/dashboard-templates';

export async function autoAssignDashboardTemplate(
  clientId: string
): Promise<DashboardTemplate> {
  // Step 1: Get client context for template matching
  const { data: client, error: clientError } = await supabase
    .from('clients')
    .select(`
      *,
      wedding_details:wedding_details(*),
      package_info:client_packages(*)
    `)
    .eq('id', clientId)
    .single();
    
  if (clientError) throw clientError;
  
  // Step 2: Get all available templates with visibility rules
  const { data: templates, error: templatesError } = await supabase
    .from('dashboard_templates')
    .select(`
      *,
      template_sections(*),
      usage_analytics:template_usage_analytics(*)
    `)
    .eq('user_id', client.user_id)
    .eq('is_active', true)
    .order('created_at', { ascending: false });
    
  if (templatesError) throw templatesError;
  
  // Step 3: Score templates based on client context
  const scoredTemplates = templates.map(template => {
    let score = 0;
    const rules = template.visibility_rules || {};
    
    // Package-based scoring
    if (rules.packageTypes && client.package_info) {
      const packageMatch = rules.packageTypes.includes(client.package_info.package_type);
      if (packageMatch) score += 40;
    }
    
    // Venue-based scoring
    if (rules.venueTypes && client.wedding_details?.venue_type) {
      const venueMatch = rules.venueTypes.includes(client.wedding_details.venue_type);
      if (venueMatch) score += 30;
    }
    
    // Guest count based scoring
    if (rules.guestCountRanges && client.wedding_details?.estimated_guests) {
      const guestCount = client.wedding_details.estimated_guests;
      const matchingRange = rules.guestCountRanges.find(range => 
        guestCount >= range.min && guestCount <= range.max
      );
      if (matchingRange) score += 20;
    }
    
    // Service category scoring
    if (rules.serviceCategories && client.service_category) {
      const serviceMatch = rules.serviceCategories.includes(client.service_category);
      if (serviceMatch) score += 25;
    }
    
    // Performance-based scoring (templates with higher engagement)
    if (template.usage_analytics && template.usage_analytics.length > 0) {
      const avgEngagement = template.usage_analytics.reduce(
        (sum, analytics) => sum + (analytics.client_engagement_score || 0), 0
      ) / template.usage_analytics.length;
      score += avgEngagement * 15; // Up to 15 points for high-performing templates
    }
    
    // Default template fallback
    if (template.is_default) score += 5;
    
    return { template, score, matchingRules: getMatchingRules(template, client) };
  });
  
  // Step 4: Select highest scoring template
  const bestMatch = scoredTemplates.sort((a, b) => b.score - a.score)[0];
  
  if (!bestMatch || bestMatch.score === 0) {
    // Fallback to default template
    const defaultTemplate = templates.find(t => t.is_default);
    if (!defaultTemplate) throw new Error('No suitable template found');
    return defaultTemplate;
  }
  
  // Step 5: Assign template to client
  const { data: assignment, error: assignError } = await supabase
    .from('client_dashboard_assignments')
    .insert({
      client_id: clientId,
      template_id: bestMatch.template.id,
      assignment_reason: `auto: ${bestMatch.matchingRules.join(', ')} (score: ${bestMatch.score})`,
      assigned_by: client.user_id
    })
    .select()
    .single();
    
  if (assignError) throw assignError;
  
  // Step 6: Log analytics
  await updateTemplateUsageAnalytics(bestMatch.template.id);
  
  return bestMatch.template;
}

export async function renderDashboardForClient(
  clientId: string
): Promise<RenderedDashboard> {
  // Step 1: Get client's assigned template
  const { data: assignment } = await supabase
    .from('client_dashboard_assignments')
    .select(`
      *,
      template:dashboard_templates(*),
      sections:template_sections(*)
    `)
    .eq('client_id', clientId)
    .eq('is_active', true)
    .single();
    
  if (!assignment) {
    // Auto-assign template if none exists
    const autoTemplate = await autoAssignDashboardTemplate(clientId);
    return renderDashboardForClient(clientId); // Recursive call with new assignment
  }
  
  // Step 2: Get client data for personalization
  const { data: client } = await supabase
    .from('clients')
    .select(`
      *,
      wedding_details:wedding_details(*),
      forms:client_forms(*),
      documents:client_documents(*),
      journey_progress:client_journey_progress(*)
    `)
    .eq('id', clientId)
    .single();
  
  // Step 3: Render each section with wedding context
  const renderedSections = await Promise.all(
    assignment.sections
      .sort((a, b) => a.position_order - b.position_order)
      .map(async section => {
        const content = await renderSectionWithContext(section, client);
        return {
          id: section.id,
          type: section.section_type,
          title: section.title,
          content,
          position: section.position_order,
          isCollapsible: section.is_collapsible,
          styling: section.styling_config
        };
      })
  );
  
  return {
    templateId: assignment.template.id,
    templateName: assignment.template.name,
    layout: assignment.template.layout_type,
    branding: assignment.template.branding_config,
    sections: renderedSections,
    customizations: assignment.customizations,
    lastUpdated: assignment.updated_at
  };
}

async function renderSectionWithContext(
  section: TemplateSection,
  client: any
): Promise<string> {
  const config = section.content_config;
  
  switch (section.section_type) {
    case 'welcome':
      return renderWelcomeSection(client, config);
    case 'journey_progress':
      return renderJourneyProgressSection(client.journey_progress, config);
    case 'forms_pending':
      const pendingForms = client.forms.filter(f => f.status === 'pending');
      return renderFormsSection(pendingForms, config);
    case 'venue_info':
      return renderVenueInfoSection(client.wedding_details, config);
    case 'timeline':
      return renderTimelineSection(client.wedding_details, config);
    default:
      return renderGenericSection(section, client);
  }
}

function renderWelcomeSection(client: any, config: any): string {
  const daysUntilWedding = Math.ceil(
    (new Date(client.wedding_date).getTime() - Date.now()) / (1000 * 60 * 60 * 24)
  );
  
  const template = config.template || 'Welcome {{couple_names}}! {{days_until}} days until your special day at {{venue_name}}.';
  
  return template
    .replace('{{couple_names}}', `${client.partner1_name} & ${client.partner2_name}`)
    .replace('{{days_until}}', daysUntilWedding.toString())
    .replace('{{venue_name}}', client.wedding_details?.venue_name || 'your chosen venue')
    .replace('{{wedding_date}}', new Date(client.wedding_date).toLocaleDateString());
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for React drag-and-drop libraries, template engines
- [x] Filesystem: Access existing dashboard and client components
- [x] Memory: Store template patterns and best practices

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/atlassian/react-beautiful-dnd", "drag drop", 3000);
await mcp__context7__get-library-docs("/react/react", "component composition", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('DashboardTemplateService', () => {
  it('should auto-assign template based on package type', async () => {
    const client = createTestClient({ packageType: 'luxury', venueType: 'estate' });
    const template = await autoAssignDashboardTemplate(client.id);
    expect(template.category).toBe('package_based');
    expect(template.name).toContain('Luxury');
  });

  it('should render welcome section with wedding context', () => {
    const client = createTestClient({
      partner1_name: 'John',
      partner2_name: 'Jane',
      wedding_date: '2025-06-15',
      venue_name: 'Garden Estate'
    });
    
    const content = renderWelcomeSection(client, {
      template: 'Welcome {{couple_names}}! {{days_until}} days until {{venue_name}}.'
    });
    
    expect(content).toContain('John & Jane');
    expect(content).toContain('Garden Estate');
    expect(content).toMatch(/\d+ days until/);
  });

  it('should clone template with customizations', async () => {
    const original = await createTestTemplate({ name: 'Original', sections: 5 });
    const cloned = await cloneTemplateWithCustomizations(original.id, {
      name: 'Luxury Version',
      category: 'package_based'
    });
    
    expect(cloned.name).toBe('Luxury Version');
    expect(cloned.template_sections).toHaveLength(5);
    expect(cloned.parent_template_id).toBe(original.id);
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Dashboard template builder workflow', async () => {
  await mcp__playwright__browser_navigate({url: '/dashboard/templates'});
  
  // Create new template
  await mcp__playwright__browser_click({element: 'create template button', ref: 'button[data-testid="create-template"]'});
  
  await mcp__playwright__browser_type({
    element: 'template name input',
    ref: 'input[name="templateName"]',
    text: 'Luxury Wedding Package'
  });
  
  // Add sections via drag and drop
  await mcp__playwright__browser_drag({
    startElement: 'welcome section',
    startRef: '[data-section-type="welcome"]',
    endElement: 'template canvas',
    endRef: '[data-testid="template-canvas"]'
  });
  
  await mcp__playwright__browser_drag({
    startElement: 'venue info section',
    startRef: '[data-section-type="venue_info"]',
    endElement: 'template canvas',
    endRef: '[data-testid="template-canvas"]'
  });
  
  // Configure section content
  await mcp__playwright__browser_click({element: 'welcome section config', ref: '[data-section="welcome"] .config-button'});
  
  await mcp__playwright__browser_type({
    element: 'welcome template textarea',
    ref: 'textarea[name="welcomeTemplate"]',
    text: 'Welcome {{couple_names}} to our luxury experience! {{days_until}} days until your dream wedding at {{venue_name}}.'
  });
  
  // Preview template
  await mcp__playwright__browser_click({element: 'preview button', ref: 'button[data-testid="preview-template"]'});
  await mcp__playwright__browser_wait_for({text: 'Welcome John & Jane'});
  
  // Save template
  await mcp__playwright__browser_click({element: 'save template button', ref: 'button[data-testid="save-template"]'});
  await mcp__playwright__browser_wait_for({text: 'Template saved successfully'});
  
  // Verify in template library
  await mcp__playwright__browser_navigate({url: '/dashboard/templates'});
  await mcp__playwright__browser_wait_for({text: 'Luxury Wedding Package'});
  
  // Verify accessibility
  await mcp__playwright__browser_evaluate({
    function: '() => axe.run()'
  });
});
```

### ACCEPTANCE CRITERIA
- [x] Drag-and-drop template builder with section library
- [x] Auto-assignment based on client package, venue, and service type
- [x] Template cloning and customization capabilities
- [x] Wedding-specific sections with dynamic content
- [x] Responsive layout options (sidebar, grid, single column)
- [x] Performance: Template rendering completes within 2 seconds
- [x] Security: Template access restricted to authorized users
- [x] Accessibility: Template builder meets WCAG 2.1 AA standards

### DEPENDENCIES
- Must complete after: None (foundational feature)
- Must complete before: WS-066 (Section Configuration), WS-067 (Branding Customization)
- Shares code with: Client dashboard components, branding system

### ESTIMATED EFFORT
- Team A Frontend: 28 hours (Template builder, drag-drop interface, preview system)
- Team D Full-stack: 20 hours (Auto-assignment logic, template rendering, analytics)
- Team B Backend: 12 hours (Database schema, API endpoints, template storage)
- Total: 60 hours