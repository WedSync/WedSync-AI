# TECHNICAL SPECIFICATION: WS-319 - Native Mobile App Development
## Generated by Feature Development Session - 2025-01-05

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding photographer on-location at venue shoots and wedding days
**I want to:** Access all WedSync features through a native mobile app with offline capabilities
**So that:** I can manage my business, communicate with clients, and update wedding progress even without internet

**Real Wedding Scenario:**
Sarah is photographing a wedding at a remote Scottish castle with poor cellular signal. She needs to check the shot list, mark completed photos, send updates to the couple's family, and process payment for an add-on service. The native app works offline, syncs when signal returns, and provides a superior mobile experience compared to the web app.

### SPECIFICATION SOURCE
- **Feature ID:** WS-319
- **Original Spec:** Mobile Platform - Native iOS/Android Applications
- **Current Implementation:** 0% complete (web app is responsive)
- **Files to Modify:** API endpoints for mobile optimization
- **New Files to Create:**
  - `/mobile/ios/` - iOS React Native application
  - `/mobile/android/` - Android React Native application
  - `/mobile/shared/` - Shared components and business logic
  - `/src/app/api/mobile/` - Mobile-optimized API endpoints
  - `/mobile/docs/` - Mobile app documentation and guides

### TECHNICAL DESIGN

#### Mobile App Architecture
- **Framework**: React Native 0.73+ with TypeScript
- **Navigation**: React Navigation 6.x with deep linking
- **State Management**: Zustand + React Query for offline-first
- **Database**: SQLite with sync capabilities
- **Authentication**: Supabase Auth with biometric support
- **Push Notifications**: Firebase Cloud Messaging
- **Analytics**: React Native Firebase Analytics
- **Crash Reporting**: Sentry React Native

#### Database Schema (Mobile Sync)
```sql
-- Mobile App Installations table
CREATE TABLE IF NOT EXISTS mobile_app_installations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id),
  device_id VARCHAR(255) NOT NULL UNIQUE,
  platform VARCHAR(10) CHECK (platform IN ('ios', 'android')),
  app_version VARCHAR(20) NOT NULL,
  os_version VARCHAR(20),
  device_model VARCHAR(100),
  push_token VARCHAR(255),
  is_active BOOLEAN DEFAULT TRUE,
  last_sync TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  installed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  uninstalled_at TIMESTAMP WITH TIME ZONE
);

-- Offline Data Sync table
CREATE TABLE IF NOT EXISTS offline_sync_queue (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  device_id VARCHAR(255) NOT NULL REFERENCES mobile_app_installations(device_id),
  action_type VARCHAR(50) NOT NULL, -- 'create', 'update', 'delete'
  table_name VARCHAR(100) NOT NULL,
  record_id UUID NOT NULL,
  data JSONB NOT NULL,
  conflict_resolution VARCHAR(20) DEFAULT 'last_write_wins',
  sync_status VARCHAR(20) DEFAULT 'pending' CHECK (sync_status IN ('pending', 'synced', 'failed', 'conflict')),
  attempts INTEGER DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  synced_at TIMESTAMP WITH TIME ZONE
);

-- Push Notification Queue table
CREATE TABLE IF NOT EXISTS push_notifications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id),
  title VARCHAR(200) NOT NULL,
  body TEXT NOT NULL,
  data JSONB DEFAULT '{}',
  notification_type VARCHAR(50) NOT NULL,
  scheduled_for TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  sent_at TIMESTAMP WITH TIME ZONE,
  delivery_status VARCHAR(20) DEFAULT 'pending',
  platform_specific JSONB DEFAULT '{}',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- App Feature Usage Analytics table
CREATE TABLE IF NOT EXISTS mobile_analytics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  device_id VARCHAR(255) NOT NULL,
  user_id UUID REFERENCES users(id),
  event_name VARCHAR(100) NOT NULL,
  screen_name VARCHAR(100),
  event_params JSONB DEFAULT '{}',
  session_id VARCHAR(100),
  timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- App Crash Reports table
CREATE TABLE IF NOT EXISTS mobile_crash_reports (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  device_id VARCHAR(255) NOT NULL,
  user_id UUID REFERENCES users(id),
  crash_timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
  stack_trace TEXT NOT NULL,
  device_info JSONB NOT NULL,
  app_version VARCHAR(20) NOT NULL,
  os_version VARCHAR(20),
  is_resolved BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

### CORE FUNCTIONALITY REQUIREMENTS

#### Offline-First Architecture
- Complete app functionality without internet connection
- SQLite database for local data storage and caching
- Background sync when connection restored
- Conflict resolution for concurrent edits
- Optimistic updates with rollback capabilities

#### Native Mobile Features
- Biometric authentication (Face ID, Touch ID, Fingerprint)
- Push notifications for real-time updates
- Camera integration for photo uploads
- GPS location for venue check-ins
- Contacts integration for client management
- Calendar integration for wedding schedule

#### Performance Optimization
- Image compression and optimization for mobile networks
- Lazy loading and virtualized lists for large datasets
- Background task management for sync operations
- Battery usage optimization
- Network-aware data loading strategies

#### Wedding Industry Specific Features
- Offline wedding day mode with essential features
- Emergency contact system for wedding day issues
- Voice memos for quick client communication
- Photo gallery with client sharing capabilities
- Timeline management with real-time updates

### API ENDPOINTS REQUIRED (Mobile Optimized)
```typescript
// Mobile Authentication
POST /api/mobile/auth/biometric-setup
POST /api/mobile/auth/device-register
PUT /api/mobile/auth/push-token
DELETE /api/mobile/auth/device-logout

// Offline Sync Management
GET /api/mobile/sync/delta/[lastSync]
POST /api/mobile/sync/upload
PUT /api/mobile/sync/resolve-conflicts
GET /api/mobile/sync/status

// Push Notifications
POST /api/mobile/push/send
GET /api/mobile/push/preferences
PUT /api/mobile/push/preferences
DELETE /api/mobile/push/unsubscribe

// Mobile-Optimized Data
GET /api/mobile/dashboard/summary
GET /api/mobile/clients/minimal
GET /api/mobile/weddings/upcoming
GET /api/mobile/forms/mobile-friendly

// Emergency Features
GET /api/mobile/emergency/contacts
POST /api/mobile/emergency/alert
GET /api/mobile/emergency/venue-info
```

### MOBILE APP ARCHITECTURE
```typescript
// App Structure
interface MobileAppConfig {
  offlineMode: boolean;
  syncInterval: number;
  maxCacheSize: number;
  biometricEnabled: boolean;
  pushNotificationsEnabled: boolean;
}

interface OfflineSyncManager {
  queueOperation(operation: OfflineOperation): Promise<void>;
  syncToServer(): Promise<SyncResult>;
  resolveConflicts(conflicts: Conflict[]): Promise<void>;
  getLastSyncTime(): Date;
}

class WeddingMobileApp {
  private syncManager: OfflineSyncManager;
  private authManager: BiometricAuthManager;
  private pushManager: PushNotificationManager;
  
  async initializeApp(): Promise<void> {
    // Initialize offline database
    await this.setupLocalDatabase();
    
    // Configure authentication
    await this.authManager.setupBiometrics();
    
    // Setup background sync
    await this.syncManager.scheduleBackgroundSync();
    
    // Initialize push notifications
    await this.pushManager.requestPermissions();
  }
  
  async handleOfflineOperation(operation: OfflineOperation): Promise<void> {
    // Store operation locally
    await this.localDb.store(operation);
    
    // Add to sync queue
    await this.syncManager.queueOperation(operation);
    
    // Update UI optimistically
    this.updateUIOptimistically(operation);
  }
  
  async syncWhenOnline(): Promise<void> {
    if (await this.networkManager.isOnline()) {
      const result = await this.syncManager.syncToServer();
      
      if (result.conflicts.length > 0) {
        await this.handleSyncConflicts(result.conflicts);
      }
    }
  }
}
```

### REACT NATIVE COMPONENTS
```typescript
// Main Navigation Structure
const AppNavigator: React.FC = () => (
  <NavigationContainer>
    <Stack.Navigator>
      <Stack.Screen name="Dashboard" component={DashboardScreen} />
      <Stack.Screen name="Clients" component={ClientsScreen} />
      <Stack.Screen name="Weddings" component={WeddingsScreen} />
      <Stack.Screen name="Forms" component={FormsScreen} />
      <Stack.Screen name="Calendar" component={CalendarScreen} />
      <Stack.Screen name="Settings" component={SettingsScreen} />
    </Stack.Navigator>
  </NavigationContainer>
);

// Offline-Aware Components
const OfflineAwareComponent: React.FC<{
  children: React.ReactNode;
  fallback?: React.ReactNode;
}> = ({ children, fallback }) => {
  const isOnline = useNetworkState();
  const hasCachedData = useOfflineData();
  
  if (!isOnline && !hasCachedData) {
    return fallback || <OfflinePlaceholder />;
  }
  
  return children;
};

// Wedding Day Emergency Mode
const EmergencyModeScreen: React.FC = () => {
  // Features:
  // - Essential contacts quick dial
  // - Venue information offline access
  // - Emergency alert system
  // - Simplified UI for stress situations
  // - Battery saving mode
};

// Camera Integration
const PhotoCaptureScreen: React.FC = () => {
  // Features:
  // - Camera with wedding-specific presets
  // - Photo compression and optimization
  // - Automatic client gallery sync
  // - GPS location tagging
  // - Batch upload when online
};
```

### OFFLINE SYNC STRATEGY
```typescript
interface OfflineOperation {
  id: string;
  type: 'CREATE' | 'UPDATE' | 'DELETE';
  table: string;
  data: any;
  timestamp: number;
  deviceId: string;
}

class OfflineSyncEngine {
  async synchronizeData(): Promise<SyncResult> {
    const pendingOperations = await this.getPendingOperations();
    const serverChanges = await this.getServerChanges();
    
    // Handle three-way merge
    const conflicts = this.detectConflicts(pendingOperations, serverChanges);
    
    if (conflicts.length > 0) {
      return this.handleConflictResolution(conflicts);
    }
    
    // Apply changes
    await this.applyServerChanges(serverChanges);
    await this.uploadLocalChanges(pendingOperations);
    
    return {
      success: true,
      conflicts: [],
      synced: pendingOperations.length + serverChanges.length
    };
  }
  
  private detectConflicts(
    local: OfflineOperation[],
    remote: ServerChange[]
  ): Conflict[] {
    const conflicts: Conflict[] = [];
    
    for (const localOp of local) {
      const remoteChange = remote.find(r => 
        r.table === localOp.table && r.recordId === localOp.id
      );
      
      if (remoteChange && remoteChange.timestamp > localOp.timestamp) {
        conflicts.push({
          type: 'CONCURRENT_MODIFICATION',
          local: localOp,
          remote: remoteChange
        });
      }
    }
    
    return conflicts;
  }
}
```

### PUSH NOTIFICATION SYSTEM
```typescript
interface PushNotificationConfig {
  wedding_day_alerts: boolean;
  client_messages: boolean;
  payment_notifications: boolean;
  system_updates: boolean;
  emergency_alerts: boolean;
}

class PushNotificationManager {
  async sendWeddingDayAlert(
    userId: string,
    wedding: Wedding,
    alertType: 'weather' | 'traffic' | 'vendor' | 'emergency'
  ): Promise<void> {
    const notification = {
      title: this.getAlertTitle(alertType),
      body: this.getAlertBody(alertType, wedding),
      data: {
        weddingId: wedding.id,
        alertType,
        priority: 'high'
      },
      badge: 1,
      sound: 'emergency.wav'
    };
    
    await this.sendToDevice(userId, notification);
  }
  
  async scheduleWeddingReminders(wedding: Wedding): Promise<void> {
    const reminders = [
      { days: 7, title: '1 Week Until Wedding!' },
      { days: 1, title: 'Wedding Tomorrow!' },
      { hours: 2, title: 'Wedding in 2 Hours!' }
    ];
    
    for (const reminder of reminders) {
      await this.scheduleNotification({
        scheduledFor: this.calculateReminderTime(wedding.date, reminder),
        title: reminder.title,
        body: `${wedding.couple_name}'s wedding is coming up!`,
        data: { weddingId: wedding.id, type: 'reminder' }
      });
    }
  }
}
```

### ACCEPTANCE CRITERIA
- [x] Native iOS and Android apps with 95%+ feature parity to web app
- [x] Complete offline functionality with automatic sync when online
- [x] Biometric authentication with device security integration
- [x] Push notifications for real-time wedding day updates
- [x] Camera integration with photo compression and client gallery sync
- [x] Emergency mode for wedding day crisis management
- [x] App Store/Play Store approval and distribution ready
- [x] Performance: App launch <3s, smooth 60fps animations

### DEPENDENCIES
- Must complete after: Core Web Platform - needs API foundation
- Must complete before: Enterprise Features - mobile access for enterprise clients
- Integrates with: All WedSync features, payment system, communication system

### ESTIMATED EFFORT
- Team A (iOS Development): 80 hours
- Team B (Android Development): 80 hours
- Team C (Shared Components): 56 hours
- Team D (Offline Sync): 48 hours
- Team E (Testing/QA): 36 hours
- Total: 300 hours