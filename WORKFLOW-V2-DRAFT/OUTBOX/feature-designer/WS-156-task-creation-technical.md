# TECHNICAL SPECIFICATION: WS-156 - Task Creation System
## Generated by Feature Development Session - August 23, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding couple preparing for their big day
**I want to:** Create detailed tasks for my wedding helpers with specific timing, locations, and instructions
**So that:** My helpers know exactly what to do, when to do it, and where to be, eliminating confusion and ensuring smooth execution

**Real Wedding Scenario:**
A couple typically creates a "day-of timeline" in a Word document that gets lost or outdated. With this feature, they create tasks like "Set up ceremony chairs (2pm-2:30pm at Garden Pavilion, need 100 white chairs from storage)" that get assigned to specific helpers. This eliminates the chaos of people asking "what should I be doing now?" throughout the wedding day.

### SPECIFICATION SOURCE
- **Feature ID:** WS-156
- **Original Spec:** /CORE-SPECIFICATIONS/03-WEDME-COUPLE-PLATFORM/05-Task-Delegation/01-task-creation md.md
- **Current Implementation:** 0% complete (new)
- **Files to Modify:** None (new feature)
- **New Files to Create:** 
  - `/src/app/(dashboard)/tasks/page.tsx`
  - `/src/components/tasks/TaskCreator.tsx`
  - `/src/components/tasks/TaskTemplateLibrary.tsx` 
  - `/src/components/tasks/TaskTimingValidator.tsx`
  - `/src/lib/services/taskService.ts`
  - `/src/types/tasks.ts`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Task management tables
CREATE TABLE IF NOT EXISTS wedding_tasks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  couple_id UUID REFERENCES couples(id),
  title VARCHAR(255) NOT NULL,
  description TEXT,
  category VARCHAR(50) CHECK (category IN ('setup', 'ceremony', 'reception', 'breakdown', 'coordination')),
  priority VARCHAR(20) CHECK (priority IN ('critical', 'high', 'medium', 'low')),
  timing_type VARCHAR(30) CHECK (timing_type IN ('specific_time', 'relative_to_event', 'time_range')),
  timing_value VARCHAR(100), -- '14:00' or 'ceremony-30min' or '13:00-14:00'
  location VARCHAR(255),
  supplies_needed JSONB, -- Array of supply items
  photo_attachments TEXT[], -- Array of photo URLs
  estimated_duration INTEGER, -- minutes
  dependency_task_ids UUID[], -- Array of task IDs that must complete first
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  is_template BOOLEAN DEFAULT false,
  template_category VARCHAR(100) -- For reusable task templates
);

-- Task templates for common wedding scenarios
CREATE TABLE IF NOT EXISTS task_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255) NOT NULL,
  description TEXT,
  category VARCHAR(50),
  wedding_type VARCHAR(100), -- 'church', 'outdoor', 'indoor', 'destination'
  tasks JSONB NOT NULL, -- Array of task objects
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_wedding_tasks_couple_id ON wedding_tasks(couple_id);
CREATE INDEX idx_wedding_tasks_category ON wedding_tasks(category);
CREATE INDEX idx_wedding_tasks_timing_value ON wedding_tasks(timing_value);
```

#### API Endpoints Required
```typescript
// POST /api/tasks
interface CreateTaskRequestBody {
  title: string;
  description: string;
  category: 'setup' | 'ceremony' | 'reception' | 'breakdown' | 'coordination';
  priority: 'critical' | 'high' | 'medium' | 'low';
  timing: {
    type: 'specific_time' | 'relative_to_event' | 'time_range';
    value: string;
  };
  location: string;
  supplies_needed?: string[];
  estimated_duration: number;
  dependency_task_ids?: string[];
}

interface CreateTaskResponseBody {
  success: boolean;
  data: WeddingTask;
  timing_conflicts?: {
    conflicting_tasks: string[];
    suggested_times: string[];
  };
}

// GET /api/tasks/templates
interface TaskTemplatesResponse {
  success: boolean;
  data: {
    templates: TaskTemplate[];
    categories: string[];
  };
}

// POST /api/tasks/bulk-create
interface BulkCreateTasksRequest {
  template_id: string;
  wedding_date: string;
  ceremony_time: string;
  venue_location: string;
}

// POST /api/tasks/validate-timing
interface ValidateTimingRequest {
  tasks: Array<{
    id?: string;
    timing_value: string;
    estimated_duration: number;
  }>;
}
```

#### Frontend Components Required
```typescript
// Component: TaskCreator
// Location: /src/components/tasks/TaskCreator.tsx

interface TaskCreatorProps {
  coupleId: string;
  onTaskCreated: (task: WeddingTask) => void;
  editingTask?: WeddingTask;
}

// Key functionality:
- Rich text editor for task descriptions
- Time picker with validation against other tasks
- Location autocomplete based on venue details
- Supply list builder with drag-and-drop
- Photo attachment uploader
- Task dependency selector
- Real-time timing conflict detection

// Component: TaskTemplateLibrary
// Location: /src/components/tasks/TaskTemplateLibrary.tsx

interface TaskTemplateLibraryProps {
  weddingType: string;
  onTemplateSelect: (template: TaskTemplate) => void;
}

// Key functionality:
- Browse pre-built task templates by wedding type
- Preview template tasks before importing
- Customize template tasks before creating
- Save custom task sets as templates
- Import from popular wedding planning books/sites

// Component: TaskTimingValidator
// Location: /src/components/tasks/TaskTimingValidator.tsx

// Key functionality:
- Visual timeline view showing task overlaps
- Conflict detection and highlighting
- Suggested alternative times
- Buffer time calculation between tasks
- Critical path analysis
```

#### Integration Points
```typescript
// Service: TaskService
// Dependencies: Timeline service, venue service, notification service

class TaskService {
  async createTask(taskData: CreateTaskData): Promise<TaskResult> {
    // Validate timing conflicts
    const conflicts = await this.validateTaskTiming(taskData);
    
    if (conflicts.length > 0) {
      return {
        success: false,
        conflicts,
        suggested_times: this.generateAlternativeTimes(taskData, conflicts)
      };
    }
    
    // Create task with automatic dependency validation
    const task = await this.insertTask(taskData);
    
    // Update master timeline if needed
    await this.updateMasterTimeline(task);
    
    return { success: true, data: task };
  }
  
  async importTaskTemplate(templateId: string, weddingDetails: WeddingContext): Promise<WeddingTask[]> {
    const template = await this.getTemplate(templateId);
    
    // Customize template tasks with wedding-specific details
    const customizedTasks = template.tasks.map(task => ({
      ...task,
      couple_id: weddingDetails.couple_id,
      location: task.location.includes('VENUE_NAME') 
        ? task.location.replace('VENUE_NAME', weddingDetails.venue_name)
        : task.location,
      timing_value: this.adjustTimingForWedding(task.timing_value, weddingDetails.ceremony_time)
    }));
    
    return await this.bulkCreateTasks(customizedTasks);
  }
  
  async validateTaskTiming(task: WeddingTask): Promise<TimingConflict[]> {
    // Check for overlapping tasks
    const existingTasks = await this.getTasksByTimeRange(task.timing_value, task.estimated_duration);
    
    // Check dependencies
    const dependencyIssues = await this.validateDependencies(task.dependency_task_ids);
    
    return [...existingTasks, ...dependencyIssues];
  }
}
```

### CODE EXAMPLES

#### Example 1: Task Creator Component
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
'use client';

import { useState, useEffect } from 'react';
import { supabase } from '@/lib/supabase';
import { WeddingTask, TaskCategory, TaskPriority } from '@/types/tasks';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Select } from '@/components/ui/select';

export function TaskCreator({ 
  coupleId, 
  onTaskCreated, 
  editingTask 
}: {
  coupleId: string;
  onTaskCreated: (task: WeddingTask) => void;
  editingTask?: WeddingTask;
}) {
  const [formData, setFormData] = useState({
    title: editingTask?.title || '',
    description: editingTask?.description || '',
    category: editingTask?.category || 'setup' as TaskCategory,
    priority: editingTask?.priority || 'medium' as TaskPriority,
    timing_type: editingTask?.timing_type || 'specific_time',
    timing_value: editingTask?.timing_value || '',
    location: editingTask?.location || '',
    supplies_needed: editingTask?.supplies_needed || [],
    estimated_duration: editingTask?.estimated_duration || 30
  });

  const [timingConflicts, setTimingConflicts] = useState<string[]>([]);
  const [isValidating, setIsValidating] = useState(false);

  // Validate timing when timing fields change
  useEffect(() => {
    if (formData.timing_value && formData.estimated_duration) {
      validateTiming();
    }
  }, [formData.timing_value, formData.estimated_duration]);

  const validateTiming = async () => {
    setIsValidating(true);
    
    const { data, error } = await supabase
      .rpc('validate_task_timing', {
        timing_value: formData.timing_value,
        duration_minutes: formData.estimated_duration,
        couple_id: coupleId,
        exclude_task_id: editingTask?.id
      });

    if (data?.conflicts) {
      setTimingConflicts(data.conflicts);
    } else {
      setTimingConflicts([]);
    }
    
    setIsValidating(false);
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    const taskData = {
      ...formData,
      couple_id: coupleId,
      timing_type: formData.timing_type,
      timing_value: formData.timing_value
    };

    try {
      let result;
      if (editingTask) {
        const { data, error } = await supabase
          .from('wedding_tasks')
          .update(taskData)
          .eq('id', editingTask.id)
          .select()
          .single();
        
        if (error) throw error;
        result = data;
      } else {
        const { data, error } = await supabase
          .from('wedding_tasks')
          .insert(taskData)
          .select()
          .single();
        
        if (error) throw error;
        result = data;
      }

      onTaskCreated(result);
      
      // Reset form if creating new
      if (!editingTask) {
        setFormData({
          title: '',
          description: '',
          category: 'setup',
          priority: 'medium',
          timing_type: 'specific_time',
          timing_value: '',
          location: '',
          supplies_needed: [],
          estimated_duration: 30
        });
      }
    } catch (error) {
      console.error('Error creating task:', error);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      <div>
        <label className="block text-sm font-medium mb-2">Task Title</label>
        <Input
          value={formData.title}
          onChange={(e) => setFormData({ ...formData, title: e.target.value })}
          placeholder="e.g., Set up ceremony chairs"
          required
        />
      </div>

      <div>
        <label className="block text-sm font-medium mb-2">Description</label>
        <Textarea
          value={formData.description}
          onChange={(e) => setFormData({ ...formData, description: e.target.value })}
          placeholder="Detailed instructions for this task..."
          rows={3}
        />
      </div>

      <div className="grid grid-cols-2 gap-4">
        <div>
          <label className="block text-sm font-medium mb-2">Category</label>
          <Select
            value={formData.category}
            onValueChange={(value) => setFormData({ ...formData, category: value as TaskCategory })}
          >
            <option value="setup">Setup</option>
            <option value="ceremony">Ceremony</option>
            <option value="reception">Reception</option>
            <option value="breakdown">Breakdown</option>
            <option value="coordination">Coordination</option>
          </Select>
        </div>

        <div>
          <label className="block text-sm font-medium mb-2">Priority</label>
          <Select
            value={formData.priority}
            onValueChange={(value) => setFormData({ ...formData, priority: value as TaskPriority })}
          >
            <option value="critical">Critical</option>
            <option value="high">High</option>
            <option value="medium">Medium</option>
            <option value="low">Low</option>
          </Select>
        </div>
      </div>

      <div className="grid grid-cols-2 gap-4">
        <div>
          <label className="block text-sm font-medium mb-2">Timing</label>
          <Select
            value={formData.timing_type}
            onValueChange={(value) => setFormData({ ...formData, timing_type: value })}
          >
            <option value="specific_time">Specific Time</option>
            <option value="relative_to_event">Relative to Event</option>
            <option value="time_range">Time Range</option>
          </Select>
        </div>

        <div>
          <label className="block text-sm font-medium mb-2">
            {formData.timing_type === 'specific_time' && 'Time'}
            {formData.timing_type === 'relative_to_event' && 'Relative Timing'}
            {formData.timing_type === 'time_range' && 'Time Range'}
          </label>
          <Input
            value={formData.timing_value}
            onChange={(e) => setFormData({ ...formData, timing_value: e.target.value })}
            placeholder={
              formData.timing_type === 'specific_time' ? '14:00' :
              formData.timing_type === 'relative_to_event' ? 'ceremony-30min' :
              '13:00-14:00'
            }
            required
          />
        </div>
      </div>

      {timingConflicts.length > 0 && (
        <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4">
          <h4 className="font-medium text-yellow-800 mb-2">Timing Conflicts Detected</h4>
          <ul className="text-sm text-yellow-700">
            {timingConflicts.map((conflict, index) => (
              <li key={index}>â€¢ {conflict}</li>
            ))}
          </ul>
        </div>
      )}

      <div className="grid grid-cols-2 gap-4">
        <div>
          <label className="block text-sm font-medium mb-2">Location</label>
          <Input
            value={formData.location}
            onChange={(e) => setFormData({ ...formData, location: e.target.value })}
            placeholder="e.g., Garden Pavilion, Bridal Suite"
          />
        </div>

        <div>
          <label className="block text-sm font-medium mb-2">Duration (minutes)</label>
          <Input
            type="number"
            value={formData.estimated_duration}
            onChange={(e) => setFormData({ ...formData, estimated_duration: parseInt(e.target.value) })}
            min="5"
            max="480"
          />
        </div>
      </div>

      <Button 
        type="submit" 
        disabled={isValidating || timingConflicts.length > 0}
        className="w-full"
      >
        {editingTask ? 'Update Task' : 'Create Task'}
      </Button>
    </form>
  );
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for React Hook Form, date-fns
- [x] Playwright: Test task creation workflows
- [x] Filesystem: Access task management components

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/react-hook-form/react-hook-form", "form validation", 2000);
await mcp__context7__get-library-docs("/date-fns/date-fns", "date manipulation", 1500);
await mcp__context7__get-library-docs("/supabase/supabase-js", "rpc functions", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('TaskService', () => {
  it('should detect timing conflicts', async () => {
    const service = new TaskService();
    const newTask = {
      timing_value: '14:00',
      estimated_duration: 60
    };
    
    const conflicts = await service.validateTaskTiming(newTask);
    expect(conflicts).toHaveLength(0);
  });

  it('should customize template tasks with wedding details', () => {
    const template = {
      tasks: [{ location: 'VENUE_NAME Main Hall', timing_value: 'CEREMONY_TIME-60min' }]
    };
    
    const weddingDetails = { venue_name: 'Oak Grove Manor', ceremony_time: '16:00' };
    const result = service.customizeTemplate(template, weddingDetails);
    
    expect(result.tasks[0].location).toBe('Oak Grove Manor Main Hall');
    expect(result.tasks[0].timing_value).toBe('15:00'); // 1 hour before ceremony
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Task creation workflow', async () => {
  await mcp__playwright__browser_navigate({url: '/tasks'});
  await mcp__playwright__browser_snapshot();
  
  // Test task creation form
  await mcp__playwright__browser_click({
    element: 'Create New Task button',
    ref: 'button[data-testid="create-task"]'
  });
  
  await mcp__playwright__browser_type({
    element: 'Task title input',
    ref: 'input[name="title"]',
    text: 'Set up ceremony chairs'
  });
  
  // Test timing conflict detection
  await mcp__playwright__browser_type({
    element: 'Timing input',
    ref: 'input[name="timing_value"]',
    text: '14:00'
  });
  
  // Verify conflict warning appears if timing conflicts
  await mcp__playwright__browser_wait_for({
    text: 'Timing Conflicts Detected'
  });
  
  await mcp__playwright__browser_snapshot();
});
```

### ACCEPTANCE CRITERIA
- [x] Users can create tasks with title, description, category, priority, timing, and location
- [x] Real-time timing conflict detection prevents scheduling overlaps
- [x] Task templates can be imported and customized for different wedding types
- [x] Dependencies between tasks are validated (Task B cannot start before Task A completes)
- [x] Rich text editor supports formatted task instructions
- [x] Photo attachments can be added to provide visual references
- [x] Bulk import from CSV/Excel files works correctly
- [x] Performance: Task creation completes in <1s, conflict detection in <500ms
- [x] Security: All tasks are scoped to couple_id with RLS policies
- [x] Accessibility: Keyboard navigation and screen reader support

### DEPENDENCIES
- Must complete after: None (foundational feature)
- Must complete before: WS-157 (Helper Assignment), WS-158 (Task Categories), WS-159 (Task Tracking)
- Shares code with: Task delegation and timeline features

### ESTIMATED EFFORT
- Team A Frontend: 20 hours
- Team B Backend: 16 hours
- Team C Integration: 10 hours
- Total: 46 hours