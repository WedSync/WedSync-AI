# TECHNICAL SPECIFICATION: WS-198 - Error Handling System
## Generated by Feature Development Session - August 25, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** WedSync platform reliability engineer ensuring robust error handling across all user interactions
**I want to:** Implement comprehensive error handling with graceful failures, detailed logging, and user-friendly messaging
**So that:** I can ensure that when a photographer supplier experiences an API timeout while uploading portfolio images, they receive clear guidance and automatic retry options; when couples encounter validation errors submitting wedding forms, they see specific field-level feedback; and when system errors occur during peak wedding season, detailed logs help developers quickly resolve issues without affecting other users

**Real Wedding Scenario:**
During peak wedding booking season, a venue supplier attempts to upload 50 high-resolution photos to their portfolio at 2 PM when the system is under heavy load. The upload service times out after 30 seconds, but instead of a generic error page, the error handling system shows a clear message: "Upload temporarily unavailable - we're processing high traffic. Your photos are safe, we'll retry automatically in 60 seconds." The error is logged with full context (user ID, file sizes, server load metrics) to help developers optimize the upload service. Meanwhile, couples submitting consultation forms receive instant validation feedback for missing fields like "Wedding date is required" rather than cryptic server errors, ensuring their booking process continues smoothly.

### SPECIFICATION SOURCE
- **Feature ID:** WS-198
- **Original Spec:** /CORE-SPECIFICATIONS/01-TECHNICAL-ARCHITECTURE/03-API-Architecture/03-error-handling md.md
- **Current Implementation:** 0% complete (new)
- **Files to Modify:** None (new feature)
- **New Files to Create:** 
  - `/wedsync/lib/errors/api-error-handler.ts`
  - `/wedsync/lib/errors/error-codes.ts`
  - `/wedsync/lib/errors/error-logger.ts`
  - `/wedsync/components/error-boundary/ErrorBoundary.tsx`
  - `/wedsync/hooks/useErrorHandler.ts`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Comprehensive error tracking for wedding platform
CREATE TABLE error_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  error_id UUID UNIQUE NOT NULL DEFAULT gen_random_uuid(), -- For user reference
  
  -- Error classification
  error_code TEXT NOT NULL, -- 'FORM_NOT_FOUND', 'UPLOAD_FAILED', etc.
  error_type TEXT NOT NULL CHECK (error_type IN (
    'validation', 'authentication', 'authorization', 'not_found', 
    'rate_limit', 'payment', 'external_service', 'database', 
    'file_upload', 'network', 'timeout', 'internal'
  )),
  severity TEXT NOT NULL CHECK (severity IN ('low', 'medium', 'high', 'critical')),
  
  -- Error details
  message TEXT NOT NULL, -- User-friendly message
  technical_message TEXT, -- Technical details for developers
  stack_trace TEXT,
  
  -- Request context
  request_id UUID,
  endpoint TEXT,
  method TEXT,
  user_agent TEXT,
  ip_address INET,
  
  -- User and business context
  user_id UUID REFERENCES users(id),
  supplier_id UUID REFERENCES suppliers(id),
  couple_id UUID REFERENCES couples(id),
  session_id TEXT,
  
  -- Wedding-specific context
  affected_form_id UUID REFERENCES forms(id),
  affected_client_id UUID REFERENCES clients(id),
  wedding_date DATE, -- If error affects specific wedding
  vendor_type TEXT, -- 'photographer', 'venue', 'catering', etc.
  
  -- Error resolution
  status TEXT DEFAULT 'new' CHECK (status IN ('new', 'investigating', 'resolved', 'ignored')),
  resolution_notes TEXT,
  resolved_at TIMESTAMPTZ,
  resolved_by UUID REFERENCES users(id),
  
  -- Performance impact
  response_time_ms INTEGER,
  memory_usage_mb DECIMAL(8,2),
  cpu_usage_percent DECIMAL(5,2),
  concurrent_users INTEGER,
  
  -- Retry and recovery
  retry_count INTEGER DEFAULT 0,
  auto_retry_enabled BOOLEAN DEFAULT FALSE,
  last_retry_at TIMESTAMPTZ,
  recovery_action_taken TEXT,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_error_logs_code ON error_logs(error_code, created_at DESC);
CREATE INDEX idx_error_logs_severity ON error_logs(severity, created_at DESC);
CREATE INDEX idx_error_logs_user ON error_logs(user_id, created_at DESC);
CREATE INDEX idx_error_logs_supplier ON error_logs(supplier_id, created_at DESC);
CREATE INDEX idx_error_logs_unresolved ON error_logs(status, created_at DESC) WHERE status IN ('new', 'investigating');

-- Error pattern detection for proactive monitoring
CREATE TABLE error_patterns (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  pattern_name TEXT UNIQUE NOT NULL,
  
  -- Pattern definition
  error_codes TEXT[] NOT NULL, -- Codes that trigger this pattern
  time_window_minutes INTEGER NOT NULL, -- Detection window
  occurrence_threshold INTEGER NOT NULL, -- Minimum occurrences to trigger
  
  -- Context matching
  endpoint_pattern TEXT, -- Regex pattern for endpoints
  user_type_filter TEXT[], -- ['supplier', 'couple'] to filter by user type
  vendor_type_filter TEXT[], -- ['photographer', 'venue'] to filter by vendor
  
  -- Alert configuration
  alert_enabled BOOLEAN DEFAULT TRUE,
  alert_severity TEXT CHECK (alert_severity IN ('low', 'medium', 'high', 'critical')),
  notification_channels TEXT[], -- ['email', 'slack', 'sms', 'webhook']
  
  -- Pattern status
  is_active BOOLEAN DEFAULT TRUE,
  last_triggered TIMESTAMPTZ,
  trigger_count INTEGER DEFAULT 0,
  
  -- Pattern learning
  false_positive_count INTEGER DEFAULT 0,
  accuracy_score DECIMAL(5,4), -- Pattern accuracy based on resolved errors
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Error recovery strategies
CREATE TABLE error_recovery_strategies (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  error_code TEXT NOT NULL, -- Error code this strategy applies to
  
  -- Recovery configuration
  strategy_name TEXT NOT NULL, -- 'auto_retry', 'fallback_service', 'graceful_degradation'
  max_retries INTEGER DEFAULT 3,
  retry_delay_seconds INTEGER DEFAULT 60,
  exponential_backoff BOOLEAN DEFAULT TRUE,
  
  -- Conditions for strategy application
  applies_to_user_types TEXT[], -- ['supplier', 'couple']
  applies_to_endpoints TEXT[], -- Endpoint patterns
  business_hours_only BOOLEAN DEFAULT FALSE,
  
  -- Success metrics
  recovery_success_rate DECIMAL(5,4),
  average_recovery_time_seconds INTEGER,
  
  -- Strategy status
  is_enabled BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(error_code, strategy_name)
);

-- User-facing error communications
CREATE TABLE error_user_communications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  error_log_id UUID NOT NULL REFERENCES error_logs(id),
  
  -- Communication details
  communication_type TEXT NOT NULL CHECK (communication_type IN (
    'toast_notification', 'modal_dialog', 'email_notification', 
    'in_app_banner', 'support_ticket_creation'
  )),
  
  -- Message content
  user_message TEXT NOT NULL, -- User-friendly error message
  recommended_actions TEXT[], -- Steps user can take
  support_contact_info JSONB, -- Contact details for support
  
  -- Display configuration
  display_duration_seconds INTEGER, -- How long to show the message
  can_dismiss BOOLEAN DEFAULT TRUE,
  show_retry_button BOOLEAN DEFAULT FALSE,
  show_support_button BOOLEAN DEFAULT TRUE,
  
  -- Tracking
  was_displayed BOOLEAN DEFAULT FALSE,
  dismissed_by_user BOOLEAN DEFAULT FALSE,
  user_took_action BOOLEAN DEFAULT FALSE,
  action_taken TEXT, -- 'retry', 'contact_support', 'dismiss', etc.
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Error resolution knowledge base
CREATE TABLE error_resolution_knowledge (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  error_code TEXT NOT NULL,
  
  -- Resolution information
  solution_title TEXT NOT NULL,
  solution_description TEXT NOT NULL,
  step_by_step_guide TEXT[],
  
  -- Context and applicability
  applies_to_user_types TEXT[],
  applies_to_vendor_types TEXT[],
  common_causes TEXT[],
  prevention_tips TEXT[],
  
  -- Effectiveness tracking
  resolution_success_rate DECIMAL(5,4),
  average_resolution_time_minutes INTEGER,
  user_satisfaction_score DECIMAL(3,2), -- 1-5 rating
  
  -- Content management
  is_public BOOLEAN DEFAULT FALSE, -- Show to users or internal only
  created_by UUID REFERENCES users(id),
  last_updated_by UUID REFERENCES users(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

#### API Endpoints Required
```typescript
// Error handling and reporting endpoints
// POST /api/errors/report
interface ReportErrorRequest {
  errorCode: string;
  message: string;
  context?: {
    formId?: string;
    clientId?: string;
    action?: string;
    additionalData?: Record<string, any>;
  };
}

// GET /api/errors/user-guidance/{errorCode}
interface ErrorGuidanceResponse {
  success: boolean;
  data: {
    userMessage: string;
    recommendedActions: string[];
    canRetry: boolean;
    supportInfo: {
      contactMethod: 'chat' | 'email' | 'phone';
      expectedResponseTime: string;
    };
    resolutionSteps?: string[];
  };
}

// GET /api/admin/errors/analytics
interface ErrorAnalyticsResponse {
  success: boolean;
  data: {
    errorsByType: ErrorTypeMetrics[];
    errorTrends: ErrorTrendData[];
    topErrors: TopErrorData[];
    resolutionMetrics: ResolutionMetrics;
  };
}
```

#### Frontend Components Required
```typescript
// Component: ErrorBoundary
// Location: /src/components/error-boundary/ErrorBoundary.tsx

interface Props {
  fallback?: React.ComponentType<ErrorInfo>;
  onError?: (error: Error, errorInfo: ErrorInfo) => void;
  context?: 'supplier_dashboard' | 'couple_forms' | 'admin_panel';
}

// Key functionality:
- Catch JavaScript errors in component tree with wedding-specific context
- Display user-friendly error messages with recovery options
- Log errors with business context (supplier/couple workflows)
- Provide retry mechanisms and fallback UI for critical workflows
```

#### Integration Points
```typescript
// Service: ErrorHandler
// Dependencies: Logging service, notification system, error recovery strategies

class ErrorHandler {
  async handleAPIError(error: APIError, context: ErrorContext): Promise<ErrorResponse> {
    // Comprehensive error handling with business context and recovery strategies
  }
  
  async logError(error: Error, context: ErrorContext): Promise<void> {
    // Detailed error logging with wedding industry context
  }
}
```

### CODE EXAMPLES

#### Example 1: Comprehensive Error Handling System
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
// lib/errors/api-error-handler.ts

import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { createClient } from '@supabase/supabase-js';
import { v4 as uuidv4 } from 'uuid';

// Wedding industry specific error codes
export enum WedSyncErrorCode {
  // Authentication & Authorization
  AUTH_REQUIRED = 'AUTH_REQUIRED',
  INSUFFICIENT_PERMISSIONS = 'INSUFFICIENT_PERMISSIONS',
  SESSION_EXPIRED = 'SESSION_EXPIRED',
  INVALID_SUPPLIER_ACCESS = 'INVALID_SUPPLIER_ACCESS',
  
  // Resource Management
  FORM_NOT_FOUND = 'FORM_NOT_FOUND',
  CLIENT_NOT_FOUND = 'CLIENT_NOT_FOUND',
  SUPPLIER_NOT_FOUND = 'SUPPLIER_NOT_FOUND',
  WEDDING_DATE_CONFLICT = 'WEDDING_DATE_CONFLICT',
  
  // Validation Errors
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  INVALID_WEDDING_DATE = 'INVALID_WEDDING_DATE',
  GUEST_COUNT_INVALID = 'GUEST_COUNT_INVALID',
  BUDGET_RANGE_INVALID = 'BUDGET_RANGE_INVALID',
  
  // Business Logic
  BOOKING_UNAVAILABLE = 'BOOKING_UNAVAILABLE',
  CAPACITY_EXCEEDED = 'CAPACITY_EXCEEDED',
  PAYMENT_REQUIRED = 'PAYMENT_REQUIRED',
  FEATURE_NOT_AVAILABLE = 'FEATURE_NOT_AVAILABLE',
  
  // External Services
  UPLOAD_FAILED = 'UPLOAD_FAILED',
  EMAIL_DELIVERY_FAILED = 'EMAIL_DELIVERY_FAILED',
  SMS_DELIVERY_FAILED = 'SMS_DELIVERY_FAILED',
  PAYMENT_PROCESSING_ERROR = 'PAYMENT_PROCESSING_ERROR',
  
  // System Errors
  DATABASE_ERROR = 'DATABASE_ERROR',
  RATE_LIMIT_EXCEEDED = 'RATE_LIMIT_EXCEEDED',
  TIMEOUT_ERROR = 'TIMEOUT_ERROR',
  INTERNAL_SERVER_ERROR = 'INTERNAL_SERVER_ERROR',
}

// Enhanced API Error class for wedding industry context
export class WedSyncAPIError extends Error {
  public readonly errorId: string;
  public readonly timestamp: string;
  public readonly context: ErrorContext;

  constructor(
    public readonly statusCode: number,
    public readonly code: WedSyncErrorCode,
    public readonly userMessage: string,
    public readonly technicalMessage?: string,
    public readonly details?: Record<string, any>,
    context?: Partial<ErrorContext>
  ) {
    super(userMessage);
    this.name = 'WedSyncAPIError';
    this.errorId = uuidv4();
    this.timestamp = new Date().toISOString();
    this.context = {
      requestId: context?.requestId || uuidv4(),
      userId: context?.userId,
      supplierId: context?.supplierId,
      coupleId: context?.coupleId,
      endpoint: context?.endpoint,
      method: context?.method,
      userAgent: context?.userAgent,
      ipAddress: context?.ipAddress,
      ...context
    };
  }

  // Factory methods for common wedding industry errors
  static formNotFound(formId: string, context?: Partial<ErrorContext>): WedSyncAPIError {
    return new WedSyncAPIError(
      404,
      WedSyncErrorCode.FORM_NOT_FOUND,
      'The requested form could not be found. It may have been deleted or you may not have access.',
      `Form with ID ${formId} not found in database`,
      { formId },
      context
    );
  }

  static invalidWeddingDate(date: string, context?: Partial<ErrorContext>): WedSyncAPIError {
    return new WedSyncAPIError(
      400,
      WedSyncErrorCode.INVALID_WEDDING_DATE,
      'Wedding date must be at least 30 days in the future and within the next 5 years.',
      `Invalid wedding date provided: ${date}`,
      { providedDate: date, minimumDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) },
      context
    );
  }

  static bookingUnavailable(vendorType: string, requestedDate: string, context?: Partial<ErrorContext>): WedSyncAPIError {
    return new WedSyncAPIError(
      409,
      WedSyncErrorCode.BOOKING_UNAVAILABLE,
      `This ${vendorType} is already booked for ${requestedDate}. Please select a different date or vendor.`,
      `Booking conflict for ${vendorType} on ${requestedDate}`,
      { vendorType, requestedDate },
      context
    );
  }

  static uploadFailed(fileName: string, reason: string, context?: Partial<ErrorContext>): WedSyncAPIError {
    return new WedSyncAPIError(
      500,
      WedSyncErrorCode.UPLOAD_FAILED,
      `Failed to upload ${fileName}. Please check your internet connection and try again.`,
      `File upload failed: ${reason}`,
      { fileName, failureReason: reason },
      context
    );
  }

  static paymentRequired(feature: string, requiredTier: string, context?: Partial<ErrorContext>): WedSyncAPIError {
    return new WedSyncAPIError(
      402,
      WedSyncErrorCode.PAYMENT_REQUIRED,
      `${feature} is only available on ${requiredTier} plans and above. Please upgrade to continue.`,
      `Feature ${feature} requires ${requiredTier} subscription`,
      { feature, requiredTier },
      context
    );
  }
}

// Comprehensive error handler with wedding industry context
export class ErrorHandler {
  private supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_KEY!
  );

  async handleError(error: unknown, request: NextRequest): Promise<NextResponse> {
    const context = this.extractErrorContext(request);
    
    try {
      if (error instanceof WedSyncAPIError) {
        return await this.handleAPIError(error, context);
      }

      if (error instanceof z.ZodError) {
        return await this.handleValidationError(error, context);
      }

      // Handle unexpected errors
      return await this.handleUnexpectedError(error, context);
    } catch (handlingError) {
      // Last resort error handling
      console.error('Error in error handler:', handlingError);
      return this.createFallbackErrorResponse(context);
    }
  }

  private async handleAPIError(error: WedSyncAPIError, context: ErrorContext): Promise<NextResponse> {
    // Log the error with full context
    await this.logError(error, context);

    // Get user-friendly guidance
    const userGuidance = await this.getUserGuidance(error.code, context);

    // Check if automatic recovery is available
    const recoveryStrategy = await this.getRecoveryStrategy(error.code, context);

    // Prepare error response with wedding industry context
    const errorResponse = {
      error: {
        id: error.errorId,
        code: error.code,
        message: error.userMessage,
        timestamp: error.timestamp,
        requestId: context.requestId,
        guidance: userGuidance,
        recovery: recoveryStrategy ? {
          canRetry: recoveryStrategy.canRetry,
          retryAfterSeconds: recoveryStrategy.retryDelay,
          maxRetries: recoveryStrategy.maxRetries
        } : undefined
      }
    };

    // Add recovery headers if applicable
    const response = NextResponse.json(errorResponse, { status: error.statusCode });
    
    if (recoveryStrategy?.canRetry) {
      response.headers.set('Retry-After', recoveryStrategy.retryDelay.toString());
      response.headers.set('X-Max-Retries', recoveryStrategy.maxRetries.toString());
    }

    // Send user notification if needed
    await this.sendUserNotification(error, context, userGuidance);

    return response;
  }

  private async handleValidationError(zodError: z.ZodError, context: ErrorContext): Promise<NextResponse> {
    const validationError = new WedSyncAPIError(
      400,
      WedSyncErrorCode.VALIDATION_ERROR,
      'Please check your input and try again.',
      'Request validation failed',
      {
        validationErrors: zodError.errors.map(err => ({
          field: err.path.join('.'),
          message: this.getWeddingFriendlyValidationMessage(err),
          code: err.code
        }))
      },
      context
    );

    return this.handleAPIError(validationError, context);
  }

  private async handleUnexpectedError(error: unknown, context: ErrorContext): Promise<NextResponse> {
    const unexpectedError = new WedSyncAPIError(
      500,
      WedSyncErrorCode.INTERNAL_SERVER_ERROR,
      'Something went wrong on our end. Our team has been notified and will fix this shortly.',
      error instanceof Error ? error.message : 'Unknown error occurred',
      {
        stack: error instanceof Error ? error.stack : undefined,
        errorType: typeof error,
        errorString: String(error)
      },
      context
    );

    // Critical errors need immediate attention
    await this.alertDevelopmentTeam(unexpectedError, context);

    return this.handleAPIError(unexpectedError, context);
  }

  private async logError(error: WedSyncAPIError, context: ErrorContext): Promise<void> {
    try {
      const errorLogData = {
        error_id: error.errorId,
        error_code: error.code,
        error_type: this.categorizeError(error.code),
        severity: this.determineSeverity(error.code, error.statusCode),
        message: error.userMessage,
        technical_message: error.technicalMessage,
        stack_trace: error.stack,
        
        // Request context
        request_id: context.requestId,
        endpoint: context.endpoint,
        method: context.method,
        user_agent: context.userAgent,
        ip_address: context.ipAddress,
        
        // User context
        user_id: context.userId,
        supplier_id: context.supplierId,
        couple_id: context.coupleId,
        session_id: context.sessionId,
        
        // Wedding industry context
        affected_form_id: error.details?.formId,
        affected_client_id: error.details?.clientId,
        wedding_date: error.details?.requestedDate,
        vendor_type: error.details?.vendorType,
        
        // Performance context
        response_time_ms: Date.now() - (context.requestStartTime || Date.now()),
        concurrent_users: context.concurrentUsers,
        
        // Recovery settings
        auto_retry_enabled: await this.isAutoRetryEnabled(error.code)
      };

      await this.supabase
        .from('error_logs')
        .insert(errorLogData);

      // Check for error patterns
      await this.checkErrorPatterns(error.code, context);
      
    } catch (loggingError) {
      console.error('Failed to log error:', loggingError);
      // Don't fail the request if logging fails
    }
  }

  private async getUserGuidance(errorCode: WedSyncErrorCode, context: ErrorContext): Promise<UserGuidance> {
    try {
      const { data: guidance } = await this.supabase
        .from('error_resolution_knowledge')
        .select('*')
        .eq('error_code', errorCode)
        .eq('is_public', true)
        .single();

      if (guidance) {
        return {
          message: guidance.solution_description,
          actions: guidance.step_by_step_guide,
          preventionTips: guidance.prevention_tips
        };
      }
    } catch (error) {
      console.warn('Failed to fetch user guidance:', error);
    }

    // Fallback to default guidance
    return this.getDefaultUserGuidance(errorCode, context);
  }

  private getDefaultUserGuidance(errorCode: WedSyncErrorCode, context: ErrorContext): UserGuidance {
    const guidanceMap: Record<WedSyncErrorCode, UserGuidance> = {
      [WedSyncErrorCode.FORM_NOT_FOUND]: {
        message: 'The form you\'re looking for might have been moved or deleted.',
        actions: [
          'Check if you have the correct link',
          'Contact your supplier if this was shared with you',
          'Try refreshing the page'
        ]
      },
      [WedSyncErrorCode.UPLOAD_FAILED]: {
        message: 'File upload failed, likely due to network issues or file size.',
        actions: [
          'Check your internet connection',
          'Ensure the file is under 10MB',
          'Try uploading again in a few minutes'
        ]
      },
      [WedSyncErrorCode.PAYMENT_REQUIRED]: {
        message: 'This feature requires a paid subscription.',
        actions: [
          'Upgrade your subscription in Settings',
          'Contact sales for custom pricing',
          'Try the feature again after upgrading'
        ]
      },
      [WedSyncErrorCode.BOOKING_UNAVAILABLE]: {
        message: 'The requested date is not available.',
        actions: [
          'Select a different date',
          'Contact the vendor directly',
          'Check alternative vendors'
        ]
      }
    };

    return guidanceMap[errorCode] || {
      message: 'An error occurred. Please try again.',
      actions: ['Refresh the page', 'Contact support if the problem persists']
    };
  }

  private async getRecoveryStrategy(errorCode: WedSyncErrorCode, context: ErrorContext): Promise<RecoveryStrategy | null> {
    try {
      const { data: strategy } = await this.supabase
        .from('error_recovery_strategies')
        .select('*')
        .eq('error_code', errorCode)
        .eq('is_enabled', true)
        .single();

      if (strategy) {
        return {
          canRetry: strategy.max_retries > 0,
          maxRetries: strategy.max_retries,
          retryDelay: strategy.retry_delay_seconds,
          useExponentialBackoff: strategy.exponential_backoff
        };
      }
    } catch (error) {
      console.warn('Failed to fetch recovery strategy:', error);
    }

    return null;
  }

  private getWeddingFriendlyValidationMessage(zodError: z.ZodIssue): string {
    const fieldName = zodError.path[zodError.path.length - 1];
    
    const weddingFieldMessages: Record<string, string> = {
      wedding_date: 'Please enter a valid wedding date',
      guest_count: 'Guest count must be a positive number',
      couple_name: 'Please enter the couple\'s names',
      venue_name: 'Venue name is required',
      budget_range: 'Please select a budget range',
      contact_email: 'Please enter a valid email address',
      phone_number: 'Please enter a valid phone number'
    };

    return weddingFieldMessages[String(fieldName)] || zodError.message;
  }

  private categorizeError(code: WedSyncErrorCode): string {
    const categoryMap: Record<string, string> = {
      AUTH_REQUIRED: 'authentication',
      INSUFFICIENT_PERMISSIONS: 'authorization',
      FORM_NOT_FOUND: 'not_found',
      VALIDATION_ERROR: 'validation',
      UPLOAD_FAILED: 'file_upload',
      PAYMENT_REQUIRED: 'payment',
      RATE_LIMIT_EXCEEDED: 'rate_limit',
      INTERNAL_SERVER_ERROR: 'internal'
    };

    return categoryMap[code] || 'unknown';
  }

  private determineSeverity(code: WedSyncErrorCode, statusCode: number): string {
    if (statusCode >= 500) return 'high';
    if (statusCode >= 400 && statusCode < 500) return 'medium';
    return 'low';
  }

  private extractErrorContext(request: NextRequest): ErrorContext {
    return {
      requestId: request.headers.get('x-request-id') || uuidv4(),
      endpoint: request.nextUrl.pathname,
      method: request.method,
      userAgent: request.headers.get('user-agent'),
      ipAddress: request.headers.get('x-forwarded-for')?.split(',')[0] || request.ip,
      userId: request.headers.get('x-user-id'),
      supplierId: request.headers.get('x-supplier-id'),
      sessionId: request.headers.get('x-session-id'),
      requestStartTime: parseInt(request.headers.get('x-request-start') || '0') || Date.now()
    };
  }

  private createFallbackErrorResponse(context: ErrorContext): NextResponse {
    return NextResponse.json({
      error: {
        id: uuidv4(),
        code: 'SYSTEM_ERROR',
        message: 'A system error occurred. Please contact support.',
        timestamp: new Date().toISOString(),
        requestId: context.requestId
      }
    }, { status: 500 });
  }
}

// Types for error handling
interface ErrorContext {
  requestId: string;
  userId?: string;
  supplierId?: string;
  coupleId?: string;
  endpoint?: string;
  method?: string;
  userAgent?: string;
  ipAddress?: string;
  sessionId?: string;
  requestStartTime?: number;
  concurrentUsers?: number;
}

interface UserGuidance {
  message: string;
  actions: string[];
  preventionTips?: string[];
}

interface RecoveryStrategy {
  canRetry: boolean;
  maxRetries: number;
  retryDelay: number;
  useExponentialBackoff: boolean;
}

// Export the main error handler instance
export const errorHandler = new ErrorHandler();

// Utility function for route handlers
export function createErrorHandler() {
  return async (error: unknown, request: NextRequest): Promise<NextResponse> => {
    return errorHandler.handleError(error, request);
  };
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for error handling patterns, logging best practices
- [x] Supabase: Error logging and pattern detection storage
- [x] Notification systems: Slack/email for critical error alerting

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/vercel/next.js", "error handling", 3000);
await mcp__context7__get-library-docs("/sentry/sentry", "error tracking", 3000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('Error Handling System', () => {
  it('should handle wedding form validation errors with user-friendly messages', () => {
    // Test comprehensive validation error handling for wedding forms
  });
  
  it('should implement automatic retry for upload failures', () => {
    // Test error recovery strategies for file uploads
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Error handling shows appropriate messages for different user types', async () => {
  // Test error messages for suppliers vs couples
  await mcp__playwright__browser_navigate({url: '/forms/invalid-form-id'});
  
  await expect(page.locator('[data-testid="error-message"]')).toContainText(
    'The form you\'re looking for might have been moved or deleted'
  );
  
  await expect(page.locator('[data-testid="retry-button"]')).toBeVisible();
});
```

### ACCEPTANCE CRITERIA
- [x] Error handling provides user-friendly messages specific to wedding industry workflows (forms, bookings, uploads)
- [x] All errors logged with comprehensive context including supplier/couple business information
- [x] Automatic retry mechanisms for recoverable errors with exponential backoff strategies
- [x] Performance: Error logging adds less than 10ms overhead to request processing
- [x] Security: Error messages never expose sensitive data or technical implementation details
- [x] Accessibility: Error messages work with screen readers and provide clear actionable guidance

### DEPENDENCIES
- Must complete after: WS-196 (API Routes Structure), WS-197 (Middleware Setup) - provides error context and logging pipeline
- Must complete before: All API endpoint development, frontend error boundaries
- Shares code with: Logging system, notification infrastructure, user feedback mechanisms

### ESTIMATED EFFORT
- Team A Backend: 48 hours (Error classification, logging, recovery strategies)
- Team D Frontend: 32 hours (Error boundary components, user guidance UI)
- Total: 80 hours