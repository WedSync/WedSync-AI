# TECHNICAL SPECIFICATION: WS-145 - Performance Optimization Targets
## Generated by Feature Development Session - 2025-01-24

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding supplier using WedSync on my phone during events
**I want to:** The app to load and respond instantly, even on slower connections
**So that:** I can quickly access client information and update details without delays that frustrate couples

**Real Wedding Scenario:**
Sarah is shooting a wedding and needs to quickly check the timeline between ceremony and cocktail hour. She opens WedSync on her iPhone while using the venue's slow WiFi. The app loads in under 2 seconds, shows the cached timeline instantly, and when she updates the couple's preferred shot, it saves immediately with an optimistic UI update. No waiting, no frustration, professional efficiency.

### SPECIFICATION SOURCE
- **Feature ID:** WS-145
- **Original Spec:** /CORE-SPECIFICATIONS/09-MOBILE-OPTIMIZATION/05-performance-targets md.md
- **Current Implementation:** 30% complete (basic Next.js optimizations)
- **Files to Modify:** 
  - /wedsync/next.config.js (performance configuration)
  - /wedsync/package.json (bundle analyzer, lighthouse CI)
- **New Files to Create:** 
  - /src/lib/performance/web-vitals-tracker.ts
  - /src/lib/performance/resource-monitor.ts
  - /src/lib/performance/bundle-analyzer.ts
  - /src/components/performance/PerformanceMonitor.tsx
  - /src/hooks/usePerformanceTracking.ts
  - /.github/workflows/performance-ci.yml

### TECHNICAL DESIGN

#### Performance Budget Configuration
```javascript
// next.config.js performance enhancements
const nextConfig = {
  // Bundle optimization
  webpack: (config, { isServer }) => {
    // Bundle analyzer in development
    if (process.env.ANALYZE === 'true') {
      const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;
      config.plugins.push(
        new BundleAnalyzerPlugin({
          analyzerMode: 'static',
          openAnalyzer: false,
          generateStatsFile: true
        })
      );
    }

    // Performance budgets
    config.performance = {
      maxAssetSize: 250000, // 250KB per asset
      maxEntrypointSize: 400000, // 400KB per entry
      hints: 'error'
    };

    if (!isServer) {
      // Split vendor bundle
      config.optimization.splitChunks = {
        cacheGroups: {
          vendor: {
            test: /[\\/]node_modules[\\/]/,
            name: 'vendors',
            chunks: 'all',
            maxSize: 300000 // 300KB vendor bundle limit
          }
        }
      };
    }

    return config;
  },

  // Image optimization
  images: {
    deviceSizes: [640, 750, 828, 1080, 1200],
    imageSizes: [16, 32, 48, 64, 96, 128, 256],
    formats: ['image/webp', 'image/avif'],
    minimumCacheTTL: 60 * 60 * 24 * 30, // 30 days
    dangerouslyAllowSVG: false
  },

  // Compression
  compress: true,
  
  // Headers for performance
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: [
          {
            key: 'Cache-Control',
            value: 'public, max-age=31536000, immutable'
          },
          {
            key: 'Strict-Transport-Security',
            value: 'max-age=63072000; includeSubDomains; preload'
          }
        ]
      }
    ];
  },

  // Code splitting configuration
  experimental: {
    optimizeCss: true,
    optimizeServerReact: true,
    serverComponentsExternalPackages: ['@supabase/supabase-js']
  }
};
```

#### Core Web Vitals Targets
```typescript
// Performance budget targets
export const PERFORMANCE_TARGETS = {
  // Core Web Vitals (Google requirements)
  LCP: {
    good: 2500,    // Largest Contentful Paint < 2.5s
    poor: 4000,    // > 4s is poor
    mobile: 3000   // Slightly relaxed for mobile
  },
  FID: {
    good: 100,     // First Input Delay < 100ms
    poor: 300,     // > 300ms is poor
    mobile: 100    // Same for mobile
  },
  CLS: {
    good: 0.1,     // Cumulative Layout Shift < 0.1
    poor: 0.25,    // > 0.25 is poor
    mobile: 0.1    // Same for mobile
  },
  
  // Additional performance metrics
  FCP: {
    good: 1800,    // First Contentful Paint < 1.8s
    poor: 3000,
    mobile: 2500
  },
  TTFB: {
    good: 600,     // Time to First Byte < 600ms
    poor: 1200,
    mobile: 800
  },
  TTI: {
    good: 3800,    // Time to Interactive < 3.8s
    poor: 7300,
    mobile: 5000
  },

  // Page-specific targets
  pages: {
    dashboard: {
      initialLoad: 2000,      // Critical path
      fullyInteractive: 3500,
      dataFetch: 1000
    },
    formBuilder: {
      initialLoad: 1500,      // Must feel instant
      dragDropReady: 2000,
      autoSave: 500
    },
    weddingDay: {
      coldStart: 1000,        // Urgent access needed
      offlineReady: 2000,
      syncTime: 5000
    }
  }
} as const;

// Bundle size targets
export const BUNDLE_TARGETS = {
  main: 200000,      // 200KB main bundle
  vendor: 300000,    // 300KB vendor bundle
  forms: 150000,     // 150KB forms module
  dashboard: 180000, // 180KB dashboard module
  total: 800000      // 800KB total JS
} as const;
```

#### Performance Monitoring System
```typescript
// Real-time performance tracking
export class PerformanceMonitor {
  private metrics: Map<string, number[]> = new Map();
  private thresholds = PERFORMANCE_TARGETS;

  constructor() {
    this.initializeWebVitals();
    this.setupResourceMonitoring();
    this.trackUserInteractions();
  }

  private initializeWebVitals() {
    // Core Web Vitals tracking
    if (typeof window !== 'undefined') {
      import('web-vitals').then(({ onCLS, onFCP, onFID, onLCP, onTTFB }) => {
        onLCP(this.handleLCP.bind(this));
        onFID(this.handleFID.bind(this));
        onCLS(this.handleCLS.bind(this));
        onFCP(this.handleFCP.bind(this));
        onTTFB(this.handleTTFB.bind(this));
      });
    }
  }

  private handleLCP(metric: any) {
    this.recordMetric('LCP', metric.value);
    
    if (metric.value > this.thresholds.LCP.poor) {
      this.triggerAlert('LCP', metric.value, 'Poor LCP detected');
    }
    
    this.sendToAnalytics('web-vital', {
      name: 'LCP',
      value: metric.value,
      rating: this.getRating('LCP', metric.value),
      id: metric.id,
      delta: metric.delta
    });
  }

  private handleFID(metric: any) {
    this.recordMetric('FID', metric.value);
    
    if (metric.value > this.thresholds.FID.poor) {
      this.triggerAlert('FID', metric.value, 'Poor interactivity detected');
    }
    
    this.sendToAnalytics('web-vital', {
      name: 'FID',
      value: metric.value,
      rating: this.getRating('FID', metric.value),
      id: metric.id
    });
  }

  private setupResourceMonitoring() {
    if (typeof window !== 'undefined' && 'PerformanceObserver' in window) {
      // Monitor resource loading
      const resourceObserver = new PerformanceObserver((list) => {
        list.getEntries().forEach((entry) => {
          this.analyzeResourceTiming(entry as PerformanceResourceTiming);
        });
      });
      resourceObserver.observe({ entryTypes: ['resource'] });

      // Monitor navigation timing
      const navObserver = new PerformanceObserver((list) => {
        list.getEntries().forEach((entry) => {
          this.analyzeNavigationTiming(entry as PerformanceNavigationTiming);
        });
      });
      navObserver.observe({ entryTypes: ['navigation'] });
    }
  }

  private analyzeResourceTiming(entry: PerformanceResourceTiming) {
    const resourceType = this.getResourceType(entry.name);
    const loadTime = entry.responseEnd - entry.startTime;
    
    // Track slow resources
    if (loadTime > 2000) { // > 2 seconds
      this.sendToAnalytics('slow-resource', {
        name: entry.name,
        type: resourceType,
        loadTime,
        size: entry.transferSize,
        cached: entry.transferSize === 0
      });
    }

    // Track bundle sizes
    if (resourceType === 'script' && entry.transferSize) {
      this.recordMetric('bundle-size', entry.transferSize);
      
      if (entry.transferSize > 300000) { // > 300KB
        console.warn(`Large bundle detected: ${entry.name} (${entry.transferSize} bytes)`);
      }
    }
  }

  async measurePageLoad(pageName: string): Promise<PageLoadMetrics> {
    const startTime = performance.now();
    
    return new Promise((resolve) => {
      const observer = new PerformanceObserver((list) => {
        const entry = list.getEntries()[0] as PerformanceNavigationTiming;
        
        const metrics: PageLoadMetrics = {
          page: pageName,
          dns: entry.domainLookupEnd - entry.domainLookupStart,
          connect: entry.connectEnd - entry.connectStart,
          ttfb: entry.responseStart - entry.requestStart,
          download: entry.responseEnd - entry.responseStart,
          domParse: entry.domContentLoadedEventEnd - entry.responseEnd,
          resource: entry.loadEventEnd - entry.domContentLoadedEventEnd,
          total: entry.loadEventEnd - entry.startTime
        };

        this.validateMetrics(metrics, pageName);
        resolve(metrics);
        observer.disconnect();
      });
      
      observer.observe({ entryTypes: ['navigation'] });
    });
  }

  private validateMetrics(metrics: PageLoadMetrics, pageName: string) {
    const targets = this.thresholds.pages[pageName as keyof typeof this.thresholds.pages];
    
    if (targets && metrics.total > targets.initialLoad) {
      this.triggerAlert('page-load', metrics.total, `Slow page load for ${pageName}`);
      
      // Identify bottlenecks
      const bottleneck = this.identifyBottleneck(metrics);
      this.sendToAnalytics('performance-issue', {
        page: pageName,
        bottleneck,
        metrics
      });
    }
  }

  private identifyBottleneck(metrics: PageLoadMetrics): string {
    const { dns, connect, ttfb, download, domParse, resource } = metrics;
    const max = Math.max(dns, connect, ttfb, download, domParse, resource);
    
    if (max === dns) return 'DNS lookup';
    if (max === connect) return 'Connection';
    if (max === ttfb) return 'Server response';
    if (max === download) return 'Content download';
    if (max === domParse) return 'DOM parsing';
    if (max === resource) return 'Resource loading';
    
    return 'Unknown';
  }
}

interface PageLoadMetrics {
  page: string;
  dns: number;
  connect: number;
  ttfb: number;
  download: number;
  domParse: number;
  resource: number;
  total: number;
}
```

#### React Performance Optimization
```typescript
// Component optimization utilities
export const ReactOptimizations = {
  // Memoization helpers
  memoizeExpensiveCalculation: <T, U>(
    fn: (input: T) => U,
    isEqual: (a: T, b: T) => boolean = Object.is
  ) => {
    let lastInput: T;
    let lastResult: U;
    let hasResult = false;

    return (input: T): U => {
      if (!hasResult || !isEqual(input, lastInput)) {
        lastInput = input;
        lastResult = fn(input);
        hasResult = true;
      }
      return lastResult;
    };
  },

  // Virtual scrolling for large lists
  VirtualizedList: React.memo(<T,>({
    items,
    itemHeight,
    containerHeight,
    renderItem
  }: {
    items: T[];
    itemHeight: number;
    containerHeight: number;
    renderItem: (item: T, index: number) => React.ReactNode;
  }) => {
    const [scrollTop, setScrollTop] = useState(0);
    
    const visibleStart = Math.floor(scrollTop / itemHeight);
    const visibleEnd = Math.min(
      visibleStart + Math.ceil(containerHeight / itemHeight) + 1,
      items.length
    );
    
    const visibleItems = items.slice(visibleStart, visibleEnd);
    
    return (
      <div
        style={{ height: containerHeight, overflow: 'auto' }}
        onScroll={(e) => setScrollTop(e.currentTarget.scrollTop)}
      >
        <div style={{ height: items.length * itemHeight, position: 'relative' }}>
          {visibleItems.map((item, index) => (
            <div
              key={visibleStart + index}
              style={{
                position: 'absolute',
                top: (visibleStart + index) * itemHeight,
                height: itemHeight,
                width: '100%'
              }}
            >
              {renderItem(item, visibleStart + index)}
            </div>
          ))}
        </div>
      </div>
    );
  }),

  // Debounced input for forms
  DebouncedInput: React.memo(({
    value,
    onChange,
    delay = 300,
    ...props
  }: {
    value: string;
    onChange: (value: string) => void;
    delay?: number;
  } & React.InputHTMLAttributes<HTMLInputElement>) => {
    const [localValue, setLocalValue] = useState(value);
    const timeoutRef = useRef<NodeJS.Timeout>();

    useEffect(() => {
      setLocalValue(value);
    }, [value]);

    const handleChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
      const newValue = e.target.value;
      setLocalValue(newValue);

      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }

      timeoutRef.current = setTimeout(() => {
        onChange(newValue);
      }, delay);
    }, [onChange, delay]);

    return (
      <input
        {...props}
        value={localValue}
        onChange={handleChange}
      />
    );
  }),

  // Optimistic UI updates
  useOptimisticUpdate: <T>(
    initialData: T,
    updateFn: (data: T) => Promise<T>
  ) => {
    const [data, setData] = useState(initialData);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState<Error | null>(null);

    const update = useCallback(async (optimisticData: T) => {
      // Immediately update UI
      setData(optimisticData);
      setIsLoading(true);
      setError(null);

      try {
        // Send to server
        const serverData = await updateFn(optimisticData);
        setData(serverData);
      } catch (err) {
        // Revert on error
        setData(initialData);
        setError(err as Error);
      } finally {
        setIsLoading(false);
      }
    }, [initialData, updateFn]);

    return { data, isLoading, error, update };
  }
};
```

### CODE EXAMPLES

#### Example 1: Automated Performance CI/CD Pipeline
```yaml
# ACTUAL CODE PATTERN TO FOLLOW:
# .github/workflows/performance-ci.yml
name: Performance CI
on:
  pull_request:
    branches: [main]
  push:
    branches: [main]

jobs:
  lighthouse:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Build application
        run: npm run build
        env:
          NODE_ENV: production
          
      - name: Start application
        run: npm start &
        env:
          PORT: 3000
          
      - name: Wait for app to be ready
        run: npx wait-on http://localhost:3000 --timeout 60000
        
      - name: Run Lighthouse CI
        run: |
          npm install -g @lhci/cli@0.12.x
          lhci autorun
        env:
          LHCI_GITHUB_APP_TOKEN: ${{ secrets.LHCI_GITHUB_APP_TOKEN }}
          
      - name: Check Performance Budget
        run: |
          # Parse Lighthouse results
          PERFORMANCE_SCORE=$(cat .lighthouseci/lhr-*.json | jq '.categories.performance.score * 100')
          echo "Performance score: $PERFORMANCE_SCORE"
          
          # Fail if below threshold
          if (( $(echo "$PERFORMANCE_SCORE < 90" | bc -l) )); then
            echo "❌ Performance score $PERFORMANCE_SCORE below 90"
            exit 1
          fi
          
          echo "✅ Performance score $PERFORMANCE_SCORE meets requirements"

  bundle-analysis:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Analyze bundle
        run: |
          ANALYZE=true npm run build
          
      - name: Check bundle size
        run: |
          # Parse webpack stats
          MAIN_SIZE=$(cat .next/analyze/client.json | jq '.assets[] | select(.name | test("main.*\\.js$")) | .size')
          VENDOR_SIZE=$(cat .next/analyze/client.json | jq '.assets[] | select(.name | test("vendors.*\\.js$")) | .size')
          
          echo "Main bundle: $MAIN_SIZE bytes"
          echo "Vendor bundle: $VENDOR_SIZE bytes"
          
          # Check against targets
          if [ $MAIN_SIZE -gt 200000 ]; then
            echo "❌ Main bundle exceeds 200KB limit"
            exit 1
          fi
          
          if [ $VENDOR_SIZE -gt 300000 ]; then
            echo "❌ Vendor bundle exceeds 300KB limit"
            exit 1
          fi
          
          echo "✅ Bundle sizes within limits"

  performance-testing:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run performance tests
        run: npm run test:performance
        
      - name: Upload performance report
        uses: actions/upload-artifact@v4
        with:
          name: performance-report
          path: performance-report.html
```

#### Example 2: Real-time Performance Monitoring Dashboard
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { useState, useEffect } from 'react';

interface PerformanceStats {
  currentMetrics: {
    lcp: number;
    fid: number;
    cls: number;
    ttfb: number;
  };
  trends: {
    pageLoads: Array<{ timestamp: number; duration: number; page: string }>;
    errors: Array<{ timestamp: number; message: string; page: string }>;
    slowQueries: Array<{ query: string; duration: number; timestamp: number }>;
  };
  resourceUsage: {
    bundleSize: number;
    cacheHitRate: number;
    memoryUsage: number;
    networkRequests: number;
  };
}

export function PerformanceDashboard() {
  const [stats, setStats] = useState<PerformanceStats | null>(null);
  const [isMonitoring, setIsMonitoring] = useState(false);

  useEffect(() => {
    let monitor: PerformanceMonitor;

    if (isMonitoring) {
      monitor = new PerformanceMonitor();
      
      // Update stats every 5 seconds
      const interval = setInterval(async () => {
        const currentStats = await monitor.getStats();
        setStats(currentStats);
      }, 5000);

      return () => {
        clearInterval(interval);
        monitor?.cleanup();
      };
    }
  }, [isMonitoring]);

  const getRating = (metric: string, value: number): 'good' | 'needs-improvement' | 'poor' => {
    const thresholds = PERFORMANCE_TARGETS[metric as keyof typeof PERFORMANCE_TARGETS];
    if (!thresholds) return 'good';
    
    if (value <= thresholds.good) return 'good';
    if (value <= thresholds.poor) return 'needs-improvement';
    return 'poor';
  };

  const getRatingColor = (rating: string): string => {
    switch (rating) {
      case 'good': return 'text-green-600';
      case 'needs-improvement': return 'text-yellow-600';
      case 'poor': return 'text-red-600';
      default: return 'text-gray-600';
    }
  };

  if (!stats) {
    return (
      <div className="performance-dashboard">
        <div className="dashboard-header">
          <h2>Performance Monitoring</h2>
          <button 
            onClick={() => setIsMonitoring(true)}
            className="btn-primary"
          >
            Start Monitoring
          </button>
        </div>
        <div className="empty-state">
          <p>Click "Start Monitoring" to begin tracking performance metrics</p>
        </div>
      </div>
    );
  }

  return (
    <div className="performance-dashboard">
      <div className="dashboard-header">
        <h2>Performance Monitoring</h2>
        <button 
          onClick={() => setIsMonitoring(false)}
          className="btn-secondary"
        >
          Stop Monitoring
        </button>
      </div>

      {/* Core Web Vitals */}
      <div className="metrics-grid">
        <div className="metric-card">
          <h3>Largest Contentful Paint</h3>
          <div className={`metric-value ${getRatingColor(getRating('LCP', stats.currentMetrics.lcp))}`}>
            {stats.currentMetrics.lcp.toFixed(0)}ms
          </div>
          <div className="metric-target">Target: &lt;2,500ms</div>
        </div>

        <div className="metric-card">
          <h3>First Input Delay</h3>
          <div className={`metric-value ${getRatingColor(getRating('FID', stats.currentMetrics.fid))}`}>
            {stats.currentMetrics.fid.toFixed(0)}ms
          </div>
          <div className="metric-target">Target: &lt;100ms</div>
        </div>

        <div className="metric-card">
          <h3>Cumulative Layout Shift</h3>
          <div className={`metric-value ${getRatingColor(getRating('CLS', stats.currentMetrics.cls))}`}>
            {stats.currentMetrics.cls.toFixed(3)}
          </div>
          <div className="metric-target">Target: &lt;0.1</div>
        </div>

        <div className="metric-card">
          <h3>Time to First Byte</h3>
          <div className={`metric-value ${getRatingColor(getRating('TTFB', stats.currentMetrics.ttfb))}`}>
            {stats.currentMetrics.ttfb.toFixed(0)}ms
          </div>
          <div className="metric-target">Target: &lt;600ms</div>
        </div>
      </div>

      {/* Resource Usage */}
      <div className="resource-section">
        <h3>Resource Usage</h3>
        <div className="resource-stats">
          <div className="stat">
            <span className="stat-label">Bundle Size:</span>
            <span className={`stat-value ${stats.resourceUsage.bundleSize > 800000 ? 'text-red-600' : 'text-green-600'}`}>
              {(stats.resourceUsage.bundleSize / 1024).toFixed(1)}KB
            </span>
          </div>
          <div className="stat">
            <span className="stat-label">Cache Hit Rate:</span>
            <span className={`stat-value ${stats.resourceUsage.cacheHitRate < 0.8 ? 'text-yellow-600' : 'text-green-600'}`}>
              {(stats.resourceUsage.cacheHitRate * 100).toFixed(1)}%
            </span>
          </div>
          <div className="stat">
            <span className="stat-label">Memory Usage:</span>
            <span className="stat-value">
              {(stats.resourceUsage.memoryUsage / 1024 / 1024).toFixed(1)}MB
            </span>
          </div>
        </div>
      </div>

      {/* Recent Performance Issues */}
      <div className="issues-section">
        <h3>Recent Issues</h3>
        <div className="issues-list">
          {stats.trends.errors.slice(0, 5).map((error, index) => (
            <div key={index} className="issue-item">
              <div className="issue-time">
                {new Date(error.timestamp).toLocaleTimeString()}
              </div>
              <div className="issue-message">{error.message}</div>
              <div className="issue-page">{error.page}</div>
            </div>
          ))}
        </div>
      </div>

      {/* Performance Timeline */}
      <div className="timeline-section">
        <h3>Page Load Timeline</h3>
        <div className="timeline-chart">
          {stats.trends.pageLoads.slice(-20).map((load, index) => (
            <div 
              key={index} 
              className="timeline-bar"
              style={{
                height: `${Math.min(load.duration / 10, 100)}px`,
                backgroundColor: load.duration > 3000 ? '#ef4444' : 
                                load.duration > 2000 ? '#f59e0b' : '#10b981'
              }}
              title={`${load.page}: ${load.duration}ms at ${new Date(load.timestamp).toLocaleTimeString()}`}
            />
          ))}
        </div>
      </div>
    </div>
  );
}

// CSS for the dashboard
const dashboardStyles = `
  .performance-dashboard {
    padding: 20px;
    font-family: system-ui, -apple-system, sans-serif;
  }

  .dashboard-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 30px;
  }

  .metrics-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 20px;
    margin-bottom: 30px;
  }

  .metric-card {
    background: white;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    text-align: center;
  }

  .metric-value {
    font-size: 2rem;
    font-weight: bold;
    margin: 10px 0;
  }

  .metric-target {
    font-size: 0.875rem;
    color: #6b7280;
  }

  .timeline-chart {
    display: flex;
    align-items: end;
    gap: 2px;
    height: 100px;
    padding: 20px;
    background: #f9fafb;
    border-radius: 8px;
  }

  .timeline-bar {
    width: 12px;
    min-height: 5px;
    border-radius: 2px;
  }
`;
```

### MCP SERVER USAGE

#### Required MCP Servers
- [ ] Context7: Load docs for Next.js optimization, React performance patterns
- [ ] PostgreSQL: Track performance metrics in database
- [ ] Supabase: Monitor real-time query performance

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/vercel/next.js", "performance optimization", 3000);
await mcp__context7__get-library-docs("/react/react", "performance hooks", 2000);
await mcp__context7__get-library-docs("/web-vitals/web-vitals", "core web vitals", 1500);
```

### TEST REQUIREMENTS

#### Performance Tests Required
```typescript
describe('Performance Targets', () => {
  it('should meet Core Web Vitals thresholds', async () => {
    const page = await browser.newPage();
    await page.goto('/dashboard');
    
    const metrics = await page.evaluate(() => {
      return new Promise((resolve) => {
        import('web-vitals').then(({ onLCP, onFID, onCLS }) => {
          const vitals: Record<string, number> = {};
          
          onLCP(metric => vitals.lcp = metric.value);
          onFID(metric => vitals.fid = metric.value);
          onCLS(metric => vitals.cls = metric.value);
          
          setTimeout(() => resolve(vitals), 5000);
        });
      });
    });
    
    expect(metrics.lcp).toBeLessThan(PERFORMANCE_TARGETS.LCP.good);
    expect(metrics.fid).toBeLessThan(PERFORMANCE_TARGETS.FID.good);
    expect(metrics.cls).toBeLessThan(PERFORMANCE_TARGETS.CLS.good);
  });

  it('should load dashboard under 2 seconds', async () => {
    const start = Date.now();
    await page.goto('/dashboard');
    await page.waitForSelector('[data-testid="dashboard-loaded"]');
    const loadTime = Date.now() - start;
    
    expect(loadTime).toBeLessThan(2000);
  });

  it('should have acceptable bundle sizes', async () => {
    const bundleStats = await analyzeBundles();
    
    expect(bundleStats.main).toBeLessThan(BUNDLE_TARGETS.main);
    expect(bundleStats.vendor).toBeLessThan(BUNDLE_TARGETS.vendor);
    expect(bundleStats.total).toBeLessThan(BUNDLE_TARGETS.total);
  });
});

describe('Mobile Performance', () => {
  beforeEach(async () => {
    // Simulate slow 3G
    await page.emulateNetworkConditions({
      offline: false,
      downloadThroughput: 1.6 * 1024 * 1024 / 8, // 1.6 Mbps
      uploadThroughput: 750 * 1024 / 8, // 750 Kbps
      latency: 750 // 750ms RTT
    });
  });

  it('should load on slow 3G within 5 seconds', async () => {
    const start = Date.now();
    await page.goto('/dashboard');
    await page.waitForSelector('[data-testid="dashboard-loaded"]');
    const loadTime = Date.now() - start;
    
    expect(loadTime).toBeLessThan(5000);
  });
});
```

#### Lighthouse CI Configuration
```javascript
// lighthouserc.js
module.exports = {
  ci: {
    collect: {
      url: [
        'http://localhost:3000/',
        'http://localhost:3000/dashboard',
        'http://localhost:3000/forms/new',
        'http://localhost:3000/clients'
      ],
      numberOfRuns: 3
    },
    assert: {
      assertions: {
        'categories:performance': ['warn', { minScore: 0.9 }],
        'categories:accessibility': ['error', { minScore: 0.95 }],
        'categories:best-practices': ['warn', { minScore: 0.9 }],
        'categories:seo': ['warn', { minScore: 0.9 }],
        
        // Core Web Vitals
        'largest-contentful-paint': ['error', { maxNumericValue: 2500 }],
        'first-input-delay': ['error', { maxNumericValue: 100 }],
        'cumulative-layout-shift': ['error', { maxNumericValue: 0.1 }],
        
        // Resource hints
        'uses-rel-preconnect': ['warn'],
        'uses-rel-preload': ['warn'],
        
        // Bundle optimization
        'unused-javascript': ['warn', { maxNumericValue: 20 }],
        'modern-image-formats': ['error'],
        'efficient-animated-content': ['warn']
      }
    },
    upload: {
      target: 'filesystem',
      outputDir: './lighthouse-reports'
    }
  }
};
```

### ACCEPTANCE CRITERIA
- [ ] Dashboard loads in under 2 seconds on 4G networks
- [ ] Form builder interactive in under 1.5 seconds
- [ ] Core Web Vitals scores: LCP <2.5s, FID <100ms, CLS <0.1
- [ ] Bundle sizes stay under targets: main <200KB, vendor <300KB
- [ ] Mobile performance on slow 3G under 5 seconds
- [ ] Zero layout shift after initial paint
- [ ] Image loading optimized with WebP/AVIF formats
- [ ] 90+ Lighthouse performance score on all key pages
- [ ] Real-time performance monitoring active in production
- [ ] Automated performance CI/CD pipeline prevents regressions
- [ ] Performance budget alerts trigger for degradations
- [ ] Memory usage stays under 50MB for typical user sessions

### DEPENDENCIES
- Must complete after: WS-144 (Offline Functionality) - Needs caching for performance
- Must complete before: WS-146 (App Store Preparation) - Performance requirements for stores
- Shares code with: All frontend components, WS-036 (Photo Management)

### ESTIMATED EFFORT
- Team A Frontend: 32 hours (React optimization, performance monitoring, bundle analysis)
- Team B Backend: 16 hours (API performance optimization, caching strategies)
- Team C Integration: 20 hours (CI/CD pipeline, monitoring setup, lighthouse automation)
- Total: 68 hours