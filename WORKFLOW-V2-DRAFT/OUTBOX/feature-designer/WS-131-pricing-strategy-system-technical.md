# TECHNICAL SPECIFICATION: WS-131 - Pricing Strategy System
## Generated by Feature Development Session - 2025-01-23

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding planner managing WedSync's business operations
**I want to:** Implement a tiered subscription system that converts free users to paid plans through value-driven upgrades
**So that:** We achieve sustainable revenue growth while providing clear value at each price point

**Real Business Scenario:**
A photography business starts with our free plan to test the platform with 3 couples. After seeing 40% faster client onboarding and 6 hours saved per wedding, they upgrade to Professional ($49/month) for unlimited clients. When they reach 20+ weddings per year and need advanced automation features, they upgrade to Premium ($149/month), increasing their annual revenue by $15,000 while reducing administrative overhead by 60%.

### SPECIFICATION SOURCE
- **Feature ID:** WS-131
- **Original Spec:** /CORE-SPECIFICATIONS/13-BUSINESS-OPERATIONS/01-pricing-strategy md.md
- **Current Implementation:** 0% complete
- **Files to Modify:** None (new feature)
- **New Files to Create:**
  - /src/lib/billing/pricing-engine.ts
  - /src/lib/billing/subscription-manager.ts
  - /src/lib/billing/usage-tracker.ts
  - /src/lib/billing/feature-gates.ts
  - /src/app/api/billing/subscription/route.ts
  - /src/app/api/billing/usage/route.ts
  - /src/app/api/billing/upgrade/route.ts
  - /src/components/billing/PricingTiers.tsx
  - /src/components/billing/UsageDashboard.tsx
  - /src/components/billing/UpgradeModal.tsx

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Subscription tiers and pricing
CREATE TABLE IF NOT EXISTS subscription_tiers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL UNIQUE, -- 'starter', 'professional', 'premium', 'enterprise'
  display_name TEXT NOT NULL,
  price_monthly DECIMAL(8,2) NOT NULL,
  price_yearly DECIMAL(10,2), -- Discounted annual price
  client_limit INTEGER, -- NULL for unlimited
  form_limit INTEGER, -- NULL for unlimited
  journey_limit INTEGER, -- NULL for unlimited
  features JSONB NOT NULL, -- {ai_assistant: true, advanced_analytics: false}
  storage_gb INTEGER DEFAULT 1,
  api_calls_per_month INTEGER DEFAULT 1000,
  support_level TEXT DEFAULT 'community', -- 'community', 'email', 'priority', 'phone'
  custom_branding BOOLEAN DEFAULT false,
  white_label BOOLEAN DEFAULT false,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- User subscriptions and billing
CREATE TABLE IF NOT EXISTS user_subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES user_profiles(id),
  tier_id UUID REFERENCES subscription_tiers(id),
  stripe_subscription_id TEXT UNIQUE,
  stripe_customer_id TEXT,
  status TEXT NOT NULL CHECK (status IN ('trialing', 'active', 'past_due', 'canceled', 'unpaid')),
  billing_cycle TEXT DEFAULT 'monthly' CHECK (billing_cycle IN ('monthly', 'yearly')),
  current_period_start TIMESTAMP,
  current_period_end TIMESTAMP,
  trial_end TIMESTAMP,
  cancel_at_period_end BOOLEAN DEFAULT false,
  canceled_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Usage tracking for billing and limits
CREATE TABLE IF NOT EXISTS usage_tracking (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES user_profiles(id),
  metric_type TEXT NOT NULL, -- 'clients_active', 'forms_created', 'journeys_sent', 'api_calls', 'storage_used'
  metric_value INTEGER NOT NULL,
  billing_period_start DATE NOT NULL,
  billing_period_end DATE NOT NULL,
  last_updated TIMESTAMP DEFAULT NOW(),
  UNIQUE(user_id, metric_type, billing_period_start)
);

-- Feature access control
CREATE TABLE IF NOT EXISTS feature_access (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES user_profiles(id),
  feature_key TEXT NOT NULL, -- 'ai_assistant', 'advanced_analytics', 'custom_branding'
  access_granted BOOLEAN DEFAULT true,
  granted_until TIMESTAMP, -- For temporary feature access
  granted_reason TEXT, -- 'subscription', 'trial', 'promotional', 'grandfathered'
  created_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(user_id, feature_key)
);

-- Pricing experiments and A/B tests
CREATE TABLE IF NOT EXISTS pricing_experiments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  experiment_name TEXT NOT NULL,
  variant_name TEXT NOT NULL, -- 'control', 'variant_a', 'variant_b'
  tier_id UUID REFERENCES subscription_tiers(id),
  modified_price_monthly DECIMAL(8,2),
  modified_price_yearly DECIMAL(10,2),
  modified_features JSONB,
  traffic_allocation DECIMAL(3,2) NOT NULL, -- 0.00 to 1.00
  start_date DATE NOT NULL,
  end_date DATE,
  is_active BOOLEAN DEFAULT true,
  conversion_goal TEXT, -- 'trial_signup', 'paid_conversion', 'upgrade_rate'
  created_at TIMESTAMP DEFAULT NOW()
);

-- Billing events and revenue tracking
CREATE TABLE IF NOT EXISTS billing_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES user_profiles(id),
  subscription_id UUID REFERENCES user_subscriptions(id),
  event_type TEXT NOT NULL, -- 'subscription_created', 'payment_succeeded', 'payment_failed', 'upgraded', 'downgraded', 'canceled'
  amount DECIMAL(10,2),
  currency TEXT DEFAULT 'USD',
  stripe_event_id TEXT,
  metadata JSONB,
  processed_at TIMESTAMP DEFAULT NOW()
);

-- Usage limit warnings and notifications
CREATE TABLE IF NOT EXISTS usage_alerts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES user_profiles(id),
  metric_type TEXT NOT NULL,
  threshold_percentage INTEGER NOT NULL, -- 75, 90, 100
  current_usage INTEGER NOT NULL,
  limit_value INTEGER NOT NULL,
  alert_sent_at TIMESTAMP,
  upgrade_prompted BOOLEAN DEFAULT false,
  created_at TIMESTAMP DEFAULT NOW()
);
```

#### API Endpoints Required
```typescript
// GET /api/billing/pricing
interface PricingResponse {
  tiers: PricingTier[];
  currentTier?: PricingTier;
  usage: UsageSummary;
  experiment?: ExperimentVariant;
}

interface PricingTier {
  id: string;
  name: string;
  displayName: string;
  priceMonthly: number;
  priceYearly: number;
  savings?: number; // Annual savings amount
  features: FeatureSet;
  limits: UsageLimits;
  recommended?: boolean;
  popular?: boolean;
}

interface UsageLimits {
  clients: number | 'unlimited';
  forms: number | 'unlimited';
  journeys: number | 'unlimited';
  storageGB: number;
  apiCallsPerMonth: number;
}

// POST /api/billing/subscription/create
interface CreateSubscriptionRequest {
  tierId: string;
  billingCycle: 'monthly' | 'yearly';
  paymentMethodId?: string;
  couponCode?: string;
}

interface CreateSubscriptionResponse {
  success: boolean;
  subscriptionId: string;
  clientSecret?: string; // For 3D Secure authentication
  requiresAction?: boolean;
}

// POST /api/billing/subscription/upgrade
interface UpgradeSubscriptionRequest {
  newTierId: string;
  billingCycle: 'monthly' | 'yearly';
  prorationBehavior: 'create_prorations' | 'none';
}

// GET /api/billing/usage/current
interface UsageResponse {
  currentPeriod: {
    start: string;
    end: string;
  };
  usage: {
    [key: string]: {
      current: number;
      limit: number | 'unlimited';
      percentage: number;
    };
  };
  alerts: UsageAlert[];
}
```

#### Frontend Components Required
```typescript
// Component: PricingTiers
// Location: /src/components/billing/PricingTiers.tsx

interface PricingTiersProps {
  currentTier?: PricingTier;
  showAnnualToggle?: boolean;
  highlightUpgrade?: boolean;
  onTierSelected: (tier: PricingTier, cycle: BillingCycle) => void;
  experiment?: ExperimentVariant;
}

interface FeatureComparison {
  feature: string;
  description: string;
  starter: boolean | string;
  professional: boolean | string;
  premium: boolean | string;
  enterprise: boolean | string;
  tooltip?: string;
}

const FEATURE_COMPARISON: FeatureComparison[] = [
  {
    feature: 'Active Clients',
    description: 'Number of couples you can work with simultaneously',
    starter: '3',
    professional: '25',
    premium: 'Unlimited',
    enterprise: 'Unlimited'
  },
  {
    feature: 'Custom Forms',
    description: 'Create personalized intake and planning forms',
    starter: '5',
    professional: 'Unlimited',
    premium: 'Unlimited',
    enterprise: 'Unlimited'
  },
  {
    feature: 'AI Assistant',
    description: 'AI-powered content generation and recommendations',
    starter: false,
    professional: '100 requests/month',
    premium: 'Unlimited',
    enterprise: 'Unlimited'
  },
  {
    feature: 'Advanced Analytics',
    description: 'Detailed insights into client engagement and business performance',
    starter: false,
    professional: false,
    premium: true,
    enterprise: true
  },
  {
    feature: 'Custom Branding',
    description: 'Remove WedSync branding and add your own logo',
    starter: false,
    professional: false,
    premium: true,
    enterprise: true
  },
  {
    feature: 'Priority Support',
    description: 'Email support with 24-hour response time',
    starter: 'Community',
    professional: 'Email',
    premium: 'Priority',
    enterprise: 'Phone + Dedicated'
  }
];

// Key functionality:
- Dynamic pricing display with annual/monthly toggle
- Feature comparison matrix
- Usage-based upgrade prompts
- A/B testing integration for pricing experiments
- Coupon code application
- Real-time limit checking and warnings
```

#### Integration Points
```typescript
// Service: PricingEngine
// Dependencies: Stripe, Usage tracking, Feature gates, A/B testing

class PricingEngine {
  async getCurrentPricing(userId?: string): Promise<PricingResponse> {
    // Get base pricing tiers
    // Apply any active experiments for this user
    // Include current usage if user is authenticated
    // Calculate upgrade recommendations based on usage patterns
  }
  
  async checkFeatureAccess(userId: string, featureKey: string): Promise<boolean> {
    // Check subscription tier
    // Verify feature is included in tier
    // Check for temporary access grants
    // Log access attempts for analytics
  }
  
  async trackUsage(userId: string, metric: string, increment: number = 1): Promise<void> {
    // Update current billing period usage
    // Check against tier limits
    // Trigger usage alerts if thresholds reached
    // Queue upgrade prompts for high-usage users
  }
}
```

### CODE EXAMPLES

#### Example 1: Feature Gating and Usage Tracking System
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import Stripe from 'stripe';

interface FeatureGate {
  key: string;
  name: string;
  description: string;
  requiredTier: string;
  usageMetric?: string;
}

const FEATURE_GATES: FeatureGate[] = [
  {
    key: 'ai_assistant',
    name: 'AI Assistant',
    description: 'AI-powered content generation and recommendations',
    requiredTier: 'professional',
    usageMetric: 'ai_requests'
  },
  {
    key: 'advanced_analytics',
    name: 'Advanced Analytics',
    description: 'Detailed business insights and reporting',
    requiredTier: 'premium'
  },
  {
    key: 'custom_branding',
    name: 'Custom Branding',
    description: 'Remove WedSync branding and add your own',
    requiredTier: 'premium'
  },
  {
    key: 'unlimited_clients',
    name: 'Unlimited Clients',
    description: 'Work with unlimited couples simultaneously',
    requiredTier: 'premium'
  }
];

export class FeatureGateManager {
  private supabase = createClient();
  private stripe = new Stripe(process.env.STRIPE_SECRET_KEY!);

  async checkFeatureAccess(
    userId: string, 
    featureKey: string
  ): Promise<FeatureAccessResult> {
    try {
      // Get user's current subscription
      const subscription = await this.getCurrentSubscription(userId);
      
      if (!subscription) {
        return {
          hasAccess: false,
          reason: 'no_subscription',
          requiredTier: this.getRequiredTier(featureKey),
          upgradeUrl: `/billing/upgrade?feature=${featureKey}`
        };
      }

      // Check if feature is included in current tier
      const featureGate = FEATURE_GATES.find(gate => gate.key === featureKey);
      if (!featureGate) {
        return { hasAccess: false, reason: 'invalid_feature' };
      }

      const tierHierarchy = ['starter', 'professional', 'premium', 'enterprise'];
      const userTierIndex = tierHierarchy.indexOf(subscription.tier.name);
      const requiredTierIndex = tierHierarchy.indexOf(featureGate.requiredTier);

      if (userTierIndex < requiredTierIndex) {
        return {
          hasAccess: false,
          reason: 'insufficient_tier',
          currentTier: subscription.tier.name,
          requiredTier: featureGate.requiredTier,
          upgradeUrl: `/billing/upgrade?from=${subscription.tier.name}&to=${featureGate.requiredTier}`
        };
      }

      // Check usage limits if applicable
      if (featureGate.usageMetric) {
        const usageCheck = await this.checkUsageLimit(
          userId, 
          featureGate.usageMetric, 
          subscription.tier
        );
        
        if (!usageCheck.allowed) {
          return {
            hasAccess: false,
            reason: 'usage_limit_exceeded',
            currentUsage: usageCheck.current,
            limit: usageCheck.limit,
            upgradeUrl: `/billing/upgrade?reason=usage_limit&metric=${featureGate.usageMetric}`
          };
        }
      }

      return { hasAccess: true };
      
    } catch (error) {
      console.error('Feature access check failed:', error);
      return { hasAccess: false, reason: 'system_error' };
    }
  }

  async trackUsage(
    userId: string,
    metric: string,
    increment: number = 1
  ): Promise<UsageTrackingResult> {
    const currentPeriod = this.getCurrentBillingPeriod();
    
    // Update usage in database
    const { data: usage, error } = await this.supabase
      .from('usage_tracking')
      .upsert({
        user_id: userId,
        metric_type: metric,
        billing_period_start: currentPeriod.start,
        billing_period_end: currentPeriod.end,
        metric_value: increment
      }, {
        onConflict: 'user_id,metric_type,billing_period_start',
        ignoreDuplicates: false
      })
      .select('*')
      .single();

    if (error) {
      console.error('Usage tracking failed:', error);
      return { success: false, error: error.message };
    }

    // Check if user is approaching limits
    const subscription = await this.getCurrentSubscription(userId);
    if (subscription) {
      await this.checkUsageAlerts(userId, metric, usage.metric_value, subscription.tier);
    }

    return {
      success: true,
      currentUsage: usage.metric_value,
      periodStart: currentPeriod.start,
      periodEnd: currentPeriod.end
    };
  }

  private async checkUsageAlerts(
    userId: string,
    metric: string,
    currentUsage: number,
    tier: SubscriptionTier
  ): Promise<void> {
    const limit = this.getTierLimit(tier, metric);
    if (limit === 'unlimited') return;

    const percentages = [75, 90, 100];
    
    for (const percentage of percentages) {
      const threshold = Math.floor((limit * percentage) / 100);
      
      if (currentUsage >= threshold) {
        // Check if alert already sent for this threshold
        const { data: existingAlert } = await this.supabase
          .from('usage_alerts')
          .select('id')
          .eq('user_id', userId)
          .eq('metric_type', metric)
          .eq('threshold_percentage', percentage)
          .gte('created_at', this.getCurrentBillingPeriod().start)
          .single();

        if (!existingAlert) {
          // Create and send new alert
          await this.createUsageAlert(userId, metric, percentage, currentUsage, limit);
          
          if (percentage >= 90) {
            // Trigger upgrade prompt for high usage
            await this.triggerUpgradePrompt(userId, metric, currentUsage, limit);
          }
        }
      }
    }
  }

  async createSubscription(
    userId: string,
    tierId: string,
    billingCycle: 'monthly' | 'yearly',
    paymentMethodId?: string
  ): Promise<CreateSubscriptionResult> {
    try {
      // Get tier details
      const tier = await this.getTierById(tierId);
      if (!tier) {
        throw new Error('Invalid tier selected');
      }

      // Get or create Stripe customer
      const customer = await this.getOrCreateStripeCustomer(userId);
      
      // Calculate price based on billing cycle
      const price = billingCycle === 'yearly' ? tier.price_yearly : tier.price_monthly;
      
      // Create Stripe subscription
      const subscription = await this.stripe.subscriptions.create({
        customer: customer.id,
        items: [{
          price: billingCycle === 'yearly' ? tier.stripe_price_id_yearly : tier.stripe_price_id_monthly
        }],
        payment_behavior: 'default_incomplete',
        payment_settings: { save_default_payment_method: 'on_subscription' },
        expand: ['latest_invoice.payment_intent'],
        trial_period_days: tier.name === 'professional' || tier.name === 'premium' ? 14 : undefined
      });

      // Save subscription to database
      const { data: userSubscription } = await this.supabase
        .from('user_subscriptions')
        .insert({
          user_id: userId,
          tier_id: tierId,
          stripe_subscription_id: subscription.id,
          stripe_customer_id: customer.id,
          status: subscription.status,
          billing_cycle: billingCycle,
          current_period_start: new Date(subscription.current_period_start * 1000),
          current_period_end: new Date(subscription.current_period_end * 1000),
          trial_end: subscription.trial_end ? new Date(subscription.trial_end * 1000) : null
        })
        .select('*')
        .single();

      // Update feature access
      await this.updateFeatureAccess(userId, tier);

      const invoice = subscription.latest_invoice as Stripe.Invoice;
      const paymentIntent = invoice.payment_intent as Stripe.PaymentIntent;

      return {
        success: true,
        subscriptionId: subscription.id,
        clientSecret: paymentIntent.client_secret,
        requiresAction: paymentIntent.status === 'requires_action'
      };

    } catch (error) {
      console.error('Subscription creation failed:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Subscription creation failed'
      };
    }
  }

  async upgradeSubscription(
    userId: string,
    newTierId: string,
    billingCycle: 'monthly' | 'yearly'
  ): Promise<UpgradeResult> {
    try {
      const currentSubscription = await this.getCurrentSubscription(userId);
      if (!currentSubscription) {
        throw new Error('No active subscription found');
      }

      const newTier = await this.getTierById(newTierId);
      if (!newTier) {
        throw new Error('Invalid tier selected');
      }

      // Calculate proration and new price
      const prorationDetails = await this.calculateProration(
        currentSubscription,
        newTier,
        billingCycle
      );

      // Update Stripe subscription
      const updatedSubscription = await this.stripe.subscriptions.update(
        currentSubscription.stripe_subscription_id,
        {
          items: [{
            id: currentSubscription.stripe_subscription_id,
            price: billingCycle === 'yearly' ? newTier.stripe_price_id_yearly : newTier.stripe_price_id_monthly
          }],
          proration_behavior: 'create_prorations'
        }
      );

      // Update database
      await this.supabase
        .from('user_subscriptions')
        .update({
          tier_id: newTierId,
          billing_cycle: billingCycle,
          updated_at: new Date().toISOString()
        })
        .eq('id', currentSubscription.id);

      // Update feature access
      await this.updateFeatureAccess(userId, newTier);

      // Log billing event
      await this.logBillingEvent(userId, 'upgraded', {
        from_tier: currentSubscription.tier.name,
        to_tier: newTier.name,
        proration_amount: prorationDetails.proratedAmount
      });

      return {
        success: true,
        newTier: newTier.name,
        proratedAmount: prorationDetails.proratedAmount,
        nextBillingDate: new Date(updatedSubscription.current_period_end * 1000)
      };

    } catch (error) {
      console.error('Subscription upgrade failed:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Upgrade failed'
      };
    }
  }

  private async updateFeatureAccess(userId: string, tier: SubscriptionTier): Promise<void> {
    // Remove all existing feature access
    await this.supabase
      .from('feature_access')
      .delete()
      .eq('user_id', userId);

    // Grant features based on new tier
    const tierFeatures = this.getTierFeatures(tier);
    const featureAccess = tierFeatures.map(featureKey => ({
      user_id: userId,
      feature_key: featureKey,
      access_granted: true,
      granted_reason: 'subscription'
    }));

    if (featureAccess.length > 0) {
      await this.supabase
        .from('feature_access')
        .insert(featureAccess);
    }
  }
}

// Usage in API routes
export async function POST(request: Request) {
  const { userId, featureKey } = await request.json();
  
  const featureGate = new FeatureGateManager();
  const accessResult = await featureGate.checkFeatureAccess(userId, featureKey);
  
  if (!accessResult.hasAccess) {
    return NextResponse.json({
      error: 'Feature access denied',
      reason: accessResult.reason,
      upgradeUrl: accessResult.upgradeUrl
    }, { status: 403 });
  }
  
  // Track usage if applicable
  if (accessResult.hasAccess) {
    await featureGate.trackUsage(userId, 'ai_requests');
  }
  
  return NextResponse.json({ success: true });
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [ ] Context7: Load Stripe API documentation and billing patterns
- [ ] Playwright: Test subscription flows, payment processing, and upgrade paths
- [ ] PostgreSQL: Manage billing data, subscriptions, and usage tracking

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/stripe/stripe-node", "subscriptions and billing", 4000);
await mcp__context7__get-library-docs("/next.js/next", "API routes for subscription management", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('PricingEngine', () => {
  it('should enforce feature gates based on subscription tier', async () => {
    const userId = 'test-user-id';
    const mockSubscription = {
      tier: { name: 'starter' },
      status: 'active'
    };
    
    const accessResult = await pricingEngine.checkFeatureAccess(userId, 'ai_assistant');
    
    expect(accessResult.hasAccess).toBe(false);
    expect(accessResult.reason).toBe('insufficient_tier');
    expect(accessResult.requiredTier).toBe('professional');
  });

  it('should track usage and enforce limits', async () => {
    const userId = 'test-user-id';
    const mockSubscription = {
      tier: { name: 'professional', limits: { ai_requests: 100 } }
    };
    
    // Track 99 requests (under limit)
    const result1 = await pricingEngine.trackUsage(userId, 'ai_requests', 99);
    expect(result1.success).toBe(true);
    
    // Track 2 more requests (over limit)
    const result2 = await pricingEngine.trackUsage(userId, 'ai_requests', 2);
    expect(result2.success).toBe(false);
    expect(result2.limitExceeded).toBe(true);
  });

  it('should calculate subscription upgrades with proration', async () => {
    const userId = 'test-user-id';
    const currentTier = 'professional';
    const newTier = 'premium';
    const billingCycle = 'monthly';
    
    const upgrade = await pricingEngine.upgradeSubscription(userId, newTier, billingCycle);
    
    expect(upgrade.success).toBe(true);
    expect(upgrade.newTier).toBe('premium');
    expect(upgrade.proratedAmount).toBeGreaterThan(0);
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Complete subscription upgrade flow', async () => {
  await mcp__playwright__browser_navigate({url: '/billing/pricing'});
  
  // View pricing tiers
  await mcp__playwright__browser_wait_for({text: 'Professional'});
  
  // Click upgrade to Professional
  await mcp__playwright__browser_click({
    element: 'Upgrade to Professional Button',
    ref: 'button[data-tier="professional"]'
  });
  
  // Select billing cycle
  await mcp__playwright__browser_click({
    element: 'Annual Billing Toggle',
    ref: 'input[name="billingCycle"][value="yearly"]'
  });
  
  // Enter payment information (test mode)
  await mcp__playwright__browser_type({
    element: 'Card Number Input',
    ref: 'input[name="cardNumber"]',
    text: '4242424242424242'
  });
  
  await mcp__playwright__browser_type({
    element: 'Card Expiry Input',
    ref: 'input[name="cardExpiry"]',
    text: '12/25'
  });
  
  await mcp__playwright__browser_type({
    element: 'Card CVC Input',
    ref: 'input[name="cardCvc"]',
    text: '123'
  });
  
  // Submit subscription
  await mcp__playwright__browser_click({
    element: 'Subscribe Button',
    ref: 'button[type="submit"]'
  });
  
  // Wait for success confirmation
  await mcp__playwright__browser_wait_for({text: 'Subscription Activated'});
  
  // Verify new features are accessible
  await mcp__playwright__browser_navigate({url: '/dashboard'});
  await mcp__playwright__browser_wait_for({text: 'AI Assistant'});
  
  await mcp__playwright__browser_snapshot();
});

test('Usage limit warnings and upgrade prompts', async () => {
  // Set user near usage limits via API
  await fetch('/api/test/set-usage', {
    method: 'POST',
    body: JSON.stringify({
      userId: 'test-user',
      metric: 'clients_active',
      value: 23, // Near 25 limit
      tier: 'professional'
    })
  });
  
  await mcp__playwright__browser_navigate({url: '/dashboard'});
  
  // Should show usage warning
  await mcp__playwright__browser_wait_for({text: 'Approaching client limit'});
  
  // Click upgrade prompt
  await mcp__playwright__browser_click({
    element: 'Upgrade Now Button',
    ref: 'button.upgrade-prompt'
  });
  
  // Should redirect to pricing with pre-selected tier
  await mcp__playwright__browser_wait_for({text: 'Premium'});
  
  const url = await mcp__playwright__browser_evaluate({
    function: '() => window.location.href'
  });
  expect(url).toContain('tier=premium');
  
  await mcp__playwright__browser_snapshot();
});
```

### ACCEPTANCE CRITERIA
- [ ] Support 4 subscription tiers (Starter, Professional, Premium, Enterprise)
- [ ] Implement usage tracking with real-time limit enforcement
- [ ] Process subscription upgrades/downgrades with accurate proration
- [ ] Feature gating system with 99.9% accuracy
- [ ] Handle failed payments with dunning management
- [ ] Support annual billing with 20% discount
- [ ] Generate usage alerts at 75%, 90%, and 100% thresholds
- [ ] A/B testing framework for pricing experiments
- [ ] Revenue analytics with MRR, churn, and LTV calculations
- [ ] Self-service billing management portal

### DEPENDENCIES
- Must complete after: WS-076 (Stripe Setup) - Payment infrastructure required
- Must complete before: WS-132 (Trial Management System)
- Shares code with: User management, feature access control, analytics tracking

### ESTIMATED EFFORT
- Team A Frontend: 28 hours (Pricing UI, billing dashboard, upgrade flows)
- Team B Backend: 36 hours (Subscription management, usage tracking, feature gates)
- Team C Integration: 24 hours (Stripe integration, webhook handling, proration logic)
- Total: 88 hours