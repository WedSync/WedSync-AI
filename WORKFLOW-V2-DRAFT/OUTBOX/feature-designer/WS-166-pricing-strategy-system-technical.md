# TECHNICAL SPECIFICATION: WS-166 - Pricing Strategy System
## Generated by Feature Development Session - 2025-01-24

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding supplier (photographer/venue/florist)
**I want to:** Choose a subscription plan that matches my business size and needs
**So that:** I can access the right features at the right price point and scale as my business grows

**Real Wedding Scenario:**
A wedding photographer currently manages 30 weddings per year but uses spreadsheets and manual emails. With the starter tier at Â£19/month, they can manage all clients digitally, saving 5+ hours per wedding. As they grow to 50+ weddings, they upgrade to Professional for automation features, saving 10+ hours per wedding.

### SPECIFICATION SOURCE
- **Feature ID:** WS-166
- **Original Spec:** /CORE-SPECIFICATIONS/13-BUSINESS-OPERATIONS/01-pricing-strategy md.md
- **Current Implementation:** 0% complete
- **Files to Modify:** None (new feature)
- **New Files to Create:** 
  - /src/lib/pricing/pricing-tiers.ts
  - /src/lib/pricing/feature-gating.ts
  - /src/lib/pricing/subscription-manager.ts
  - /src/components/pricing/PricingTable.tsx
  - /src/components/pricing/UpgradeModal.tsx
  - /src/app/api/pricing/route.ts
  - /src/app/api/subscription/upgrade/route.ts
  - /src/app/api/subscription/downgrade/route.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Subscription tiers table
CREATE TABLE IF NOT EXISTS subscription_tiers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL, -- 'free', 'starter', 'professional', 'scale', 'enterprise'
  price_monthly DECIMAL(10,2),
  price_annual DECIMAL(10,2),
  features JSONB NOT NULL,
  limits JSONB NOT NULL,
  display_order INT,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Supplier subscriptions
CREATE TABLE IF NOT EXISTS supplier_subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES suppliers(id) ON DELETE CASCADE,
  tier_id UUID REFERENCES subscription_tiers(id),
  status TEXT CHECK (status IN ('trialing', 'active', 'past_due', 'canceled', 'paused')),
  trial_ends_at TIMESTAMPTZ,
  current_period_end TIMESTAMPTZ,
  stripe_subscription_id TEXT UNIQUE,
  stripe_customer_id TEXT,
  original_price DECIMAL(10,2), -- Grandfather pricing
  paused_at TIMESTAMPTZ,
  pause_reason TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Feature usage tracking
CREATE TABLE IF NOT EXISTS feature_usage (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES suppliers(id) ON DELETE CASCADE,
  feature_name TEXT NOT NULL,
  usage_count INT DEFAULT 0,
  last_used_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create indexes
CREATE INDEX idx_supplier_subscriptions_supplier ON supplier_subscriptions(supplier_id);
CREATE INDEX idx_supplier_subscriptions_status ON supplier_subscriptions(status);
CREATE INDEX idx_feature_usage_supplier ON feature_usage(supplier_id);
```

#### API Endpoints Required
```typescript
// GET /api/pricing/tiers
interface GetTiersResponse {
  tiers: Array<{
    id: string;
    name: string;
    priceMonthly: number;
    priceAnnual: number;
    features: Record<string, boolean | string>;
    limits: {
      forms: number | 'unlimited';
      clients: number | 'unlimited';
      logins: number;
      storage: number; // MB
    };
    popular?: boolean;
  }>;
}

// POST /api/subscription/upgrade
interface UpgradeRequest {
  tierId: string;
  billingPeriod: 'monthly' | 'annual';
  paymentMethodId?: string;
}

interface UpgradeResponse {
  success: boolean;
  subscription: {
    id: string;
    tier: string;
    status: string;
    currentPeriodEnd: string;
  };
  stripeSessionUrl?: string;
}

// POST /api/subscription/downgrade
interface DowngradeRequest {
  tierId: string;
  reason: string;
  feedback?: string;
}

interface DowngradeResponse {
  success: boolean;
  effectiveDate: string;
  dataRetention: {
    readOnly: boolean;
    expiresAt: string;
  };
}

// POST /api/subscription/pause
interface PauseRequest {
  reason: string;
  resumeDate?: string; // ISO date
}

interface PauseResponse {
  success: boolean;
  pausedUntil: string;
  dataAccessible: boolean;
}
```

#### Frontend Components Required
```typescript
// Component: PricingTable
// Location: /src/components/pricing/PricingTable.tsx

interface PricingTableProps {
  currentTier?: string;
  onSelectTier: (tierId: string, billing: 'monthly' | 'annual') => void;
  showComparison?: boolean;
}

// Key functionality:
- Display all available tiers with features
- Highlight current tier if user is logged in
- Show savings for annual billing
- Feature comparison matrix
- Mobile-responsive card layout

// Component: UpgradeModal
// Location: /src/components/pricing/UpgradeModal.tsx

interface UpgradeModalProps {
  isOpen: boolean;
  onClose: () => void;
  fromTier: string;
  toTier: string;
  onConfirm: () => Promise<void>;
}

// Key functionality:
- Show what's changing (new features, new limits)
- Display prorated billing information
- Handle payment method selection
- Show immediate vs next-billing-cycle changes
```

#### Integration Points
```typescript
// Service: SubscriptionManager
// Dependencies: Stripe API, Supabase, Email service

class SubscriptionManager {
  async createTrialSubscription(supplierId: string) {
    // Create 30-day trial for new supplier
  }
  
  async checkFeatureAccess(supplierId: string, feature: string): Promise<boolean> {
    // Verify if supplier's tier includes feature
  }
  
  async upgradeSubscription(supplierId: string, newTierId: string) {
    // Handle tier upgrade with Stripe
  }
  
  async downgradeSubscription(supplierId: string, newTierId: string) {
    // Schedule downgrade for end of billing period
  }
  
  async pauseSubscription(supplierId: string, resumeDate?: Date) {
    // Pause subscription for up to 90 days
  }
}
```

### CODE EXAMPLES

#### Example 1: Feature Gating Middleware
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { NextRequest, NextResponse } from 'next/server';
import { createServerClient } from '@supabase/ssr';

export async function checkFeatureAccess(
  req: NextRequest,
  feature: string
): Promise<boolean> {
  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    { cookies: () => req.cookies }
  );
  
  // Get current user's subscription
  const { data: session } = await supabase.auth.getSession();
  if (!session?.session?.user) return false;
  
  const { data: subscription } = await supabase
    .from('supplier_subscriptions')
    .select('*, subscription_tiers(*)')
    .eq('supplier_id', session.session.user.id)
    .single();
  
  if (!subscription) return false;
  
  const features = subscription.subscription_tiers.features as Record<string, any>;
  return features[feature] === true;
}

// Usage in API route
export async function POST(req: NextRequest) {
  if (!await checkFeatureAccess(req, 'ai_chatbot')) {
    return NextResponse.json(
      { error: 'Upgrade to Professional to access AI features' },
      { status: 403 }
    );
  }
  
  // Continue with feature logic
}
```

#### Example 2: Trial Extension Logic
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { differenceInDays } from 'date-fns';
import { supabase } from '@/lib/supabase';

interface TrialActivity {
  logins: number;
  clientsImported: number;
  formsCreated: number;
  hasExtendedBefore: boolean;
}

export async function checkTrialExtensionEligibility(
  supplierId: string
): Promise<{ eligible: boolean; reason?: string }> {
  // Get subscription
  const { data: subscription } = await supabase
    .from('supplier_subscriptions')
    .select('*')
    .eq('supplier_id', supplierId)
    .eq('status', 'trialing')
    .single();
  
  if (!subscription) {
    return { eligible: false, reason: 'No trial subscription found' };
  }
  
  // Check days until expiry
  const daysUntilExpiry = differenceInDays(
    new Date(subscription.trial_ends_at),
    new Date()
  );
  
  if (daysUntilExpiry > 7 || daysUntilExpiry < 3) {
    return { eligible: false, reason: 'Outside extension window' };
  }
  
  // Check activity metrics
  const activity = await getSupplierActivity(supplierId);
  
  if (activity.logins >= 5 && 
      activity.clientsImported >= 10 && 
      !activity.hasExtendedBefore) {
    return { eligible: true };
  }
  
  return { eligible: false, reason: 'Activity requirements not met' };
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [ ] Context7: Load docs for Stripe integration, Next.js API routes
- [ ] PostgreSQL: Execute migration scripts
- [ ] Supabase: Configure RLS policies for subscription tables

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/stripe/stripe-node", "subscriptions", 3000);
await mcp__context7__get-library-docs("/vercel/next.js", "api routes", 2000);
await mcp__context7__get-library-docs("/supabase/supabase", "row level security", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('SubscriptionManager', () => {
  it('should create trial subscription for new supplier', async () => {
    const supplierId = 'test-supplier-id';
    const subscription = await createTrialSubscription(supplierId);
    expect(subscription.status).toBe('trialing');
    expect(subscription.trial_ends_at).toBeDefined();
  });
  
  it('should correctly check feature access', async () => {
    const hasAccess = await checkFeatureAccess('supplier-id', 'ai_chatbot');
    expect(hasAccess).toBe(false); // Free tier
  });
  
  it('should handle tier upgrades', async () => {
    const result = await upgradeSubscription('supplier-id', 'professional');
    expect(result.success).toBe(true);
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Pricing page tier selection', async () => {
  await mcp__playwright__browser_navigate({url: '/pricing'});
  await mcp__playwright__browser_snapshot();
  
  // Select professional tier
  await mcp__playwright__browser_click({
    element: 'Professional tier select button',
    ref: '[data-tier="professional"]'
  });
  
  // Verify upgrade modal appears
  await mcp__playwright__browser_wait_for({
    text: 'Upgrade to Professional'
  });
});
```

### ACCEPTANCE CRITERIA
- [ ] All pricing tiers display correctly with features and limits
- [ ] Trial subscription auto-creates for new suppliers
- [ ] Feature gating blocks access to premium features for free users
- [ ] Upgrade flow completes with Stripe payment
- [ ] Downgrade schedules for end of billing period
- [ ] Grandfather pricing preserved for existing customers
- [ ] Trial extension offers sent at day 25 of 30
- [ ] Usage metrics tracked for all gated features
- [ ] Pause functionality works for up to 90 days
- [ ] Currency displays in GBP with structure ready for USD/EUR

### DEPENDENCIES
- Must complete after: WS-076 (Stripe Setup) - Payment infrastructure required
- Must complete before: WS-167 (Trial Management) - Needs pricing foundation
- Shares code with: WS-132 (Trial Management System), WS-133 (Customer Success)

### ESTIMATED EFFORT
- Team A Frontend: 16 hours (pricing table, upgrade modal, UI)
- Team B Backend: 24 hours (subscription logic, Stripe integration, database)
- Team C Integration: 8 hours (feature gating, usage tracking)
- Total: 48 hours