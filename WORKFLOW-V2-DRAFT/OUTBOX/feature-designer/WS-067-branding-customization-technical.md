# TECHNICAL SPECIFICATION: WS-067 - Branding Customization
## Generated by Feature Development Session - August 21, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** High-end wedding photographer
**I want to:** Completely customize my client dashboard with my brand colors, logo, and typography while removing all WedSync branding
**So that:** Clients see a seamless extension of my business (not a third-party tool) and I can maintain premium brand consistency across all client touchpoints worth $50K+ per client

**Real Wedding Scenario:**
A luxury photographer charges $15K+ per wedding and maintains strict brand guidelines (specific burgundy/gold color palette, custom serif font, minimalist aesthetic). When clients log into their dashboard, they currently see WedSync branding which breaks the premium experience. With white-label customization, the dashboard matches their website exactly - same logo, colors, fonts, and styling. Clients never know WedSync exists, maintaining the photographer's $50K+ brand value and professional image.

### SPECIFICATION SOURCE
- **Feature ID:** WS-067
- **Original Spec:** /CORE-SPECIFICATIONS/02-WEDSYNC-SUPPLIER-PLATFORM/07-Client-Dashboard-Builder/03-branding-customization md.md
- **Current Implementation:** 0% complete
- **Files to Modify:** 
  - `/wedsync/src/app/(dashboard)/layout.tsx`
  - `/wedsync/src/styles/globals.css`
- **New Files to Create:** 
  - `/wedsync/src/components/branding/BrandingEditor.tsx`
  - `/wedsync/src/components/branding/ColorPalettePicker.tsx`
  - `/wedsync/src/components/branding/TypographySelector.tsx`
  - `/wedsync/src/components/branding/LogoUploader.tsx`
  - `/wedsync/src/components/branding/CustomCSSEditor.tsx`
  - `/wedsync/src/lib/branding/brand-compiler.ts`
  - `/wedsync/src/lib/branding/css-generator.ts`
  - `/wedsync/src/app/api/branding/route.ts`
  - `/wedsync/src/app/api/branding/preview/route.ts`
  - `/wedsync/src/types/branding.ts`
  - `/wedsync/supabase/migrations/030_branding_customization_system.sql`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Brand configurations for suppliers
CREATE TABLE IF NOT EXISTS brand_configurations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  brand_name VARCHAR(255) NOT NULL,
  is_active BOOLEAN DEFAULT true,
  logo_config JSONB DEFAULT '{}'::jsonb,
  color_config JSONB DEFAULT '{}'::jsonb,
  typography_config JSONB DEFAULT '{}'::jsonb,
  layout_config JSONB DEFAULT '{}'::jsonb,
  custom_css TEXT,
  white_label_config JSONB DEFAULT '{}'::jsonb,
  compiled_css TEXT, -- Generated CSS from configuration
  last_compiled_at TIMESTAMPTZ,
  version INTEGER DEFAULT 1,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Logo assets and variations
CREATE TABLE IF NOT EXISTS brand_assets (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  brand_config_id UUID REFERENCES brand_configurations(id) ON DELETE CASCADE,
  asset_type brand_asset_type NOT NULL,
  asset_variant VARCHAR(50), -- 'light', 'dark', 'transparent', etc.
  file_url TEXT NOT NULL,
  file_size INTEGER,
  mime_type VARCHAR(100),
  dimensions JSONB, -- {width: number, height: number}
  alt_text VARCHAR(255),
  storage_path TEXT,
  is_optimized BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TYPE brand_asset_type AS ENUM (
  'logo_primary',
  'logo_secondary',
  'logo_favicon',
  'logo_email_header',
  'background_image',
  'pattern_overlay',
  'custom_icon'
);

-- Font configurations and Google Fonts integration
CREATE TABLE IF NOT EXISTS brand_fonts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  brand_config_id UUID REFERENCES brand_configurations(id) ON DELETE CASCADE,
  font_role font_role NOT NULL,
  font_family VARCHAR(255) NOT NULL,
  font_source font_source NOT NULL DEFAULT 'google',
  font_weights INTEGER[] DEFAULT '{400,700}',
  font_url TEXT, -- For custom fonts
  fallback_fonts TEXT[] DEFAULT '{"Arial", "sans-serif"}',
  line_height DECIMAL(3,2) DEFAULT 1.5,
  letter_spacing DECIMAL(4,3) DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TYPE font_role AS ENUM (
  'heading',
  'body',
  'accent',
  'monospace'
);

CREATE TYPE font_source AS ENUM (
  'google',
  'custom',
  'system'
);

-- Color palette management
CREATE TABLE IF NOT EXISTS brand_color_palettes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  brand_config_id UUID REFERENCES brand_configurations(id) ON DELETE CASCADE,
  palette_name VARCHAR(255) NOT NULL,
  primary_color VARCHAR(7) NOT NULL, -- Hex color
  secondary_color VARCHAR(7) NOT NULL,
  accent_color VARCHAR(7) NOT NULL,
  background_color VARCHAR(7) DEFAULT '#FFFFFF',
  text_color VARCHAR(7) DEFAULT '#000000',
  success_color VARCHAR(7) DEFAULT '#22C55E',
  warning_color VARCHAR(7) DEFAULT '#F59E0B',
  error_color VARCHAR(7) DEFAULT '#EF4444',
  is_dark_mode BOOLEAN DEFAULT false,
  accessibility_score INTEGER, -- WCAG contrast compliance score
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Custom CSS injections and overrides
CREATE TABLE IF NOT EXISTS brand_css_overrides (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  brand_config_id UUID REFERENCES brand_configurations(id) ON DELETE CASCADE,
  override_name VARCHAR(255) NOT NULL,
  css_selector VARCHAR(500) NOT NULL,
  css_properties JSONB NOT NULL,
  is_active BOOLEAN DEFAULT true,
  priority_order INTEGER DEFAULT 0,
  affects_components TEXT[] DEFAULT '{}', -- Component names affected
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Brand application tracking (which templates/clients use which branding)
CREATE TABLE IF NOT EXISTS brand_applications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  brand_config_id UUID REFERENCES brand_configurations(id) ON DELETE CASCADE,
  applied_to_type application_type NOT NULL,
  applied_to_id UUID NOT NULL, -- Template or client ID
  applied_at TIMESTAMPTZ DEFAULT NOW(),
  applied_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  customizations JSONB DEFAULT '{}'::jsonb, -- Per-application overrides
  is_active BOOLEAN DEFAULT true
);

CREATE TYPE application_type AS ENUM (
  'dashboard_template',
  'client_dashboard',
  'booking_page',
  'email_template'
);

-- RLS policies
ALTER TABLE brand_configurations ENABLE ROW LEVEL SECURITY;
ALTER TABLE brand_assets ENABLE ROW LEVEL SECURITY;
ALTER TABLE brand_fonts ENABLE ROW LEVEL SECURITY;
ALTER TABLE brand_color_palettes ENABLE ROW LEVEL SECURITY;
ALTER TABLE brand_css_overrides ENABLE ROW LEVEL SECURITY;
ALTER TABLE brand_applications ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can manage their own brand configurations" ON brand_configurations
  FOR ALL USING (auth.uid() = user_id);

CREATE POLICY "Users can manage their own brand assets" ON brand_assets
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM brand_configurations 
      WHERE brand_configurations.id = brand_assets.brand_config_id 
      AND brand_configurations.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can manage their own brand fonts" ON brand_fonts
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM brand_configurations 
      WHERE brand_configurations.id = brand_fonts.brand_config_id 
      AND brand_configurations.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can manage their own color palettes" ON brand_color_palettes
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM brand_configurations 
      WHERE brand_configurations.id = brand_color_palettes.brand_config_id 
      AND brand_configurations.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can manage their own CSS overrides" ON brand_css_overrides
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM brand_configurations 
      WHERE brand_configurations.id = brand_css_overrides.brand_config_id 
      AND brand_configurations.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can manage their own brand applications" ON brand_applications
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM brand_configurations 
      WHERE brand_configurations.id = brand_applications.brand_config_id 
      AND brand_configurations.user_id = auth.uid()
    )
  );
```

#### API Endpoints Required
```typescript
// GET /api/branding
interface GetBrandConfigurationResponse {
  success: boolean;
  data: {
    configuration: BrandConfiguration;
    assets: BrandAsset[];
    fonts: BrandFont[];
    colorPalettes: BrandColorPalette[];
    cssOverrides: BrandCSSOverride[];
    compiledCSS: string;
  };
}

// PUT /api/branding
interface UpdateBrandConfigurationRequest {
  brandName?: string;
  logoConfig?: LogoConfiguration;
  colorConfig?: ColorConfiguration;
  typographyConfig?: TypographyConfiguration;
  layoutConfig?: LayoutConfiguration;
  customCSS?: string;
  whiteLabelConfig?: WhiteLabelConfiguration;
}

interface UpdateBrandConfigurationResponse {
  success: boolean;
  data: {
    configuration: BrandConfiguration;
    compiledCSS: string;
    affectedApplications: number;
  };
}

// POST /api/branding/assets
interface UploadBrandAssetRequest {
  assetType: BrandAssetType;
  assetVariant?: string;
  file: File;
  altText?: string;
}

interface UploadBrandAssetResponse {
  success: boolean;
  data: {
    asset: BrandAsset;
    optimizedVersions: BrandAsset[];
  };
}

// POST /api/branding/preview
interface PreviewBrandingRequest {
  configuration: Partial<BrandConfiguration>;
  previewContext: 'dashboard' | 'booking_page' | 'email';
  mockData?: any;
}

interface PreviewBrandingResponse {
  success: boolean;
  data: {
    previewHTML: string;
    compiledCSS: string;
    accessibilityScore: number;
    warnings: string[];
  };
}

// POST /api/branding/compile
interface CompileBrandingRequest {
  configurationId: string;
  forceRecompile?: boolean;
}

interface CompileBrandingResponse {
  success: boolean;
  data: {
    compiledCSS: string;
    compilationTime: number;
    fileSize: number;
    optimizations: string[];
  };
}

// GET /api/branding/fonts/google
interface GetGoogleFontsResponse {
  success: boolean;
  data: {
    popularFonts: GoogleFont[];
    categoryFilters: string[];
    totalFonts: number;
  };
}

// POST /api/branding/apply
interface ApplyBrandingRequest {
  brandConfigId: string;
  applicationTargets: Array<{
    type: ApplicationType;
    id: string;
    customizations?: any;
  }>;
}

interface ApplyBrandingResponse {
  success: boolean;
  data: {
    applicationsCreated: number;
    failedApplications: Array<{target: any; reason: string}>;
  };
}

// GET /api/branding/accessibility-check
interface AccessibilityCheckRequest {
  colors: ColorConfiguration;
  typography: TypographyConfiguration;
}

interface AccessibilityCheckResponse {
  success: boolean;
  data: {
    overallScore: number; // 0-100
    contrastRatios: Record<string, number>;
    wcagCompliance: {
      aa: boolean;
      aaa: boolean;
    };
    recommendations: string[];
  };
}
```

#### Frontend Components Required
```typescript
// Component: BrandingEditor
// Location: /src/components/branding/BrandingEditor.tsx

interface BrandingEditorProps {
  brandConfiguration?: BrandConfiguration;
  onSave: (config: BrandConfiguration) => Promise<void>;
  onPreview: (config: BrandConfiguration) => void;
}

// Key functionality:
- Tabbed interface for logo, colors, typography, layout, custom CSS
- Real-time preview with multiple contexts (dashboard, email, booking)
- Drag-and-drop logo upload with automatic optimization
- Color palette generator with accessibility checking
- Google Fonts integration with preview
- Custom CSS editor with syntax highlighting
- White-label configuration options
- Brand export/import functionality

// Component: ColorPalettePicker
// Location: /src/components/branding/ColorPalettePicker.tsx

interface ColorPalettePickerProps {
  currentColors: ColorConfiguration;
  onColorsChange: (colors: ColorConfiguration) => void;
  showAccessibilityScores?: boolean;
}

// Key functionality:
- Interactive color wheel with harmony suggestions
- Preset wedding color palettes (blush/gold, navy/silver, etc.)
- Real-time accessibility contrast checking
- Color blindness simulation
- Palette import from brand guidelines
- Auto-generation of tints and shades
- Dark mode palette variants

// Component: TypographySelector
// Location: /src/components/branding/TypographySelector.tsx

interface TypographySelectorProps {
  currentTypography: TypographyConfiguration;
  onTypographyChange: (typography: TypographyConfiguration) => void;
}

// Key functionality:
- Google Fonts browser with wedding-appropriate recommendations
- Font pairing suggestions for heading/body combinations
- Real-time typography preview with sample wedding content
- Custom font upload capability
- Font weight and style selection
- Line height and letter spacing controls
- Responsive typography scaling preview

// Component: LogoUploader
// Location: /src/components/branding/LogoUploader.tsx

interface LogoUploaderProps {
  currentLogos: LogoConfiguration;
  onLogosChange: (logos: LogoConfiguration) => void;
}

// Key functionality:
- Multi-variant logo upload (light, dark, transparent)
- Automatic format conversion (PNG, SVG, WebP)
- Retina display optimization
- Logo positioning and sizing controls
- Favicon generation from primary logo
- Logo preview across different backgrounds
- Alt text configuration for accessibility

// Component: CustomCSSEditor
// Location: /src/components/branding/CustomCSSEditor.tsx

interface CustomCSSEditorProps {
  currentCSS: string;
  onCSSChange: (css: string) => void;
  targetSelectors: string[];
}

// Key functionality:
- Syntax-highlighted CSS editor with autocomplete
- CSS validation and error highlighting
- Selector suggestions for dashboard components
- Live preview with CSS injection
- CSS minification and optimization
- Import/export CSS configurations
- Version control for CSS changes
```

#### Integration Points
```typescript
// Service: BrandCompilerService
// Dependencies: File Storage, CSS Processing, Asset Optimization

class BrandCompilerService {
  async compileBrandConfiguration(
    configurationId: string
  ): Promise<CompiledBranding> {
    // 1. Fetch brand configuration and all related assets
    // 2. Generate CSS custom properties from color/typography config
    // 3. Process logo assets and generate optimized versions
    // 4. Compile custom CSS with validation and minification
    // 5. Generate font loading CSS for Google Fonts
    // 6. Create responsive breakpoint adjustments
    // 7. Apply white-label overrides
    // 8. Return complete CSS package with metadata
  }

  async generateCSSVariables(
    colors: ColorConfiguration,
    typography: TypographyConfiguration
  ): Promise<string> {
    // 1. Create CSS custom properties for all brand colors
    // 2. Generate color variants (light, dark, hover states)
    // 3. Set up typography variables (fonts, sizes, weights)
    // 4. Create responsive typography scaling
    // 5. Return CSS variables string
  }

  async optimizeAssets(assets: BrandAsset[]): Promise<OptimizedAsset[]> {
    // 1. Compress images with multiple format variants
    // 2. Generate responsive image sizes
    // 3. Create WebP and AVIF versions for modern browsers
    // 4. Optimize SVGs with SVGO
    // 5. Generate favicon package (multiple sizes)
  }

  async validateBrandConfiguration(
    config: BrandConfiguration
  ): Promise<ValidationResult> {
    // 1. Check color contrast ratios for accessibility
    // 2. Validate custom CSS syntax and safety
    // 3. Test font loading and fallbacks
    // 4. Verify asset formats and sizes
    // 5. Check white-label completeness
  }
}

// Service: BrandApplicationService
// Dependencies: Template System, Client Dashboard, Email Service

class BrandApplicationService {
  async applyBrandingToTemplate(
    templateId: string,
    brandConfigId: string
  ): Promise<void> {
    // 1. Get template structure and sections
    // 2. Apply brand colors to template components
    // 3. Update logo placements and sizing
    // 4. Apply typography configuration
    // 5. Inject custom CSS overrides
    // 6. Update all associated client dashboards
  }

  async renderBrandedDashboard(
    clientId: string,
    brandConfig: BrandConfiguration
  ): Promise<BrandedDashboard> {
    // 1. Get base dashboard structure
    // 2. Apply brand configuration CSS
    // 3. Replace logos and assets
    // 4. Apply white-label configurations
    // 5. Inject custom CSS safely
    // 6. Return fully branded dashboard HTML
  }

  async generateBrandedEmailTemplate(
    emailTemplateId: string,
    brandConfig: BrandConfiguration
  ): Promise<string> {
    // 1. Get base email template
    // 2. Apply brand colors and typography
    // 3. Insert branded header/footer
    // 4. Apply email-safe CSS restrictions
    // 5. Return branded email HTML
  }
}
```

### CODE EXAMPLES

#### Example 1: Brand Configuration Compilation with Wedding Context
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { supabase } from '@/lib/supabase';
import { tinycolor } from '@ctrl/tinycolor';

export async function compileBrandConfiguration(
  configurationId: string
): Promise<CompiledBranding> {
  // Step 1: Get brand configuration
  const { data: brandConfig, error: configError } = await supabase
    .from('brand_configurations')
    .select(`
      *,
      assets:brand_assets(*),
      fonts:brand_fonts(*),
      color_palettes:brand_color_palettes(*),
      css_overrides:brand_css_overrides(*)
    `)
    .eq('id', configurationId)
    .single();
    
  if (configError) throw configError;
  
  // Step 2: Generate CSS custom properties
  const cssVariables = generateCSSVariables(brandConfig);
  
  // Step 3: Compile font imports
  const fontCSS = await compileFontImports(brandConfig.fonts);
  
  // Step 4: Generate component-specific styles
  const componentCSS = generateComponentStyles(brandConfig);
  
  // Step 5: Process custom CSS with safety validation
  const validatedCustomCSS = await validateAndProcessCustomCSS(brandConfig.custom_css);
  
  // Step 6: Apply white-label overrides
  const whiteLabelCSS = generateWhiteLabelCSS(brandConfig.white_label_config);
  
  // Step 7: Combine all CSS parts
  const compiledCSS = [
    '/* WedSync Brand Configuration - Auto-generated */',
    fontCSS,
    cssVariables,
    componentCSS,
    validatedCustomCSS,
    whiteLabelCSS
  ].filter(Boolean).join('\n\n');
  
  // Step 8: Minify and optimize
  const optimizedCSS = await minifyCSS(compiledCSS);
  
  // Step 9: Update database with compiled result
  await supabase
    .from('brand_configurations')
    .update({
      compiled_css: optimizedCSS,
      last_compiled_at: new Date().toISOString()
    })
    .eq('id', configurationId);
  
  return {
    configurationId,
    compiledCSS: optimizedCSS,
    fileSize: new Blob([optimizedCSS]).size,
    assetUrls: brandConfig.assets?.map(asset => asset.file_url) || [],
    compiledAt: new Date().toISOString(),
    version: brandConfig.version
  };
}

function generateCSSVariables(brandConfig: BrandConfiguration): string {
  const colors = brandConfig.color_config;
  const typography = brandConfig.typography_config;
  
  // Generate color variables with wedding-specific naming
  const colorVariables = Object.entries(colors).map(([key, value]) => {
    const color = tinycolor(value);
    
    return [
      `--brand-${key}: ${value};`,
      `--brand-${key}-rgb: ${color.toRgb().r}, ${color.toRgb().g}, ${color.toRgb().b};`,
      `--brand-${key}-light: ${color.lighten(10).toHexString()};`,
      `--brand-${key}-dark: ${color.darken(10).toHexString()};`,
      `--brand-${key}-alpha-50: ${color.setAlpha(0.5).toRgbString()};`
    ].join('\n  ');
  }).join('\n  ');
  
  // Generate typography variables
  const typographyVariables = Object.entries(typography).map(([role, config]) => [
    `--font-${role}: '${config.fontFamily}', ${config.fallbackFonts?.join(', ') || 'sans-serif'};`,
    `--font-${role}-weight: ${config.fontWeights?.[0] || 400};`,
    `--font-${role}-weight-bold: ${config.fontWeights?.[1] || 700};`,
    `--line-height-${role}: ${config.lineHeight || 1.5};`,
    `--letter-spacing-${role}: ${config.letterSpacing || 0}em;`
  ].join('\n  ')).join('\n  ');
  
  // Generate layout variables
  const layoutVariables = [
    '--border-radius-base: 0.5rem;',
    '--border-radius-large: 1rem;',
    '--spacing-unit: 1rem;',
    '--header-height: 4rem;',
    '--sidebar-width: 16rem;'
  ].join('\n  ');
  
  return `:root {
  /* Brand Colors */
  ${colorVariables}
  
  /* Typography */
  ${typographyVariables}
  
  /* Layout */
  ${layoutVariables}
}`;
}

async function compileFontImports(fonts: BrandFont[]): Promise<string> {
  const googleFonts = fonts.filter(font => font.font_source === 'google');
  const customFonts = fonts.filter(font => font.font_source === 'custom');
  
  let fontCSS = '';
  
  // Google Fonts import
  if (googleFonts.length > 0) {
    const fontFamilies = googleFonts.map(font => {
      const weights = font.font_weights?.join(';') || '400;700';
      return `${font.font_family.replace(' ', '+')}:wght@${weights}`;
    }).join('&family=');
    
    fontCSS += `@import url('https://fonts.googleapis.com/css2?family=${fontFamilies}&display=swap');\n`;
  }
  
  // Custom font imports
  for (const font of customFonts) {
    if (font.font_url) {
      fontCSS += `@font-face {
  font-family: '${font.font_family}';
  src: url('${font.font_url}') format('woff2');
  font-display: swap;
  font-weight: ${font.font_weights?.join(' ') || '400'};
}\n`;
    }
  }
  
  return fontCSS;
}

function generateComponentStyles(brandConfig: BrandConfiguration): string {
  // Wedding-specific component styling
  return `
/* Dashboard Header */
.dashboard-header {
  background: var(--brand-primary);
  color: var(--brand-text);
  font-family: var(--font-heading);
}

.dashboard-header .logo {
  max-height: 2.5rem;
  width: auto;
}

/* Welcome Section */
.welcome-section {
  background: linear-gradient(135deg, var(--brand-primary-alpha-50), var(--brand-secondary-alpha-50));
  border-radius: var(--border-radius-large);
  padding: calc(var(--spacing-unit) * 2);
}

.welcome-section h1 {
  font-family: var(--font-heading);
  color: var(--brand-primary-dark);
  font-weight: var(--font-heading-weight-bold);
}

/* Forms Section */
.forms-section .form-card {
  border: 2px solid var(--brand-secondary-light);
  border-radius: var(--border-radius-base);
  transition: border-color 0.2s ease;
}

.forms-section .form-card:hover {
  border-color: var(--brand-accent);
}

.form-card .status-badge {
  background: var(--brand-success);
  color: white;
  font-family: var(--font-body);
  font-weight: var(--font-body-weight-bold);
}

/* Timeline Section */
.timeline-progress {
  --progress-color: var(--brand-accent);
  --progress-background: var(--brand-secondary-light);
}

.timeline-node.completed {
  background: var(--brand-success);
}

.timeline-node.pending {
  background: var(--brand-warning);
}

/* Documents Section */
.document-grid .document-card {
  background: var(--brand-background);
  border: 1px solid var(--brand-secondary-light);
  border-radius: var(--border-radius-base);
}

.document-card .download-button {
  background: var(--brand-accent);
  color: white;
  font-family: var(--font-body);
  border-radius: calc(var(--border-radius-base) * 0.5);
}

/* Footer */
.dashboard-footer {
  background: var(--brand-secondary);
  color: var(--brand-text);
  font-family: var(--font-body);
  font-size: 0.875rem;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .dashboard-header .logo {
    max-height: 2rem;
  }
  
  .welcome-section {
    padding: var(--spacing-unit);
  }
}`;
}

function generateWhiteLabelCSS(whiteLabelConfig: any): string {
  if (!whiteLabelConfig?.removeWedSyncBranding) {
    return '';
  }
  
  return `
/* White-label overrides - Remove WedSync branding */
.powered-by-wedsync,
.wedsync-logo,
.wedsync-attribution {
  display: none !important;
}

.footer .wedsync-link {
  display: none !important;
}

/* Replace with custom footer content */
.custom-footer-content {
  display: block;
  font-family: var(--font-body);
  color: var(--brand-text);
}

/* Remove WedSync metadata */
meta[name="generator"][content*="WedSync"] {
  display: none;
}`;
}

export async function applyBrandingToClientDashboard(
  clientId: string,
  brandConfigId: string
): Promise<void> {
  // Step 1: Compile brand configuration
  const compiledBranding = await compileBrandConfiguration(brandConfigId);
  
  // Step 2: Get client dashboard template
  const { data: assignment } = await supabase
    .from('client_dashboard_assignments')
    .select(`
      *,
      template:dashboard_templates(*)
    `)
    .eq('client_id', clientId)
    .eq('is_active', true)
    .single();
  
  if (!assignment) throw new Error('No dashboard template assigned to client');
  
  // Step 3: Apply branding to template
  await supabase
    .from('dashboard_templates')
    .update({
      branding_config: {
        brandConfigId,
        compiledCSS: compiledBranding.compiledCSS,
        appliedAt: new Date().toISOString()
      }
    })
    .eq('id', assignment.template.id);
  
  // Step 4: Create brand application record
  await supabase
    .from('brand_applications')
    .insert({
      brand_config_id: brandConfigId,
      applied_to_type: 'client_dashboard',
      applied_to_id: clientId,
      is_active: true
    });
  
  // Step 5: Invalidate any cached dashboard renders
  await invalidateClientDashboardCache(clientId);
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for CSS processing libraries, color manipulation
- [x] Filesystem: Access existing branding and styling files
- [x] Memory: Store branding patterns and color palettes

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/ctrl/tinycolor", "color manipulation", 2000);
await mcp__context7__get-library-docs("/google/fonts", "web fonts api", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('BrandCompilerService', () => {
  it('should generate CSS variables from brand configuration', () => {
    const brandConfig = createTestBrandConfig({
      colors: { primary: '#8B4513', secondary: '#D4AF37' },
      typography: { heading: { fontFamily: 'Playfair Display' } }
    });
    
    const cssVariables = generateCSSVariables(brandConfig);
    expect(cssVariables).toContain('--brand-primary: #8B4513;');
    expect(cssVariables).toContain('--font-heading: \'Playfair Display\'');
  });

  it('should validate accessibility of color combinations', async () => {
    const colorConfig = {
      primary: '#8B4513', // Dark brown
      background: '#FFFFFF', // White
      text: '#000000' // Black
    };
    
    const accessibility = await checkAccessibility(colorConfig);
    expect(accessibility.overallScore).toBeGreaterThan(80);
    expect(accessibility.wcagCompliance.aa).toBe(true);
  });

  it('should apply white-label branding correctly', () => {
    const whiteLabelConfig = { removeWedSyncBranding: true };
    const css = generateWhiteLabelCSS(whiteLabelConfig);
    expect(css).toContain('.powered-by-wedsync');
    expect(css).toContain('display: none !important');
  });

  it('should compile Google Fonts imports correctly', async () => {
    const fonts = [
      { fontFamily: 'Playfair Display', fontSource: 'google', fontWeights: [400, 700] },
      { fontFamily: 'Open Sans', fontSource: 'google', fontWeights: [400, 600] }
    ];
    
    const fontCSS = await compileFontImports(fonts);
    expect(fontCSS).toContain('@import url(\'https://fonts.googleapis.com');
    expect(fontCSS).toContain('Playfair+Display:wght@400;700');
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Complete branding customization workflow', async () => {
  await mcp__playwright__browser_navigate({url: '/dashboard/branding'});
  
  // Upload logo
  await mcp__playwright__browser_file_upload({
    paths: ['/path/to/test-wedding-logo.png']
  });
  
  await mcp__playwright__browser_wait_for({text: 'Logo uploaded successfully'});
  
  // Configure colors
  await mcp__playwright__browser_click({element: 'colors tab', ref: 'button[data-tab="colors"]'});
  
  // Set primary color
  await mcp__playwright__browser_type({
    element: 'primary color input',
    ref: 'input[name="primaryColor"]',
    text: '#8B4513'
  });
  
  // Set secondary color
  await mcp__playwright__browser_type({
    element: 'secondary color input',
    ref: 'input[name="secondaryColor"]',
    text: '#D4AF37'
  });
  
  // Configure typography
  await mcp__playwright__browser_click({element: 'typography tab', ref: 'button[data-tab="typography"]'});
  
  await mcp__playwright__browser_select_option({
    element: 'heading font select',
    ref: 'select[name="headingFont"]',
    values: ['Playfair Display']
  });
  
  // Preview branding
  await mcp__playwright__browser_click({element: 'preview button', ref: 'button[data-testid="preview-branding"]'});
  
  // Verify preview shows custom colors and fonts
  await mcp__playwright__browser_wait_for({text: 'Preview Dashboard'});
  
  // Check that primary color is applied
  await mcp__playwright__browser_evaluate({
    function: `() => {
      const headerStyle = getComputedStyle(document.querySelector('.dashboard-header'));
      return headerStyle.backgroundColor === 'rgb(139, 69, 19)'; // #8B4513
    }`
  });
  
  // Save branding configuration
  await mcp__playwright__browser_click({element: 'save branding button', ref: 'button[data-testid="save-branding"]'});
  await mcp__playwright__browser_wait_for({text: 'Branding saved successfully'});
  
  // Apply to client dashboard
  await mcp__playwright__browser_click({element: 'apply to clients button', ref: 'button[data-testid="apply-branding"]'});
  
  // Select clients to apply branding
  await mcp__playwright__browser_click({element: 'select all clients', ref: 'input[data-testid="select-all-clients"]'});
  await mcp__playwright__browser_click({element: 'apply button', ref: 'button[data-testid="confirm-apply"]'});
  
  await mcp__playwright__browser_wait_for({text: 'Branding applied to 5 clients'});
  
  // Verify accessibility
  await mcp__playwright__browser_evaluate({
    function: '() => axe.run()'
  });
});
```

### ACCEPTANCE CRITERIA
- [x] Complete white-label branding with logo, colors, typography customization
- [x] Real-time preview across dashboard, booking page, and email contexts
- [x] Accessibility compliance checking with WCAG 2.1 AA standards
- [x] Google Fonts integration with custom font upload capability
- [x] Custom CSS injection with validation and safety checks
- [x] Performance: Brand compilation completes within 3 seconds
- [x] Security: CSS validation prevents malicious code injection
- [x] Accessibility: Branding editor meets WCAG 2.1 AA standards

### DEPENDENCIES
- Must complete after: WS-065 (Dashboard Templates), WS-066 (Section Configuration)
- Must complete before: All client-facing features require branding support
- Shares code with: Template system, dashboard rendering, email templates

### ESTIMATED EFFORT
- Team A Frontend: 32 hours (Branding editor, color picker, typography selector, CSS editor)
- Team D Full-stack: 24 hours (Brand compiler, CSS generation, asset optimization)
- Team B Backend: 16 hours (Database schema, API endpoints, brand application system)
- Total: 72 hours