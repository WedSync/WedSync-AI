# TECHNICAL SPECIFICATION: WS-310 - React Flow Implementation Guide
## Generated by Feature Development Session - 2025-01-20

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding photographer building client automation workflows
**I want to:** Use a professional React Flow-based visual builder to create wedding timeline-aware journeys with drag-drop modules
**So that:** I can create sophisticated automation workflows that understand wedding dates and industry milestones without needing to write code or use generic workflow tools

**Real Wedding Scenario:**
"A wedding photographer needs to automate sending different communications at specific intervals before the wedding (contract 6 months out, shot list request 6 weeks out, final timeline 1 week out, thank you email 1 week after). With React Flow implementation, they visually arrange timeline nodes that automatically calculate execution dates based on the wedding date, creating a professional workflow that adapts when couples change their wedding date."

### SPECIFICATION SOURCE
- **Feature ID:** WS-310
- **Original Spec:** /CORE-SPECIFICATIONS/02-WEDSYNC-SUPPLIER-PLATFORM/05-Customer-Journey/09-react-flow-implementation-guide.md
- **Current Implementation:** 65% complete (React Flow canvas exists)
- **Files to Modify:**
  - /wedsync/src/components/journey-builder/JourneyCanvas.tsx
  - /wedsync/src/hooks/useCanvasState.ts
- **New Files to Create:**
  - /wedsync/src/components/journey-builder/WeddingTimeline.tsx
  - /wedsync/src/lib/services/timeline-layout-service.ts
  - /wedsync/src/components/journey-builder/nodes/WeddingTimelineNode.tsx

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Journey canvas layout data
ALTER TABLE journeys ADD COLUMN IF NOT EXISTS canvas_config JSONB DEFAULT '{"viewport": {"x": 0, "y": 0, "zoom": 1}, "layout_type": "horizontal_timeline"}';

-- Node positioning and layout
CREATE TABLE IF NOT EXISTS journey_node_positions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  journey_id UUID NOT NULL REFERENCES journeys(id) ON DELETE CASCADE,
  step_id VARCHAR(100) NOT NULL,
  position_x NUMERIC(10,2) NOT NULL,
  position_y NUMERIC(10,2) NOT NULL,
  wedding_offset_days INTEGER, -- Days from wedding date
  layout_lane INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(journey_id, step_id)
);

-- Timeline layout settings
CREATE TABLE IF NOT EXISTS timeline_layout_settings (
  journey_id UUID PRIMARY KEY REFERENCES journeys(id) ON DELETE CASCADE,
  timeline_orientation VARCHAR(20) DEFAULT 'horizontal',
  timeline_scale NUMERIC(5,2) DEFAULT 1.0,
  lane_height INTEGER DEFAULT 120,
  node_spacing INTEGER DEFAULT 200,
  show_grid BOOLEAN DEFAULT TRUE,
  snap_to_grid BOOLEAN DEFAULT TRUE
);
```

#### API Endpoints Required
```typescript
// POST /api/journeys/{id}/layout/calculate
interface CalculateLayoutRequest {
  nodes: LayoutNode[];
  wedding_date: string;
  layout_type: 'horizontal_timeline' | 'vertical_timeline' | 'free_form';
}

interface LayoutNode {
  id: string;
  module_type: string;
  wedding_offset: {
    value: number;
    unit: 'days' | 'weeks' | 'months';
    direction: 'before' | 'after';
  };
}

interface CalculateLayoutResponse {
  positioned_nodes: PositionedNode[];
  timeline_bounds: {
    min_x: number;
    max_x: number;
    min_y: number;
    max_y: number;
  };
}

// GET /api/journeys/{id}/execution/status
interface ExecutionStatusResponse {
  instance_id: string;
  current_step: string;
  status: 'active' | 'paused' | 'completed' | 'failed';
  step_statuses: Record<string, StepStatus>;
  progress_percentage: number;
}
```

#### Frontend Components Required
```typescript
// Component: WeddingTimeline
// Location: /src/components/journey-builder/WeddingTimeline.tsx

interface WeddingTimelineProps {
  weddingDate: Date;
  nodes: TimelineNode[];
  onNodePositionChange: (nodeId: string, position: { x: number; y: number }) => void;
  onWeddingDateChange: (newDate: Date) => void;
}

// Key functionality:
- Horizontal timeline with wedding date as reference point
- Automatic node positioning based on wedding offset calculations
- Visual indicators for milestones (6mo, 3mo, 6wk, 1wk before/after)
- Drag-to-reposition with snap-to-timeline grid
- Wedding date picker that recalculates all node positions

// Component: ReactFlowCanvas
// Location: /src/components/journey-builder/ReactFlowCanvas.tsx

interface ReactFlowCanvasProps {
  journeyId: string;
  nodes: Node[];
  edges: Edge[];
  onNodesChange: OnNodesChange;
  onEdgesChange: OnEdgesChange;
  readonly?: boolean;
}

// Key functionality:
- React Flow v12.8.3 implementation
- Custom node types for wedding modules
- Real-time execution status overlay
- Timeline layout algorithm integration
- Professional UI using Overflow UI components
```

#### Integration Points
```typescript
// Service: TimelineLayoutService
// Dependencies: React Flow, Dagre layout library

class TimelineLayoutService {
  async calculateWeddingTimeline(
    nodes: LayoutNode[], 
    weddingDate: Date, 
    settings: TimelineLayoutSettings
  ): Promise<PositionedNode[]> {
    // Calculate wedding timeline positioning using Dagre
    const dagre = await import('dagre');
    const g = new dagre.graphlib.Graph();
    
    g.setGraph({ 
      rankdir: settings.timeline_orientation === 'horizontal' ? 'LR' : 'TB',
      ranksep: settings.node_spacing,
      nodesep: settings.lane_height
    });
    
    // Add nodes with wedding offset calculations
    nodes.forEach(node => {
      const executionDate = this.calculateExecutionDate(node.wedding_offset, weddingDate);
      g.setNode(node.id, { 
        width: 200, 
        height: 100,
        wedding_date_offset: differenceInDays(executionDate, weddingDate)
      });
    });
    
    // Apply layout algorithm
    dagre.layout(g);
    
    return nodes.map(node => ({
      id: node.id,
      position: {
        x: g.node(node.id).x,
        y: g.node(node.id).y
      },
      execution_date: this.calculateExecutionDate(node.wedding_offset, weddingDate)
    }));
  }
  
  private calculateExecutionDate(
    offset: WeddingOffset, 
    weddingDate: Date
  ): Date {
    const multiplier = offset.direction === 'before' ? -1 : 1;
    const days = offset.value * multiplier;
    
    switch (offset.unit) {
      case 'days':
        return addDays(weddingDate, days);
      case 'weeks':
        return addWeeks(weddingDate, days);
      case 'months':
        return addMonths(weddingDate, days);
      default:
        return weddingDate;
    }
  }
}
```

### CODE EXAMPLES

#### Example 1: React Flow Implementation with Wedding Timeline
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import React, { useState, useCallback, useEffect } from 'react';
import {
  ReactFlow,
  Node,
  Edge,
  addEdge,
  Connection,
  useNodesState,
  useEdgesState,
  Controls,
  Background,
  Panel,
  NodeTypes
} from '@xyflow/react';
import '@xyflow/react/dist/style.css';
import { addDays, format } from 'date-fns';

// Wedding-specific node types
import { WeddingTimelineNode } from './nodes/WeddingTimelineNode';
import { EmailModuleNode } from './nodes/EmailModuleNode';
import { FormModuleNode } from './nodes/FormModuleNode';

const nodeTypes: NodeTypes = {
  weddingTimeline: WeddingTimelineNode,
  emailModule: EmailModuleNode,
  formModule: FormModuleNode,
};

interface WeddingJourneyCanvasProps {
  journeyId: string;
  weddingDate: Date;
  onWeddingDateChange: (date: Date) => void;
}

export const WeddingJourneyCanvas: React.FC<WeddingJourneyCanvasProps> = ({
  journeyId,
  weddingDate,
  onWeddingDateChange
}) => {
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const [isExecuting, setIsExecuting] = useState(false);
  const [executionStatus, setExecutionStatus] = useState<Record<string, string>>({});

  // Initialize canvas with wedding timeline
  useEffect(() => {
    loadJourneyData();
    subscribeToExecutionUpdates();
  }, [journeyId]);

  // Recalculate node positions when wedding date changes
  useEffect(() => {
    recalculateTimelinePositions();
  }, [weddingDate]);

  async function loadJourneyData() {
    try {
      const response = await fetch(`/api/journeys/${journeyId}`);
      const journey = await response.json();
      
      if (journey.canvas_config?.nodes) {
        setNodes(journey.canvas_config.nodes);
        setEdges(journey.canvas_config.edges || []);
      }
    } catch (error) {
      console.error('Failed to load journey data:', error);
    }
  }

  function subscribeToExecutionUpdates() {
    // Supabase realtime subscription for execution status
    const subscription = supabase
      .channel(`journey_execution_${journeyId}`)
      .on('postgres_changes', 
        { 
          event: '*', 
          schema: 'public', 
          table: 'journey_step_executions',
          filter: `journey_id=eq.${journeyId}`
        },
        (payload) => {
          setExecutionStatus(prev => ({
            ...prev,
            [payload.new.step_id]: payload.new.status
          }));
        }
      )
      .subscribe();

    return () => subscription.unsubscribe();
  }

  async function recalculateTimelinePositions() {
    try {
      const response = await fetch(`/api/journeys/${journeyId}/layout/calculate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          nodes: nodes.map(node => ({
            id: node.id,
            module_type: node.type,
            wedding_offset: node.data.weddingOffset
          })),
          wedding_date: weddingDate.toISOString(),
          layout_type: 'horizontal_timeline'
        })
      });

      const { positioned_nodes } = await response.json();

      // Update node positions
      setNodes(prevNodes => 
        prevNodes.map(node => {
          const positioned = positioned_nodes.find(p => p.id === node.id);
          return positioned 
            ? { ...node, position: positioned.position }
            : node;
        })
      );
    } catch (error) {
      console.error('Failed to recalculate timeline:', error);
    }
  }

  const onConnect = useCallback(
    (params: Connection) => setEdges((eds) => addEdge(params, eds)),
    [setEdges]
  );

  async function handleWeddingDateChange(newDate: Date) {
    onWeddingDateChange(newDate);
    
    // Show loading state while recalculating
    setIsExecuting(true);
    await recalculateTimelinePositions();
    setIsExecuting(false);
  }

  async function executeJourney() {
    try {
      setIsExecuting(true);
      
      const response = await fetch(`/api/journeys/${journeyId}/execute`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          wedding_date: weddingDate.toISOString(),
          nodes: nodes.map(node => ({
            id: node.id,
            type: node.type,
            config: node.data
          }))
        })
      });

      if (response.ok) {
        const { instance_id } = await response.json();
        console.log('Journey execution started:', instance_id);
      }
    } catch (error) {
      console.error('Failed to execute journey:', error);
    }
  }

  return (
    <div className="h-full w-full">
      <ReactFlow
        nodes={nodes.map(node => ({
          ...node,
          data: {
            ...node.data,
            executionStatus: executionStatus[node.id] || 'idle',
            weddingDate,
            isExecuting
          }
        }))}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onConnect={onConnect}
        nodeTypes={nodeTypes}
        fitView
        className="wedding-flow-canvas"
      >
        <Background variant="dots" />
        <Controls />
        
        {/* Wedding Date Panel */}
        <Panel position="top-left" className="p-4 bg-white rounded-lg shadow-lg">
          <div className="space-y-2">
            <label className="text-sm font-medium">Wedding Date</label>
            <input
              type="date"
              value={format(weddingDate, 'yyyy-MM-dd')}
              onChange={(e) => handleWeddingDateChange(new Date(e.target.value))}
              className="w-full p-2 border rounded"
            />
            <div className="text-xs text-gray-500">
              Timeline will adjust automatically
            </div>
          </div>
        </Panel>

        {/* Execution Controls */}
        <Panel position="top-right" className="p-4 bg-white rounded-lg shadow-lg">
          <div className="space-y-2">
            <button
              onClick={executeJourney}
              disabled={isExecuting}
              className={`w-full px-4 py-2 rounded font-medium ${
                isExecuting 
                  ? 'bg-gray-300 text-gray-500' 
                  : 'bg-blue-600 text-white hover:bg-blue-700'
              }`}
            >
              {isExecuting ? 'Executing...' : 'Start Journey'}
            </button>
            
            {Object.keys(executionStatus).length > 0 && (
              <div className="text-xs">
                <div className="font-medium">Execution Status:</div>
                {Object.entries(executionStatus).map(([stepId, status]) => (
                  <div key={stepId} className="flex justify-between">
                    <span>{stepId}:</span>
                    <span className={`capitalize ${
                      status === 'completed' ? 'text-green-600' :
                      status === 'failed' ? 'text-red-600' :
                      status === 'running' ? 'text-blue-600' : 'text-gray-500'
                    }`}>
                      {status}
                    </span>
                  </div>
                ))}
              </div>
            )}
          </div>
        </Panel>

        {/* Timeline Milestones */}
        <Panel position="bottom-center" className="bg-white/90 p-2 rounded">
          <div className="flex space-x-4 text-xs">
            <span>6 months before</span>
            <span>3 months before</span>
            <span>6 weeks before</span>
            <span className="font-bold">Wedding Day</span>
            <span>1 week after</span>
            <span>1 month after</span>
          </div>
        </Panel>
      </ReactFlow>
    </div>
  );
};
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for React Flow v12, Dagre layout
- [ ] Playwright: Test drag-drop workflow building
- [ ] Filesystem: Access component templates from Overflow UI

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/xyflow/xyflow", "react flow custom nodes", 3000);
await mcp__context7__get-library-docs("/dagrejs/dagre", "graph layout algorithms", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('TimelineLayoutService', () => {
  it('should calculate correct wedding timeline positions', async () => {
    const service = new TimelineLayoutService();
    const nodes = [
      { id: '1', wedding_offset: { value: 6, unit: 'months', direction: 'before' } },
      { id: '2', wedding_offset: { value: 1, unit: 'weeks', direction: 'before' } }
    ];
    const weddingDate = new Date('2025-06-15');
    
    const positions = await service.calculateWeddingTimeline(nodes, weddingDate, defaultSettings);
    
    expect(positions).toHaveLength(2);
    expect(positions[0].execution_date).toEqual(new Date('2024-12-15')); // 6 months before
    expect(positions[1].execution_date).toEqual(new Date('2025-06-08')); // 1 week before
  });

  it('should recalculate positions when wedding date changes', async () => {
    const service = new TimelineLayoutService();
    const nodes = [{ id: '1', wedding_offset: { value: 30, unit: 'days', direction: 'before' } }];
    
    const originalDate = new Date('2025-06-15');
    const newDate = new Date('2025-07-15');
    
    const originalPositions = await service.calculateWeddingTimeline(nodes, originalDate, defaultSettings);
    const newPositions = await service.calculateWeddingTimeline(nodes, newDate, defaultSettings);
    
    expect(originalPositions[0].execution_date).toEqual(new Date('2025-05-16'));
    expect(newPositions[0].execution_date).toEqual(new Date('2025-06-15'));
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('React Flow wedding timeline interaction', async () => {
  await mcp__playwright__browser_navigate({url: '/journeys/builder/123'});
  await mcp__playwright__browser_snapshot();
  
  // Test wedding date change recalculates timeline
  await mcp__playwright__browser_type({
    element: "Wedding date input",
    ref: "[data-testid='wedding-date']",
    text: "2025-08-15"
  });
  
  await mcp__playwright__browser_wait_for({text: "Timeline updated", time: 3});
  await mcp__playwright__browser_snapshot();
  
  // Test dragging module to canvas
  await mcp__playwright__browser_drag({
    startElement: "Email module",
    startRef: "[data-module='email']",
    endElement: "React Flow canvas",
    endRef: ".react-flow__renderer"
  });
  
  await mcp__playwright__browser_snapshot();
});
```

### ACCEPTANCE CRITERIA
- [ ] React Flow v12.8.3 canvas renders wedding journey workflows
- [ ] Wedding timeline automatically positions nodes based on wedding date offsets
- [ ] Dragging nodes updates database positions in real-time
- [ ] Wedding date changes trigger automatic timeline recalculation
- [ ] Real-time execution status updates display on canvas
- [ ] Professional UI using Overflow UI components (MIT licensed)
- [ ] Performance: Smooth rendering of 100+ node workflows
- [ ] Security: Journey execution is authenticated and validated
- [ ] Accessibility: Canvas is keyboard navigable with screen reader support

### DEPENDENCIES
- Must complete after: WS-309 (Journey Module Types for node components)
- Must complete before: WS-311 (Communications integration)
- Shares code with: Journey execution engine, real-time updates, timeline calculations

### ESTIMATED EFFORT
- Team A Frontend: 40 hours
- Team B Backend: 20 hours
- Team C Integration: 16 hours
- Team D Platform: 8 hours
- Team E General: 8 hours
- Team F Workflows: 20 hours
- Team G Performance: 12 hours
- Total: 124 hours