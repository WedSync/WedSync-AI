# TECHNICAL SPECIFICATION: WS-196 - API Routes Structure
## Generated by Feature Development Session - August 25, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** WedSync platform architect designing the API foundation for supplier and couple interactions
**I want to:** Implement a standardized API route structure with consistent patterns, clear separation of concerns, and scalable organization
**So that:** I can ensure that suppliers managing multiple wedding bookings have predictable API endpoints for client management, couples can access their wedding planning data through intuitive routes, and third-party integrations can reliably connect to wedding vendor services across different supplier types (photographers, venues, caterers)

**Real Wedding Scenario:**
A photography supplier manages 15 couples with weddings scheduled over 6 months. They need API endpoints that logically separate client management (`/api/suppliers/{id}/clients`), form generation (`/api/forms/{formId}/generate`), and portfolio management (`/api/suppliers/{id}/portfolio`). Meanwhile, couples planning their Yorkshire Dales wedding need consistent endpoints for accessing venue availability (`/api/suppliers/venues/{venueId}/availability`), comparing photographer packages (`/api/suppliers/photographers/{id}/packages`), and tracking their wedding timeline (`/api/couples/{coupleId}/timeline`). The API structure ensures that a venue's booking system can integrate seamlessly while a photography studio's custom CRM can access the same data through predictable, RESTful endpoints.

### SPECIFICATION SOURCE
- **Feature ID:** WS-196
- **Original Spec:** /CORE-SPECIFICATIONS/01-TECHNICAL-ARCHITECTURE/03-API-Architecture/01-api-routes-structure md.md
- **Current Implementation:** 0% complete (new)
- **Files to Modify:** None (new feature)
- **New Files to Create:** 
  - `/wedsync/app/api/README.md`
  - `/wedsync/lib/api/route-patterns.ts`
  - `/wedsync/lib/api/response-schemas.ts`
  - `/wedsync/lib/api/validation-helpers.ts`
  - `/wedsync/types/api.ts`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- API request tracking and analytics
CREATE TABLE api_request_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  request_id UUID UNIQUE NOT NULL DEFAULT gen_random_uuid(),
  
  -- Request details
  method TEXT NOT NULL CHECK (method IN ('GET', 'POST', 'PUT', 'DELETE', 'PATCH')),
  route_pattern TEXT NOT NULL, -- e.g., '/api/suppliers/[id]/clients'
  full_path TEXT NOT NULL,
  user_agent TEXT,
  ip_address INET,
  
  -- Authentication context
  user_id UUID REFERENCES users(id),
  session_id TEXT,
  api_key_id UUID REFERENCES api_keys(id),
  
  -- Response details
  status_code INTEGER NOT NULL,
  response_time_ms INTEGER NOT NULL,
  response_size_bytes INTEGER,
  
  -- Request metadata
  request_headers JSONB,
  query_params JSONB,
  body_size_bytes INTEGER,
  
  -- Error tracking
  error_type TEXT, -- 'validation', 'auth', 'server', 'rate_limit'
  error_message TEXT,
  stack_trace TEXT,
  
  -- Wedding business context
  supplier_id UUID REFERENCES suppliers(id),
  couple_id UUID REFERENCES couples(id),
  form_id UUID REFERENCES forms(id),
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_api_logs_route ON api_request_logs(route_pattern, created_at DESC);
CREATE INDEX idx_api_logs_user ON api_request_logs(user_id, created_at DESC);
CREATE INDEX idx_api_logs_performance ON api_request_logs(response_time_ms DESC, created_at DESC);
CREATE INDEX idx_api_logs_errors ON api_request_logs(status_code, created_at DESC) WHERE status_code >= 400;

-- API versioning and deprecation tracking
CREATE TABLE api_versions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  version_identifier TEXT UNIQUE NOT NULL, -- '1.0', '1.1', '2.0'
  
  -- Version metadata
  release_date DATE NOT NULL,
  deprecation_date DATE,
  sunset_date DATE,
  
  -- Version configuration
  is_active BOOLEAN DEFAULT TRUE,
  is_deprecated BOOLEAN DEFAULT FALSE,
  supported_endpoints TEXT[], -- Array of endpoint patterns
  
  -- Documentation
  changelog TEXT,
  migration_guide_url TEXT,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Route configuration and feature flags
CREATE TABLE api_route_configs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  route_pattern TEXT UNIQUE NOT NULL,
  
  -- Route metadata
  description TEXT NOT NULL,
  handler_file TEXT NOT NULL, -- 'app/api/suppliers/[id]/route.ts'
  supported_methods TEXT[] NOT NULL, -- ['GET', 'POST', 'PUT']
  
  -- Access control
  requires_auth BOOLEAN DEFAULT TRUE,
  required_permissions TEXT[],
  rate_limit_tier TEXT CHECK (rate_limit_tier IN ('basic', 'premium', 'unlimited')),
  
  -- Feature flags
  is_enabled BOOLEAN DEFAULT TRUE,
  beta_access_only BOOLEAN DEFAULT FALSE,
  maintenance_mode BOOLEAN DEFAULT FALSE,
  
  -- Version support
  min_api_version TEXT NOT NULL,
  max_api_version TEXT,
  
  -- Performance settings
  cache_ttl_seconds INTEGER DEFAULT 0,
  timeout_seconds INTEGER DEFAULT 30,
  max_request_size_mb INTEGER DEFAULT 10,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Business context mapping for API endpoints
CREATE TABLE api_business_contexts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  route_pattern TEXT NOT NULL REFERENCES api_route_configs(route_pattern),
  
  -- Wedding industry context
  business_domain TEXT NOT NULL, -- 'supplier_management', 'client_forms', 'portfolio'
  vendor_types TEXT[], -- ['photographer', 'venue', 'catering'] if applicable
  
  -- Usage patterns
  typical_use_cases TEXT[] NOT NULL,
  peak_usage_seasons TEXT[], -- ['spring', 'summer'] for wedding season traffic
  expected_qps INTEGER, -- Queries per second during normal operation
  peak_qps INTEGER, -- Expected peak load
  
  -- Integration requirements
  third_party_integrations TEXT[], -- ['zapier', 'custom_crm', 'booking_systems']
  webhook_events TEXT[], -- Events this endpoint might trigger
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

#### API Endpoints Required
```typescript
// Base API structure with consistent response patterns
interface APIResponse<T = any> {
  success: boolean;
  data?: T;
  error?: {
    code: string;
    message: string;
    details?: Record<string, any>;
  };
  meta?: {
    requestId: string;
    timestamp: string;
    version: string;
    pagination?: PaginationMeta;
  };
}

// GET /api/system/routes - Get available API routes
interface GetAPIRoutesResponse {
  success: boolean;
  data: {
    routes: APIRouteInfo[];
    version: string;
    deprecatedRoutes: DeprecatedRoute[];
  };
}

// GET /api/system/health - API health check
interface APIHealthResponse {
  success: boolean;
  data: {
    status: 'healthy' | 'degraded' | 'unhealthy';
    version: string;
    timestamp: string;
    services: ServiceHealth[];
    performance: {
      avgResponseTime: number;
      errorRate: number;
      requestsPerMinute: number;
    };
  };
}
```

#### Frontend Components Required
```typescript
// Component: APIExplorer
// Location: /src/components/developer/APIExplorer.tsx

interface Props {
  availableRoutes: APIRouteInfo[];
  userPermissions: string[];
  currentAPIVersion: string;
}

// Key functionality:
- Interactive API endpoint explorer with real-time testing capabilities
- Route documentation with parameter examples and response schemas
- Authentication context switching for different user types (supplier/couple)
- Request/response logging with performance metrics display
```

#### Integration Points
```typescript
// Service: APIRouteManager
// Dependencies: Next.js App Router, authentication, logging, rate limiting

class APIRouteManager {
  async validateRoute(pattern: string, method: string): Promise<RouteValidation> {
    // Route validation with pattern matching and method verification
  }
  
  async logRequest(request: APIRequest, response: APIResponse): Promise<void> {
    // Comprehensive request logging with business context
  }
}
```

### CODE EXAMPLES

#### Example 1: Comprehensive API Route Structure
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
// app/api/suppliers/[id]/clients/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { z } from 'zod';
import { v4 as uuidv4 } from 'uuid';
import { createClient } from '@supabase/supabase-js';
import { authOptions } from '@/lib/auth';
import { APIResponse, createAPIResponse, logAPIRequest } from '@/lib/api/response-schemas';
import { validateRouteAccess } from '@/lib/api/validation-helpers';
import { rateLimitCheck } from '@/lib/api/rate-limiting';

// Validation schemas for wedding industry context
const GetClientsQuerySchema = z.object({
  page: z.coerce.number().min(1).default(1),
  limit: z.coerce.number().min(1).max(100).default(20),
  status: z.enum(['active', 'pending', 'completed', 'cancelled']).optional(),
  wedding_date_from: z.string().datetime().optional(),
  wedding_date_to: z.string().datetime().optional(),
  search: z.string().min(1).max(100).optional(), // Couple name or venue search
  sort: z.enum(['wedding_date', 'created_at', 'couple_name']).default('wedding_date'),
  order: z.enum(['asc', 'desc']).default('asc'),
});

const CreateClientSchema = z.object({
  couple_name: z.string().min(2).max(100),
  wedding_date: z.string().datetime(),
  venue_name: z.string().min(1).max(200).optional(),
  guest_count: z.number().min(1).max(1000).optional(),
  budget_range: z.enum(['under_1000', '1000_2500', '2500_5000', '5000_plus']).optional(),
  contact_email: z.string().email(),
  contact_phone: z.string().optional(),
  requirements: z.string().max(1000).optional(),
  preferred_style: z.string().max(100).optional(), // Photography style, catering style, etc.
});

interface RouteParams {
  params: { id: string };
}

// GET /api/suppliers/[id]/clients - List supplier's clients
export async function GET(request: NextRequest, { params }: RouteParams) {
  const requestId = uuidv4();
  const startTime = Date.now();

  try {
    // Step 1: Authentication and session validation
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      await logAPIRequest({
        requestId,
        method: 'GET',
        routePattern: '/api/suppliers/[id]/clients',
        statusCode: 401,
        responseTime: Date.now() - startTime,
        errorType: 'auth',
        errorMessage: 'No valid session'
      });
      
      return createAPIResponse({
        success: false,
        error: {
          code: 'UNAUTHORIZED',
          message: 'Authentication required to access client data'
        },
        meta: { requestId, timestamp: new Date().toISOString(), version: '1.0' }
      }, 401);
    }

    // Step 2: Route parameter validation
    const supplierId = params.id;
    if (!supplierId || !/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(supplierId)) {
      return createAPIResponse({
        success: false,
        error: {
          code: 'INVALID_SUPPLIER_ID',
          message: 'Supplier ID must be a valid UUID'
        },
        meta: { requestId, timestamp: new Date().toISOString(), version: '1.0' }
      }, 400);
    }

    // Step 3: Authorization - ensure user can access this supplier's data
    const hasAccess = await validateRouteAccess({
      userId: session.user.id,
      resourceType: 'supplier',
      resourceId: supplierId,
      action: 'read'
    });

    if (!hasAccess) {
      return createAPIResponse({
        success: false,
        error: {
          code: 'FORBIDDEN',
          message: 'You do not have permission to access this supplier\'s client data'
        },
        meta: { requestId, timestamp: new Date().toISOString(), version: '1.0' }
      }, 403);
    }

    // Step 4: Rate limiting check
    const rateLimitResult = await rateLimitCheck({
      userId: session.user.id,
      endpoint: 'supplier_clients',
      tier: 'standard'
    });

    if (!rateLimitResult.allowed) {
      return createAPIResponse({
        success: false,
        error: {
          code: 'RATE_LIMIT_EXCEEDED',
          message: `Rate limit exceeded. Try again in ${rateLimitResult.retryAfter} seconds`
        },
        meta: { requestId, timestamp: new Date().toISOString(), version: '1.0' }
      }, 429);
    }

    // Step 5: Query parameter validation with wedding industry context
    const url = new URL(request.url);
    const queryParams = Object.fromEntries(url.searchParams.entries());
    
    const validatedQuery = GetClientsQuerySchema.parse(queryParams);

    // Step 6: Database query with Supabase
    const supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_KEY!
    );

    let query = supabase
      .from('clients')
      .select(`
        id,
        couple_name,
        wedding_date,
        venue_name,
        guest_count,
        budget_range,
        contact_email,
        contact_phone,
        status,
        requirements,
        preferred_style,
        created_at,
        updated_at,
        forms:client_forms(id, title, status, created_at)
      `)
      .eq('supplier_id', supplierId)
      .range(
        (validatedQuery.page - 1) * validatedQuery.limit,
        validatedQuery.page * validatedQuery.limit - 1
      );

    // Apply filters based on wedding industry needs
    if (validatedQuery.status) {
      query = query.eq('status', validatedQuery.status);
    }
    
    if (validatedQuery.wedding_date_from) {
      query = query.gte('wedding_date', validatedQuery.wedding_date_from);
    }
    
    if (validatedQuery.wedding_date_to) {
      query = query.lte('wedding_date', validatedQuery.wedding_date_to);
    }
    
    if (validatedQuery.search) {
      query = query.or(`couple_name.ilike.%${validatedQuery.search}%,venue_name.ilike.%${validatedQuery.search}%`);
    }

    // Apply sorting
    query = query.order(validatedQuery.sort, { ascending: validatedQuery.order === 'asc' });

    const { data: clients, error: queryError, count } = await query;

    if (queryError) {
      await logAPIRequest({
        requestId,
        method: 'GET',
        routePattern: '/api/suppliers/[id]/clients',
        statusCode: 500,
        responseTime: Date.now() - startTime,
        errorType: 'server',
        errorMessage: queryError.message,
        supplierId
      });

      return createAPIResponse({
        success: false,
        error: {
          code: 'DATABASE_ERROR',
          message: 'Failed to retrieve client data',
          details: { queryError: queryError.message }
        },
        meta: { requestId, timestamp: new Date().toISOString(), version: '1.0' }
      }, 500);
    }

    // Step 7: Get total count for pagination
    const { count: totalCount } = await supabase
      .from('clients')
      .select('id', { count: 'exact', head: true })
      .eq('supplier_id', supplierId);

    // Step 8: Transform data for wedding industry context
    const transformedClients = clients?.map(client => ({
      ...client,
      // Calculate days until wedding
      days_until_wedding: client.wedding_date 
        ? Math.ceil((new Date(client.wedding_date).getTime() - new Date().getTime()) / (1000 * 60 * 60 * 24))
        : null,
      
      // Determine wedding season
      wedding_season: client.wedding_date 
        ? getWeddingSeason(new Date(client.wedding_date))
        : null,
        
      // Count forms for this client
      form_count: client.forms?.length || 0,
      
      // Budget display (convert enum to readable format)
      budget_display: getBudgetDisplay(client.budget_range),
    }));

    // Step 9: Prepare pagination metadata
    const paginationMeta = {
      page: validatedQuery.page,
      limit: validatedQuery.limit,
      total: totalCount || 0,
      totalPages: Math.ceil((totalCount || 0) / validatedQuery.limit),
      hasNextPage: validatedQuery.page < Math.ceil((totalCount || 0) / validatedQuery.limit),
      hasPreviousPage: validatedQuery.page > 1,
    };

    // Step 10: Log successful request
    await logAPIRequest({
      requestId,
      method: 'GET',
      routePattern: '/api/suppliers/[id]/clients',
      statusCode: 200,
      responseTime: Date.now() - startTime,
      supplierId,
      userId: session.user.id
    });

    // Step 11: Return structured response
    return createAPIResponse({
      success: true,
      data: {
        clients: transformedClients,
        summary: {
          total_clients: totalCount || 0,
          upcoming_weddings: transformedClients?.filter(c => 
            c.days_until_wedding && c.days_until_wedding > 0 && c.days_until_wedding <= 180
          ).length || 0,
          active_clients: transformedClients?.filter(c => c.status === 'active').length || 0,
        }
      },
      meta: {
        requestId,
        timestamp: new Date().toISOString(),
        version: '1.0',
        pagination: paginationMeta
      }
    });

  } catch (error) {
    // Step 12: Handle unexpected errors
    await logAPIRequest({
      requestId,
      method: 'GET',
      routePattern: '/api/suppliers/[id]/clients',
      statusCode: 500,
      responseTime: Date.now() - startTime,
      errorType: 'server',
      errorMessage: error instanceof Error ? error.message : 'Unknown error',
      stackTrace: error instanceof Error ? error.stack : undefined,
      supplierId: params.id
    });

    return createAPIResponse({
      success: false,
      error: {
        code: 'INTERNAL_SERVER_ERROR',
        message: 'An unexpected error occurred while retrieving client data'
      },
      meta: { requestId, timestamp: new Date().toISOString(), version: '1.0' }
    }, 500);
  }
}

// POST /api/suppliers/[id]/clients - Create new client
export async function POST(request: NextRequest, { params }: RouteParams) {
  const requestId = uuidv4();
  const startTime = Date.now();

  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return createAPIResponse({
        success: false,
        error: {
          code: 'UNAUTHORIZED',
          message: 'Authentication required to create client'
        },
        meta: { requestId, timestamp: new Date().toISOString(), version: '1.0' }
      }, 401);
    }

    // Validate supplier ID
    const supplierId = params.id;
    if (!supplierId || !/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(supplierId)) {
      return createAPIResponse({
        success: false,
        error: {
          code: 'INVALID_SUPPLIER_ID',
          message: 'Supplier ID must be a valid UUID'
        },
        meta: { requestId, timestamp: new Date().toISOString(), version: '1.0' }
      }, 400);
    }

    // Parse and validate request body
    const requestBody = await request.json();
    const validatedData = CreateClientSchema.parse(requestBody);

    // Check authorization
    const hasAccess = await validateRouteAccess({
      userId: session.user.id,
      resourceType: 'supplier',
      resourceId: supplierId,
      action: 'write'
    });

    if (!hasAccess) {
      return createAPIResponse({
        success: false,
        error: {
          code: 'FORBIDDEN',
          message: 'You do not have permission to create clients for this supplier'
        },
        meta: { requestId, timestamp: new Date().toISOString(), version: '1.0' }
      }, 403);
    }

    // Create client in database
    const supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_KEY!
    );

    const { data: newClient, error: createError } = await supabase
      .from('clients')
      .insert({
        id: uuidv4(),
        supplier_id: supplierId,
        ...validatedData,
        status: 'active',
        created_by: session.user.id
      })
      .select()
      .single();

    if (createError) {
      return createAPIResponse({
        success: false,
        error: {
          code: 'CREATE_FAILED',
          message: 'Failed to create client',
          details: { error: createError.message }
        },
        meta: { requestId, timestamp: new Date().toISOString(), version: '1.0' }
      }, 500);
    }

    return createAPIResponse({
      success: true,
      data: {
        client: {
          ...newClient,
          days_until_wedding: Math.ceil((new Date(newClient.wedding_date).getTime() - new Date().getTime()) / (1000 * 60 * 60 * 24)),
          wedding_season: getWeddingSeason(new Date(newClient.wedding_date)),
          budget_display: getBudgetDisplay(newClient.budget_range)
        }
      },
      meta: { requestId, timestamp: new Date().toISOString(), version: '1.0' }
    }, 201);

  } catch (error) {
    if (error instanceof z.ZodError) {
      return createAPIResponse({
        success: false,
        error: {
          code: 'VALIDATION_ERROR',
          message: 'Invalid request data',
          details: { validationErrors: error.errors }
        },
        meta: { requestId, timestamp: new Date().toISOString(), version: '1.0' }
      }, 400);
    }

    return createAPIResponse({
      success: false,
      error: {
        code: 'INTERNAL_SERVER_ERROR',
        message: 'An unexpected error occurred'
      },
      meta: { requestId, timestamp: new Date().toISOString(), version: '1.0' }
    }, 500);
  }
}

// Helper functions for wedding industry context
function getWeddingSeason(weddingDate: Date): string {
  const month = weddingDate.getMonth() + 1;
  if (month >= 3 && month <= 5) return 'spring';
  if (month >= 6 && month <= 8) return 'summer';
  if (month >= 9 && month <= 11) return 'autumn';
  return 'winter';
}

function getBudgetDisplay(budgetRange?: string): string {
  const budgetMap: Record<string, string> = {
    'under_1000': 'Under £1,000',
    '1000_2500': '£1,000 - £2,500',
    '2500_5000': '£2,500 - £5,000',
    '5000_plus': '£5,000+'
  };
  return budgetMap[budgetRange || ''] || 'Not specified';
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for Next.js App Router, API route patterns, RESTful design
- [x] Filesystem: Manage API route structure and helper files
- [x] Supabase: Database operations and API endpoint validation

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/vercel/next.js", "app router api routes", 4000);
await mcp__context7__get-library-docs("/zod/zod", "request validation", 3000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('API Route Structure', () => {
  it('should validate supplier client endpoint with proper authentication', () => {
    // Test comprehensive supplier client API with authentication flow
  });
  
  it('should handle pagination and filtering for wedding date ranges', () => {
    // Test wedding industry specific filtering and pagination
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('API route structure supports supplier workflow', async () => {
  await mcp__playwright__browser_navigate({url: '/api-explorer'});
  
  // Test API endpoint discovery and authentication
  await mcp__playwright__browser_click({
    element: 'test api endpoint button',
    ref: '[data-testid="test-endpoint"]'
  });
  
  // Verify response structure and wedding industry context
  await expect(page.locator('[data-testid="api-response"]')).toContainText('clients');
});
```

### ACCEPTANCE CRITERIA
- [x] API routes follow Next.js App Router conventions with clear separation between supplier/couple endpoints
- [x] All endpoints return consistent JSON structure with success/error patterns and request tracking
- [x] Route validation supports UUID parameters, query filtering, and wedding industry business context
- [x] Performance: API responses include request ID tracking and response time under 200ms for simple queries
- [x] Security: All routes require authentication, validate permissions, and include rate limiting
- [x] Accessibility: API documentation includes clear parameter descriptions and example responses

### DEPENDENCIES
- Must complete before: WS-197 (Middleware Setup), WS-198 (Error Handling), WS-199 (Rate Limiting)
- Foundation for: All API development, authentication flows, business logic endpoints
- Shares code with: Authentication system, database models, response formatting

### ESTIMATED EFFORT
- Team A Backend: 48 hours (API route structure, validation patterns, response schemas)
- Team B Infrastructure: 24 hours (Route configuration, monitoring, documentation)
- Total: 72 hours