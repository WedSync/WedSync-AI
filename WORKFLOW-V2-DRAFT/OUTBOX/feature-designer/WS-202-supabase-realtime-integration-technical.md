# TECHNICAL SPECIFICATION: WS-202 - Supabase Realtime Integration
## Generated by Feature Development Session - 2025-08-25

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding photographer or venue coordinator
**I want to:** See form responses and updates from couples instantly without refreshing my browser
**So that:** I can react immediately to changes and provide better service, saving 2-3 hours per wedding on follow-ups

**Real Wedding Scenario:**
A couple updates their ceremony time from 2pm to 3pm on Wednesday night. With realtime sync, the photographer immediately sees the change on their dashboard and can adjust their schedule. The venue coordinator also sees it instantly and can notify the catering team. Without this feature, suppliers might not notice the change until days later, causing coordination disasters on the wedding day.

### SPECIFICATION SOURCE
- **Feature ID:** WS-202
- **Original Spec:** /CORE-SPECIFICATIONS/01-TECHNICAL-ARCHITECTURE/04-Real-time-Systems/01-supabase-realtime md.md
- **Current Implementation:** 0% complete
- **Files to Modify:** 
  - /wedsync/src/lib/supabase/client.ts
  - /wedsync/src/hooks/useRealtimeSubscription.ts
  - /wedsync/src/components/providers/RealtimeProvider.tsx
- **New Files to Create:**
  - /wedsync/src/lib/realtime/subscription-manager.ts
  - /wedsync/src/lib/realtime/channel-factory.ts
  - /wedsync/src/types/realtime.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Enable realtime for critical tables
ALTER TABLE suppliers REPLICA IDENTITY FULL;
ALTER TABLE couples REPLICA IDENTITY FULL;
ALTER TABLE form_responses REPLICA IDENTITY FULL;
ALTER TABLE core_fields REPLICA IDENTITY FULL;
ALTER TABLE journey_progress REPLICA IDENTITY FULL;
ALTER TABLE clients REPLICA IDENTITY FULL;
ALTER TABLE wedding_details REPLICA IDENTITY FULL;

-- Create realtime_subscriptions table for tracking
CREATE TABLE IF NOT EXISTS realtime_subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  channel_name TEXT NOT NULL,
  table_name TEXT NOT NULL,
  filter_params JSONB,
  active BOOLEAN DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  last_ping_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Index for performance
CREATE INDEX idx_realtime_subs_user ON realtime_subscriptions(user_id);
CREATE INDEX idx_realtime_subs_channel ON realtime_subscriptions(channel_name);
```

#### API Endpoints Required
```typescript
// POST /api/realtime/subscribe
interface SubscribeRequest {
  channels: string[];
  filters?: {
    supplier_id?: string;
    couple_id?: string;
    wedding_id?: string;
  };
}

interface SubscribeResponse {
  success: boolean;
  subscriptions: {
    channel: string;
    status: 'active' | 'pending' | 'error';
    filter: string;
  }[];
}

// POST /api/realtime/unsubscribe
interface UnsubscribeRequest {
  channels: string[];
}

interface UnsubscribeResponse {
  success: boolean;
  unsubscribed: string[];
}

// GET /api/realtime/status
interface StatusResponse {
  connected: boolean;
  activeChannels: string[];
  messageCount: number;
  lastMessageAt: string | null;
}
```

#### Frontend Components Required
```typescript
// Component: RealtimeProvider
// Location: /src/components/providers/RealtimeProvider.tsx

interface RealtimeProviderProps {
  children: React.ReactNode;
  userId: string;
  userType: 'supplier' | 'couple';
}

// Key functionality:
- Initialize Supabase realtime client
- Manage channel subscriptions
- Handle connection state
- Provide context to child components
- Auto-reconnect on connection loss
- Clean up on unmount

// Component: RealtimeIndicator
// Location: /src/components/ui/RealtimeIndicator.tsx

interface RealtimeIndicatorProps {
  connected: boolean;
  lastUpdate?: Date;
  messageCount?: number;
}

// Key functionality:
- Show connection status (green/red dot)
- Display last update timestamp
- Show unread message count
- Pulse animation for new updates
```

#### Integration Points
```typescript
// Service: RealtimeSubscriptionManager
// Dependencies: Supabase client, user context, notification service

class RealtimeSubscriptionManager {
  private channels: Map<string, RealtimeChannel>;
  private callbacks: Map<string, Function[]>;
  
  async subscribeToFormResponses(supplierId: string) {
    // Subscribe to form response updates for supplier
  }
  
  async subscribeToJourneyProgress(coupleId: string) {
    // Subscribe to journey progress updates
  }
  
  async subscribeToCoreFields(weddingId: string) {
    // Subscribe to core field changes
  }
  
  async cleanup() {
    // Unsubscribe from all channels
  }
}
```

### CODE EXAMPLES

#### Example 1: Realtime Hook Implementation
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { useEffect, useState, useCallback } from 'react';
import { RealtimeChannel, RealtimePostgresChangesPayload } from '@supabase/supabase-js';
import { supabase } from '@/lib/supabase';

export function useRealtimeSubscription<T>(
  table: string,
  filter?: string,
  onUpdate?: (payload: RealtimePostgresChangesPayload<T>) => void
) {
  const [channel, setChannel] = useState<RealtimeChannel | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  
  useEffect(() => {
    // Step 1: Create channel with unique name
    const channelName = `${table}-${filter || 'all'}-${Date.now()}`;
    const newChannel = supabase.channel(channelName);
    
    // Step 2: Set up subscription
    newChannel
      .on<T>(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table,
          filter
        },
        (payload) => {
          console.log('Realtime update received:', payload);
          onUpdate?.(payload);
        }
      )
      .subscribe((status) => {
        setIsConnected(status === 'SUBSCRIBED');
      });
    
    setChannel(newChannel);
    
    // Step 3: Cleanup on unmount
    return () => {
      newChannel.unsubscribe();
    };
  }, [table, filter]);
  
  return { isConnected, channel };
}
```

#### Example 2: Form Response Realtime Updates
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { useRealtimeSubscription } from '@/hooks/useRealtimeSubscription';
import { FormResponse } from '@/types/forms';

export function FormResponseDashboard({ supplierId }: { supplierId: string }) {
  const [responses, setResponses] = useState<FormResponse[]>([]);
  
  // Subscribe to realtime updates
  const { isConnected } = useRealtimeSubscription<FormResponse>(
    'form_responses',
    `supplier_id=eq.${supplierId}`,
    (payload) => {
      if (payload.eventType === 'INSERT') {
        // Add new response with animation
        setResponses(prev => [payload.new, ...prev]);
        showNotification('New form response received!');
      } else if (payload.eventType === 'UPDATE') {
        // Update existing response
        setResponses(prev => 
          prev.map(r => r.id === payload.new.id ? payload.new : r)
        );
      } else if (payload.eventType === 'DELETE') {
        // Remove deleted response
        setResponses(prev => 
          prev.filter(r => r.id !== payload.old.id)
        );
      }
    }
  );
  
  return (
    <div>
      {isConnected && <RealtimeIndicator connected={true} />}
      {/* Render form responses */}
    </div>
  );
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for Supabase Realtime, Next.js App Router
- [x] Playwright: Test realtime updates, connection states
- [x] Filesystem: Access component and hook files
- [x] Supabase: Configure realtime on tables

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/supabase/supabase", "realtime subscriptions", 3000);
await mcp__context7__get-library-docs("/vercel/next.js", "app router websockets", 2000);
await mcp__context7__get-library-docs("/supabase/supabase", "postgres changes", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('RealtimeSubscriptionManager', () => {
  it('should subscribe to form responses channel', async () => {
    const manager = new RealtimeSubscriptionManager();
    const channel = await manager.subscribeToFormResponses('supplier-123');
    expect(channel).toBeDefined();
    expect(channel.state).toBe('subscribed');
  });
  
  it('should handle connection loss and reconnect', async () => {
    // Test reconnection logic
  });
  
  it('should cleanup all subscriptions on unmount', async () => {
    // Test cleanup
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Realtime form updates', async () => {
  // Open two browser windows
  await mcp__playwright__browser_navigate({url: '/dashboard'});
  
  // In window 1: Submit form as couple
  await mcp__playwright__browser_navigate({url: '/forms/wedding-details'});
  await mcp__playwright__browser_fill_form({
    fields: [{
      name: 'ceremony_time',
      type: 'textbox',
      ref: 'ceremony-time-input',
      value: '3:00 PM'
    }]
  });
  
  // In window 2: Verify supplier sees update instantly
  await mcp__playwright__browser_snapshot();
  // Check for update notification
  // Verify new data appears without refresh
});
```

### ACCEPTANCE CRITERIA
- [ ] Realtime updates appear within 500ms of database change
- [ ] Connection indicator shows accurate status
- [ ] Subscriptions automatically reconnect after network interruption
- [ ] Memory leaks prevented by proper cleanup
- [ ] Updates include optimistic UI updates
- [ ] Performance: No more than 2% CPU usage for realtime
- [ ] Security: Row Level Security enforced on all subscriptions
- [ ] Accessibility: Screen readers announce new updates

### DEPENDENCIES
- Must complete after: WS-298 (Database schema), WS-299 (RLS policies)
- Must complete before: WS-203 (WebSocket channels)
- Shares code with: WS-204 (Presence tracking), WS-205 (Broadcast events)

### ESTIMATED EFFORT
- Team A Frontend: 16 hours
- Team B Backend: 8 hours
- Team C Integration: 4 hours
- Team D Platform: 12 hours
- Team E General: 0 hours
- Team F Workflows: 0 hours
- Team G Performance: 4 hours
- Total: 44 hours