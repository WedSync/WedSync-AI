# TECHNICAL SPECIFICATION: WS-217 - Outlook Calendar Integration
## Generated by Feature Development Session - 2025-01-25

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding professional who uses Outlook/Office 365 for my business calendar
**I want to:** Have my WedSync bookings, meetings, and deadlines automatically sync to my Outlook calendar
**So that:** I never double-book clients, my assistant can see my availability, and I can manage everything from my familiar Outlook interface, saving 2-3 hours per week of manual calendar management

**Real Wedding Scenario:**
A wedding planner uses Office 365 for their business and has meetings scheduled in Outlook throughout the week. When they book a new client consultation through WedSync at 2pm on Tuesday, they want it to automatically appear in their Outlook calendar so their assistant knows they're unavailable. When the client's wedding timeline changes from 4pm to 5pm ceremony, that update should automatically reflect in Outlook so the planner doesn't show up at the wrong time. The planner also wants venue visits, vendor meetings, and final wedding day timeline to sync bidirectionally - if they reschedule something in Outlook, it updates in WedSync, and vice versa.

### SPECIFICATION SOURCE
- **Feature ID:** WS-217
- **Original Spec:** /CORE-SPECIFICATIONS/08-INTEGRATIONS/03-Calendar-Systems/02-outlook-integration md.md
- **Current Implementation:** 0% complete (requires WS-201 Webhook Endpoints)
- **Files to Modify:** 
  - /src/lib/webhooks/webhook-manager.ts (add Outlook webhook handlers)
  - /src/components/calendar/CalendarSettings.tsx (add Outlook connection)
- **New Files to Create:** 
  - /src/lib/integrations/microsoft-graph-client.ts
  - /src/lib/services/outlook-sync-service.ts
  - /src/components/calendar/OutlookCalendarSync.tsx
  - /src/components/calendar/OutlookEventMapping.tsx
  - /src/hooks/useOutlookSync.ts
  - /src/app/api/calendar/outlook/auth/route.ts
  - /src/app/api/calendar/outlook/events/route.ts
  - /src/app/api/calendar/outlook/sync/route.ts
  - /src/app/api/calendar/outlook/webhook/route.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Outlook calendar integration configuration
CREATE TABLE IF NOT EXISTS outlook_calendar_integrations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  tenant_id VARCHAR(255) NOT NULL, -- Microsoft tenant ID
  microsoft_user_id VARCHAR(255) NOT NULL, -- Microsoft user ID
  access_token_encrypted TEXT NOT NULL, -- Encrypted OAuth access token
  refresh_token_encrypted TEXT NOT NULL, -- Encrypted OAuth refresh token
  token_expires_at TIMESTAMP NOT NULL,
  calendar_id VARCHAR(255), -- Primary calendar ID to sync with
  calendar_name TEXT, -- Calendar display name
  sync_enabled BOOLEAN DEFAULT true,
  sync_direction TEXT DEFAULT 'bidirectional' CHECK (sync_direction IN ('to_outlook', 'from_outlook', 'bidirectional')),
  sync_preferences JSONB DEFAULT '{
    "syncClientMeetings": true,
    "syncWeddingEvents": true,
    "syncDeadlines": true,
    "syncTravelTime": false,
    "eventPrefix": "WedSync: ",
    "createSeparateCalendar": false,
    "notificationMinutes": [15, 60]
  }',
  webhook_subscription_id VARCHAR(255), -- Microsoft Graph webhook subscription ID
  webhook_expires_at TIMESTAMP,
  last_sync_at TIMESTAMP,
  last_sync_status TEXT DEFAULT 'pending' CHECK (last_sync_status IN ('pending', 'success', 'error', 'partial')),
  sync_errors JSONB DEFAULT '[]',
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Event synchronization mapping
CREATE TABLE IF NOT EXISTS outlook_event_mappings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  integration_id UUID REFERENCES outlook_calendar_integrations(id) ON DELETE CASCADE,
  wedsync_event_type TEXT NOT NULL CHECK (wedsync_event_type IN (
    'client_meeting', 'venue_visit', 'vendor_meeting', 'wedding_ceremony', 
    'wedding_reception', 'engagement_shoot', 'deadline', 'task_due', 'rehearsal'
  )),
  wedsync_event_id VARCHAR(255) NOT NULL, -- ID of the event in WedSync
  outlook_event_id VARCHAR(255) NOT NULL, -- ID of the event in Outlook
  outlook_calendar_id VARCHAR(255) NOT NULL,
  last_synced_at TIMESTAMP DEFAULT NOW(),
  sync_hash VARCHAR(255), -- Hash of event data to detect changes
  sync_conflicts JSONB DEFAULT '[]', -- Record of any sync conflicts
  created_at TIMESTAMP DEFAULT NOW(),
  
  UNIQUE(integration_id, wedsync_event_id),
  UNIQUE(integration_id, outlook_event_id)
);

-- Sync operation history
CREATE TABLE IF NOT EXISTS outlook_sync_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  integration_id UUID REFERENCES outlook_calendar_integrations(id) ON DELETE CASCADE,
  sync_type TEXT NOT NULL CHECK (sync_type IN ('full_sync', 'incremental', 'single_event', 'webhook_triggered')),
  sync_direction TEXT NOT NULL CHECK (sync_direction IN ('to_outlook', 'from_outlook', 'bidirectional')),
  events_processed INTEGER DEFAULT 0,
  events_created INTEGER DEFAULT 0,
  events_updated INTEGER DEFAULT 0,
  events_deleted INTEGER DEFAULT 0,
  conflicts_detected INTEGER DEFAULT 0,
  sync_status TEXT NOT NULL CHECK (sync_status IN ('in_progress', 'completed', 'failed', 'cancelled')),
  sync_errors JSONB DEFAULT '[]',
  sync_duration_ms INTEGER,
  started_at TIMESTAMP DEFAULT NOW(),
  completed_at TIMESTAMP,
  triggered_by TEXT DEFAULT 'manual' -- 'manual', 'webhook', 'scheduled', 'auto'
);

-- Default event type mappings for new integrations
INSERT INTO outlook_event_mappings (integration_id, wedsync_event_type, outlook_event_id, outlook_calendar_id) VALUES
-- These will be populated dynamically when events are created

-- Indexes for performance
CREATE INDEX idx_outlook_integrations_user ON outlook_calendar_integrations(user_id);
CREATE INDEX idx_outlook_event_mappings_integration ON outlook_event_mappings(integration_id);
CREATE INDEX idx_outlook_event_mappings_wedsync_event ON outlook_event_mappings(wedsync_event_id);
CREATE INDEX idx_outlook_event_mappings_outlook_event ON outlook_event_mappings(outlook_event_id);
CREATE INDEX idx_outlook_sync_history_integration ON outlook_sync_history(integration_id);
CREATE INDEX idx_outlook_sync_history_completed ON outlook_sync_history(completed_at);
```

#### API Endpoints Required

**1. Outlook Authentication**
```typescript
// GET /api/calendar/outlook/auth
// Initiate Outlook OAuth2 authentication
interface OutlookAuthResponse {
  authUrl: string;
  state: string; // CSRF protection
}

// POST /api/calendar/outlook/auth/callback
// Handle OAuth2 callback and store tokens
interface OutlookCallbackRequest {
  code: string;
  state: string;
}

interface OutlookCallbackResponse {
  success: boolean;
  integration: OutlookIntegration;
  calendars: OutlookCalendar[]; // Available calendars to sync with
}

interface OutlookIntegration {
  id: string;
  microsoftUserId: string;
  tenantId: string;
  calendarId?: string;
  calendarName?: string;
  syncEnabled: boolean;
  syncDirection: 'to_outlook' | 'from_outlook' | 'bidirectional';
  syncPreferences: OutlookSyncPreferences;
  lastSyncAt?: string;
  lastSyncStatus: 'pending' | 'success' | 'error' | 'partial';
}

interface OutlookCalendar {
  id: string;
  name: string;
  color: string;
  isDefaultCalendar: boolean;
  canEdit: boolean;
  owner: {
    name: string;
    address: string;
  };
}

interface OutlookSyncPreferences {
  syncClientMeetings: boolean;
  syncWeddingEvents: boolean;
  syncDeadlines: boolean;
  syncTravelTime: boolean;
  eventPrefix: string;
  createSeparateCalendar: boolean;
  notificationMinutes: number[];
}
```

**2. Calendar Sync Management**
```typescript
// GET /api/calendar/outlook/sync
// Get current sync status and configuration
interface OutlookSyncStatusResponse {
  integration: OutlookIntegration;
  syncStats: {
    totalEvents: number;
    syncedEvents: number;
    pendingEvents: number;
    conflictedEvents: number;
    lastFullSync: string;
    nextScheduledSync: string;
  };
  recentSyncHistory: OutlookSyncHistoryItem[];
  webhookStatus: {
    isActive: boolean;
    subscriptionId?: string;
    expiresAt?: string;
    renewalNeeded: boolean;
  };
}

interface OutlookSyncHistoryItem {
  id: string;
  syncType: 'full_sync' | 'incremental' | 'single_event' | 'webhook_triggered';
  syncDirection: string;
  eventsProcessed: number;
  eventsCreated: number;
  eventsUpdated: number;
  eventsDeleted: number;
  conflictsDetected: number;
  syncStatus: 'in_progress' | 'completed' | 'failed' | 'cancelled';
  syncDurationMs: number;
  startedAt: string;
  completedAt?: string;
  triggeredBy: string;
  errors?: any[];
}

// POST /api/calendar/outlook/sync
// Trigger manual sync operation
interface OutlookSyncRequest {
  syncType?: 'full_sync' | 'incremental';
  syncDirection?: 'to_outlook' | 'from_outlook' | 'bidirectional';
  specificEvents?: string[]; // Sync only these WedSync event IDs
}

interface OutlookSyncResponse {
  syncId: string;
  status: 'started' | 'queued';
  estimatedDuration: number; // seconds
  eventsToProcess: number;
}

// GET /api/calendar/outlook/sync/{syncId}
// Get status of specific sync operation
interface OutlookSyncJobResponse {
  syncId: string;
  status: 'in_progress' | 'completed' | 'failed' | 'cancelled';
  progress: {
    totalEvents: number;
    processedEvents: number;
    createdEvents: number;
    updatedEvents: number;
    deletedEvents: number;
    errorEvents: number;
  };
  errors?: SyncError[];
  startedAt: string;
  completedAt?: string;
  estimatedTimeRemaining?: number;
}

interface SyncError {
  eventId: string;
  eventType: string;
  errorCode: string;
  errorMessage: string;
  retryable: boolean;
}
```

**3. Event Management**
```typescript
// GET /api/calendar/outlook/events
// Get synced events and their mapping status
interface OutlookEventsResponse {
  events: OutlookMappedEvent[];
  pagination: {
    page: number;
    totalPages: number;
    totalEvents: number;
  };
  filters: {
    eventTypes: string[];
    syncStatuses: string[];
    dateRange?: {
      start: string;
      end: string;
    };
  };
}

interface OutlookMappedEvent {
  wedSyncEventId: string;
  wedSyncEventType: string;
  wedSyncEventTitle: string;
  wedSyncEventDate: string;
  outlookEventId: string;
  outlookEventTitle: string;
  outlookEventDate: string;
  syncStatus: 'synced' | 'pending' | 'conflict' | 'error';
  lastSynced: string;
  syncConflicts?: SyncConflict[];
  canResync: boolean;
}

interface SyncConflict {
  field: string;
  wedSyncValue: any;
  outlookValue: any;
  conflictType: 'date_time' | 'title' | 'description' | 'attendees' | 'location';
  suggestedResolution: 'use_wedsync' | 'use_outlook' | 'manual_review';
}

// POST /api/calendar/outlook/events/{eventId}/resolve
// Resolve sync conflicts for specific event
interface ResolveConflictRequest {
  resolutions: Record<string, {
    useValue: 'wedsync' | 'outlook' | 'custom';
    customValue?: any;
  }>;
  setAsDefault?: boolean; // Apply resolution rule to future similar conflicts
}

// POST /api/calendar/outlook/events/{eventId}/force-sync
// Force sync single event (override normal sync rules)
interface ForceSyncEventRequest {
  direction: 'to_outlook' | 'from_outlook';
  overwriteConflicts?: boolean;
}
```

**4. Settings & Configuration**
```typescript
// PUT /api/calendar/outlook/settings
// Update sync preferences and configuration
interface UpdateOutlookSettingsRequest {
  calendarId?: string; // Change which calendar to sync with
  syncDirection?: 'to_outlook' | 'from_outlook' | 'bidirectional';
  syncPreferences?: Partial<OutlookSyncPreferences>;
  syncEnabled?: boolean;
  webhookEnabled?: boolean;
}

interface UpdateOutlookSettingsResponse {
  integration: OutlookIntegration;
  webhookSubscriptionUpdated: boolean;
  syncScheduleChanged: boolean;
  requiresFullResync: boolean;
}

// DELETE /api/calendar/outlook/integration
// Remove Outlook integration and clean up
interface RemoveIntegrationResponse {
  success: boolean;
  eventsDeleted: number; // Events removed from Outlook
  mappingsDeleted: number; // Sync mappings removed
  webhookUnsubscribed: boolean;
}

// POST /api/calendar/outlook/webhook
// Handle Microsoft Graph webhook notifications
interface OutlookWebhookNotification {
  value: OutlookWebhookChange[];
}

interface OutlookWebhookChange {
  changeType: 'created' | 'updated' | 'deleted';
  clientState: string; // Validation token
  resource: string; // Event resource URL
  resourceData: {
    '@odata.type': string;
    '@odata.id': string;
    '@odata.etag': string;
    id: string;
  };
  subscriptionExpirationDateTime: string;
  subscriptionId: string;
  tenantId: string;
}
```

#### Frontend Components Required

**1. Outlook Calendar Sync Component**
```typescript
// src/components/calendar/OutlookCalendarSync.tsx
import React, { useState, useEffect } from 'react';
import { useOutlookSync } from '@/hooks/useOutlookSync';
import { OutlookEventMapping } from './OutlookEventMapping';

export function OutlookCalendarSync() {
  const {
    integration,
    syncStatus,
    syncHistory,
    isLoading,
    connectOutlook,
    disconnectOutlook,
    triggerSync,
    updateSettings,
    resolveConflicts
  } = useOutlookSync();

  const [showSettings, setShowSettings] = useState(false);
  const [syncInProgress, setSyncInProgress] = useState(false);

  useEffect(() => {
    // Poll for sync status updates when sync is in progress
    let pollInterval: NodeJS.Timeout;
    
    if (syncInProgress) {
      pollInterval = setInterval(async () => {
        const status = await getSyncStatus();
        if (status.status === 'completed' || status.status === 'failed') {
          setSyncInProgress(false);
        }
      }, 2000);
    }

    return () => {
      if (pollInterval) clearInterval(pollInterval);
    };
  }, [syncInProgress]);

  const handleConnect = async () => {
    try {
      const authUrl = await connectOutlook();
      // Redirect to Microsoft OAuth
      window.location.href = authUrl;
    } catch (error) {
      console.error('Failed to connect Outlook:', error);
    }
  };

  const handleTriggerSync = async () => {
    try {
      setSyncInProgress(true);
      await triggerSync({ syncType: 'incremental' });
    } catch (error) {
      setSyncInProgress(false);
      console.error('Sync failed:', error);
    }
  };

  const handleSettingsUpdate = async (newSettings: Partial<OutlookSyncPreferences>) => {
    try {
      await updateSettings({
        syncPreferences: { ...integration?.syncPreferences, ...newSettings }
      });
      setShowSettings(false);
    } catch (error) {
      console.error('Failed to update settings:', error);
    }
  };

  if (isLoading) {
    return <div className="animate-pulse">Loading Outlook integration...</div>;
  }

  if (!integration) {
    return (
      <div className="bg-white border border-gray-200 rounded-lg p-6">
        <div className="flex items-center justify-between mb-4">
          <div className="flex items-center space-x-3">
            <div className="w-10 h-10 bg-blue-100 rounded-lg flex items-center justify-center">
              ðŸ“…
            </div>
            <div>
              <h3 className="text-lg font-semibold text-gray-900">
                Microsoft Outlook Calendar
              </h3>
              <p className="text-sm text-gray-600">
                Sync your wedding events with Outlook/Office 365
              </p>
            </div>
          </div>
        </div>

        <div className="space-y-4">
          <div className="bg-blue-50 p-4 rounded-lg">
            <h4 className="text-sm font-medium text-blue-900 mb-2">
              What gets synced:
            </h4>
            <ul className="text-sm text-blue-700 space-y-1">
              <li>â€¢ Client meetings and consultations</li>
              <li>â€¢ Wedding ceremony and reception times</li>
              <li>â€¢ Venue visits and vendor meetings</li>
              <li>â€¢ Important deadlines and reminders</li>
              <li>â€¢ Engagement and photo shoots</li>
            </ul>
          </div>

          <button
            onClick={handleConnect}
            className="w-full flex items-center justify-center px-4 py-3 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors"
          >
            <svg className="w-5 h-5 mr-2" viewBox="0 0 24 24" fill="currentColor">
              <path d="M7 18h10V6H7v12zM21 4H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2z"/>
            </svg>
            Connect Microsoft Outlook
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="bg-white border border-gray-200 rounded-lg p-6">
      <div className="flex items-center justify-between mb-6">
        <div className="flex items-center space-x-3">
          <div className="w-10 h-10 bg-green-100 rounded-lg flex items-center justify-center">
            âœ…
          </div>
          <div>
            <h3 className="text-lg font-semibold text-gray-900">
              Outlook Calendar Connected
            </h3>
            <p className="text-sm text-gray-600">
              Syncing with: {integration.calendarName}
            </p>
          </div>
        </div>
        
        <div className="flex items-center space-x-2">
          <button
            onClick={() => setShowSettings(!showSettings)}
            className="px-3 py-2 text-sm text-gray-600 hover:text-gray-900 border border-gray-300 rounded-md"
          >
            Settings
          </button>
          <button
            onClick={handleTriggerSync}
            disabled={syncInProgress}
            className={`px-4 py-2 text-sm rounded-md ${
              syncInProgress 
                ? 'bg-gray-100 text-gray-400 cursor-not-allowed' 
                : 'bg-blue-600 text-white hover:bg-blue-700'
            }`}
          >
            {syncInProgress ? 'Syncing...' : 'Sync Now'}
          </button>
        </div>
      </div>

      {/* Sync Status */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6">
        <div className="bg-gray-50 p-3 rounded-lg">
          <div className="text-2xl font-bold text-gray-900">
            {syncStatus?.syncStats.syncedEvents || 0}
          </div>
          <div className="text-sm text-gray-600">Synced Events</div>
        </div>
        
        <div className="bg-blue-50 p-3 rounded-lg">
          <div className="text-2xl font-bold text-blue-600">
            {syncStatus?.syncStats.pendingEvents || 0}
          </div>
          <div className="text-sm text-blue-700">Pending Sync</div>
        </div>
        
        <div className="bg-yellow-50 p-3 rounded-lg">
          <div className="text-2xl font-bold text-yellow-600">
            {syncStatus?.syncStats.conflictedEvents || 0}
          </div>
          <div className="text-sm text-yellow-700">Conflicts</div>
        </div>
        
        <div className="bg-green-50 p-3 rounded-lg">
          <div className="text-sm text-green-700 font-medium">Last Sync</div>
          <div className="text-sm text-green-600">
            {integration.lastSyncAt 
              ? new Date(integration.lastSyncAt).toLocaleDateString()
              : 'Never'
            }
          </div>
        </div>
      </div>

      {/* Settings Panel */}
      {showSettings && (
        <div className="border-t border-gray-200 pt-6 mb-6">
          <h4 className="text-md font-semibold text-gray-900 mb-4">
            Sync Settings
          </h4>
          
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div>
              <label className="text-sm font-medium text-gray-700 mb-2 block">
                Sync Direction
              </label>
              <select
                value={integration.syncDirection}
                onChange={(e) => handleSettingsUpdate({ 
                  syncDirection: e.target.value as any 
                })}
                className="w-full px-3 py-2 border border-gray-300 rounded-md"
              >
                <option value="bidirectional">Two-way sync</option>
                <option value="to_outlook">WedSync â†’ Outlook only</option>
                <option value="from_outlook">Outlook â†’ WedSync only</option>
              </select>
            </div>
            
            <div>
              <label className="text-sm font-medium text-gray-700 mb-2 block">
                Event Prefix
              </label>
              <input
                type="text"
                value={integration.syncPreferences.eventPrefix}
                onChange={(e) => handleSettingsUpdate({ 
                  eventPrefix: e.target.value 
                })}
                placeholder="WedSync: "
                className="w-full px-3 py-2 border border-gray-300 rounded-md"
              />
            </div>
          </div>

          <div className="mt-4">
            <label className="text-sm font-medium text-gray-700 mb-2 block">
              What to Sync
            </label>
            <div className="space-y-2">
              {Object.entries({
                syncClientMeetings: 'Client meetings & consultations',
                syncWeddingEvents: 'Wedding ceremony & reception',
                syncDeadlines: 'Important deadlines',
                syncTravelTime: 'Include travel time buffers'
              }).map(([key, label]) => (
                <label key={key} className="flex items-center">
                  <input
                    type="checkbox"
                    checked={integration.syncPreferences[key as keyof OutlookSyncPreferences] as boolean}
                    onChange={(e) => handleSettingsUpdate({
                      [key]: e.target.checked
                    })}
                    className="mr-2"
                  />
                  <span className="text-sm text-gray-700">{label}</span>
                </label>
              ))}
            </div>
          </div>
        </div>
      )}

      {/* Event Mappings */}
      <OutlookEventMapping 
        integration={integration}
        onResolveConflicts={resolveConflicts}
      />

      {/* Recent Sync History */}
      {syncHistory && syncHistory.length > 0 && (
        <div className="border-t border-gray-200 pt-6">
          <h4 className="text-md font-semibold text-gray-900 mb-4">
            Recent Sync Activity
          </h4>
          <div className="space-y-2">
            {syncHistory.slice(0, 5).map((sync) => (
              <div key={sync.id} className="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
                <div>
                  <div className="text-sm font-medium text-gray-900">
                    {sync.syncType.replace('_', ' ')} - {sync.syncDirection}
                  </div>
                  <div className="text-xs text-gray-600">
                    {sync.eventsProcessed} events processed â€¢ 
                    {sync.eventsCreated} created â€¢ 
                    {sync.eventsUpdated} updated
                  </div>
                </div>
                <div className="text-right">
                  <div className={`text-sm font-medium ${
                    sync.syncStatus === 'completed' ? 'text-green-600' :
                    sync.syncStatus === 'failed' ? 'text-red-600' :
                    'text-yellow-600'
                  }`}>
                    {sync.syncStatus}
                  </div>
                  <div className="text-xs text-gray-600">
                    {new Date(sync.startedAt).toLocaleString()}
                  </div>
                </div>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Disconnect Option */}
      <div className="border-t border-gray-200 pt-6 mt-6">
        <button
          onClick={disconnectOutlook}
          className="text-sm text-red-600 hover:text-red-800"
        >
          Disconnect Outlook Calendar
        </button>
      </div>
    </div>
  );
}
```

**2. Outlook Sync Hook**
```typescript
// src/hooks/useOutlookSync.ts
import { useState, useEffect, useCallback } from 'react';

export function useOutlookSync() {
  const [integration, setIntegration] = useState<OutlookIntegration | null>(null);
  const [syncStatus, setSyncStatus] = useState<OutlookSyncStatusResponse | null>(null);
  const [syncHistory, setSyncHistory] = useState<OutlookSyncHistoryItem[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const loadIntegration = useCallback(async () => {
    try {
      setIsLoading(true);
      const response = await fetch('/api/calendar/outlook/sync');
      
      if (response.ok) {
        const data = await response.json();
        setIntegration(data.integration);
        setSyncStatus(data);
        setSyncHistory(data.recentSyncHistory);
      } else if (response.status === 404) {
        // No integration exists yet
        setIntegration(null);
      } else {
        throw new Error('Failed to load integration');
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Load failed');
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    loadIntegration();
  }, [loadIntegration]);

  const connectOutlook = useCallback(async () => {
    try {
      const response = await fetch('/api/calendar/outlook/auth');
      const data = await response.json();
      return data.authUrl;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Connection failed');
      throw err;
    }
  }, []);

  const disconnectOutlook = useCallback(async () => {
    try {
      const response = await fetch('/api/calendar/outlook/integration', {
        method: 'DELETE'
      });

      if (response.ok) {
        setIntegration(null);
        setSyncStatus(null);
        setSyncHistory([]);
      } else {
        throw new Error('Failed to disconnect');
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Disconnect failed');
    }
  }, []);

  const triggerSync = useCallback(async (options: OutlookSyncRequest = {}) => {
    try {
      const response = await fetch('/api/calendar/outlook/sync', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(options)
      });

      if (!response.ok) {
        throw new Error('Sync failed to start');
      }

      const result = await response.json();
      
      // Refresh status after a short delay
      setTimeout(() => {
        loadIntegration();
      }, 1000);

      return result;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Sync failed');
      throw err;
    }
  }, [loadIntegration]);

  const updateSettings = useCallback(async (settings: UpdateOutlookSettingsRequest) => {
    try {
      const response = await fetch('/api/calendar/outlook/settings', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(settings)
      });

      if (!response.ok) {
        throw new Error('Settings update failed');
      }

      const result = await response.json();
      setIntegration(result.integration);

      return result;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Settings update failed');
      throw err;
    }
  }, []);

  const resolveConflicts = useCallback(async (eventId: string, resolutions: ResolveConflictRequest) => {
    try {
      const response = await fetch(`/api/calendar/outlook/events/${eventId}/resolve`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(resolutions)
      });

      if (!response.ok) {
        throw new Error('Conflict resolution failed');
      }

      // Refresh integration status
      loadIntegration();
      
      return await response.json();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Conflict resolution failed');
      throw err;
    }
  }, [loadIntegration]);

  return {
    integration,
    syncStatus,
    syncHistory,
    isLoading,
    error,
    connectOutlook,
    disconnectOutlook,
    triggerSync,
    updateSettings,
    resolveConflicts,
    refresh: loadIntegration
  };
}
```

### TESTING REQUIREMENTS

#### Unit Tests
- Microsoft Graph API client methods
- OAuth2 token management and refresh
- Event mapping and transformation logic
- Sync conflict detection and resolution
- Webhook payload validation and processing

#### Integration Tests
- Complete OAuth2 authentication flow
- Bidirectional calendar sync operations
- Event CRUD operations in both systems
- Webhook subscription management
- Error handling for API failures

#### E2E Tests
- Full calendar integration setup workflow
- Real-time sync between WedSync and Outlook
- Conflict resolution user interface
- Bulk sync operations and status tracking
- Integration disconnection and cleanup

### DEPENDENCIES & EFFORT ESTIMATE

#### Dependencies
- **WS-201 Webhook Endpoints** - Required for Outlook webhook handling
- **Microsoft Graph API Access** - Azure app registration required
- **OAuth2 Implementation** - Secure token management
- **Event Management System** - WedSync events to sync

#### Effort Estimate: 18 development days
- **Microsoft Graph Integration**: 4 days
- **OAuth2 Authentication Flow**: 3 days  
- **Bidirectional Sync Engine**: 5 days
- **Conflict Resolution System**: 3 days
- **Webhook Management**: 2 days
- **UI Components & Settings**: 1 day

#### Risk Factors
- **High:** Microsoft Graph API rate limits and throttling
- **Medium:** OAuth2 token refresh reliability
- **Medium:** Sync conflict complexity and user experience  
- **Low:** Webhook reliability and renewal management

### SUCCESS CRITERIA
1. OAuth2 authentication completes without user confusion
2. Events sync bidirectionally within 30 seconds of changes
3. Sync conflicts are clearly presented with resolution options
4. Webhook updates trigger near-real-time synchronization
5. Integration handles token refresh automatically
6. Bulk sync operations complete within 2 minutes for 100+ events
7. Settings allow granular control over sync behavior
8. Disconnect process cleanly removes all synced events