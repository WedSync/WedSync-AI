# TECHNICAL SPECIFICATION: WS-192 - Integration Tests Suite
## Generated by Feature Development Session - August 25, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** WedSync development team member preparing for production deployment
**I want to:** Implement comprehensive integration tests that verify complete user workflows and data flows between components
**So that:** I can catch critical bugs before they affect wedding suppliers and couples, ensure data integrity across the entire platform, and maintain confidence when deploying updates during peak wedding season

**Real Wedding Scenario:**
A photographer connects to a couple's wedding 2 months before the big day. The photographer's intake form auto-populates with the couple's venue and date information, the couple fills out the form, which triggers an automated journey with a consultation meeting booking, and the photographer receives the completed information. Integration tests verify this entire workflow works correctly - form creation, couple connection, core field synchronization, form submission, journey automation, and meeting scheduling - ensuring no couples lose their form data or miss critical photography timelines.

### SPECIFICATION SOURCE
- **Feature ID:** WS-192
- **Original Spec:** /CORE-SPECIFICATIONS/11-TESTING-DEPLOYMENT/01-Testing/02-integration-tests md.md
- **Current Implementation:** 0% complete (new)
- **Files to Modify:** None (new feature)
- **New Files to Create:** 
  - `/wedsync/tests/integration/setup.ts`
  - `/wedsync/tests/integration/supplier-couple-flow.test.ts`
  - `/wedsync/tests/integration/journey-automation.test.ts`
  - `/wedsync/tests/integration/core-fields-sync.test.ts`
  - `/wedsync/tests/factories/index.ts`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Test execution tracking
CREATE TABLE test_executions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  test_suite TEXT NOT NULL,
  test_name TEXT NOT NULL,
  execution_id TEXT UNIQUE NOT NULL,
  
  -- Test environment
  environment TEXT DEFAULT 'test',
  database_state TEXT, -- snapshot reference
  
  -- Execution details
  started_at TIMESTAMPTZ DEFAULT NOW(),
  completed_at TIMESTAMPTZ,
  status TEXT CHECK (status IN ('running', 'passed', 'failed', 'skipped')),
  
  -- Test data isolation
  transaction_id BIGINT,
  test_data_seed TEXT,
  cleanup_required BOOLEAN DEFAULT TRUE,
  
  -- Results
  assertions_total INTEGER,
  assertions_passed INTEGER,
  error_details JSONB,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Test data factories for consistent test scenarios
CREATE TABLE test_data_factories (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  factory_name TEXT UNIQUE NOT NULL,
  template_data JSONB NOT NULL,
  
  -- Usage tracking
  times_used INTEGER DEFAULT 0,
  success_rate DECIMAL(5,4),
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Test environment configuration
CREATE TABLE test_configurations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  config_name TEXT UNIQUE NOT NULL,
  environment_vars JSONB,
  
  -- Mock service configurations
  mock_services JSONB, -- {stripe: 'mock', openai: 'mock', email: 'test'}
  external_endpoints JSONB,
  
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

#### API Endpoints Required
```typescript
// POST /api/testing/integration/setup
interface IntegrationTestSetupRequest {
  testSuite: string;
  testName: string;
  requiredFactories: string[];
  mockServices: Record<string, 'mock' | 'real'>;
}

interface IntegrationTestSetupResponse {
  success: boolean;
  data: {
    executionId: string;
    testDatabase: string;
    mockEndpoints: Record<string, string>;
    factoryData: Record<string, any>;
  };
}
```

#### Frontend Components Required
```typescript
// Component: IntegrationTestRunner
// Location: /src/components/admin/IntegrationTestRunner.tsx

interface Props {
  testSuites: TestSuite[];
  executionHistory: TestExecution[];
  realTimeResults: boolean;
}

// Key functionality:
- Test suite execution with real-time progress monitoring
- Test isolation management with transaction control
- Mock service configuration and validation
- Test data factory management and cleanup verification
```

#### Integration Points
```typescript
// Service: IntegrationTestOrchestrator
// Dependencies: Test database, mock services, data factories

class IntegrationTestOrchestrator {
  async executeTestSuite(suite: TestSuite): Promise<TestSuiteResult> {
    // Complete integration test execution with isolation and cleanup
  }
  
  async createTestIsolation(testName: string): Promise<TestIsolation> {
    // Transaction-based test isolation for parallel execution
  }
}
```

### CODE EXAMPLES

#### Example 1: Comprehensive Supplier-Couple Integration Test
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { testDb, createTestIsolation, cleanupTestData } from './setup';
import { supplierFactory, coupleFactory, formFactory } from '../factories';

export class SupplierCoupleIntegrationTest {
  private testIsolation: TestIsolation;

  beforeEach(async () => {
    // Create isolated test environment
    this.testIsolation = await createTestIsolation('supplier-couple-flow');
    
    // Start database transaction for test isolation
    await testDb.rpc('begin_test_transaction', {
      isolation_id: this.testIsolation.id
    });
  });

  async testCompleteSupplierCoupleWorkflow(): Promise<void> {
    // Step 1: Create test supplier with realistic data
    const supplier = await supplierFactory.create({
      vendor_type: 'photographer',
      business_name: 'Sunset Wedding Photography',
      tier: 'professional',
      location: 'Yorkshire, UK'
    });

    // Step 2: Create photographer intake form
    const intakeForm = await formFactory.create(supplier.id, {
      name: 'Photography Consultation Form',
      fields: [
        { id: 'wedding_date', type: 'date', core_field: true, required: true },
        { id: 'venue_name', type: 'text', core_field: true, required: true },
        { id: 'ceremony_time', type: 'time', core_field: false, required: true },
        { id: 'photo_style', type: 'select', core_field: false, 
          options: ['Traditional', 'Candid', 'Artistic'] },
        { id: 'special_requests', type: 'textarea', core_field: false }
      ]
    });

    // Step 3: Create couple with core wedding information
    const couple = await coupleFactory.create({
      names: 'Sarah & James Miller',
      email: 'sarah.james@example.com',
      core_fields: {
        wedding_date: '2025-07-12',
        venue_name: 'The Historic Manor House',
        guest_count: 95,
        ceremony_time: '15:00'
      }
    });

    // Step 4: Connect supplier to couple (critical business flow)
    const connection = await testDb
      .from('supplier_couple_connections')
      .insert({
        supplier_id: supplier.id,
        couple_id: couple.id,
        status: 'connected',
        connected_at: new Date().toISOString()
      })
      .select()
      .single();

    expect(connection.data.status).toBe('connected');

    // Step 5: Verify couple can access supplier's form
    const formAccess = await testDb.rpc('grant_form_access', {
      form_id: intakeForm.id,
      couple_id: couple.id,
      supplier_id: supplier.id
    });

    expect(formAccess.data.access_granted).toBe(true);

    // Step 6: Test core field auto-population
    const formWithData = await testDb.rpc('get_form_with_core_fields', {
      form_id: intakeForm.id,
      couple_id: couple.id
    });

    expect(formWithData.data.fields).toContainEqual(
      expect.objectContaining({
        id: 'wedding_date',
        value: '2025-07-12',
        populated_from: 'core_fields'
      })
    );

    expect(formWithData.data.fields).toContainEqual(
      expect.objectContaining({
        id: 'venue_name',
        value: 'The Historic Manor House',
        populated_from: 'core_fields'
      })
    );

    // Step 7: Submit form as couple
    const formSubmission = await testDb
      .from('form_submissions')
      .insert({
        form_id: intakeForm.id,
        couple_id: couple.id,
        supplier_id: supplier.id,
        data: {
          fields: {
            wedding_date: '2025-07-12',
            venue_name: 'The Historic Manor House',
            ceremony_time: '15:00',
            photo_style: 'Candid',
            special_requests: 'Please capture candid moments during the ceremony'
          }
        },
        status: 'submitted',
        submitted_at: new Date().toISOString()
      })
      .select()
      .single();

    // Step 8: Verify supplier receives notification
    const notifications = await testDb
      .from('notifications')
      .select('*')
      .eq('recipient_id', supplier.id)
      .eq('type', 'form_submission');

    expect(notifications.data).toHaveLength(1);
    expect(notifications.data[0].title).toBe('New Form Submission');

    // Step 9: Verify data integrity across all tables
    const connectionStatus = await testDb
      .from('supplier_couple_connections')
      .select('status')
      .eq('id', connection.data.id)
      .single();

    expect(connectionStatus.data.status).toBe('connected');

    const submissionStatus = await testDb
      .from('form_submissions')
      .select('status, data')
      .eq('id', formSubmission.data.id)
      .single();

    expect(submissionStatus.data.status).toBe('submitted');
    expect(submissionStatus.data.data.fields.photo_style).toBe('Candid');
  }

  afterEach(async () => {
    // Rollback transaction to ensure test isolation
    await testDb.rpc('rollback_test_transaction', {
      isolation_id: this.testIsolation.id
    });
    
    // Clean up any test artifacts
    await cleanupTestData(this.testIsolation.id);
  });
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] PostgreSQL: Execute integration test database operations and transaction management
- [x] Filesystem: Manage test files, factories, and execution artifacts
- [x] Playwright: E2E integration testing with real browser interactions

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/vitest/vitest", "integration testing", 4000);
await mcp__context7__get-library-docs("/faker/faker", "test data generation", 3000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('IntegrationTestOrchestrator', () => {
  it('should isolate tests using database transactions', () => {
    // Test transaction-based test isolation
  });
  
  it('should cleanup test data after suite completion', () => {
    // Test comprehensive cleanup procedures
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Integration test suite executes successfully', async () => {
  await mcp__playwright__browser_navigate({url: '/admin/testing/integration'});
  
  await mcp__playwright__browser_click({
    element: 'run supplier-couple flow test',
    ref: '[data-testid="run-supplier-couple-test"]'
  });
  
  // Verify test execution and results
  await mcp__playwright__browser_wait_for({text: 'Test completed successfully'});
});
```

### ACCEPTANCE CRITERIA
- [x] Complete supplier-couple connection flow tested end-to-end with data verification
- [x] Core field synchronization verified across multiple suppliers and forms
- [x] Journey automation tested with email, wait, form, and meeting modules
- [x] Performance: Integration test suite completes within 10 minutes for full coverage
- [x] Security: Test isolation prevents data leaks between test runs
- [x] Accessibility: Integration test results dashboard compatible with screen readers

### DEPENDENCIES
- Must complete after: Unit test foundation and database migration system
- Must complete before: WS-193 (Performance Tests Suite) - provides integration test foundation
- Shares code with: Test infrastructure, database seeding, mock services

### ESTIMATED EFFORT
- Team C Integration: 80 hours (Test framework setup, data factories, mock services, test isolation)
- Team A Backend: 32 hours (API integration tests, database transaction management)
- Team B Frontend: 16 hours (Test results dashboard, test runner interface)
- Total: 128 hours