# TECHNICAL SPECIFICATION: WS-352 - Comprehensive Contract Management System
## Generated by Feature Development Session - 2025-01-20

### USER STORY & BUSINESS CONTEXT
**As a:** Wedding supplier managing client contracts and legal agreements
**I want to:** A comprehensive contract management system that handles creation, customization, electronic signatures, payment tracking, and legal compliance
**So that:** I can streamline my contracting process, reduce legal risks, improve client experience, and maintain professional standards while ensuring all agreements are properly executed and tracked

**Real Wedding Scenario:**
Emma, a wedding planner, currently manages contracts using Word documents and email chains. She spends 3+ hours per client on contract administration, often loses track of signature status, struggles with payment terms integration, and worries about legal compliance. With WedSync's Contract Management System, she can generate professional contracts from templates, send for electronic signature, automatically integrate payment schedules, track contract status in real-time, and ensure all legal requirements are met - reducing contract administration time to 30 minutes per client while improving professionalism and compliance.

**Business Impact:**
- 89% of wedding suppliers use manual contract processes
- Average contract administration takes 2-4 hours per client
- Electronic signatures increase completion rates by 67%
- Contract disputes cost wedding businesses £1,200+ per incident
- Professional contracts improve client trust by 78%
- Automated payment integration reduces collection time by 45%

### SPECIFICATION SOURCE
- **Feature ID:** WS-352
- **Original Spec:** /CORE-SPECIFICATIONS/contract-management-system/
- **Current Implementation:** 0% complete (new comprehensive system)
- **Files to Modify:** 
  - `/src/app/contracts/page.tsx` - Contract management dashboard
  - `/src/components/contracts/` - All contract management components
  - `/src/lib/contracts/` - Contract processing services
- **New Files to Create:**
  - Contract template builder and editor
  - Electronic signature integration
  - Payment terms and milestone tracking
  - Legal compliance and audit system
  - Contract analytics and reporting

### TECHNICAL DESIGN

#### Database Schema Required

```sql
-- Core contracts table
CREATE TABLE contracts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    client_id UUID REFERENCES clients(id) ON DELETE SET NULL,
    lead_id UUID REFERENCES leads(id) ON DELETE SET NULL,
    wedding_id UUID REFERENCES weddings(id) ON DELETE SET NULL,
    
    -- Contract Identification
    contract_number VARCHAR(50) UNIQUE NOT NULL,
    contract_title VARCHAR(255) NOT NULL,
    contract_type VARCHAR(100) NOT NULL, -- 'wedding_photography', 'venue_rental', 'catering', 'planning', 'flowers', 'music', 'transport', 'other'
    
    -- Template and Content
    template_id UUID REFERENCES contract_templates(id),
    contract_content TEXT NOT NULL, -- HTML/rich text content
    contract_version INTEGER DEFAULT 1,
    
    -- Financial Terms
    total_amount DECIMAL(12,2) NOT NULL,
    currency VARCHAR(3) DEFAULT 'GBP',
    deposit_amount DECIMAL(12,2),
    deposit_percentage DECIMAL(5,2),
    payment_schedule JSONB DEFAULT '{}', -- Payment milestones and amounts
    
    -- Contract Status
    contract_status VARCHAR(50) CHECK (contract_status IN (
        'draft', 'pending_review', 'sent_for_signature', 'partially_signed', 
        'fully_signed', 'active', 'completed', 'cancelled', 'disputed'
    )) DEFAULT 'draft',
    
    -- Signature Information
    signature_required_from TEXT[] DEFAULT '{}', -- Array of required signers
    signatures_received INTEGER DEFAULT 0,
    signatures_required INTEGER DEFAULT 2,
    
    -- Important Dates
    sent_date TIMESTAMPTZ,
    signature_deadline TIMESTAMPTZ,
    signed_date TIMESTAMPTZ,
    contract_start_date DATE,
    contract_end_date DATE,
    service_date DATE, -- Wedding date or service delivery date
    
    -- Legal and Compliance
    legal_review_required BOOLEAN DEFAULT FALSE,
    legal_review_completed BOOLEAN DEFAULT FALSE,
    legal_reviewer_id UUID REFERENCES users(id),
    compliance_status VARCHAR(50) DEFAULT 'pending',
    jurisdiction VARCHAR(100) DEFAULT 'England and Wales',
    
    -- Terms and Conditions
    cancellation_policy TEXT,
    refund_policy TEXT,
    force_majeure_clause TEXT,
    liability_limitations TEXT,
    
    -- Client Communication
    client_notes TEXT,
    internal_notes TEXT,
    
    -- Automation and Reminders
    reminder_schedule JSONB DEFAULT '{}',
    auto_follow_up BOOLEAN DEFAULT TRUE,
    next_reminder_at TIMESTAMPTZ,
    
    -- Metadata
    tags TEXT[] DEFAULT '{}',
    custom_fields JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    -- Indexes
    INDEX idx_contracts_supplier_id (supplier_id),
    INDEX idx_contracts_client_id (client_id),
    INDEX idx_contracts_status (contract_status),
    INDEX idx_contracts_number (contract_number),
    INDEX idx_contracts_service_date (service_date),
    INDEX idx_contracts_signature_deadline (signature_deadline),
    INDEX idx_contracts_created (created_at DESC)
);

-- Contract templates for reusable contracts
CREATE TABLE contract_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    template_name VARCHAR(255) NOT NULL,
    template_description TEXT,
    
    -- Template Content
    template_content TEXT NOT NULL, -- HTML/rich text with placeholders
    template_variables JSONB DEFAULT '{}', -- Variable definitions and defaults
    
    -- Template Configuration
    contract_type VARCHAR(100) NOT NULL,
    service_category VARCHAR(100),
    
    -- Default Terms
    default_payment_terms JSONB DEFAULT '{}',
    default_cancellation_policy TEXT,
    default_refund_policy TEXT,
    
    -- Usage and Performance
    usage_count INTEGER DEFAULT 0,
    last_used_at TIMESTAMPTZ,
    is_active BOOLEAN DEFAULT TRUE,
    is_default BOOLEAN DEFAULT FALSE,
    
    -- Legal Compliance
    legal_review_status VARCHAR(50) DEFAULT 'pending',
    legal_approved_at TIMESTAMPTZ,
    compliance_version INTEGER DEFAULT 1,
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    INDEX idx_templates_supplier_id (supplier_id),
    INDEX idx_templates_type (contract_type),
    INDEX idx_templates_active (is_active),
    UNIQUE INDEX idx_templates_supplier_name (supplier_id, template_name)
);

-- Electronic signatures tracking
CREATE TABLE contract_signatures (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    contract_id UUID NOT NULL REFERENCES contracts(id) ON DELETE CASCADE,
    
    -- Signer Information
    signer_name VARCHAR(255) NOT NULL,
    signer_email VARCHAR(255) NOT NULL,
    signer_role VARCHAR(100) NOT NULL, -- 'supplier', 'client', 'witness', 'guarantor'
    
    -- Signature Details
    signature_status VARCHAR(50) CHECK (signature_status IN (
        'pending', 'invited', 'viewed', 'signed', 'declined', 'expired'
    )) DEFAULT 'pending',
    
    signature_method VARCHAR(50) DEFAULT 'electronic', -- 'electronic', 'wet_ink', 'digital_certificate'
    signature_data TEXT, -- Base64 encoded signature or certificate data
    signature_ip_address INET,
    signature_user_agent TEXT,
    signature_location JSONB DEFAULT '{}',
    
    -- Timing
    invitation_sent_at TIMESTAMPTZ,
    first_viewed_at TIMESTAMPTZ,
    signed_at TIMESTAMPTZ,
    signature_expires_at TIMESTAMPTZ,
    
    -- Verification
    verification_code VARCHAR(100),
    verification_method VARCHAR(50), -- 'email', 'sms', 'id_check'
    verification_completed_at TIMESTAMPTZ,
    
    -- Legal Compliance
    consent_to_electronic_signature BOOLEAN DEFAULT FALSE,
    identity_verified BOOLEAN DEFAULT FALSE,
    signature_intent_confirmed BOOLEAN DEFAULT FALSE,
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    
    INDEX idx_signatures_contract_id (contract_id),
    INDEX idx_signatures_email (signer_email),
    INDEX idx_signatures_status (signature_status),
    INDEX idx_signatures_signed_at (signed_at DESC)
);

-- Contract amendments and modifications
CREATE TABLE contract_amendments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    contract_id UUID NOT NULL REFERENCES contracts(id) ON DELETE CASCADE,
    
    amendment_number INTEGER NOT NULL,
    amendment_title VARCHAR(255) NOT NULL,
    amendment_description TEXT,
    
    -- Amendment Content
    original_content TEXT NOT NULL,
    amended_content TEXT NOT NULL,
    amendment_reason TEXT,
    
    -- Financial Changes
    amount_change DECIMAL(12,2) DEFAULT 0.00,
    new_total_amount DECIMAL(12,2),
    payment_schedule_changes JSONB DEFAULT '{}',
    
    -- Approval Process
    amendment_status VARCHAR(50) CHECK (amendment_status IN (
        'draft', 'pending_approval', 'approved', 'rejected', 'signed', 'active'
    )) DEFAULT 'draft',
    
    requested_by_user_id UUID REFERENCES users(id),
    approved_by_user_id UUID REFERENCES users(id),
    
    -- Signatures for Amendment
    requires_signatures BOOLEAN DEFAULT TRUE,
    signatures_completed BOOLEAN DEFAULT FALSE,
    
    -- Dates
    requested_at TIMESTAMPTZ DEFAULT NOW(),
    approved_at TIMESTAMPTZ,
    effective_date DATE,
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    
    INDEX idx_amendments_contract_id (contract_id),
    INDEX idx_amendments_status (amendment_status),
    INDEX idx_amendments_effective_date (effective_date)
);

-- Payment milestones tied to contracts
CREATE TABLE contract_payment_milestones (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    contract_id UUID NOT NULL REFERENCES contracts(id) ON DELETE CASCADE,
    
    milestone_name VARCHAR(255) NOT NULL,
    milestone_description TEXT,
    milestone_order INTEGER NOT NULL,
    
    -- Payment Details
    amount DECIMAL(12,2) NOT NULL,
    percentage_of_total DECIMAL(5,2),
    
    -- Trigger Conditions
    trigger_type VARCHAR(50) CHECK (trigger_type IN (
        'contract_signing', 'date_based', 'milestone_completion', 'service_delivery', 'manual'
    )) NOT NULL,
    trigger_date DATE,
    trigger_conditions JSONB DEFAULT '{}',
    
    -- Status and Tracking
    milestone_status VARCHAR(50) CHECK (milestone_status IN (
        'pending', 'due', 'overdue', 'paid', 'partially_paid', 'waived', 'disputed'
    )) DEFAULT 'pending',
    
    due_date DATE,
    paid_date DATE,
    paid_amount DECIMAL(12,2) DEFAULT 0.00,
    
    -- Payment Integration
    invoice_id UUID REFERENCES invoices(id),
    payment_method VARCHAR(50),
    payment_reference VARCHAR(100),
    
    -- Automation
    auto_invoice BOOLEAN DEFAULT TRUE,
    reminder_schedule JSONB DEFAULT '{}',
    next_reminder_at TIMESTAMPTZ,
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    INDEX idx_milestones_contract_id (contract_id),
    INDEX idx_milestones_status (milestone_status),
    INDEX idx_milestones_due_date (due_date),
    INDEX idx_milestones_order (milestone_order)
);

-- Contract activities and audit trail
CREATE TABLE contract_activities (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    contract_id UUID NOT NULL REFERENCES contracts(id) ON DELETE CASCADE,
    user_id UUID REFERENCES users(id),
    
    activity_type VARCHAR(100) CHECK (activity_type IN (
        'created', 'sent', 'viewed', 'signed', 'amended', 'cancelled', 'completed',
        'payment_received', 'reminder_sent', 'note_added', 'status_changed',
        'document_attached', 'legal_review_requested', 'compliance_check'
    )) NOT NULL,
    
    activity_description TEXT NOT NULL,
    activity_details JSONB DEFAULT '{}',
    
    -- Context Information
    ip_address INET,
    user_agent TEXT,
    location_data JSONB DEFAULT '{}',
    
    -- Related Objects
    related_signature_id UUID REFERENCES contract_signatures(id),
    related_amendment_id UUID REFERENCES contract_amendments(id),
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    
    INDEX idx_activities_contract_id (contract_id),
    INDEX idx_activities_type (activity_type),
    INDEX idx_activities_created (created_at DESC)
);

-- Contract documents and attachments
CREATE TABLE contract_documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    contract_id UUID NOT NULL REFERENCES contracts(id) ON DELETE CASCADE,
    
    document_name VARCHAR(255) NOT NULL,
    document_type VARCHAR(100) NOT NULL, -- 'contract_pdf', 'attachment', 'amendment', 'signature_page', 'legal_review'
    document_description TEXT,
    
    -- File Information
    file_path TEXT NOT NULL,
    file_size BIGINT,
    mime_type VARCHAR(100),
    file_hash VARCHAR(64), -- For integrity verification
    
    -- Version Control
    version_number INTEGER DEFAULT 1,
    is_current_version BOOLEAN DEFAULT TRUE,
    
    -- Access Control
    is_public BOOLEAN DEFAULT FALSE,
    access_permissions JSONB DEFAULT '{}',
    
    -- Document Status
    processing_status VARCHAR(50) DEFAULT 'processed',
    
    uploaded_by_user_id UUID REFERENCES users(id),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    
    INDEX idx_documents_contract_id (contract_id),
    INDEX idx_documents_type (document_type),
    INDEX idx_documents_current (is_current_version)
);

-- Contract compliance and legal tracking
CREATE TABLE contract_compliance (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    contract_id UUID NOT NULL REFERENCES contracts(id) ON DELETE CASCADE,
    
    compliance_type VARCHAR(100) NOT NULL, -- 'gdpr', 'consumer_rights', 'cancellation_rights', 'dispute_resolution'
    compliance_status VARCHAR(50) CHECK (compliance_status IN (
        'compliant', 'non_compliant', 'under_review', 'requires_action', 'exempt'
    )) NOT NULL,
    
    -- Compliance Details
    requirements_met JSONB DEFAULT '{}',
    requirements_missing JSONB DEFAULT '{}',
    compliance_notes TEXT,
    
    -- Review Information
    reviewed_by_user_id UUID REFERENCES users(id),
    reviewed_at TIMESTAMPTZ,
    next_review_due TIMESTAMPTZ,
    
    -- Legal References
    applicable_regulations TEXT[],
    legal_precedents TEXT,
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    INDEX idx_compliance_contract_id (contract_id),
    INDEX idx_compliance_type (compliance_type),
    INDEX idx_compliance_status (compliance_status)
);

-- Contract analytics and reporting
CREATE TABLE contract_analytics_daily (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    date_recorded DATE NOT NULL,
    
    -- Volume Metrics
    contracts_created INTEGER DEFAULT 0,
    contracts_sent INTEGER DEFAULT 0,
    contracts_signed INTEGER DEFAULT 0,
    contracts_completed INTEGER DEFAULT 0,
    
    -- Financial Metrics
    total_contract_value DECIMAL(12,2) DEFAULT 0.00,
    payments_received DECIMAL(12,2) DEFAULT 0.00,
    overdue_payments DECIMAL(12,2) DEFAULT 0.00,
    
    -- Performance Metrics
    average_signature_time_hours INTEGER,
    contract_completion_rate DECIMAL(5,2),
    payment_collection_rate DECIMAL(5,2),
    
    -- Compliance Metrics
    compliance_issues INTEGER DEFAULT 0,
    legal_reviews_required INTEGER DEFAULT 0,
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    
    INDEX idx_analytics_supplier (supplier_id),
    INDEX idx_analytics_date (date_recorded DESC),
    UNIQUE INDEX idx_analytics_supplier_date (supplier_id, date_recorded)
);
```

#### API Endpoints Required

```typescript
// Contract Management API Types
interface Contract {
    id: string;
    supplier_id: string;
    client_id?: string;
    lead_id?: string;
    wedding_id?: string;
    
    // Contract Identification
    contract_number: string;
    contract_title: string;
    contract_type: string;
    
    // Template and Content
    template_id?: string;
    contract_content: string;
    contract_version: number;
    
    // Financial Terms
    total_amount: number;
    currency: string;
    deposit_amount?: number;
    deposit_percentage?: number;
    payment_schedule: Record<string, any>;
    
    // Contract Status
    contract_status: 'draft' | 'pending_review' | 'sent_for_signature' | 'partially_signed' | 
                    'fully_signed' | 'active' | 'completed' | 'cancelled' | 'disputed';
    
    // Signature Information
    signature_required_from: string[];
    signatures_received: number;
    signatures_required: number;
    
    // Important Dates
    sent_date?: string;
    signature_deadline?: string;
    signed_date?: string;
    contract_start_date?: string;
    contract_end_date?: string;
    service_date?: string;
    
    // Legal and Compliance
    legal_review_required: boolean;
    legal_review_completed: boolean;
    legal_reviewer_id?: string;
    compliance_status: string;
    jurisdiction: string;
    
    // Terms and Conditions
    cancellation_policy?: string;
    refund_policy?: string;
    force_majeure_clause?: string;
    liability_limitations?: string;
    
    // Client Communication
    client_notes?: string;
    internal_notes?: string;
    
    // Automation and Reminders
    reminder_schedule: Record<string, any>;
    auto_follow_up: boolean;
    next_reminder_at?: string;
    
    // Metadata
    tags: string[];
    custom_fields: Record<string, any>;
    created_at: string;
    updated_at: string;
}

interface ContractTemplate {
    id: string;
    supplier_id: string;
    template_name: string;
    template_description?: string;
    
    // Template Content
    template_content: string;
    template_variables: Record<string, any>;
    
    // Template Configuration
    contract_type: string;
    service_category?: string;
    
    // Default Terms
    default_payment_terms: Record<string, any>;
    default_cancellation_policy?: string;
    default_refund_policy?: string;
    
    // Usage and Performance
    usage_count: number;
    last_used_at?: string;
    is_active: boolean;
    is_default: boolean;
    
    // Legal Compliance
    legal_review_status: string;
    legal_approved_at?: string;
    compliance_version: number;
    
    created_at: string;
    updated_at: string;
}

interface ContractSignature {
    id: string;
    contract_id: string;
    
    // Signer Information
    signer_name: string;
    signer_email: string;
    signer_role: string;
    
    // Signature Details
    signature_status: 'pending' | 'invited' | 'viewed' | 'signed' | 'declined' | 'expired';
    signature_method: string;
    signature_data?: string;
    signature_ip_address?: string;
    signature_user_agent?: string;
    signature_location: Record<string, any>;
    
    // Timing
    invitation_sent_at?: string;
    first_viewed_at?: string;
    signed_at?: string;
    signature_expires_at?: string;
    
    // Verification
    verification_code?: string;
    verification_method?: string;
    verification_completed_at?: string;
    
    // Legal Compliance
    consent_to_electronic_signature: boolean;
    identity_verified: boolean;
    signature_intent_confirmed: boolean;
    
    created_at: string;
}

interface ContractPaymentMilestone {
    id: string;
    contract_id: string;
    milestone_name: string;
    milestone_description?: string;
    milestone_order: number;
    
    // Payment Details
    amount: number;
    percentage_of_total?: number;
    
    // Trigger Conditions
    trigger_type: 'contract_signing' | 'date_based' | 'milestone_completion' | 'service_delivery' | 'manual';
    trigger_date?: string;
    trigger_conditions: Record<string, any>;
    
    // Status and Tracking
    milestone_status: 'pending' | 'due' | 'overdue' | 'paid' | 'partially_paid' | 'waived' | 'disputed';
    due_date?: string;
    paid_date?: string;
    paid_amount: number;
    
    // Payment Integration
    invoice_id?: string;
    payment_method?: string;
    payment_reference?: string;
    
    // Automation
    auto_invoice: boolean;
    reminder_schedule: Record<string, any>;
    next_reminder_at?: string;
    
    created_at: string;
    updated_at: string;
}

interface ContractCreateRequest {
    client_id?: string;
    lead_id?: string;
    wedding_id?: string;
    contract_title: string;
    contract_type: string;
    template_id?: string;
    contract_content: string;
    total_amount: number;
    currency?: string;
    deposit_amount?: number;
    deposit_percentage?: number;
    payment_schedule?: Record<string, any>;
    signature_required_from: string[];
    signature_deadline?: string;
    contract_start_date?: string;
    contract_end_date?: string;
    service_date?: string;
    cancellation_policy?: string;
    refund_policy?: string;
    client_notes?: string;
    internal_notes?: string;
    tags?: string[];
    custom_fields?: Record<string, any>;
}

interface ContractUpdateRequest {
    contract_title?: string;
    contract_content?: string;
    total_amount?: number;
    deposit_amount?: number;
    deposit_percentage?: number;
    payment_schedule?: Record<string, any>;
    contract_status?: string;
    signature_deadline?: string;
    contract_start_date?: string;
    contract_end_date?: string;
    service_date?: string;
    cancellation_policy?: string;
    refund_policy?: string;
    client_notes?: string;
    internal_notes?: string;
    tags?: string[];
    custom_fields?: Record<string, any>;
}

interface ContractsListResponse {
    contracts: Contract[];
    pagination: {
        total: number;
        page: number;
        limit: number;
        totalPages: number;
    };
    filters_applied: Record<string, any>;
    summary: {
        total_contracts: number;
        pending_signatures: number;
        active_contracts: number;
        overdue_payments: number;
        total_contract_value: number;
        completion_rate: number;
    };
}

interface ContractAnalyticsResponse {
    date_range: {
        start_date: string;
        end_date: string;
    };
    metrics: {
        contracts_created: number;
        contracts_sent: number;
        contracts_signed: number;
        contracts_completed: number;
        total_contract_value: number;
        payments_received: number;
        overdue_payments: number;
        average_signature_time_hours: number;
        contract_completion_rate: number;
        payment_collection_rate: number;
    };
    contract_types_performance: Array<{
        contract_type: string;
        count: number;
        completion_rate: number;
        average_value: number;
        signature_time_hours: number;
    }>;
    monthly_trends: Array<{
        month: string;
        contracts_created: number;
        contracts_signed: number;
        contract_value: number;
        payments_received: number;
    }>;
    signature_funnel: Array<{
        stage: string;
        count: number;
        percentage: number;
        drop_off_rate: number;
    }>;
}

// API Endpoints

// GET /api/contracts - List and filter contracts
interface ContractsListRequest {
    page?: number;
    limit?: number;
    status?: string[];
    contract_type?: string[];
    client_id?: string;
    wedding_id?: string;
    signature_status?: string[];
    payment_status?: string[];
    service_date_from?: string;
    service_date_to?: string;
    created_from?: string;
    created_to?: string;
    overdue_only?: boolean;
    search?: string; // Search across contract title, number, client name
    sort_by?: 'created_at' | 'updated_at' | 'service_date' | 'total_amount' | 'signature_deadline';
    sort_order?: 'asc' | 'desc';
}

// POST /api/contracts - Create new contract
interface ContractCreateResponse {
    success: boolean;
    contract: Contract;
    contract_number_generated: string;
    payment_milestones_created: ContractPaymentMilestone[];
    compliance_checks: Array<{
        type: string;
        status: string;
        issues: string[];
    }>;
    message?: string;
}

// PUT /api/contracts/:id - Update contract
interface ContractUpdateResponse {
    success: boolean;
    contract: Contract;
    version_incremented: boolean;
    compliance_updates: Array<{
        type: string;
        previous_status: string;
        new_status: string;
    }>;
    message?: string;
}

// POST /api/contracts/:id/send - Send contract for signature
interface SendContractRequest {
    signers: Array<{
        name: string;
        email: string;
        role: string;
        verification_method?: string;
    }>;
    signature_deadline?: string;
    custom_message?: string;
    reminder_schedule?: Record<string, any>;
}

interface SendContractResponse {
    success: boolean;
    signatures_created: ContractSignature[];
    invitations_sent: number;
    contract_updated: Contract;
    tracking_urls: Array<{
        signer_email: string;
        tracking_url: string;
    }>;
    message?: string;
}

// GET /api/contracts/:id/signatures - Get signature status
interface ContractSignaturesResponse {
    signatures: ContractSignature[];
    summary: {
        total_required: number;
        completed: number;
        pending: number;
        overdue: number;
        completion_percentage: number;
    };
    next_required_signatures: string[];
}

// POST /api/contracts/:id/sign - Process electronic signature
interface SignContractRequest {
    signature_id: string;
    signature_data: string;
    verification_code?: string;
    consent_confirmed: boolean;
    signer_ip?: string;
    signer_location?: Record<string, any>;
}

interface SignContractResponse {
    success: boolean;
    signature_updated: ContractSignature;
    contract_status_updated: boolean;
    next_steps: string[];
    completion_percentage: number;
    message?: string;
}

// GET /api/contracts/analytics - Contract analytics and reporting
interface ContractAnalyticsRequest {
    start_date: string;
    end_date: string;
    group_by?: 'day' | 'week' | 'month';
    contract_types?: string[];
    include_forecasts?: boolean;
}

// GET/POST /api/contract-templates - Template management
interface ContractTemplatesResponse {
    templates: ContractTemplate[];
    categories: Array<{
        contract_type: string;
        count: number;
        most_used_template: string;
    }>;
    usage_stats: {
        total_templates: number;
        active_templates: number;
        most_popular_template: string;
        average_usage_per_template: number;
    };
}

// POST /api/contracts/:id/generate-pdf - Generate contract PDF
interface GeneratePDFRequest {
    include_signatures: boolean;
    include_amendments: boolean;
    watermark?: string;
    format?: 'a4' | 'letter';
}

interface GeneratePDFResponse {
    success: boolean;
    pdf_url: string;
    pdf_file_path: string;
    file_size: number;
    generation_time_ms: number;
    message?: string;
}

// POST /api/contracts/:id/amendments - Create contract amendment
interface CreateAmendmentRequest {
    amendment_title: string;
    amendment_description?: string;
    original_content: string;
    amended_content: string;
    amendment_reason?: string;
    amount_change?: number;
    payment_schedule_changes?: Record<string, any>;
    requires_signatures?: boolean;
    effective_date?: string;
}

interface CreateAmendmentResponse {
    success: boolean;
    amendment: ContractAmendment;
    contract_updated: Contract;
    signatures_required: boolean;
    compliance_checks: Array<{
        type: string;
        status: string;
    }>;
    message?: string;
}
```

### CODE EXAMPLES

#### Example 1: Contract Management Dashboard Component

```typescript
// /src/components/contracts/ContractManagementDashboard.tsx
'use client';

import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Input } from '@/components/ui/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { DataTable } from '@/components/ui/data-table';
import { Progress } from '@/components/ui/progress';
import { 
  FileText, Signature, Calendar, Clock, AlertTriangle, 
  DollarSign, CheckCircle, Users, TrendingUp 
} from 'lucide-react';
import { Contract, ContractsListResponse, ContractAnalyticsResponse } from '@/types/contracts';
import { contractService } from '@/lib/contracts/contract-service';
import { formatCurrency, formatDate, getStatusColor, getDaysUntilDeadline } from '@/lib/utils';

interface ContractManagementDashboardProps {
  initialData?: ContractsListResponse;
  analytics?: ContractAnalyticsResponse;
}

export function ContractManagementDashboard({ initialData, analytics }: ContractManagementDashboardProps) {
  const router = useRouter();
  const [contracts, setContracts] = useState<Contract[]>(initialData?.contracts || []);
  const [loading, setLoading] = useState(false);
  const [filters, setFilters] = useState({
    status: '',
    contract_type: '',
    signature_status: '',
    payment_status: '',
    search: ''
  });
  const [selectedContracts, setSelectedContracts] = useState<string[]>([]);
  const [viewMode, setViewMode] = useState<'list' | 'cards' | 'calendar'>('list');

  // Contract status statistics
  const statusStats = {
    draft: contracts.filter(c => c.contract_status === 'draft').length,
    sent_for_signature: contracts.filter(c => c.contract_status === 'sent_for_signature').length,
    partially_signed: contracts.filter(c => c.contract_status === 'partially_signed').length,
    fully_signed: contracts.filter(c => c.contract_status === 'fully_signed').length,
    active: contracts.filter(c => c.contract_status === 'active').length,
    completed: contracts.filter(c => c.contract_status === 'completed').length
  };

  const overdueContracts = contracts.filter(c => 
    c.signature_deadline && 
    new Date(c.signature_deadline) < new Date() && 
    ['sent_for_signature', 'partially_signed'].includes(c.contract_status)
  );

  const totalValue = contracts.reduce((sum, contract) => sum + contract.total_amount, 0);
  const signatureCompletionRate = contracts.length > 0 
    ? ((statusStats.fully_signed + statusStats.active + statusStats.completed) / contracts.length * 100) 
    : 0;

  const handleFilterChange = async (key: string, value: string) => {
    const newFilters = { ...filters, [key]: value };
    setFilters(newFilters);
    await loadContracts(newFilters);
  };

  const loadContracts = async (filterParams = filters) => {
    setLoading(true);
    try {
      const response = await contractService.getContracts({
        ...filterParams,
        page: 1,
        limit: 50
      });
      setContracts(response.contracts);
    } catch (error) {
      console.error('Failed to load contracts:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleContractClick = (contractId: string) => {
    router.push(`/contracts/${contractId}`);
  };

  const handleBulkAction = async (action: string) => {
    if (selectedContracts.length === 0) return;
    
    try {
      setLoading(true);
      await contractService.bulkUpdateContracts(selectedContracts, { action });
      await loadContracts();
      setSelectedContracts([]);
    } catch (error) {
      console.error('Bulk action failed:', error);
    } finally {
      setLoading(false);
    }
  };

  const getSignatureProgress = (contract: Contract) => {
    if (contract.signatures_required === 0) return 100;
    return (contract.signatures_received / contract.signatures_required) * 100;
  };

  const getContractPriorityColor = (contract: Contract) => {
    if (overdueContracts.some(c => c.id === contract.id)) return 'destructive';
    if (contract.signature_deadline) {
      const daysUntil = getDaysUntilDeadline(contract.signature_deadline);
      if (daysUntil <= 3) return 'warning';
    }
    return 'secondary';
  };

  const columns = [
    {
      accessorKey: 'select',
      header: ({ table }) => (
        <input
          type="checkbox"
          checked={table.getIsAllPageRowsSelected()}
          onChange={(e) => {
            if (e.target.checked) {
              setSelectedContracts(contracts.map(c => c.id));
            } else {
              setSelectedContracts([]);
            }
          }}
        />
      ),
      cell: ({ row }) => {
        const contract = row.original as Contract;
        return (
          <input
            type="checkbox"
            checked={selectedContracts.includes(contract.id)}
            onChange={(e) => {
              if (e.target.checked) {
                setSelectedContracts(prev => [...prev, contract.id]);
              } else {
                setSelectedContracts(prev => prev.filter(id => id !== contract.id));
              }
            }}
          />
        );
      }
    },
    {
      accessorKey: 'contract_info',
      header: 'Contract',
      cell: ({ row }) => {
        const contract = row.original as Contract;
        return (
          <div className="space-y-1">
            <div className="font-medium">{contract.contract_title}</div>
            <div className="text-sm text-muted-foreground">
              #{contract.contract_number} • {contract.contract_type.replace('_', ' ')}
            </div>
          </div>
        );
      }
    },
    {
      accessorKey: 'client_info',
      header: 'Client',
      cell: ({ row }) => {
        const contract = row.original as Contract;
        return (
          <div className="space-y-1">
            <div className="font-medium">
              {/* This would be populated from client relationship */}
              Client Name
            </div>
            <div className="text-sm text-muted-foreground">
              {contract.service_date ? `Service: ${formatDate(contract.service_date)}` : 'No service date'}
            </div>
          </div>
        );
      }
    },
    {
      accessorKey: 'contract_status',
      header: 'Status',
      cell: ({ row }) => {
        const contract = row.original as Contract;
        return (
          <Badge 
            variant={getStatusColor(contract.contract_status)}
            className="capitalize"
          >
            {contract.contract_status.replace('_', ' ')}
          </Badge>
        );
      }
    },
    {
      accessorKey: 'signature_progress',
      header: 'Signatures',
      cell: ({ row }) => {
        const contract = row.original as Contract;
        const progress = getSignatureProgress(contract);
        return (
          <div className="space-y-1">
            <div className="flex items-center gap-2">
              <Signature className="w-4 h-4" />
              <span className="text-sm">
                {contract.signatures_received}/{contract.signatures_required}
              </span>
            </div>
            <Progress value={progress} className="w-20" />
          </div>
        );
      }
    },
    {
      accessorKey: 'total_amount',
      header: 'Value',
      cell: ({ row }) => {
        const contract = row.original as Contract;
        return (
          <div className="space-y-1">
            <div className="font-medium">{formatCurrency(contract.total_amount)}</div>
            {contract.deposit_amount && (
              <div className="text-sm text-muted-foreground">
                Deposit: {formatCurrency(contract.deposit_amount)}
              </div>
            )}
          </div>
        );
      }
    },
    {
      accessorKey: 'signature_deadline',
      header: 'Deadline',
      cell: ({ row }) => {
        const contract = row.original as Contract;
        if (!contract.signature_deadline) return '-';
        
        const daysUntil = getDaysUntilDeadline(contract.signature_deadline);
        const isOverdue = daysUntil < 0;
        const isUrgent = daysUntil <= 3;
        
        return (
          <div className={`text-sm ${
            isOverdue ? 'text-red-600 font-medium' : 
            isUrgent ? 'text-orange-600 font-medium' : 
            'text-muted-foreground'
          }`}>
            <div className="flex items-center gap-1">
              <Calendar className="w-4 h-4" />
              {formatDate(contract.signature_deadline)}
            </div>
            <div>
              {isOverdue ? `${Math.abs(daysUntil)} days overdue` : 
               isUrgent ? `${daysUntil} days left` : 
               `${daysUntil} days left`}
            </div>
          </div>
        );
      }
    },
    {
      id: 'actions',
      cell: ({ row }) => {
        const contract = row.original as Contract;
        return (
          <div className="flex gap-1">
            <Button variant="ghost" size="sm" onClick={() => handleContractClick(contract.id)}>
              View
            </Button>
            {contract.contract_status === 'draft' && (
              <Button 
                variant="ghost" 
                size="sm" 
                onClick={() => router.push(`/contracts/${contract.id}/send`)}
              >
                Send
              </Button>
            )}
            {contract.contract_status === 'fully_signed' && (
              <Button 
                variant="ghost" 
                size="sm" 
                onClick={() => contractService.generatePDF(contract.id)}
              >
                <FileText className="w-4 h-4" />
              </Button>
            )}
          </div>
        );
      }
    }
  ];

  return (
    <div className="space-y-6">
      {/* Header with key metrics */}
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-3xl font-bold">Contract Management</h1>
          <p className="text-muted-foreground">Manage your client contracts and agreements</p>
        </div>
        <div className="flex gap-2">
          <Button variant="outline" onClick={() => router.push('/contracts/templates')}>
            Templates
          </Button>
          <Button onClick={() => router.push('/contracts/new')}>
            Create Contract
          </Button>
        </div>
      </div>

      {/* Key Metrics Cards */}
      <div className="grid grid-cols-1 md:grid-cols-5 gap-4">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Total Contracts</CardTitle>
            <FileText className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{contracts.length}</div>
            <p className="text-xs text-muted-foreground">
              {statusStats.draft} drafts
            </p>
          </CardContent>
        </Card>
        
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Awaiting Signatures</CardTitle>
            <Signature className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              {statusStats.sent_for_signature + statusStats.partially_signed}
            </div>
            <p className="text-xs text-muted-foreground">
              {overdueContracts.length} overdue
            </p>
          </CardContent>
        </Card>
        
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Signature Rate</CardTitle>
            <CheckCircle className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{signatureCompletionRate.toFixed(1)}%</div>
            <Progress value={signatureCompletionRate} className="mt-2" />
          </CardContent>
        </Card>
        
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Contract Value</CardTitle>
            <DollarSign className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{formatCurrency(totalValue)}</div>
            <p className="text-xs text-muted-foreground">
              Total portfolio value
            </p>
          </CardContent>
        </Card>
        
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Active Contracts</CardTitle>
            <Users className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{statusStats.active}</div>
            <p className="text-xs text-muted-foreground">
              Currently active
            </p>
          </CardContent>
        </Card>
      </div>

      {/* Urgent Actions Alert */}
      {overdueContracts.length > 0 && (
        <Card className="border-orange-200 bg-orange-50">
          <CardContent className="pt-6">
            <div className="flex items-center gap-3">
              <AlertTriangle className="w-5 h-5 text-orange-600" />
              <div>
                <p className="font-medium text-orange-900">
                  {overdueContracts.length} contract{overdueContracts.length > 1 ? 's' : ''} overdue
                </p>
                <p className="text-sm text-orange-700">
                  These contracts have passed their signature deadline and need immediate attention.
                </p>
              </div>
              <Button 
                variant="outline" 
                size="sm"
                onClick={() => setFilters({ ...filters, signature_status: 'overdue' })}
              >
                View Overdue
              </Button>
            </div>
          </CardContent>
        </Card>
      )}

      {/* Filters and Actions */}
      <Card>
        <CardContent className="pt-6">
          <div className="flex flex-wrap gap-4 mb-4">
            <Input
              placeholder="Search contracts..."
              value={filters.search}
              onChange={(e) => handleFilterChange('search', e.target.value)}
              className="max-w-sm"
            />
            
            <Select value={filters.status} onValueChange={(value) => handleFilterChange('status', value)}>
              <SelectTrigger className="w-[180px]">
                <SelectValue placeholder="Status" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="">All Statuses</SelectItem>
                <SelectItem value="draft">Draft</SelectItem>
                <SelectItem value="sent_for_signature">Sent for Signature</SelectItem>
                <SelectItem value="partially_signed">Partially Signed</SelectItem>
                <SelectItem value="fully_signed">Fully Signed</SelectItem>
                <SelectItem value="active">Active</SelectItem>
                <SelectItem value="completed">Completed</SelectItem>
              </SelectContent>
            </Select>
            
            <Select value={filters.contract_type} onValueChange={(value) => handleFilterChange('contract_type', value)}>
              <SelectTrigger className="w-[180px]">
                <SelectValue placeholder="Contract Type" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="">All Types</SelectItem>
                <SelectItem value="wedding_photography">Photography</SelectItem>
                <SelectItem value="venue_rental">Venue</SelectItem>
                <SelectItem value="catering">Catering</SelectItem>
                <SelectItem value="planning">Planning</SelectItem>
                <SelectItem value="flowers">Flowers</SelectItem>
                <SelectItem value="music">Music</SelectItem>
              </SelectContent>
            </Select>
            
            <Select value={filters.signature_status} onValueChange={(value) => handleFilterChange('signature_status', value)}>
              <SelectTrigger className="w-[180px]">
                <SelectValue placeholder="Signatures" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="">All</SelectItem>
                <SelectItem value="pending">Pending</SelectItem>
                <SelectItem value="overdue">Overdue</SelectItem>
                <SelectItem value="complete">Complete</SelectItem>
              </SelectContent>
            </Select>
          </div>
          
          {selectedContracts.length > 0 && (
            <div className="flex gap-2 mb-4">
              <Button 
                variant="outline" 
                size="sm"
                onClick={() => handleBulkAction('send_reminders')}
              >
                Send Reminders ({selectedContracts.length})
              </Button>
              <Button 
                variant="outline" 
                size="sm"
                onClick={() => handleBulkAction('update_deadline')}
              >
                Update Deadline
              </Button>
              <Button 
                variant="outline" 
                size="sm"
                onClick={() => handleBulkAction('generate_reports')}
              >
                Generate Reports
              </Button>
            </div>
          )}
        </CardContent>
      </Card>

      {/* Contracts Data Table */}
      <Card>
        <CardContent className="pt-6">
          <DataTable
            columns={columns}
            data={contracts}
            loading={loading}
            onRowClick={(contract) => handleContractClick(contract.id)}
          />
        </CardContent>
      </Card>
    </div>
  );
}
```

#### Example 2: Electronic Signature Service

```typescript
// /src/lib/contracts/electronic-signature-service.ts
import { supabase } from '@/lib/supabase';
import { Contract, ContractSignature } from '@/types/contracts';
import { emailService } from '@/lib/email/email-service';
import { smsService } from '@/lib/sms/sms-service';

export class ElectronicSignatureService {
  private readonly SIGNATURE_EXPIRES_DAYS = 30;
  private readonly VERIFICATION_EXPIRES_MINUTES = 15;

  /**
   * Send contract for electronic signature
   */
  async sendContractForSignature(
    contractId: string,
    signers: Array<{
      name: string;
      email: string;
      role: string;
      verification_method?: string;
    }>,
    options: {
      signature_deadline?: string;
      custom_message?: string;
      reminder_schedule?: Record<string, any>;
    } = {}
  ): Promise<{ success: boolean; signatures: ContractSignature[]; tracking_urls: Array<{ signer_email: string; tracking_url: string }> }> {
    try {
      // Get contract details
      const { data: contract, error: contractError } = await supabase
        .from('contracts')
        .select('*')
        .eq('id', contractId)
        .single();

      if (contractError || !contract) {
        throw new Error('Contract not found');
      }

      const signatures: ContractSignature[] = [];
      const trackingUrls: Array<{ signer_email: string; tracking_url: string }> = [];

      // Create signature records for each signer
      for (const signer of signers) {
        const signature = await this.createSignatureRecord(contractId, signer, options);
        signatures.push(signature);
        
        // Generate tracking URL
        const trackingUrl = await this.generateTrackingUrl(signature.id);
        trackingUrls.push({
          signer_email: signer.email,
          tracking_url: trackingUrl
        });

        // Send invitation email
        await this.sendSignatureInvitation(signature, contract, options.custom_message);
      }

      // Update contract status
      await supabase
        .from('contracts')
        .update({
          contract_status: 'sent_for_signature',
          sent_date: new Date().toISOString(),
          signature_deadline: options.signature_deadline,
          signatures_required: signers.length,
          updated_at: new Date().toISOString()
        })
        .eq('id', contractId);

      // Log activity
      await this.logContractActivity(contractId, 'sent', {
        signers_count: signers.length,
        signature_deadline: options.signature_deadline
      });

      return {
        success: true,
        signatures,
        tracking_urls: trackingUrls
      };
    } catch (error) {
      console.error('Failed to send contract for signature:', error);
      throw error;
    }
  }

  /**
   * Create signature record for a signer
   */
  private async createSignatureRecord(
    contractId: string,
    signer: {
      name: string;
      email: string;
      role: string;
      verification_method?: string;
    },
    options: Record<string, any>
  ): Promise<ContractSignature> {
    const verificationCode = this.generateVerificationCode();
    const expirationDate = new Date();
    expirationDate.setDate(expirationDate.getDate() + this.SIGNATURE_EXPIRES_DAYS);

    const { data: signature, error } = await supabase
      .from('contract_signatures')
      .insert({
        contract_id: contractId,
        signer_name: signer.name,
        signer_email: signer.email,
        signer_role: signer.role,
        signature_status: 'pending',
        verification_code: verificationCode,
        verification_method: signer.verification_method || 'email',
        signature_expires_at: expirationDate.toISOString()
      })
      .select()
      .single();

    if (error) {
      throw new Error(`Failed to create signature record: ${error.message}`);
    }

    return signature;
  }

  /**
   * Send signature invitation email
   */
  private async sendSignatureInvitation(
    signature: ContractSignature,
    contract: Contract,
    customMessage?: string
  ): Promise<void> {
    try {
      const trackingUrl = await this.generateTrackingUrl(signature.id);
      
      const emailContent = this.generateInvitationEmail({
        signerName: signature.signer_name,
        contractTitle: contract.contract_title,
        contractNumber: contract.contract_number,
        trackingUrl,
        expirationDate: signature.signature_expires_at!,
        customMessage
      });

      await emailService.sendEmail({
        to: signature.signer_email,
        subject: `Signature Required: ${contract.contract_title}`,
        html: emailContent,
        metadata: {
          contract_id: contract.id,
          signature_id: signature.id,
          email_type: 'signature_invitation'
        }
      });

      // Update signature record with invitation sent timestamp
      await supabase
        .from('contract_signatures')
        .update({
          invitation_sent_at: new Date().toISOString(),
          signature_status: 'invited'
        })
        .eq('id', signature.id);

    } catch (error) {
      console.error('Failed to send signature invitation:', error);
      throw error;
    }
  }

  /**
   * Process electronic signature
   */
  async processElectronicSignature(
    signatureId: string,
    signatureData: {
      signature_data: string;
      verification_code?: string;
      consent_confirmed: boolean;
      signer_ip?: string;
      signer_location?: Record<string, any>;
      user_agent?: string;
    }
  ): Promise<{ success: boolean; signature: ContractSignature; contract_completed: boolean }> {
    try {
      // Get signature record
      const { data: signature, error: signatureError } = await supabase
        .from('contract_signatures')
        .select('*, contract:contracts(*)')
        .eq('id', signatureId)
        .single();

      if (signatureError || !signature) {
        throw new Error('Signature record not found');
      }

      // Verify signature is still valid
      if (signature.signature_status === 'signed') {
        throw new Error('Contract already signed by this party');
      }

      if (signature.signature_status === 'expired') {
        throw new Error('Signature invitation has expired');
      }

      if (new Date(signature.signature_expires_at!) < new Date()) {
        throw new Error('Signature deadline has passed');
      }

      // Verify verification code if provided
      if (signatureData.verification_code && 
          signatureData.verification_code !== signature.verification_code) {
        throw new Error('Invalid verification code');
      }

      // Verify consent
      if (!signatureData.consent_confirmed) {
        throw new Error('Electronic signature consent not confirmed');
      }

      // Update signature record
      const { data: updatedSignature, error: updateError } = await supabase
        .from('contract_signatures')
        .update({
          signature_status: 'signed',
          signature_data: signatureData.signature_data,
          signature_ip_address: signatureData.signer_ip,
          signature_user_agent: signatureData.user_agent,
          signature_location: signatureData.signer_location || {},
          signed_at: new Date().toISOString(),
          consent_to_electronic_signature: signatureData.consent_confirmed,
          identity_verified: true,
          signature_intent_confirmed: true
        })
        .eq('id', signatureId)
        .select()
        .single();

      if (updateError) {
        throw new Error(`Failed to update signature: ${updateError.message}`);
      }

      // Update contract signature count
      const { data: allSignatures } = await supabase
        .from('contract_signatures')
        .select('*')
        .eq('contract_id', signature.contract_id);

      const signedCount = allSignatures?.filter(s => s.signature_status === 'signed').length || 0;
      const totalRequired = signature.contract.signatures_required;

      let newContractStatus = signature.contract.contract_status;
      let contractCompleted = false;

      if (signedCount === totalRequired) {
        newContractStatus = 'fully_signed';
        contractCompleted = true;
      } else if (signedCount > 0) {
        newContractStatus = 'partially_signed';
      }

      // Update contract
      await supabase
        .from('contracts')
        .update({
          signatures_received: signedCount,
          contract_status: newContractStatus,
          signed_date: contractCompleted ? new Date().toISOString() : signature.contract.signed_date,
          updated_at: new Date().toISOString()
        })
        .eq('id', signature.contract_id);

      // Log activity
      await this.logContractActivity(signature.contract_id, 'signed', {
        signer_name: signature.signer_name,
        signer_email: signature.signer_email,
        signer_role: signature.signer_role,
        signatures_completed: signedCount,
        total_required: totalRequired,
        contract_completed: contractCompleted
      });

      // Send completion notifications if fully signed
      if (contractCompleted) {
        await this.sendCompletionNotifications(signature.contract_id);
      }

      return {
        success: true,
        signature: updatedSignature,
        contract_completed: contractCompleted
      };

    } catch (error) {
      console.error('Failed to process electronic signature:', error);
      throw error;
    }
  }

  /**
   * Generate signature tracking URL
   */
  private async generateTrackingUrl(signatureId: string): Promise<string> {
    const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'https://app.wedsync.com';
    return `${baseUrl}/contracts/sign/${signatureId}`;
  }

  /**
   * Generate verification code
   */
  private generateVerificationCode(): string {
    return Math.random().toString(36).substring(2, 8).toUpperCase();
  }

  /**
   * Generate invitation email HTML
   */
  private generateInvitationEmail(params: {
    signerName: string;
    contractTitle: string;
    contractNumber: string;
    trackingUrl: string;
    expirationDate: string;
    customMessage?: string;
  }): string {
    const expirationFormatted = new Date(params.expirationDate).toLocaleDateString();
    
    return `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <div style="background: #f8f9fa; padding: 20px; text-align: center;">
          <h1 style="color: #333; margin: 0;">WedSync</h1>
          <p style="color: #666; margin: 5px 0;">Electronic Signature Required</p>
        </div>
        
        <div style="padding: 30px 20px;">
          <h2 style="color: #333;">Hello ${params.signerName},</h2>
          
          <p>You have been requested to electronically sign the following contract:</p>
          
          <div style="background: #f8f9fa; padding: 15px; border-left: 4px solid #007bff; margin: 20px 0;">
            <strong>${params.contractTitle}</strong><br>
            <small style="color: #666;">Contract #${params.contractNumber}</small>
          </div>
          
          ${params.customMessage ? `
            <div style="background: #fff3cd; padding: 15px; border: 1px solid #ffeaa7; border-radius: 4px; margin: 20px 0;">
              <strong>Message from sender:</strong><br>
              ${params.customMessage}
            </div>
          ` : ''}
          
          <div style="text-align: center; margin: 30px 0;">
            <a href="${params.trackingUrl}" 
               style="background: #007bff; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; display: inline-block; font-weight: bold;">
              Review & Sign Contract
            </a>
          </div>
          
          <div style="background: #f8f9fa; padding: 15px; border-radius: 4px; margin: 20px 0;">
            <h4 style="margin: 0 0 10px 0; color: #333;">Important Information:</h4>
            <ul style="margin: 0; padding-left: 20px; color: #666;">
              <li>This signature request expires on ${expirationFormatted}</li>
              <li>You will need to confirm your identity and consent to electronic signature</li>
              <li>Once signed, you will receive a copy of the completed contract</li>
              <li>If you have questions, please contact the sender directly</li>
            </ul>
          </div>
          
          <p style="color: #666; font-size: 12px; margin-top: 30px;">
            This email was sent by WedSync on behalf of the contract sender. 
            If you believe this was sent in error, please contact support.
          </p>
        </div>
      </div>
    `;
  }

  /**
   * Send completion notifications
   */
  private async sendCompletionNotifications(contractId: string): Promise<void> {
    try {
      // Get contract and all signatures
      const { data: contract } = await supabase
        .from('contracts')
        .select('*, signatures:contract_signatures(*)')
        .eq('id', contractId)
        .single();

      if (!contract) return;

      // Send notification to all parties
      for (const signature of contract.signatures) {
        await emailService.sendEmail({
          to: signature.signer_email,
          subject: `Contract Completed: ${contract.contract_title}`,
          html: this.generateCompletionEmail({
            signerName: signature.signer_name,
            contractTitle: contract.contract_title,
            contractNumber: contract.contract_number,
            completedDate: new Date().toLocaleDateString()
          }),
          metadata: {
            contract_id: contractId,
            signature_id: signature.id,
            email_type: 'signature_completion'
          }
        });
      }
    } catch (error) {
      console.error('Failed to send completion notifications:', error);
    }
  }

  /**
   * Generate completion email HTML
   */
  private generateCompletionEmail(params: {
    signerName: string;
    contractTitle: string;
    contractNumber: string;
    completedDate: string;
  }): string {
    return `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <div style="background: #d4edda; padding: 20px; text-align: center; border: 1px solid #c3e6cb;">
          <h1 style="color: #155724; margin: 0;">✓ Contract Completed</h1>
          <p style="color: #155724; margin: 5px 0;">All parties have signed</p>
        </div>
        
        <div style="padding: 30px 20px;">
          <h2 style="color: #333;">Hello ${params.signerName},</h2>
          
          <p>Great news! The following contract has been fully executed:</p>
          
          <div style="background: #f8f9fa; padding: 15px; border-left: 4px solid #28a745; margin: 20px 0;">
            <strong>${params.contractTitle}</strong><br>
            <small style="color: #666;">Contract #${params.contractNumber}</small><br>
            <small style="color: #666;">Completed on ${params.completedDate}</small>
          </div>
          
          <p>A copy of the fully executed contract is available in your WedSync dashboard. 
             You can download a PDF copy at any time.</p>
          
          <div style="text-align: center; margin: 30px 0;">
            <a href="${process.env.NEXT_PUBLIC_APP_URL}/contracts" 
               style="background: #28a745; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; display: inline-block; font-weight: bold;">
              View Contract
            </a>
          </div>
          
          <p style="color: #666; font-size: 12px; margin-top: 30px;">
            Thank you for using WedSync for your contract management needs.
          </p>
        </div>
      </div>
    `;
  }

  /**
   * Log contract activity
   */
  private async logContractActivity(
    contractId: string,
    activityType: string,
    details: Record<string, any>
  ): Promise<void> {
    try {
      await supabase
        .from('contract_activities')
        .insert({
          contract_id: contractId,
          activity_type: activityType,
          activity_description: this.getActivityDescription(activityType, details),
          activity_details: details
        });
    } catch (error) {
      console.error('Failed to log contract activity:', error);
    }
  }

  /**
   * Get human-readable activity description
   */
  private getActivityDescription(activityType: string, details: Record<string, any>): string {
    switch (activityType) {
      case 'sent':
        return `Contract sent for signature to ${details.signers_count} parties`;
      case 'signed':
        return `Contract signed by ${details.signer_name} (${details.signer_role})`;
      case 'completed':
        return `Contract fully executed - all ${details.total_required} signatures obtained`;
      default:
        return `Contract ${activityType}`;
    }
  }

  /**
   * Send signature reminders
   */
  async sendSignatureReminders(contractId: string): Promise<{ success: boolean; reminders_sent: number }> {
    try {
      // Get pending signatures
      const { data: pendingSignatures, error } = await supabase
        .from('contract_signatures')
        .select('*, contract:contracts(*)')
        .eq('contract_id', contractId)
        .in('signature_status', ['pending', 'invited', 'viewed'])
        .lt('signature_expires_at', new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString()); // Within 7 days of expiration

      if (error || !pendingSignatures?.length) {
        return { success: true, reminders_sent: 0 };
      }

      let remindersSent = 0;

      for (const signature of pendingSignatures) {
        try {
          const trackingUrl = await this.generateTrackingUrl(signature.id);
          const daysUntilExpiration = Math.ceil(
            (new Date(signature.signature_expires_at!).getTime() - new Date().getTime()) / (1000 * 3600 * 24)
          );

          await emailService.sendEmail({
            to: signature.signer_email,
            subject: `Reminder: Signature Required - ${signature.contract.contract_title}`,
            html: this.generateReminderEmail({
              signerName: signature.signer_name,
              contractTitle: signature.contract.contract_title,
              contractNumber: signature.contract.contract_number,
              trackingUrl,
              daysUntilExpiration
            }),
            metadata: {
              contract_id: contractId,
              signature_id: signature.id,
              email_type: 'signature_reminder'
            }
          });

          remindersSent++;
        } catch (error) {
          console.error(`Failed to send reminder to ${signature.signer_email}:`, error);
        }
      }

      return { success: true, reminders_sent: remindersSent };
    } catch (error) {
      console.error('Failed to send signature reminders:', error);
      throw error;
    }
  }

  /**
   * Generate reminder email HTML
   */
  private generateReminderEmail(params: {
    signerName: string;
    contractTitle: string;
    contractNumber: string;
    trackingUrl: string;
    daysUntilExpiration: number;
  }): string {
    const urgencyColor = params.daysUntilExpiration <= 3 ? '#dc3545' : '#ffc107';
    const urgencyText = params.daysUntilExpiration <= 1 
      ? 'Expires tomorrow!' 
      : `Expires in ${params.daysUntilExpiration} days`;

    return `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <div style="background: ${urgencyColor}; color: white; padding: 20px; text-align: center;">
          <h1 style="margin: 0;">⏰ Signature Reminder</h1>
          <p style="margin: 5px 0; font-weight: bold;">${urgencyText}</p>
        </div>
        
        <div style="padding: 30px 20px;">
          <h2 style="color: #333;">Hello ${params.signerName},</h2>
          
          <p>This is a friendly reminder that you still need to sign the following contract:</p>
          
          <div style="background: #f8f9fa; padding: 15px; border-left: 4px solid ${urgencyColor}; margin: 20px 0;">
            <strong>${params.contractTitle}</strong><br>
            <small style="color: #666;">Contract #${params.contractNumber}</small>
          </div>
          
          <div style="text-align: center; margin: 30px 0;">
            <a href="${params.trackingUrl}" 
               style="background: #007bff; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; display: inline-block; font-weight: bold;">
              Sign Contract Now
            </a>
          </div>
          
          <p style="color: #666;">
            Please sign this contract at your earliest convenience to avoid any delays. 
            If you have any questions or concerns, please contact the sender directly.
          </p>
        </div>
      </div>
    `;
  }
}

export const electronicSignatureService = new ElectronicSignatureService();
```

### ACCEPTANCE CRITERIA
- [ ] Complete contract creation system with template builder
- [ ] Electronic signature integration with legal compliance
- [ ] Contract status tracking and workflow management
- [ ] Payment milestone integration with automated invoicing
- [ ] Contract amendment and modification tracking
- [ ] Legal compliance monitoring and audit trails
- [ ] Mobile-responsive contract management interface
- [ ] PDF generation with signature pages
- [ ] Automated reminder and notification system
- [ ] Contract analytics and performance reporting
- [ ] Template library with customization options
- [ ] Client portal for contract viewing and signing
- [ ] Integration with existing WedSync payment systems
- [ ] GDPR compliance with data retention policies
- [ ] Multi-language support for international suppliers
- [ ] Bulk contract operations and management
- [ ] Contract approval workflow for teams
- [ ] Document attachment and version control
- [ ] Comprehensive testing coverage >90%
- [ ] Legal review and approval process integration

### DEPENDENCIES
- Must complete after: User authentication system, client management, payment processing
- Must complete before: Advanced business intelligence, legal compliance suite
- Shares code with: Payment systems, client communication, document management, analytics platform

### ESTIMATED EFFORT
- Team A Frontend: 36 hours (Dashboard, signature interface, mobile optimization)
- Team B Backend: 32 hours (API endpoints, signature processing, compliance tracking)
- Team C Integration: 28 hours (Payment integration, PDF generation, email/SMS systems)
- Team D Platform: 20 hours (Database optimization, file storage, security)
- Team E General: 16 hours (Testing, documentation, legal review)
- Team F Workflows: 12 hours (Automated workflows, reminders, notifications)
- Team G Performance: 12 hours (Analytics, reporting, optimization)
- Total: 156 hours
