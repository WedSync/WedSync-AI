# TECHNICAL SPECIFICATION: WS-346 - SMS/WhatsApp Integration
## Generated by Feature Development Session - 2025-01-31

### USER STORY & BUSINESS CONTEXT
**As a:** Wedding supplier needing instant client communication
**I want to:** Send automated SMS and WhatsApp messages for time-sensitive updates, confirmations, and reminders
**So that:** I can ensure clients receive critical information immediately, improve response rates, and provide exceptional customer service through their preferred messaging channels

**Real Wedding Scenario:**
The morning of Sarah's wedding, the photographer automatically sends WhatsApp messages with weather updates, timeline confirmations, and "get ready" reminders. The venue coordinator sends SMS alerts about setup progress. When the florist is running 15 minutes late, they trigger an automated SMS to the wedding coordinator and bride. All messages are branded, professional, and include relevant details like contact numbers and backup plans.

**Business Impact:**
- Increases message open rates to 98% (vs 22% for email)
- Reduces no-shows by 40% through timely reminders
- Enables real-time crisis communication on wedding days
- Provides clients' preferred communication method (85% prefer SMS/WhatsApp)
- Critical for SCALE tier value proposition (Â£79/month)
- Supports international clients with WhatsApp's global reach

### SPECIFICATION SOURCE
- **Feature ID:** WS-346
- **Priority Level:** HIGH PRIORITY (Client Communication)
- **Estimated Effort:** 95 hours total
- **Dependencies:** Email Automation Engine, Client Management, Notification System
- **Integration Complexity:** High (Multiple providers, compliance requirements)

### TECHNICAL DESIGN

#### Database Schema Required

```sql
-- SMS/WhatsApp Providers Configuration
CREATE TABLE messaging_providers (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    provider_name TEXT NOT NULL CHECK (provider_name IN (
        'twilio', 'whatsapp_business', 'messagebird', 'clicksend', 'vonage', 'aws_sns'
    )),
    provider_type TEXT NOT NULL CHECK (provider_type IN (
        'sms', 'whatsapp', 'both'
    )),
    is_active BOOLEAN DEFAULT true,
    is_primary BOOLEAN DEFAULT false,
    
    -- Provider Configuration
    provider_config JSONB NOT NULL DEFAULT '{}', -- API keys, phone numbers, etc.
    sender_id TEXT, -- SMS sender ID or WhatsApp Business number
    webhook_url TEXT,
    
    -- Capabilities and Limits
    supports_media BOOLEAN DEFAULT false,
    supports_templates BOOLEAN DEFAULT false,
    daily_limit INTEGER DEFAULT 1000,
    rate_limit_per_minute INTEGER DEFAULT 10,
    cost_per_message DECIMAL(8,4) DEFAULT 0.05,
    
    -- Status and Health
    provider_status TEXT NOT NULL CHECK (provider_status IN (
        'active', 'suspended', 'failed', 'configuration_error'
    )) DEFAULT 'active',
    last_health_check TIMESTAMPTZ,
    health_check_status TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(supplier_id, provider_name),
    -- Ensure only one primary provider per type
    UNIQUE(supplier_id, provider_type, is_primary) WHERE is_primary = true
);

-- Message Templates (SMS/WhatsApp templates)
CREATE TABLE message_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    template_name TEXT NOT NULL,
    template_description TEXT,
    message_type TEXT NOT NULL CHECK (message_type IN (
        'sms', 'whatsapp_text', 'whatsapp_media', 'whatsapp_template'
    )),
    template_category TEXT NOT NULL CHECK (template_category IN (
        'welcome', 'confirmation', 'reminder', 'update', 'emergency', 
        'payment_due', 'thank_you', 'review_request', 'appointment', 'custom'
    )),
    
    -- Template Content
    message_content TEXT NOT NULL,
    media_url TEXT, -- For WhatsApp media messages
    media_type TEXT CHECK (media_type IN ('image', 'document', 'video', 'audio')),
    
    -- WhatsApp Template Specific
    whatsapp_template_id TEXT, -- WhatsApp Business API template ID
    template_language TEXT DEFAULT 'en',
    template_status TEXT CHECK (template_status IN (
        'pending', 'approved', 'rejected', 'disabled'
    )),
    
    -- Merge Fields and Personalization
    merge_fields JSONB DEFAULT '[]',
    character_count INTEGER,
    estimated_segments INTEGER DEFAULT 1, -- SMS segments for pricing
    
    -- Usage Statistics
    times_sent INTEGER DEFAULT 0,
    delivery_rate_percent DECIMAL(5,2) DEFAULT 0,
    response_rate_percent DECIMAL(5,2) DEFAULT 0,
    
    -- Scheduling and Automation
    can_be_scheduled BOOLEAN DEFAULT true,
    requires_opt_in BOOLEAN DEFAULT true,
    
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(supplier_id, template_name, message_type)
);

-- Message Send Queue
CREATE TABLE message_send_queue (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    client_id UUID NOT NULL REFERENCES clients(id) ON DELETE CASCADE,
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    messaging_provider_id UUID NOT NULL REFERENCES messaging_providers(id),
    message_template_id UUID REFERENCES message_templates(id),
    
    -- Message Details
    message_type TEXT NOT NULL CHECK (message_type IN (
        'sms', 'whatsapp_text', 'whatsapp_media', 'whatsapp_template'
    )),
    recipient_phone TEXT NOT NULL,
    recipient_name TEXT,
    sender_id TEXT NOT NULL,
    
    -- Content
    message_content TEXT NOT NULL,
    media_url TEXT,
    media_type TEXT,
    
    -- Scheduling
    scheduled_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    priority INTEGER DEFAULT 5 CHECK (priority >= 1 AND priority <= 10),
    
    -- Send Status
    send_status TEXT NOT NULL CHECK (send_status IN (
        'queued', 'sending', 'sent', 'delivered', 'failed', 'cancelled'
    )) DEFAULT 'queued',
    
    -- Delivery Tracking
    sent_at TIMESTAMPTZ,
    delivered_at TIMESTAMPTZ,
    read_at TIMESTAMPTZ, -- WhatsApp read receipts
    external_message_id TEXT, -- Provider's message ID
    
    -- Error Handling
    retry_count INTEGER DEFAULT 0,
    max_retries INTEGER DEFAULT 3,
    last_error_message TEXT,
    error_code TEXT,
    failed_at TIMESTAMPTZ,
    
    -- Cost Tracking
    message_cost DECIMAL(8,4),
    segments_used INTEGER DEFAULT 1,
    
    -- Personalization Data
    merge_data JSONB DEFAULT '{}',
    
    -- Compliance
    opt_in_confirmed BOOLEAN DEFAULT false,
    opt_in_timestamp TIMESTAMPTZ,
    can_retry BOOLEAN DEFAULT true,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    INDEX (send_status, priority, scheduled_at),
    INDEX (client_id, send_status),
    INDEX (supplier_id, scheduled_at),
    INDEX (external_message_id),
    INDEX (recipient_phone, supplier_id)
);

-- Message Conversations (for two-way messaging)
CREATE TABLE message_conversations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    client_id UUID NOT NULL REFERENCES clients(id) ON DELETE CASCADE,
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    messaging_provider_id UUID NOT NULL REFERENCES messaging_providers(id),
    
    -- Conversation Details
    phone_number TEXT NOT NULL,
    conversation_type TEXT NOT NULL CHECK (conversation_type IN (
        'sms', 'whatsapp'
    )),
    conversation_status TEXT NOT NULL CHECK (conversation_status IN (
        'active', 'archived', 'blocked', 'opt_out'
    )) DEFAULT 'active',
    
    -- Latest Message Info
    last_message_at TIMESTAMPTZ,
    last_message_from TEXT CHECK (last_message_from IN ('supplier', 'client')),
    last_message_preview TEXT,
    unread_count INTEGER DEFAULT 0,
    
    -- Conversation Context
    subject TEXT, -- What this conversation is about
    context_data JSONB DEFAULT '{}', -- Wedding date, service type, etc.
    
    -- Automation
    auto_reply_enabled BOOLEAN DEFAULT false,
    business_hours_only BOOLEAN DEFAULT true,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(client_id, supplier_id, phone_number, conversation_type),
    INDEX (supplier_id, conversation_status, last_message_at),
    INDEX (phone_number, conversation_type)
);

-- Individual Messages in Conversations
CREATE TABLE conversation_messages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    conversation_id UUID NOT NULL REFERENCES message_conversations(id) ON DELETE CASCADE,
    message_queue_id UUID REFERENCES message_send_queue(id), -- If this was a sent message
    
    -- Message Details
    message_direction TEXT NOT NULL CHECK (message_direction IN (
        'inbound', 'outbound'
    )),
    message_type TEXT NOT NULL CHECK (message_type IN (
        'text', 'media', 'location', 'contact', 'template'
    )),
    message_content TEXT,
    media_url TEXT,
    media_type TEXT,
    
    -- External Provider Info
    external_message_id TEXT,
    provider_timestamp TIMESTAMPTZ,
    
    -- Status (for outbound messages)
    delivery_status TEXT CHECK (delivery_status IN (
        'sent', 'delivered', 'read', 'failed'
    )),
    read_at TIMESTAMPTZ,
    
    -- Metadata
    sender_name TEXT,
    is_automated BOOLEAN DEFAULT false,
    template_id UUID REFERENCES message_templates(id),
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    INDEX (conversation_id, created_at),
    INDEX (external_message_id)
);

-- Client Communication Preferences
CREATE TABLE client_communication_preferences (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    client_id UUID NOT NULL REFERENCES clients(id) ON DELETE CASCADE,
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    
    -- SMS Preferences
    sms_enabled BOOLEAN DEFAULT true,
    sms_opt_in_date TIMESTAMPTZ,
    sms_opt_out_date TIMESTAMPTZ,
    sms_phone_number TEXT,
    sms_preferred_time_start TIME DEFAULT '09:00',
    sms_preferred_time_end TIME DEFAULT '21:00',
    
    -- WhatsApp Preferences
    whatsapp_enabled BOOLEAN DEFAULT false,
    whatsapp_opt_in_date TIMESTAMPTZ,
    whatsapp_opt_out_date TIMESTAMPTZ,
    whatsapp_phone_number TEXT,
    whatsapp_business_verified BOOLEAN DEFAULT false,
    
    -- General Preferences
    timezone TEXT DEFAULT 'Europe/London',
    preferred_language TEXT DEFAULT 'en',
    emergency_notifications_enabled BOOLEAN DEFAULT true,
    marketing_messages_enabled BOOLEAN DEFAULT false,
    
    -- Compliance
    gdpr_consent_given BOOLEAN DEFAULT false,
    gdpr_consent_date TIMESTAMPTZ,
    can_contact_after_event BOOLEAN DEFAULT false,
    
    -- Quiet Hours
    quiet_hours_enabled BOOLEAN DEFAULT true,
    quiet_hours_start TIME DEFAULT '22:00',
    quiet_hours_end TIME DEFAULT '08:00',
    weekend_messages_enabled BOOLEAN DEFAULT false,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(client_id, supplier_id)
);

-- Message Automation Workflows (extends email workflows)
CREATE TABLE message_workflow_steps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES email_workflows(id) ON DELETE CASCADE,
    step_number INTEGER NOT NULL,
    step_name TEXT NOT NULL,
    step_type TEXT NOT NULL CHECK (step_type IN (
        'send_sms', 'send_whatsapp', 'wait_for_reply', 'check_delivery'
    )),
    
    -- Step Configuration
    message_template_id UUID REFERENCES message_templates(id),
    provider_preference TEXT[], -- Preferred providers in order
    require_opt_in BOOLEAN DEFAULT true,
    
    -- Conditional Logic
    condition_type TEXT CHECK (condition_type IN (
        'always', 'if_delivered', 'if_not_delivered', 'if_replied', 'if_not_replied'
    )) DEFAULT 'always',
    
    -- Timing
    delay_type TEXT CHECK (delay_type IN ('immediate', 'minutes', 'hours', 'days')) DEFAULT 'immediate',
    delay_amount INTEGER DEFAULT 0,
    
    -- Fallback Behavior
    fallback_to_email BOOLEAN DEFAULT false,
    fallback_template_id UUID REFERENCES email_templates(id),
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(workflow_id, step_number)
);

-- Message Analytics and Reporting
CREATE TABLE message_analytics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    analytics_date DATE NOT NULL,
    message_type TEXT NOT NULL CHECK (message_type IN ('sms', 'whatsapp', 'all')),
    
    -- Message Metrics
    messages_sent INTEGER DEFAULT 0,
    messages_delivered INTEGER DEFAULT 0,
    messages_failed INTEGER DEFAULT 0,
    messages_replied INTEGER DEFAULT 0,
    
    -- Cost Metrics
    total_cost DECIMAL(10,2) DEFAULT 0,
    cost_per_message DECIMAL(8,4) DEFAULT 0,
    
    -- Performance Metrics
    delivery_rate_percent DECIMAL(5,2) DEFAULT 0,
    response_rate_percent DECIMAL(5,2) DEFAULT 0,
    avg_delivery_time_seconds INTEGER DEFAULT 0,
    
    -- Business Metrics
    bookings_attributed INTEGER DEFAULT 0,
    revenue_attributed DECIMAL(10,2) DEFAULT 0,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(supplier_id, analytics_date, message_type)
);

-- WhatsApp Business Integration
CREATE TABLE whatsapp_business_accounts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    
    -- WhatsApp Business Account Details
    business_account_id TEXT NOT NULL,
    phone_number TEXT NOT NULL,
    phone_number_id TEXT NOT NULL,
    display_name TEXT NOT NULL,
    
    -- Verification Status
    verified_name TEXT,
    verification_status TEXT CHECK (verification_status IN (
        'unverified', 'pending', 'verified', 'rejected'
    )) DEFAULT 'unverified',
    
    -- Account Status
    account_status TEXT CHECK (account_status IN (
        'active', 'suspended', 'restricted', 'pending_review'
    )) DEFAULT 'active',
    
    -- Messaging Limits
    messaging_limit_tier TEXT, -- Based on WhatsApp's tiered messaging limits
    messages_sent_24h INTEGER DEFAULT 0,
    limit_reset_time TIMESTAMPTZ,
    
    -- Webhook Configuration
    webhook_verified BOOLEAN DEFAULT false,
    webhook_verification_token TEXT,
    
    -- API Configuration
    access_token TEXT NOT NULL,
    app_id TEXT NOT NULL,
    app_secret TEXT NOT NULL,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(supplier_id),
    UNIQUE(business_account_id)
);

-- Message Compliance and Opt-ins
CREATE TABLE message_compliance_log (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    client_id UUID NOT NULL REFERENCES clients(id) ON DELETE CASCADE,
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    
    -- Compliance Action
    action_type TEXT NOT NULL CHECK (action_type IN (
        'opt_in', 'opt_out', 'consent_given', 'consent_withdrawn', 
        'gdpr_request', 'data_deletion', 'complaint_received'
    )),
    message_type TEXT CHECK (message_type IN ('sms', 'whatsapp', 'both')),
    
    -- Action Details
    action_method TEXT CHECK (action_method IN (
        'web_form', 'reply_message', 'phone_call', 'email', 'manual'
    )),
    action_timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Context
    phone_number TEXT,
    source_message_id UUID REFERENCES message_send_queue(id),
    notes TEXT,
    
    -- Legal Documentation
    ip_address INET,
    user_agent TEXT,
    consent_document_url TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    INDEX (client_id, action_type, action_timestamp),
    INDEX (supplier_id, action_timestamp)
);

-- Add messaging integration to clients table
ALTER TABLE clients ADD COLUMN IF NOT EXISTS primary_phone TEXT;
ALTER TABLE clients ADD COLUMN IF NOT EXISTS whatsapp_phone TEXT;
ALTER TABLE clients ADD COLUMN IF NOT EXISTS sms_opt_in BOOLEAN DEFAULT false;
ALTER TABLE clients ADD COLUMN IF NOT EXISTS whatsapp_opt_in BOOLEAN DEFAULT false;
ALTER TABLE clients ADD COLUMN IF NOT EXISTS last_message_sent_at TIMESTAMPTZ;
ALTER TABLE clients ADD COLUMN IF NOT EXISTS total_messages_sent INTEGER DEFAULT 0;

-- Performance indexes
CREATE INDEX IF NOT EXISTS idx_message_queue_status_scheduled ON message_send_queue(send_status, scheduled_at);
CREATE INDEX IF NOT EXISTS idx_conversations_supplier_active ON message_conversations(supplier_id, conversation_status, last_message_at);
CREATE INDEX IF NOT EXISTS idx_conversation_messages_created ON conversation_messages(conversation_id, created_at);
CREATE INDEX IF NOT EXISTS idx_compliance_log_client_action ON message_compliance_log(client_id, action_type, action_timestamp);
```

#### API Endpoints Required

```typescript
// Message Types
interface MessagingProvider {
  id: string;
  supplier_id: string;
  provider_name: 'twilio' | 'whatsapp_business' | 'messagebird' | 'clicksend' | 'vonage' | 'aws_sns';
  provider_type: 'sms' | 'whatsapp' | 'both';
  is_active: boolean;
  is_primary: boolean;
  provider_config: Record<string, any>;
  sender_id?: string;
  webhook_url?: string;
  supports_media: boolean;
  supports_templates: boolean;
  daily_limit: number;
  rate_limit_per_minute: number;
  cost_per_message: number;
  provider_status: 'active' | 'suspended' | 'failed' | 'configuration_error';
  last_health_check?: string;
  health_check_status?: string;
  created_at: string;
  updated_at: string;
}

interface MessageTemplate {
  id: string;
  supplier_id: string;
  template_name: string;
  template_description?: string;
  message_type: 'sms' | 'whatsapp_text' | 'whatsapp_media' | 'whatsapp_template';
  template_category: 'welcome' | 'confirmation' | 'reminder' | 'update' | 'emergency' | 
                     'payment_due' | 'thank_you' | 'review_request' | 'appointment' | 'custom';
  message_content: string;
  media_url?: string;
  media_type?: 'image' | 'document' | 'video' | 'audio';
  whatsapp_template_id?: string;
  template_language: string;
  template_status?: 'pending' | 'approved' | 'rejected' | 'disabled';
  merge_fields: MergeField[];
  character_count?: number;
  estimated_segments: number;
  times_sent: number;
  delivery_rate_percent: number;
  response_rate_percent: number;
  can_be_scheduled: boolean;
  requires_opt_in: boolean;
  is_active: boolean;
  created_at: string;
  updated_at: string;
}

interface MessageSendQueue {
  id: string;
  client_id: string;
  supplier_id: string;
  messaging_provider_id: string;
  message_template_id?: string;
  message_type: 'sms' | 'whatsapp_text' | 'whatsapp_media' | 'whatsapp_template';
  recipient_phone: string;
  recipient_name?: string;
  sender_id: string;
  message_content: string;
  media_url?: string;
  media_type?: string;
  scheduled_at: string;
  priority: number;
  send_status: 'queued' | 'sending' | 'sent' | 'delivered' | 'failed' | 'cancelled';
  sent_at?: string;
  delivered_at?: string;
  read_at?: string;
  external_message_id?: string;
  retry_count: number;
  max_retries: number;
  last_error_message?: string;
  error_code?: string;
  failed_at?: string;
  message_cost?: number;
  segments_used: number;
  merge_data: Record<string, any>;
  opt_in_confirmed: boolean;
  opt_in_timestamp?: string;
  can_retry: boolean;
  created_at: string;
  updated_at: string;
}

interface MessageConversation {
  id: string;
  client_id: string;
  supplier_id: string;
  messaging_provider_id: string;
  phone_number: string;
  conversation_type: 'sms' | 'whatsapp';
  conversation_status: 'active' | 'archived' | 'blocked' | 'opt_out';
  last_message_at?: string;
  last_message_from?: 'supplier' | 'client';
  last_message_preview?: string;
  unread_count: number;
  subject?: string;
  context_data: Record<string, any>;
  auto_reply_enabled: boolean;
  business_hours_only: boolean;
  created_at: string;
  updated_at: string;
}

interface ConversationMessage {
  id: string;
  conversation_id: string;
  message_queue_id?: string;
  message_direction: 'inbound' | 'outbound';
  message_type: 'text' | 'media' | 'location' | 'contact' | 'template';
  message_content?: string;
  media_url?: string;
  media_type?: string;
  external_message_id?: string;
  provider_timestamp?: string;
  delivery_status?: 'sent' | 'delivered' | 'read' | 'failed';
  read_at?: string;
  sender_name?: string;
  is_automated: boolean;
  template_id?: string;
  created_at: string;
}

interface ClientCommunicationPreferences {
  id: string;
  client_id: string;
  supplier_id: string;
  sms_enabled: boolean;
  sms_opt_in_date?: string;
  sms_opt_out_date?: string;
  sms_phone_number?: string;
  sms_preferred_time_start: string;
  sms_preferred_time_end: string;
  whatsapp_enabled: boolean;
  whatsapp_opt_in_date?: string;
  whatsapp_opt_out_date?: string;
  whatsapp_phone_number?: string;
  whatsapp_business_verified: boolean;
  timezone: string;
  preferred_language: string;
  emergency_notifications_enabled: boolean;
  marketing_messages_enabled: boolean;
  gdpr_consent_given: boolean;
  gdpr_consent_date?: string;
  can_contact_after_event: boolean;
  quiet_hours_enabled: boolean;
  quiet_hours_start: string;
  quiet_hours_end: string;
  weekend_messages_enabled: boolean;
  created_at: string;
  updated_at: string;
}

// API Endpoints

// Provider Management
// GET /api/messaging/providers - List messaging providers
interface GetMessagingProvidersResponse {
  providers: MessagingProvider[];
  available_providers: {
    name: string;
    display_name: string;
    type: 'sms' | 'whatsapp' | 'both';
    features: string[];
    pricing: {
      setup_fee: number;
      cost_per_message: number;
      monthly_fee: number;
    };
  }[];
}

// POST /api/messaging/providers - Add messaging provider
interface AddMessagingProviderRequest {
  provider_name: string;
  provider_type: 'sms' | 'whatsapp' | 'both';
  provider_config: {
    account_sid?: string; // Twilio
    auth_token?: string; // Twilio
    phone_number?: string; // SMS sender number
    whatsapp_number?: string; // WhatsApp Business number
    api_key?: string; // Generic API key
    webhook_secret?: string;
  };
  sender_id?: string;
  is_primary?: boolean;
}

interface AddMessagingProviderResponse {
  provider: MessagingProvider;
  setup_instructions?: string[];
  webhook_url: string;
  test_connection_result: {
    success: boolean;
    error_message?: string;
  };
}

// POST /api/messaging/providers/:id/test - Test provider connection
interface TestProviderConnectionResponse {
  success: boolean;
  provider_info: {
    account_name?: string;
    balance?: number;
    phone_numbers: string[];
    rate_limits: {
      messages_per_second: number;
      daily_limit: number;
    };
  };
  error_message?: string;
}

// Message Templates
// GET /api/messaging/templates - List message templates
interface GetMessageTemplatesResponse {
  templates: MessageTemplate[];
  system_templates: MessageTemplate[]; // WedSync provided templates
  whatsapp_templates: {
    approved: MessageTemplate[];
    pending: MessageTemplate[];
    rejected: MessageTemplate[];
  };
  total: number;
  page: number;
  per_page: number;
}

// POST /api/messaging/templates - Create message template
interface CreateMessageTemplateRequest {
  template_name: string;
  template_description?: string;
  message_type: 'sms' | 'whatsapp_text' | 'whatsapp_media' | 'whatsapp_template';
  template_category: string;
  message_content: string;
  media_url?: string;
  media_type?: string;
  template_language?: string;
  merge_fields?: MergeField[];
  requires_opt_in?: boolean;
}

interface CreateMessageTemplateResponse {
  template: MessageTemplate;
  character_analysis: {
    character_count: number;
    sms_segments: number;
    estimated_cost: number;
  };
  whatsapp_submission?: {
    template_id: string;
    status: string;
    review_time_estimate: string;
  };
  validation_errors?: TemplateValidationError[];
}

interface TemplateValidationError {
  field: string;
  error: string;
  suggestion?: string;
}

// POST /api/messaging/templates/:id/submit-whatsapp - Submit WhatsApp template for approval
interface SubmitWhatsAppTemplateRequest {
  template_category: string;
  business_justification: string;
}

interface SubmitWhatsAppTemplateResponse {
  submission_id: string;
  estimated_review_time: string;
  status: 'submitted' | 'pending' | 'under_review';
  requirements_met: boolean;
  missing_requirements?: string[];
}

// Message Sending
// POST /api/messaging/send - Send individual message
interface SendMessageRequest {
  client_id: string;
  message_type: 'sms' | 'whatsapp_text' | 'whatsapp_media' | 'whatsapp_template';
  template_id?: string;
  message_content?: string; // For custom messages
  media_url?: string;
  media_type?: string;
  recipient_phone?: string; // Override client's default
  scheduled_at?: string;
  priority?: number;
  merge_data?: Record<string, any>;
  require_opt_in?: boolean;
}

interface SendMessageResponse {
  message_queue_id: string;
  estimated_delivery: string;
  cost_estimate: number;
  segments_required: number;
  opt_in_status: {
    required: boolean;
    confirmed: boolean;
    opt_in_url?: string;
  };
  provider_used: string;
}

// POST /api/messaging/send-bulk - Send bulk messages
interface SendBulkMessageRequest {
  template_id: string;
  recipients: BulkMessageRecipient[];
  scheduled_at?: string;
  priority?: number;
  batch_size?: number;
  respect_quiet_hours?: boolean;
}

interface BulkMessageRecipient {
  client_id: string;
  phone_number?: string;
  merge_data?: Record<string, any>;
  opt_in_confirmed?: boolean;
}

interface SendBulkMessageResponse {
  batch_id: string;
  total_messages: number;
  messages_queued: number;
  messages_failed: number;
  estimated_cost: number;
  estimated_completion: string;
  opt_in_required_count: number;
}

// Conversations
// GET /api/messaging/conversations - List conversations
interface GetConversationsResponse {
  conversations: (MessageConversation & {
    client: {
      first_name: string;
      last_name: string;
      wedding_date?: string;
    };
    latest_messages: ConversationMessage[];
  })[];
  total: number;
  unread_total: number;
  page: number;
  per_page: number;
}

// GET /api/messaging/conversations/:id/messages - Get conversation messages
interface GetConversationMessagesResponse {
  messages: ConversationMessage[];
  conversation: MessageConversation;
  client: {
    first_name: string;
    last_name: string;
    wedding_date?: string;
    preferences: ClientCommunicationPreferences;
  };
  total: number;
  page: number;
  per_page: number;
}

// POST /api/messaging/conversations/:id/reply - Reply to conversation
interface ReplyToConversationRequest {
  message_content: string;
  message_type?: 'text' | 'media';
  media_url?: string;
  media_type?: string;
  template_id?: string;
}

interface ReplyToConversationResponse {
  message: ConversationMessage;
  conversation_updated: MessageConversation;
  delivery_estimate: string;
}

// POST /api/messaging/conversations/:id/mark-read - Mark conversation as read
interface MarkConversationReadResponse {
  success: boolean;
  unread_count: number;
}

// Client Preferences
// GET /api/messaging/clients/:id/preferences - Get client communication preferences
interface GetClientPreferencesResponse {
  preferences: ClientCommunicationPreferences;
  opt_in_history: {
    action_type: string;
    action_timestamp: string;
    action_method: string;
  }[];
  compliance_status: {
    sms_compliant: boolean;
    whatsapp_compliant: boolean;
    gdpr_compliant: boolean;
    can_send_marketing: boolean;
  };
}

// PUT /api/messaging/clients/:id/preferences - Update client preferences
interface UpdateClientPreferencesRequest {
  sms_enabled?: boolean;
  sms_phone_number?: string;
  whatsapp_enabled?: boolean;
  whatsapp_phone_number?: string;
  timezone?: string;
  preferred_language?: string;
  emergency_notifications_enabled?: boolean;
  marketing_messages_enabled?: boolean;
  quiet_hours_enabled?: boolean;
  quiet_hours_start?: string;
  quiet_hours_end?: string;
  weekend_messages_enabled?: boolean;
}

// POST /api/messaging/opt-in - Process opt-in request
interface ProcessOptInRequest {
  client_id: string;
  phone_number: string;
  message_type: 'sms' | 'whatsapp' | 'both';
  opt_in_method: 'web_form' | 'reply_message' | 'phone_call' | 'email' | 'manual';
  consent_given: boolean;
  gdpr_consent?: boolean;
  marketing_consent?: boolean;
  ip_address?: string;
  user_agent?: string;
}

interface ProcessOptInResponse {
  success: boolean;
  opt_in_id: string;
  confirmation_message_sent: boolean;
  can_send_messages: boolean;
  compliance_status: {
    sms_compliant: boolean;
    whatsapp_compliant: boolean;
    gdpr_compliant: boolean;
  };
}

// Analytics and Reporting
// GET /api/messaging/analytics - Get messaging analytics
interface GetMessagingAnalyticsRequest {
  start_date: string;
  end_date: string;
  message_type?: 'sms' | 'whatsapp' | 'all';
  group_by?: 'day' | 'week' | 'month';
}

interface GetMessagingAnalyticsResponse {
  analytics: MessageAnalytics[];
  summary: {
    total_sent: number;
    total_delivered: number;
    total_failed: number;
    total_replied: number;
    delivery_rate: number;
    response_rate: number;
    total_cost: number;
    avg_cost_per_message: number;
  };
  trends: {
    date: string;
    sent: number;
    delivered: number;
    failed: number;
    replied: number;
    cost: number;
  }[];
  top_performing_templates: MessageTemplate[];
  provider_performance: {
    provider: string;
    delivery_rate: number;
    avg_delivery_time: number;
    cost_efficiency: number;
  }[];
}

// WhatsApp Business Integration
// GET /api/messaging/whatsapp/business-account - Get WhatsApp Business account info
interface GetWhatsAppBusinessAccountResponse {
  account: WhatsAppBusinessAccount;
  phone_numbers: {
    id: string;
    phone_number: string;
    verified_name: string;
    status: string;
    messaging_limit_tier: string;
  }[];
  webhook_status: {
    configured: boolean;
    verified: boolean;
    url: string;
  };
  template_status: {
    approved: number;
    pending: number;
    rejected: number;
  };
}

interface WhatsAppBusinessAccount {
  id: string;
  supplier_id: string;
  business_account_id: string;
  phone_number: string;
  phone_number_id: string;
  display_name: string;
  verified_name?: string;
  verification_status: 'unverified' | 'pending' | 'verified' | 'rejected';
  account_status: 'active' | 'suspended' | 'restricted' | 'pending_review';
  messaging_limit_tier?: string;
  messages_sent_24h: number;
  limit_reset_time?: string;
  webhook_verified: boolean;
  created_at: string;
  updated_at: string;
}

// POST /api/messaging/whatsapp/setup - Set up WhatsApp Business integration
interface SetupWhatsAppBusinessRequest {
  access_token: string;
  app_id: string;
  app_secret: string;
  business_account_id: string;
  phone_number_id: string;
  webhook_verification_token: string;
}

interface SetupWhatsAppBusinessResponse {
  account: WhatsAppBusinessAccount;
  setup_status: {
    account_verified: boolean;
    webhook_configured: boolean;
    phone_verified: boolean;
    templates_synced: boolean;
  };
  next_steps: string[];
}

// Webhooks (for processing provider callbacks)
// POST /api/messaging/webhooks/twilio - Twilio webhook
// POST /api/messaging/webhooks/whatsapp - WhatsApp webhook
// POST /api/messaging/webhooks/messagebird - MessageBird webhook

interface MessageWebhookPayload {
  provider: string;
  event_type: string;
  message_id: string;
  status: string;
  timestamp: string;
  error_code?: string;
  error_message?: string;
  cost?: number;
  // Provider-specific data
  raw_payload: Record<string, any>;
}
```

### IMPLEMENTATION DETAILS

#### Frontend Message Management Components

```typescript
// Message Center Dashboard Component
import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Badge } from '@/components/ui/badge';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { 
  MessageSquare, 
  Send, 
  Phone, 
  CheckCheck, 
  Clock, 
  AlertCircle,
  Settings,
  Plus,
  Search,
  Filter,
  Zap
} from 'lucide-react';

interface MessageCenterProps {
  supplierId: string;
}

const MessageCenter: React.FC<MessageCenterProps> = ({ supplierId }) => {
  const [conversations, setConversations] = useState<MessageConversation[]>([]);
  const [selectedConversation, setSelectedConversation] = useState<string | null>(null);
  const [messages, setMessages] = useState<ConversationMessage[]>([]);
  const [newMessage, setNewMessage] = useState('');
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    loadConversations();
  }, [supplierId]);

  const loadConversations = async () => {
    try {
      const response = await fetch('/api/messaging/conversations');
      const data: GetConversationsResponse = await response.json();
      setConversations(data.conversations);
    } catch (error) {
      console.error('Failed to load conversations:', error);
    } finally {
      setLoading(false);
    }
  };

  const loadMessages = async (conversationId: string) => {
    try {
      const response = await fetch(`/api/messaging/conversations/${conversationId}/messages`);
      const data: GetConversationMessagesResponse = await response.json();
      setMessages(data.messages);
      setSelectedConversation(conversationId);
      
      // Mark as read
      await fetch(`/api/messaging/conversations/${conversationId}/mark-read`, {
        method: 'POST'
      });
    } catch (error) {
      console.error('Failed to load messages:', error);
    }
  };

  const sendMessage = async () => {
    if (!selectedConversation || !newMessage.trim()) return;

    try {
      const response = await fetch(`/api/messaging/conversations/${selectedConversation}/reply`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          message_content: newMessage,
          message_type: 'text'
        })
      });

      if (response.ok) {
        setNewMessage('');
        await loadMessages(selectedConversation);
      }
    } catch (error) {
      console.error('Failed to send message:', error);
    }
  };

  const getMessageStatusIcon = (status?: string) => {
    switch (status) {
      case 'delivered':
        return <CheckCheck className="w-3 h-3 text-green-600" />;
      case 'sent':
        return <CheckCheck className="w-3 h-3 text-gray-400" />;
      case 'failed':
        return <AlertCircle className="w-3 h-3 text-red-600" />;
      default:
        return <Clock className="w-3 h-3 text-gray-400" />;
    }
  };

  const formatTimestamp = (timestamp: string) => {
    const date = new Date(timestamp);
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffHours = diffMs / (1000 * 60 * 60);
    
    if (diffHours < 24) {
      return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    } else {
      return date.toLocaleDateString();
    }
  };

  return (
    <div className="flex h-screen bg-gray-50">
      {/* Conversations List */}
      <div className="w-80 bg-white border-r border-gray-200 flex flex-col">
        {/* Header */}
        <div className="p-4 border-b border-gray-200">
          <div className="flex items-center justify-between mb-4">
            <h1 className="text-xl font-semibold">Messages</h1>
            <div className="flex space-x-2">
              <Button variant="ghost" size="sm">
                <Filter className="w-4 h-4" />
              </Button>
              <Button size="sm">
                <Plus className="w-4 h-4 mr-2" />
                New
              </Button>
            </div>
          </div>
          
          <div className="relative">
            <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-4 h-4" />
            <Input
              placeholder="Search conversations..."
              className="pl-10"
            />
          </div>
        </div>

        {/* Conversations */}
        <div className="flex-1 overflow-y-auto">
          {conversations.map((conversation) => (
            <div
              key={conversation.id}
              onClick={() => loadMessages(conversation.id)}
              className={`p-4 border-b border-gray-100 cursor-pointer hover:bg-gray-50 ${
                selectedConversation === conversation.id ? 'bg-blue-50 border-l-4 border-l-blue-500' : ''
              }`}
            >
              <div className="flex items-center space-x-3">
                <div className="relative">
                  <Avatar className="w-10 h-10">
                    <AvatarFallback>
                      {conversation.client?.first_name?.[0]}{conversation.client?.last_name?.[0]}
                    </AvatarFallback>
                  </Avatar>
                  {conversation.conversation_type === 'whatsapp' && (
                    <div className="absolute -bottom-1 -right-1 w-4 h-4 bg-green-500 rounded-full flex items-center justify-center">
                      <MessageSquare className="w-2 h-2 text-white" />
                    </div>
                  )}
                </div>
                
                <div className="flex-1 min-w-0">
                  <div className="flex items-center justify-between">
                    <p className="font-medium text-gray-900 truncate">
                      {conversation.client?.first_name} {conversation.client?.last_name}
                    </p>
                    <span className="text-xs text-gray-500">
                      {formatTimestamp(conversation.last_message_at || conversation.created_at)}
                    </span>
                  </div>
                  
                  <p className="text-sm text-gray-600 truncate">
                    {conversation.last_message_preview || 'No messages yet'}
                  </p>
                  
                  <div className="flex items-center justify-between mt-1">
                    <div className="flex items-center space-x-2">
                      {conversation.conversation_type === 'sms' ? (
                        <Phone className="w-3 h-3 text-gray-400" />
                      ) : (
                        <MessageSquare className="w-3 h-3 text-green-500" />
                      )}
                      <span className="text-xs text-gray-500">
                        {conversation.phone_number}
                      </span>
                    </div>
                    
                    {conversation.unread_count > 0 && (
                      <Badge variant="default" className="text-xs">
                        {conversation.unread_count}
                      </Badge>
                    )}
                  </div>
                </div>
              </div>
            </div>
          ))}
        </div>
      </div>

      {/* Message Thread */}
      <div className="flex-1 flex flex-col">
        {selectedConversation ? (
          <>
            {/* Chat Header */}
            <div className="p-4 bg-white border-b border-gray-200">
              <div className="flex items-center justify-between">
                <div className="flex items-center space-x-3">
                  <Avatar>
                    <AvatarFallback>
                      {conversations.find(c => c.id === selectedConversation)?.client?.first_name?.[0]}
                      {conversations.find(c => c.id === selectedConversation)?.client?.last_name?.[0]}
                    </AvatarFallback>
                  </Avatar>
                  <div>
                    <h2 className="font-semibold">
                      {conversations.find(c => c.id === selectedConversation)?.client?.first_name}{' '}
                      {conversations.find(c => c.id === selectedConversation)?.client?.last_name}
                    </h2>
                    <p className="text-sm text-gray-600">
                      {conversations.find(c => c.id === selectedConversation)?.phone_number}
                    </p>
                  </div>
                </div>
                
                <div className="flex items-center space-x-2">
                  <Badge variant="secondary">
                    {conversations.find(c => c.id === selectedConversation)?.conversation_type}
                  </Badge>
                  <Button variant="ghost" size="sm">
                    <Settings className="w-4 h-4" />
                  </Button>
                </div>
              </div>
            </div>

            {/* Messages */}
            <div className="flex-1 overflow-y-auto p-4 space-y-4 bg-gray-50">
              {messages.map((message) => (
                <div
                  key={message.id}
                  className={`flex ${
                    message.message_direction === 'outbound' ? 'justify-end' : 'justify-start'
                  }`}
                >
                  <div
                    className={`max-w-xs lg:max-w-md px-4 py-2 rounded-lg ${
                      message.message_direction === 'outbound'
                        ? 'bg-blue-600 text-white'
                        : 'bg-white text-gray-900 border border-gray-200'
                    }`}
                  >
                    <p className="text-sm">{message.message_content}</p>
                    
                    {message.media_url && (
                      <div className="mt-2">
                        {message.media_type === 'image' ? (
                          <img 
                            src={message.media_url} 
                            alt="Message media" 
                            className="max-w-full h-auto rounded"
                          />
                        ) : (
                          <a 
                            href={message.media_url} 
                            target="_blank" 
                            rel="noopener noreferrer"
                            className="text-blue-200 underline text-xs"
                          >
                            View {message.media_type}
                          </a>
                        )}
                      </div>
                    )}
                    
                    <div className={`flex items-center justify-between mt-1 text-xs ${
                      message.message_direction === 'outbound' ? 'text-blue-200' : 'text-gray-500'
                    }`}>
                      <span>{formatTimestamp(message.created_at)}</span>
                      {message.message_direction === 'outbound' && (
                        <div className="flex items-center space-x-1">
                          {getMessageStatusIcon(message.delivery_status)}
                        </div>
                      )}
                    </div>
                  </div>
                </div>
              ))}
            </div>

            {/* Message Input */}
            <div className="p-4 bg-white border-t border-gray-200">
              <div className="flex items-center space-x-2">
                <Input
                  placeholder="Type your message..."
                  value={newMessage}
                  onChange={(e) => setNewMessage(e.target.value)}
                  onKeyPress={(e) => e.key === 'Enter' && sendMessage()}
                  className="flex-1"
                />
                <Button onClick={sendMessage} disabled={!newMessage.trim()}>
                  <Send className="w-4 h-4" />
                </Button>
              </div>
              
              <div className="flex items-center justify-between mt-2 text-xs text-gray-500">
                <span>
                  Press Enter to send â¢ Shift+Enter for new line
                </span>
                <span>
                  {newMessage.length}/160 chars ({Math.ceil(newMessage.length / 160)} SMS)
                </span>
              </div>
            </div>
          </>
        ) : (
          <div className="flex-1 flex items-center justify-center bg-gray-50">
            <div className="text-center">
              <MessageSquare className="w-16 h-16 text-gray-400 mx-auto mb-4" />
              <h3 className="text-lg font-medium text-gray-900 mb-2">
                No conversation selected
              </h3>
              <p className="text-gray-600">
                Choose a conversation from the list to start messaging
              </p>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default MessageCenter;
```

#### Backend SMS/WhatsApp Service

```typescript
// SMS/WhatsApp Service Implementation
import { createClient } from '@supabase/supabase-js';
import { Twilio } from 'twilio';
import axios from 'axios';

export class MessageService {
  private supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );

  // Send message via appropriate provider
  async sendMessage(
    clientId: string,
    supplierId: string,
    messageType: 'sms' | 'whatsapp_text' | 'whatsapp_media',
    content: string,
    options: {
      templateId?: string;
      mediaUrl?: string;
      mediaType?: string;
      scheduledAt?: string;
      priority?: number;
      requireOptIn?: boolean;
    } = {}
  ): Promise<string> {

    // Get client communication preferences
    const { data: preferences } = await this.supabase
      .from('client_communication_preferences')
      .select('*')
      .eq('client_id', clientId)
      .eq('supplier_id', supplierId)
      .single();

    // Check opt-in status
    if (options.requireOptIn !== false) {
      const optInValid = messageType.startsWith('whatsapp') 
        ? preferences?.whatsapp_enabled && preferences.whatsapp_opt_in_date
        : preferences?.sms_enabled && preferences.sms_opt_in_date;

      if (!optInValid) {
        throw new Error('Client has not opted in for this message type');
      }
    }

    // Get appropriate provider
    const { data: provider } = await this.supabase
      .from('messaging_providers')
      .select('*')
      .eq('supplier_id', supplierId)
      .eq('provider_type', messageType.startsWith('whatsapp') ? 'whatsapp' : 'sms')
      .eq('is_active', true)
      .eq('is_primary', true)
      .single();

    if (!provider) {
      throw new Error('No active messaging provider configured');
    }

    // Get client phone number
    const { data: client } = await this.supabase
      .from('clients')
      .select('primary_phone, whatsapp_phone')
      .eq('id', clientId)
      .single();

    const phoneNumber = messageType.startsWith('whatsapp') 
      ? client.whatsapp_phone || client.primary_phone 
      : client.primary_phone;

    if (!phoneNumber) {
      throw new Error('No phone number available for client');
    }

    // Calculate message cost and segments
    const segments = Math.ceil(content.length / 160);
    const estimatedCost = segments * provider.cost_per_message;

    // Queue message for sending
    const { data: queuedMessage, error } = await this.supabase
      .from('message_send_queue')
      .insert({
        client_id: clientId,
        supplier_id: supplierId,
        messaging_provider_id: provider.id,
        message_template_id: options.templateId,
        message_type: messageType,
        recipient_phone: phoneNumber,
        sender_id: provider.sender_id,
        message_content: content,
        media_url: options.mediaUrl,
        media_type: options.mediaType,
        scheduled_at: options.scheduledAt || new Date().toISOString(),
        priority: options.priority || 5,
        message_cost: estimatedCost,
        segments_used: segments,
        opt_in_confirmed: true
      })
      .select()
      .single();

    if (error) throw error;

    // Process message immediately if scheduled for now
    if (!options.scheduledAt || new Date(options.scheduledAt).getTime() <= Date.now()) {
      setTimeout(() => this.processMessage(queuedMessage.id), 1000);
    }

    return queuedMessage.id;
  }

  // Process queued message
  async processMessage(messageId: string): Promise<void> {
    const { data: message, error } = await this.supabase
      .from('message_send_queue')
      .select(`
        *,
        messaging_providers(*)
      `)
      .eq('id', messageId)
      .eq('send_status', 'queued')
      .single();

    if (error || !message) {
      console.error('Message not found:', messageId);
      return;
    }

    try {
      // Update status to sending
      await this.supabase
        .from('message_send_queue')
        .update({ send_status: 'sending' })
        .eq('id', messageId);

      let result;
      
      // Send via appropriate provider
      switch (message.messaging_providers.provider_name) {
        case 'twilio':
          result = await this.sendViaTwilio(message);
          break;
        case 'whatsapp_business':
          result = await this.sendViaWhatsAppBusiness(message);
          break;
        default:
          throw new Error(`Unsupported provider: ${message.messaging_providers.provider_name}`);
      }

      // Update message status
      await this.supabase
        .from('message_send_queue')
        .update({
          send_status: 'sent',
          sent_at: new Date().toISOString(),
          external_message_id: result.messageId
        })
        .eq('id', messageId);

      // Update conversation
      await this.updateConversation(message, 'outbound', message.message_content);

    } catch (error) {
      console.error('Failed to send message:', error);
      
      await this.supabase
        .from('message_send_queue')
        .update({
          send_status: 'failed',
          failed_at: new Date().toISOString(),
          last_error_message: error.message,
          retry_count: message.retry_count + 1
        })
        .eq('id', messageId);

      // Retry if under retry limit
      if (message.retry_count < message.max_retries) {
        setTimeout(() => this.processMessage(messageId), 30000); // Retry in 30 seconds
      }
    }
  }

  // Send via Twilio
  private async sendViaTwilio(message: any): Promise<{ messageId: string }> {
    const client = new Twilio(
      message.messaging_providers.provider_config.account_sid,
      message.messaging_providers.provider_config.auth_token
    );

    const messageOptions: any = {
      body: message.message_content,
      from: message.sender_id,
      to: message.recipient_phone
    };

    // Add media if present
    if (message.media_url) {
      messageOptions.mediaUrl = [message.media_url];
    }

    const twilioMessage = await client.messages.create(messageOptions);
    
    return { messageId: twilioMessage.sid };
  }

  // Send via WhatsApp Business API
  private async sendViaWhatsAppBusiness(message: any): Promise<{ messageId: string }> {
    const config = message.messaging_providers.provider_config;
    
    const payload: any = {
      messaging_product: 'whatsapp',
      to: message.recipient_phone,
      type: message.message_type === 'whatsapp_media' ? 'image' : 'text'
    };

    if (message.message_type === 'whatsapp_media') {
      payload.image = {
        link: message.media_url,
        caption: message.message_content
      };
    } else {
      payload.text = {
        body: message.message_content
      };
    }

    const response = await axios.post(
      `https://graph.facebook.com/v18.0/${config.phone_number_id}/messages`,
      payload,
      {
        headers: {
          'Authorization': `Bearer ${config.access_token}`,
          'Content-Type': 'application/json'
        }
      }
    );

    return { messageId: response.data.messages[0].id };
  }

  // Update or create conversation
  private async updateConversation(
    message: any,
    direction: 'inbound' | 'outbound',
    content: string
  ): Promise<void> {
    const conversationType = message.message_type.startsWith('whatsapp') ? 'whatsapp' : 'sms';
    
    // Find or create conversation
    const { data: conversation, error: conversationError } = await this.supabase
      .from('message_conversations')
      .select('*')
      .eq('client_id', message.client_id)
      .eq('supplier_id', message.supplier_id)
      .eq('phone_number', message.recipient_phone)
      .eq('conversation_type', conversationType)
      .single();

    let conversationId;

    if (conversationError) {
      // Create new conversation
      const { data: newConversation, error: createError } = await this.supabase
        .from('message_conversations')
        .insert({
          client_id: message.client_id,
          supplier_id: message.supplier_id,
          messaging_provider_id: message.messaging_provider_id,
          phone_number: message.recipient_phone,
          conversation_type: conversationType,
          last_message_at: new Date().toISOString(),
          last_message_from: direction === 'outbound' ? 'supplier' : 'client',
          last_message_preview: content.substring(0, 100)
        })
        .select()
        .single();

      if (createError) throw createError;
      conversationId = newConversation.id;
    } else {
      // Update existing conversation
      conversationId = conversation.id;
      
      await this.supabase
        .from('message_conversations')
        .update({
          last_message_at: new Date().toISOString(),
          last_message_from: direction === 'outbound' ? 'supplier' : 'client',
          last_message_preview: content.substring(0, 100),
          unread_count: direction === 'inbound' ? (conversation.unread_count || 0) + 1 : 0
        })
        .eq('id', conversationId);
    }

    // Add message to conversation
    await this.supabase
      .from('conversation_messages')
      .insert({
        conversation_id: conversationId,
        message_queue_id: direction === 'outbound' ? message.id : null,
        message_direction: direction,
        message_type: 'text',
        message_content: content,
        external_message_id: message.external_message_id,
        is_automated: !!message.message_template_id
      });
  }

  // Process webhooks from messaging providers
  async processWebhook(provider: string, webhookData: any): Promise<void> {
    switch (provider) {
      case 'twilio':
        await this.processTwilioWebhook(webhookData);
        break;
      case 'whatsapp':
        await this.processWhatsAppWebhook(webhookData);
        break;
      default:
        console.log('Unknown webhook provider:', provider);
    }
  }

  // Process Twilio status webhooks
  private async processTwilioWebhook(data: any): Promise<void> {
    const { MessageSid, MessageStatus, ErrorMessage, ErrorCode } = data;

    // Update message status
    const updateData: any = {
      send_status: this.mapTwilioStatus(MessageStatus)
    };

    if (MessageStatus === 'delivered') {
      updateData.delivered_at = new Date().toISOString();
    } else if (MessageStatus === 'failed') {
      updateData.failed_at = new Date().toISOString();
      updateData.last_error_message = ErrorMessage;
      updateData.error_code = ErrorCode;
    }

    await this.supabase
      .from('message_send_queue')
      .update(updateData)
      .eq('external_message_id', MessageSid);
  }

  // Process WhatsApp Business API webhooks
  private async processWhatsAppWebhook(data: any): Promise<void> {
    const { entry } = data;
    
    for (const entryItem of entry) {
      for (const change of entryItem.changes) {
        if (change.field === 'messages') {
          const { messages, statuses } = change.value;
          
          // Process status updates
          if (statuses) {
            for (const status of statuses) {
              await this.updateWhatsAppMessageStatus(status);
            }
          }
          
          // Process incoming messages
          if (messages) {
            for (const message of messages) {
              await this.processIncomingWhatsAppMessage(message, change.value);
            }
          }
        }
      }
    }
  }

  private async updateWhatsAppMessageStatus(status: any): Promise<void> {
    const updateData: any = {
      send_status: this.mapWhatsAppStatus(status.status)
    };

    if (status.status === 'delivered') {
      updateData.delivered_at = new Date(status.timestamp * 1000).toISOString();
    } else if (status.status === 'read') {
      updateData.read_at = new Date(status.timestamp * 1000).toISOString();
    }

    await this.supabase
      .from('message_send_queue')
      .update(updateData)
      .eq('external_message_id', status.id);
  }

  private async processIncomingWhatsAppMessage(message: any, value: any): Promise<void> {
    const phoneNumber = message.from;
    const content = message.text?.body || '[Media message]';
    
    // Find client by phone number
    const { data: client } = await this.supabase
      .from('clients')
      .select('id, supplier_id')
      .or(`primary_phone.eq.${phoneNumber},whatsapp_phone.eq.${phoneNumber}`)
      .single();

    if (!client) {
      console.log('Client not found for phone number:', phoneNumber);
      return;
    }

    // Update conversation with incoming message
    await this.updateConversation({
      client_id: client.id,
      supplier_id: client.supplier_id,
      recipient_phone: phoneNumber,
      message_type: 'whatsapp_text',
      messaging_provider_id: null, // Will be set in updateConversation
      external_message_id: message.id
    }, 'inbound', content);
  }

  private mapTwilioStatus(status: string): string {
    switch (status) {
      case 'queued':
      case 'accepted':
        return 'queued';
      case 'sending':
        return 'sending';
      case 'sent':
        return 'sent';
      case 'delivered':
        return 'delivered';
      case 'undelivered':
      case 'failed':
        return 'failed';
      default:
        return 'sent';
    }
  }

  private mapWhatsAppStatus(status: string): string {
    switch (status) {
      case 'sent':
        return 'sent';
      case 'delivered':
        return 'delivered';
      case 'read':
        return 'delivered'; // We handle read status separately
      case 'failed':
        return 'failed';
      default:
        return 'sent';
    }
  }
}
```

### ACCEPTANCE CRITERIA

**Provider Integration:**
- [ ] Twilio SMS/MMS integration with delivery tracking
- [ ] WhatsApp Business API integration with rich media support
- [ ] MessageBird, ClickSend, and Vonage as backup providers
- [ ] Automatic failover between providers
- [ ] Provider health monitoring and status tracking
- [ ] Cost optimization through provider comparison
- [ ] Rate limiting compliance for all providers
- [ ] Webhook processing for delivery confirmations

**Message Management:**
- [ ] Rich message templates with merge fields and media
- [ ] Automated message workflows triggered by client actions
- [ ] Two-way conversation management with threaded messages
- [ ] Message scheduling with timezone awareness
- [ ] Priority message queue with immediate delivery options
- [ ] Bulk messaging with batch processing
- [ ] Message retry logic for failed deliveries
- [ ] Character counting and SMS segment calculation

**Compliance & Consent:**
- [ ] GDPR-compliant opt-in/opt-out management
- [ ] WhatsApp Business Policy compliance
- [ ] TCPA compliance for US markets
- [ ] Quiet hours enforcement and timezone handling
- [ ] Marketing message consent tracking
- [ ] Automated unsubscribe processing
- [ ] Compliance audit trails and reporting
- [ ] Double opt-in workflows for marketing messages

**WhatsApp Specific:**
- [ ] WhatsApp Business account verification
- [ ] Template message approval workflow
- [ ] Rich media messaging (images, documents, videos)
- [ ] WhatsApp Business profile management
- [ ] Session message vs template message handling
- [ ] Message template category compliance
- [ ] WhatsApp Commerce integration preparation
- [ ] Multi-language template support

**User Experience:**
- [ ] Unified message center with SMS and WhatsApp conversations
- [ ] Real-time message status updates
- [ ] Contact management with communication preferences
- [ ] Message templates library with categories
- [ ] Conversation search and filtering
- [ ] Mobile-responsive messaging interface
- [ ] Message scheduling calendar integration
- [ ] Quick reply templates and shortcuts

**Business Logic:**
- [ ] Tier-based messaging limits (FREE: 0, STARTER: 50/month, PROFESSIONAL: 500/month, SCALE: unlimited)
- [ ] Cost tracking and billing integration
- [ ] Message analytics and performance reporting
- [ ] Client engagement scoring
- [ ] Integration with email automation workflows
- [ ] Form submission triggered messaging
- [ ] Payment reminder automation
- [ ] Wedding day emergency communication protocols

### DEPENDENCIES & INTEGRATION

**Must Complete After:**
- WS-345: Email Automation Engine (workflow integration)
- WS-306: Client Management System (client data access)
- WS-334: Notification System (unified notifications)

**Must Complete Before:**
- WS-355: Business Intelligence (message analytics)
- Production launch (critical for real-time communication)

**Shares Code With:**
- Email Automation Engine (workflow triggers and templates)
- Client Management (preferences and opt-in status)
- Notification System (unified message center)
- Analytics System (engagement reporting)

### ESTIMATED EFFORT

- **Frontend Development:** 30 hours
  - Message center interface with conversation threads
  - Template editor and management
  - Provider configuration screens
  - Mobile-responsive messaging UI

- **Backend Development:** 40 hours
  - Multi-provider integration (Twilio, WhatsApp Business)
  - Message queue processing system
  - Webhook handling for delivery status
  - Compliance and opt-in management

- **WhatsApp Integration:** 15 hours
  - Business API setup and verification
  - Template submission workflow
  - Rich media message handling
  - Compliance policy implementation

- **Testing & QA:** 10 hours
  - Provider integration testing
  - Message delivery testing
  - Compliance workflow testing
  - Mobile messaging testing

**Total Estimated Effort:** 95 hours

### TECHNICAL NOTES

**Provider Selection Strategy:**
- Primary: Twilio (reliable, global reach, excellent API)
- WhatsApp: Meta Business API (official, feature-rich)
- Backup: MessageBird, ClickSend for redundancy
- Cost optimization through intelligent routing

**Performance Considerations:**
- Message queue processing with background jobs
- Rate limiting to respect provider limits
- Intelligent retry logic with exponential backoff
- Database indexing for conversation queries
- Media file optimization for WhatsApp

**Security Best Practices:**
- Webhook signature verification for all providers
- Secure credential storage with encryption
- Phone number validation and sanitization
- Message content filtering and sanitization
- Comprehensive audit logging for compliance

This SMS/WhatsApp Integration completes the multi-channel communication suite, enabling suppliers to reach clients instantly through their preferred messaging channels while maintaining full compliance with global messaging regulations.