# TECHNICAL SPECIFICATION: WS-253 - Florist Intelligence System
## Generated by Feature Development Session - 2025-08-30

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding florist using WedSync to manage my client arrangements
**I want to:** Access AI-powered flower recommendations based on seasonality, color harmony, sustainability, and allergen considerations, plus automated arrangement optimization
**So that:** I can reduce my design planning time from 2 hours to 20 minutes per wedding, ensure optimal flower selection for budget and season, avoid allergen issues, and provide eco-conscious options that differentiate my business

**Real Wedding Scenario:**
A florist has an October wedding with a "dusty rose and sage green" color scheme and a guest with severe pollen allergies. The AI system suggests dahlias, roses, and eucalyptus (all peak season in October), generates a complementary color palette with cream and burgundy accents, flags that chrysanthemums would be problematic due to high pollen, and recommends low-pollen alternatives like orchids. The system also calculates that choosing local dahlias over imported roses reduces the carbon footprint by 60% and provides a detailed arrangement plan with quantities, timeline, and care instructions.

### SPECIFICATION SOURCE
- **Feature ID:** WS-253
- **Original Spec:** /CORE-SPECIFICATIONS/04-AI-INTEGRATION/05-Vendor-Specific/03-florist-intelligence md.md
- **Current Implementation:** 0% complete
- **Files to Modify:**
  - /wedsync/src/app/(dashboard)/florist/page.tsx (new)
  - /wedsync/src/components/florist/FloristIntelligence.tsx (new)
  - /wedsync/src/app/api/florist/search/route.ts (new)
- **New Files to Create:**
  - /wedsync/src/lib/florist/flower-database.ts
  - /wedsync/src/lib/florist/color-harmony-ai.ts
  - /wedsync/src/lib/florist/sustainability-engine.ts
  - /wedsync/src/lib/florist/arrangement-optimizer.ts
  - /wedsync/src/lib/florist/allergen-detector.ts
  - /wedsync/src/lib/florist/seasonal-intelligence.ts
  - /wedsync/src/components/florist/FlowerSearch.tsx
  - /wedsync/src/components/florist/ColorPaletteGenerator.tsx
  - /wedsync/src/components/florist/SustainabilityAnalyzer.tsx
  - /wedsync/src/components/florist/ArrangementPlanner.tsx
  - /wedsync/src/components/florist/AllergenChecker.tsx

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Comprehensive flower varieties database
CREATE TABLE IF NOT EXISTS flower_varieties (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  common_name TEXT NOT NULL,
  scientific_name TEXT UNIQUE,
  family_name TEXT,
  color_variants JSONB NOT NULL DEFAULT '[]'::jsonb,
  seasonality JSONB NOT NULL DEFAULT '{"peak": [], "available": [], "scarce": []}'::jsonb,
  characteristics JSONB NOT NULL DEFAULT '{}'::jsonb,
  wedding_uses JSONB NOT NULL DEFAULT '{"bouquet": false, "centerpiece": false, "ceremony": false, "boutonniere": false}'::jsonb,
  growing_regions TEXT[] DEFAULT '{}',
  sustainability_score DECIMAL(3,2) CHECK (sustainability_score >= 0 AND sustainability_score <= 1),
  allergen_info JSONB DEFAULT '{"pollen": "low", "fragrance": "none", "contact_irritant": false}'::jsonb,
  care_instructions JSONB DEFAULT '{}'::jsonb,
  average_lifespan_days INTEGER,
  stem_length_range JSONB DEFAULT '{"min": 0, "max": 0}'::jsonb,
  fragrance_intensity TEXT CHECK (fragrance_intensity IN ('none', 'light', 'moderate', 'strong')) DEFAULT 'none',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  INDEX idx_flower_varieties_common_name(common_name),
  INDEX idx_flower_varieties_scientific_name(scientific_name),
  INDEX idx_flower_varieties_family(family_name)
);

-- Regional flower pricing and availability
CREATE TABLE IF NOT EXISTS flower_pricing (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  flower_id UUID REFERENCES flower_varieties(id) ON DELETE CASCADE,
  region TEXT NOT NULL,
  month INTEGER CHECK (month >= 1 AND month <= 12),
  year INTEGER DEFAULT EXTRACT(YEAR FROM NOW()),
  base_price_per_stem DECIMAL(6,2) NOT NULL,
  wholesale_price_per_stem DECIMAL(6,2),
  availability_score DECIMAL(3,2) CHECK (availability_score >= 0 AND availability_score <= 1),
  quality_score DECIMAL(3,2) CHECK (quality_score >= 0 AND quality_score <= 1),
  supplier_reliability DECIMAL(3,2) CHECK (supplier_reliability >= 0 AND supplier_reliability <= 1),
  transportation_carbon_cost DECIMAL(8,2), -- CO2 kg per stem
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(flower_id, region, month, year),
  INDEX idx_pricing_region_month(region, month),
  INDEX idx_pricing_flower_date(flower_id, month, year)
);

-- Color matching database for accurate color harmony
CREATE TABLE IF NOT EXISTS flower_color_matches (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  flower_id UUID REFERENCES flower_varieties(id) ON DELETE CASCADE,
  color_hex TEXT NOT NULL,
  color_name TEXT,
  color_category TEXT, -- 'primary', 'secondary', 'accent', 'variegated'
  match_accuracy DECIMAL(3,2) CHECK (match_accuracy >= 0 AND match_accuracy <= 1),
  color_lab JSONB, -- LAB color space values for accurate matching
  seasonal_variation JSONB, -- How colors change by season
  created_at TIMESTAMPTZ DEFAULT NOW(),
  
  INDEX idx_color_matches_hex(color_hex),
  INDEX idx_color_matches_flower(flower_id),
  INDEX idx_color_matches_category(color_category)
);

-- Pre-designed arrangement templates and optimization data
CREATE TABLE IF NOT EXISTS arrangement_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  template_name TEXT NOT NULL,
  arrangement_type TEXT NOT NULL CHECK (arrangement_type IN ('bouquet', 'centerpiece', 'ceremony_arch', 'aisle_decor', 'corsage', 'boutonniere', 'installation')),
  style TEXT NOT NULL CHECK (style IN ('romantic', 'modern', 'rustic', 'classic', 'bohemian', 'minimalist')),
  size_category TEXT NOT NULL CHECK (size_category IN ('small', 'medium', 'large', 'extra_large')),
  flower_composition JSONB NOT NULL, -- Array of {flower_id, quantity, role: 'focal'|'filler'|'foliage'}
  technique_notes TEXT,
  construction_instructions JSONB,
  difficulty_level INTEGER CHECK (difficulty_level >= 1 AND difficulty_level <= 5),
  estimated_time_hours DECIMAL(4,2),
  estimated_cost_range JSONB, -- {min: number, max: number}
  sustainability_score DECIMAL(3,2) CHECK (sustainability_score >= 0 AND sustainability_score <= 1),
  allergen_score DECIMAL(3,2) CHECK (allergen_score >= 0 AND allergen_score <= 1),
  seasonal_adaptations JSONB, -- Variations for different seasons
  created_by UUID REFERENCES suppliers(id),
  is_public BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  INDEX idx_templates_type_style(arrangement_type, style),
  INDEX idx_templates_size(size_category),
  INDEX idx_templates_public(is_public)
);

-- Wedding-specific flower arrangements and plans
CREATE TABLE IF NOT EXISTS wedding_floral_plans (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  wedding_id UUID REFERENCES weddings(id) ON DELETE CASCADE,
  florist_id UUID REFERENCES suppliers(id) ON DELETE CASCADE,
  color_palette JSONB NOT NULL, -- Primary wedding colors
  style_preferences JSONB, -- Style, budget, preferences
  arrangement_list JSONB NOT NULL, -- All arrangements with quantities and details
  sustainability_analysis JSONB,
  allergen_analysis JSONB,
  total_estimated_cost DECIMAL(10,2),
  carbon_footprint_estimate DECIMAL(8,2), -- kg CO2
  seasonal_score DECIMAL(3,2),
  ai_generated BOOLEAN DEFAULT false,
  generation_notes TEXT,
  client_approved BOOLEAN DEFAULT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(wedding_id, florist_id),
  INDEX idx_floral_plans_wedding(wedding_id),
  INDEX idx_floral_plans_florist(florist_id, created_at DESC)
);

-- Sustainability and carbon footprint tracking
CREATE TABLE IF NOT EXISTS flower_sustainability_data (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  flower_id UUID REFERENCES flower_varieties(id) ON DELETE CASCADE,
  growing_method TEXT CHECK (growing_method IN ('organic', 'conventional', 'hydroponic', 'wild_harvested')),
  water_usage_liters_per_stem DECIMAL(6,2),
  pesticide_usage_score DECIMAL(3,2) CHECK (pesticide_usage_score >= 0 AND pesticide_usage_score <= 1), -- 0 = organic, 1 = heavy pesticides
  labor_conditions_score DECIMAL(3,2) CHECK (labor_conditions_score >= 0 AND labor_conditions_score <= 1), -- Fair trade scoring
  transportation_method TEXT, -- 'local', 'truck', 'air', 'sea'
  average_transport_distance_km INTEGER,
  carbon_footprint_per_stem DECIMAL(6,2), -- kg CO2 equivalent
  certifications TEXT[], -- 'organic', 'fair_trade', 'carbon_neutral', etc.
  data_source TEXT,
  last_verified TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(flower_id, growing_method),
  INDEX idx_sustainability_flower(flower_id),
  INDEX idx_sustainability_footprint(carbon_footprint_per_stem)
);

-- Allergen and safety information
CREATE TABLE IF NOT EXISTS flower_allergen_data (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  flower_id UUID REFERENCES flower_varieties(id) ON DELETE CASCADE,
  allergen_type TEXT NOT NULL CHECK (allergen_type IN ('pollen', 'fragrance', 'contact', 'ingestion')),
  severity_level TEXT NOT NULL CHECK (severity_level IN ('none', 'low', 'moderate', 'high', 'severe')),
  affected_population_percent DECIMAL(4,2), -- What % of population is sensitive
  specific_compounds TEXT[], -- Specific allergens identified
  symptoms TEXT[],
  mitigation_strategies TEXT[],
  safe_handling_notes TEXT,
  pet_safety_notes TEXT,
  research_sources TEXT[],
  last_updated TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(flower_id, allergen_type),
  INDEX idx_allergen_flower(flower_id),
  INDEX idx_allergen_severity(severity_level)
);

-- AI-generated seasonal forecasts and recommendations
CREATE TABLE IF NOT EXISTS seasonal_flower_forecasts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  region TEXT NOT NULL,
  month INTEGER CHECK (month >= 1 AND month <= 12),
  year INTEGER DEFAULT EXTRACT(YEAR FROM NOW()),
  flower_id UUID REFERENCES flower_varieties(id) ON DELETE CASCADE,
  availability_forecast DECIMAL(3,2) CHECK (availability_forecast >= 0 AND availability_forecast <= 1),
  price_trend TEXT CHECK (price_trend IN ('increasing', 'stable', 'decreasing')),
  quality_forecast DECIMAL(3,2) CHECK (quality_forecast >= 0 AND quality_forecast <= 1),
  weather_impact_risk DECIMAL(3,2) CHECK (weather_impact_risk >= 0 AND weather_impact_risk <= 1),
  recommended_alternatives UUID[] REFERENCES flower_varieties(id),
  forecast_confidence DECIMAL(3,2) CHECK (forecast_confidence >= 0 AND forecast_confidence <= 1),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(region, month, year, flower_id),
  INDEX idx_forecasts_region_date(region, month, year),
  INDEX idx_forecasts_flower(flower_id)
);

-- Indexes for performance optimization
CREATE INDEX IF NOT EXISTS idx_flower_varieties_seasonality ON flower_varieties USING GIN (seasonality);
CREATE INDEX IF NOT EXISTS idx_flower_varieties_wedding_uses ON flower_varieties USING GIN (wedding_uses);
CREATE INDEX IF NOT EXISTS idx_flower_varieties_sustainability ON flower_varieties(sustainability_score DESC) WHERE sustainability_score IS NOT NULL;
```

#### API Endpoints Required
```typescript
// GET /api/florist/flowers/search
interface FlowerSearchRequest {
  colors?: string[]; // Hex color codes
  season?: 'spring' | 'summer' | 'fall' | 'winter';
  month?: number;
  style?: 'romantic' | 'modern' | 'rustic' | 'classic' | 'bohemian';
  budget_per_stem?: { min: number; max: number };
  wedding_uses?: ('bouquet' | 'centerpiece' | 'ceremony' | 'boutonniere')[];
  exclude_allergens?: ('pollen' | 'fragrance' | 'contact')[];
  sustainability_minimum?: number; // 0-1 scale
  region?: string;
  limit?: number;
}

interface FlowerSearchResponse {
  success: boolean;
  flowers: Array<{
    id: string;
    common_name: string;
    scientific_name: string;
    color_variants: any[];
    seasonal_score: number;
    availability_score: number;
    price_estimate: {
      per_stem: number;
      currency: string;
      last_updated: string;
    };
    sustainability: {
      score: number;
      carbon_footprint: number;
      certifications: string[];
    };
    allergen_info: {
      pollen: string;
      fragrance: string;
      contact_safe: boolean;
    };
    wedding_suitability: {
      bouquet: boolean;
      centerpiece: boolean;
      ceremony: boolean;
      boutonniere: boolean;
    };
  }>;
  total_results: number;
  seasonal_recommendations?: string[];
}

// POST /api/florist/colors/palette
interface ColorPaletteRequest {
  base_colors: string[]; // Hex codes
  style: string;
  season: string;
  preferences?: {
    include_neutrals: boolean;
    accent_count: number;
    harmony_type?: 'complementary' | 'analogous' | 'triadic' | 'monochromatic';
  };
}

interface ColorPaletteResponse {
  success: boolean;
  palette: {
    primary_colors: Array<{ hex: string; name: string; role: string }>;
    accent_colors: Array<{ hex: string; name: string; role: string }>;
    neutral_colors: Array<{ hex: string; name: string; role: string }>;
    harmony_type: string;
    confidence_score: number;
  };
  matching_flowers: Array<{
    flower: any;
    color_match: string;
    match_confidence: number;
  }>;
  seasonal_availability: any;
}

// POST /api/florist/arrangements/optimize
interface ArrangementOptimizationRequest {
  arrangement_type: string;
  size_category: string;
  style: string;
  color_palette: string[];
  budget_range: { min: number; max: number };
  wedding_date: string;
  guest_allergies?: string[];
  sustainability_priority: number; // 0-1, how much to prioritize sustainability
  special_requirements?: string[];
}

interface ArrangementOptimizationResponse {
  success: boolean;
  optimized_arrangement: {
    id: string;
    name: string;
    flowers: Array<{
      flower: any;
      quantity: number;
      role: 'focal' | 'filler' | 'foliage' | 'accent';
      estimated_cost: number;
    }>;
    construction_plan: {
      technique: string;
      estimated_time_hours: number;
      difficulty_level: number;
      instructions: string[];
      care_timeline: any[];
    };
    sustainability_analysis: {
      score: number;
      carbon_footprint: number;
      local_percentage: number;
      recommendations: string[];
    };
    allergen_analysis: {
      risk_level: string;
      specific_risks: any[];
      mitigation_strategies: string[];
    };
    total_cost_estimate: number;
    alternatives: any[];
  };
}

// POST /api/florist/sustainability/analyze
interface SustainabilityAnalysisRequest {
  flower_selections: Array<{
    flower_id: string;
    quantity: number;
  }>;
  wedding_location: {
    lat: number;
    lng: number;
    region: string;
  };
  wedding_date: string;
  include_alternatives: boolean;
}

interface SustainabilityAnalysisResponse {
  success: boolean;
  analysis: {
    overall_score: number; // 0-1 scale
    total_carbon_footprint: number; // kg CO2
    local_percentage: number;
    seasonal_percentage: number;
    certifications: {
      organic: number;
      fair_trade: number;
      carbon_neutral: number;
    };
    detailed_breakdown: Array<{
      flower: any;
      quantity: number;
      sustainability_score: number;
      carbon_footprint: number;
      distance_km: number;
      in_season: boolean;
      issues: string[];
      alternatives?: any[];
    }>;
    recommendations: Array<{
      type: 'substitution' | 'quantity_reduction' | 'timing_adjustment';
      description: string;
      impact: {
        carbon_reduction: number;
        cost_change: number;
        sustainability_improvement: number;
      };
    }>;
  };
}

// POST /api/florist/allergens/check
interface AllergenCheckRequest {
  flower_selections: Array<{
    flower_id: string;
    quantity: number;
    placement: 'bouquet' | 'centerpiece' | 'ceremony' | 'boutonniere';
  }>;
  guest_allergies: Array<{
    type: 'pollen' | 'fragrance' | 'contact';
    severity: 'mild' | 'moderate' | 'severe';
    specific_flowers?: string[];
  }>;
  venue_info?: {
    indoor_percentage: number;
    ventilation: 'poor' | 'average' | 'excellent';
  };
}
```

#### Frontend Components Required
```typescript
// Component: FloristIntelligence
// Location: /src/components/florist/FloristIntelligence.tsx

interface FloristIntelligenceProps {
  weddingId?: string;
  onRecommendationSelect?: (recommendation: any) => void;
  initialMode?: 'search' | 'palette' | 'arrangement' | 'sustainability';
}

// Key functionality:
- Tabbed interface for different AI tools
- Flower search with advanced filtering
- Color palette generation with flower matching
- Arrangement optimization with drag-and-drop
- Sustainability analysis with carbon footprint
- Allergen checking with risk assessment
- Integration with wedding planning tools

// Component: ColorPaletteGenerator
// Location: /src/components/florist/ColorPaletteGenerator.tsx

interface ColorPaletteGeneratorProps {
  initialColors?: string[];
  weddingStyle?: string;
  season?: string;
  onPaletteGenerated: (palette: any) => void;
}

// Key functionality:
- Interactive color picker with harmony visualization
- AI-powered palette generation
- Flower matching for each color
- Seasonal appropriateness indicators
- Export to design tools
- Save palettes to wedding plans

// Component: SustainabilityAnalyzer
// Location: /src/components/florist/SustainabilityAnalyzer.tsx

interface SustainabilityAnalyzerProps {
  flowerSelections: FlowerSelection[];
  weddingLocation: Location;
  onAnalysisComplete: (analysis: any) => void;
}

// Key functionality:
- Carbon footprint calculation with visualization
- Local vs imported flower analysis
- Certification tracking (organic, fair trade)
- Alternative suggestions for improvement
- Sustainability score breakdown
- Environmental impact comparison charts
```

#### Integration Points
```typescript
// Service: FloristIntelligenceService
// Dependencies: OpenAI API, Color matching algorithms, Geographic distance calculations

class FloristIntelligenceService {
  async searchFlowersWithIntelligence(criteria: SearchCriteria): Promise<FlowerSearchResults> {
    // Apply base filtering
    let flowers = await this.applyBasicFilters(criteria);
    
    // Apply seasonal intelligence
    flowers = await this.applySeasonalScoring(flowers, criteria.wedding_date, criteria.region);
    
    // Apply color matching if colors specified
    if (criteria.colors?.length) {
      flowers = await this.applyColorMatching(flowers, criteria.colors);
    }
    
    // Apply sustainability filtering
    if (criteria.sustainability_minimum) {
      flowers = await this.applySustainabilityFilter(flowers, criteria.sustainability_minimum);
    }
    
    // Apply allergen filtering
    if (criteria.exclude_allergens?.length) {
      flowers = await this.applyAllergenFilter(flowers, criteria.exclude_allergens);
    }
    
    // Rank and return results
    return this.rankFlowerResults(flowers, criteria);
  }

  async generateWeddingColorPalette(baseColors: string[], style: string, season: string): Promise<ColorPalette> {
    // Use AI to generate harmonious color palette
    const palette = await this.generateAIColorPalette(baseColors, style, season);
    
    // Find matching flowers for each color
    const flowerMatches = await Promise.all(
      palette.colors.map(color => this.findFlowersForColor(color.hex))
    );
    
    // Enhance with seasonal availability
    const seasonalEnhanced = await this.enhanceWithSeasonalData(flowerMatches, season);
    
    return {
      ...palette,
      flower_matches: seasonalEnhanced,
      seasonal_appropriateness: await this.calculateSeasonalAppropri(flowerMatches, season)
    };
  }

  async optimizeArrangement(requirements: ArrangementRequirements): Promise<OptimizedArrangement> {
    // Use AI to generate base arrangement design
    const baseDesign = await this.generateArrangementDesign(requirements);
    
    // Enhance with real-world data (pricing, availability)
    const enhancedDesign = await this.enhanceWithMarketData(baseDesign, requirements.wedding_date);
    
    // Apply sustainability optimization if requested
    if (requirements.sustainability_priority > 0.5) {
      enhancedDesign = await this.optimizeForSustainability(enhancedDesign, requirements.wedding_location);
    }
    
    // Check for allergen issues
    const allergenAnalysis = await this.analyzeAllergenRisks(enhancedDesign, requirements.guest_allergies);
    
    return {
      ...enhancedDesign,
      allergen_analysis: allergenAnalysis,
      sustainability_analysis: await this.calculateSustainabilityScore(enhancedDesign)
    };
  }
}

// Service: ColorHarmonyAI
// Dependencies: Color space conversion, AI color theory, Flower color database

class ColorHarmonyAI {
  async analyzeColorHarmony(colors: string[]): Promise<ColorHarmonyAnalysis> {
    // Convert to LAB color space for accurate analysis
    const labColors = colors.map(hex => this.hexToLab(hex));
    
    // Analyze harmony relationships
    const harmonies = {
      complementary: this.findComplementaryColors(labColors),
      analogous: this.findAnalogousColors(labColors),
      triadic: this.findTriadicColors(labColors),
      monochromatic: this.findMonochromaticColors(labColors)
    };
    
    // Score each harmony type
    const harmonyScores = await this.scoreHarmonies(harmonies);
    
    return {
      input_colors: colors,
      harmony_analysis: harmonies,
      harmony_scores: harmonyScores,
      recommended_harmony: this.findBestHarmony(harmonyScores),
      flower_matches: await this.findFlowersForHarmonies(harmonies)
    };
  }

  private hexToLab(hex: string): LabColor {
    // Convert hex to RGB first
    const rgb = this.hexToRgb(hex);
    
    // Convert RGB to XYZ
    const xyz = this.rgbToXyz(rgb);
    
    // Convert XYZ to LAB
    return this.xyzToLab(xyz);
  }

  private findComplementaryColors(labColors: LabColor[]): ComplementaryHarmony {
    // Find colors opposite on the color wheel
    return labColors.map(color => ({
      original: color,
      complement: this.getComplementaryColor(color),
      harmony_strength: this.calculateHarmonyStrength(color, this.getComplementaryColor(color))
    }));
  }
}
```

### CODE EXAMPLES

#### Example 1: AI-Powered Flower Search with Seasonal Intelligence
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { OpenAI } from 'openai';
import { supabase } from '@/lib/supabase';

interface FlowerSearchCriteria {
  colors?: string[];
  wedding_date?: Date;
  style?: string;
  budget_range?: { min: number; max: number };
  region?: string;
  exclude_allergens?: string[];
  sustainability_minimum?: number;
  wedding_uses?: string[];
}

export class FloristIntelligenceService {
  private openai: OpenAI;

  constructor() {
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });
  }

  async searchFlowersWithIntelligence(criteria: FlowerSearchCriteria): Promise<any> {
    try {
      // Step 1: Get base flower data from database
      let query = supabase
        .from('flower_varieties')
        .select(`
          *,
          flower_color_matches(*),
          flower_sustainability_data(*),
          flower_allergen_data(*)
        `);

      // Apply basic filters
      if (criteria.wedding_uses?.length) {
        query = query.filter('wedding_uses', 'cs', JSON.stringify(criteria.wedding_uses));
      }

      const { data: flowers, error } = await query;
      if (error) throw error;

      // Step 2: Apply AI-powered seasonal scoring
      const seasonallyScored = await this.applySeasonalIntelligence(flowers, criteria);

      // Step 3: Apply color matching if specified
      const colorMatched = criteria.colors?.length 
        ? await this.applyColorMatching(seasonallyScored, criteria.colors)
        : seasonallyScored;

      // Step 4: Apply sustainability filtering
      const sustainabilityFiltered = criteria.sustainability_minimum
        ? colorMatched.filter(f => f.sustainability_score >= criteria.sustainability_minimum)
        : colorMatched;

      // Step 5: Apply allergen filtering
      const allergenSafe = criteria.exclude_allergens?.length
        ? this.applyAllergenFiltering(sustainabilityFiltered, criteria.exclude_allergens)
        : sustainabilityFiltered;

      // Step 6: Get pricing data and availability
      const withPricing = await this.enhanceWithPricingData(allergenSafe, criteria);

      // Step 7: Rank and return results
      return this.rankFlowerResults(withPricing, criteria);

    } catch (error) {
      console.error('Flower search failed:', error);
      throw new Error('Failed to search flowers with intelligence');
    }
  }

  private async applySeasonalIntelligence(flowers: any[], criteria: FlowerSearchCriteria): Promise<any[]> {
    const weddingMonth = criteria.wedding_date?.getMonth() + 1 || new Date().getMonth() + 1;
    
    return flowers.map(flower => {
      const seasonality = flower.seasonality || {};
      let seasonalScore = 0.5; // Base score

      // Peak season bonus
      if (seasonality.peak?.includes(weddingMonth)) {
        seasonalScore = 1.0;
      }
      // Available season
      else if (seasonality.available?.includes(weddingMonth)) {
        seasonalScore = 0.8;
      }
      // Scarce season penalty
      else if (seasonality.scarce?.includes(weddingMonth)) {
        seasonalScore = 0.3;
      }

      return {
        ...flower,
        seasonal_score: seasonalScore,
        price_multiplier: this.calculatePriceMultiplier(seasonalScore),
        seasonal_notes: this.getSeasonalNotes(flower, weddingMonth)
      };
    });
  }

  private async applyColorMatching(flowers: any[], targetColors: string[]): Promise<any[]> {
    const flowersWithColorScores = await Promise.all(
      flowers.map(async flower => {
        const colorMatches = flower.flower_color_matches || [];
        let bestColorMatch = 0;
        let matchedColor = null;

        // Find best color match for this flower
        for (const targetColor of targetColors) {
          for (const flowerColor of colorMatches) {
            const similarity = this.calculateColorSimilarity(targetColor, flowerColor.color_hex);
            if (similarity > bestColorMatch) {
              bestColorMatch = similarity;
              matchedColor = flowerColor;
            }
          }
        }

        return {
          ...flower,
          color_match_score: bestColorMatch,
          matched_color: matchedColor,
          color_compatibility: bestColorMatch > 0.7 ? 'excellent' : 
                             bestColorMatch > 0.5 ? 'good' : 
                             bestColorMatch > 0.3 ? 'fair' : 'poor'
        };
      })
    );

    // Filter out flowers with very poor color matches unless no good matches found
    const goodMatches = flowersWithColorScores.filter(f => f.color_match_score > 0.3);
    return goodMatches.length > 0 ? goodMatches : flowersWithColorScores.slice(0, 10);
  }

  private calculateColorSimilarity(color1: string, color2: string): number {
    // Convert hex colors to LAB space for perceptual similarity
    const lab1 = this.hexToLab(color1);
    const lab2 = this.hexToLab(color2);
    
    // Calculate Delta E (perceptual color difference)
    const deltaE = Math.sqrt(
      Math.pow(lab1.L - lab2.L, 2) + 
      Math.pow(lab1.a - lab2.a, 2) + 
      Math.pow(lab1.b - lab2.b, 2)
    );
    
    // Convert to similarity score (0-1, where 1 is identical)
    return Math.max(0, 1 - (deltaE / 100));
  }

  private hexToLab(hex: string): { L: number; a: number; b: number } {
    // Simplified LAB conversion for demo
    // In production, use a proper color library like chroma.js
    const rgb = this.hexToRgb(hex);
    
    // Simple approximation - replace with proper RGB->XYZ->LAB conversion
    return {
      L: (rgb.r * 0.299 + rgb.g * 0.587 + rgb.b * 0.114) / 255 * 100,
      a: (rgb.r - rgb.g) / 255 * 100,
      b: (rgb.g - rgb.b) / 255 * 100
    };
  }

  private hexToRgb(hex: string): { r: number; g: number; b: number } {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : { r: 0, g: 0, b: 0 };
  }

  private applyAllergenFiltering(flowers: any[], excludeAllergens: string[]): any[] {
    return flowers.filter(flower => {
      const allergenData = flower.flower_allergen_data || [];
      
      for (const exclusion of excludeAllergens) {
        const allergenInfo = allergenData.find(a => a.allergen_type === exclusion);
        if (allergenInfo && ['high', 'severe'].includes(allergenInfo.severity_level)) {
          return false; // Exclude this flower
        }
      }
      
      return true;
    });
  }

  private async enhanceWithPricingData(flowers: any[], criteria: FlowerSearchCriteria): Promise<any[]> {
    const month = criteria.wedding_date?.getMonth() + 1 || new Date().getMonth() + 1;
    const region = criteria.region || 'US';
    
    return await Promise.all(
      flowers.map(async flower => {
        // Get current pricing for this flower
        const { data: pricing } = await supabase
          .from('flower_pricing')
          .select('*')
          .eq('flower_id', flower.id)
          .eq('region', region)
          .eq('month', month)
          .order('updated_at', { ascending: false })
          .limit(1)
          .single();

        const basePrice = pricing?.base_price_per_stem || 2.50; // Default fallback
        const adjustedPrice = basePrice * (flower.price_multiplier || 1.0);

        return {
          ...flower,
          current_pricing: {
            base_price: basePrice,
            adjusted_price: adjustedPrice,
            currency: 'USD',
            availability_score: pricing?.availability_score || 0.5,
            last_updated: pricing?.updated_at
          }
        };
      })
    );
  }

  private rankFlowerResults(flowers: any[], criteria: FlowerSearchCriteria): any {
    // Calculate composite score for each flower
    const scored = flowers.map(flower => {
      let score = 0;
      let weights = 0;

      // Seasonal appropriateness (30% weight)
      score += flower.seasonal_score * 0.3;
      weights += 0.3;

      // Color matching (25% weight if colors specified)
      if (criteria.colors?.length) {
        score += flower.color_match_score * 0.25;
        weights += 0.25;
      }

      // Sustainability (20% weight if specified)
      if (criteria.sustainability_minimum) {
        score += flower.sustainability_score * 0.2;
        weights += 0.2;
      }

      // Availability (15% weight)
      score += flower.current_pricing?.availability_score * 0.15;
      weights += 0.15;

      // Price appropriateness (10% weight if budget specified)
      if (criteria.budget_range) {
        const priceScore = this.calculatePriceScore(flower.current_pricing?.adjusted_price, criteria.budget_range);
        score += priceScore * 0.1;
        weights += 0.1;
      }

      return {
        ...flower,
        composite_score: weights > 0 ? score / weights : score,
        ranking_factors: {
          seasonal: flower.seasonal_score,
          color_match: flower.color_match_score || null,
          sustainability: flower.sustainability_score || null,
          availability: flower.current_pricing?.availability_score || null,
          price_fit: criteria.budget_range ? this.calculatePriceScore(flower.current_pricing?.adjusted_price, criteria.budget_range) : null
        }
      };
    });

    // Sort by composite score
    scored.sort((a, b) => b.composite_score - a.composite_score);

    return {
      flowers: scored,
      search_metadata: {
        total_results: scored.length,
        avg_seasonal_score: scored.reduce((sum, f) => sum + f.seasonal_score, 0) / scored.length,
        avg_sustainability_score: scored.reduce((sum, f) => sum + (f.sustainability_score || 0), 0) / scored.length,
        search_criteria: criteria,
        generated_at: new Date().toISOString()
      }
    };
  }

  private calculatePriceScore(price: number, budget: { min: number; max: number }): number {
    if (!price) return 0.5;
    
    if (price >= budget.min && price <= budget.max) {
      return 1.0; // Perfect fit
    } else if (price < budget.min) {
      return 0.8; // Below budget (good but maybe quality concern)
    } else {
      // Above budget - scale down based on how much over
      const overageRatio = price / budget.max;
      return Math.max(0, 1 - (overageRatio - 1) * 2); // Penalty for being over budget
    }
  }

  private calculatePriceMultiplier(seasonalScore: number): number {
    // Out of season flowers cost more
    if (seasonalScore >= 0.8) return 1.0; // In season, normal price
    if (seasonalScore >= 0.5) return 1.2; // Moderate season, slight premium
    return 1.5; // Out of season, significant premium
  }

  private getSeasonalNotes(flower: any, month: number): string[] {
    const notes = [];
    const seasonality = flower.seasonality || {};
    
    if (seasonality.peak?.includes(month)) {
      notes.push('Peak season - best quality and availability');
    } else if (seasonality.available?.includes(month)) {
      notes.push('Available but not peak season');
    } else if (seasonality.scarce?.includes(month)) {
      notes.push('Out of season - limited availability and higher prices');
    } else {
      notes.push('Seasonal data unavailable');
    }
    
    return notes;
  }
}
```

#### Example 2: AI-Powered Color Palette Generation with Flower Matching
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
export class ColorPaletteGenerator {
  private openai: OpenAI;
  
  constructor() {
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });
  }

  async generateWeddingColorPalette(
    baseColors: string[],
    style: string,
    season: string,
    preferences?: any
  ): Promise<any> {
    try {
      // Step 1: Use AI to generate harmonious color palette
      const aiPalette = await this.generateAIColorPalette(baseColors, style, season);
      
      // Step 2: Find flowers that match each color
      const flowerMatches = await this.findMatchingFlowers(aiPalette.colors);
      
      // Step 3: Check seasonal appropriateness of matched flowers
      const seasonalAnalysis = await this.analyzeSeasonalFit(flowerMatches, season);
      
      // Step 4: Generate alternative palettes if seasonal fit is poor
      const alternatives = seasonalAnalysis.overall_fit < 0.6 
        ? await this.generateAlternativePalettes(baseColors, style, season)
        : [];

      return {
        primary_palette: aiPalette,
        flower_matches: flowerMatches,
        seasonal_analysis: seasonalAnalysis,
        alternatives: alternatives,
        generated_at: new Date().toISOString()
      };

    } catch (error) {
      console.error('Color palette generation failed:', error);
      throw new Error('Failed to generate color palette');
    }
  }

  private async generateAIColorPalette(baseColors: string[], style: string, season: string): Promise<any> {
    const prompt = `Create a sophisticated wedding color palette based on these requirements:

Base Colors: ${baseColors.join(', ')}
Wedding Style: ${style}
Season: ${season}

Generate a complete color palette including:

1. PRIMARY COLORS (2-3 colors):
   - Main wedding colors that will be most prominent
   - Should include or build upon the provided base colors

2. ACCENT COLORS (2-3 colors):
   - Supporting colors that complement the primary palette
   - Can be bolder or more dramatic for visual interest

3. NEUTRAL COLORS (1-2 colors):
   - Balancing colors like creams, whites, or soft grays
   - Should ground the palette and provide rest for the eye

Consider these ${season} seasonal characteristics:
- Spring: Fresh, light, renewal themes
- Summer: Vibrant, bold, sun-soaked themes  
- Fall: Warm, rich, harvest themes
- Winter: Cool, elegant, cozy themes

For ${style} style weddings, consider:
- Romantic: Soft, flowing, dreamy colors
- Modern: Clean, bold, contemporary colors
- Rustic: Earthy, natural, organic colors
- Classic: Timeless, sophisticated, traditional colors
- Bohemian: Rich, eclectic, artistic colors

Return as JSON with this exact structure:
{
  "primary_colors": [{"hex": "#hexcode", "name": "Color Name", "description": "Why this color works"}],
  "accent_colors": [{"hex": "#hexcode", "name": "Color Name", "description": "Role in palette"}],
  "neutral_colors": [{"hex": "#hexcode", "name": "Color Name", "description": "Balancing purpose"}],
  "palette_name": "Descriptive palette name",
  "style_reasoning": "Why this palette suits the style",
  "seasonal_appropriateness": "How it fits the season"
}`;

    const response = await this.openai.chat.completions.create({
      model: 'gpt-4',
      messages: [
        {
          role: 'system',
          content: 'You are a professional wedding color consultant with expertise in color theory, floral design, and seasonal appropriateness. Create sophisticated, harmonious color palettes that work beautifully for weddings.'
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      response_format: { type: 'json_object' },
      temperature: 0.7, // Allow some creativity while staying coherent
      max_tokens: 800
    });

    const paletteText = response.choices[0]?.message?.content;
    if (!paletteText) {
      throw new Error('No color palette received from AI');
    }

    return JSON.parse(paletteText);
  }

  private async findMatchingFlowers(colors: any[]): Promise<any[]> {
    const allColors = colors.flatMap(colorGroup => colorGroup); // Flatten primary, accent, neutral
    const flowerMatches = [];

    for (const color of allColors) {
      try {
        // Find flowers that match this specific color
        const { data: matchingFlowers, error } = await supabase
          .from('flower_color_matches')
          .select(`
            *,
            flower_varieties (
              id,
              common_name,
              scientific_name,
              seasonality,
              sustainability_score,
              wedding_uses,
              allergen_info
            )
          `)
          .gte('match_accuracy', 0.6); // Only reasonably good matches

        if (error) throw error;

        // Calculate similarity scores for this specific color
        const scoredMatches = matchingFlowers
          .map(match => ({
            ...match,
            color_similarity: this.calculateColorSimilarity(color.hex, match.color_hex),
            flower: match.flower_varieties
          }))
          .filter(match => match.color_similarity > 0.5) // Filter out poor matches
          .sort((a, b) => b.color_similarity - a.color_similarity)
          .slice(0, 5); // Top 5 matches per color

        flowerMatches.push({
          target_color: color,
          matching_flowers: scoredMatches,
          match_count: scoredMatches.length
        });

      } catch (error) {
        console.error(`Error finding flowers for color ${color.hex}:`, error);
        flowerMatches.push({
          target_color: color,
          matching_flowers: [],
          match_count: 0,
          error: error.message
        });
      }
    }

    return flowerMatches;
  }

  private async analyzeSeasonalFit(flowerMatches: any[], season: string): Promise<any> {
    const seasonNum = this.getSeasonMonths(season);
    let totalFlowers = 0;
    let seasonallyAppropriate = 0;
    let wellMatched = 0;

    for (const colorMatch of flowerMatches) {
      for (const flower of colorMatch.matching_flowers) {
        totalFlowers++;
        
        if (flower.color_similarity > 0.7) {
          wellMatched++;
        }

        // Check if flower is in season
        const flowerSeasonality = flower.flower?.seasonality || {};
        const isInSeason = seasonNum.some(month => 
          flowerSeasonality.peak?.includes(month) || 
          flowerSeasonality.available?.includes(month)
        );

        if (isInSeason) {
          seasonallyAppropriate++;
        }
      }
    }

    const seasonalFitScore = totalFlowers > 0 ? seasonallyAppropriate / totalFlowers : 0;
    const colorMatchScore = totalFlowers > 0 ? wellMatched / totalFlowers : 0;
    const overallFit = (seasonalFitScore + colorMatchScore) / 2;

    return {
      overall_fit: overallFit,
      seasonal_fit_score: seasonalFitScore,
      color_match_score: colorMatchScore,
      total_flowers_analyzed: totalFlowers,
      seasonally_appropriate_count: seasonallyAppropriate,
      well_matched_count: wellMatched,
      recommendations: this.generateSeasonalRecommendations(overallFit, seasonalFitScore, colorMatchScore),
      season_analyzed: season
    };
  }

  private getSeasonMonths(season: string): number[] {
    switch (season.toLowerCase()) {
      case 'spring': return [3, 4, 5];
      case 'summer': return [6, 7, 8];
      case 'fall': case 'autumn': return [9, 10, 11];
      case 'winter': return [12, 1, 2];
      default: return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]; // All months if unknown
    }
  }

  private generateSeasonalRecommendations(overallFit: number, seasonalFit: number, colorFit: number): string[] {
    const recommendations = [];

    if (overallFit >= 0.8) {
      recommendations.push('Excellent palette - great flower availability and color matches');
    } else if (overallFit >= 0.6) {
      recommendations.push('Good palette with minor adjustments possible');
    } else {
      recommendations.push('Consider palette modifications for better flower availability');
    }

    if (seasonalFit < 0.5) {
      recommendations.push('Many flowers in this palette may be out of season - expect higher costs');
      recommendations.push('Consider seasonal alternatives or adjust wedding date for optimal flower availability');
    }

    if (colorFit < 0.6) {
      recommendations.push('Some colors may be difficult to match perfectly in flowers');
      recommendations.push('Consider silk flowers or dyed options for exact color matching');
    }

    return recommendations;
  }

  private async generateAlternativePalettes(baseColors: string[], style: string, season: string): Promise<any[]> {
    // Generate 2-3 alternative palettes with better seasonal fit
    const alternatives = [];

    for (let i = 0; i < 3; i++) {
      try {
        const altPrompt = `Create an alternative wedding color palette (variation ${i + 1}) that improves on the seasonal flower availability:

Base Colors: ${baseColors.join(', ')}
Style: ${style}
Season: ${season}

Focus on colors that are easier to achieve with ${season} flowers while maintaining the overall aesthetic. Make this palette distinctly different from previous variations while staying true to the style and base colors.

Use the same JSON structure as before.`;

        const response = await this.openai.chat.completions.create({
          model: 'gpt-4',
          messages: [
            {
              role: 'system',
              content: 'Create alternative wedding color palettes optimized for seasonal flower availability.'
            },
            {
              role: 'user',
              content: altPrompt
            }
          ],
          response_format: { type: 'json_object' },
          temperature: 0.8, // Higher creativity for alternatives
          max_tokens: 600
        });

        const altPaletteText = response.choices[0]?.message?.content;
        if (altPaletteText) {
          const altPalette = JSON.parse(altPaletteText);
          const altFlowerMatches = await this.findMatchingFlowers(altPalette.colors);
          const altSeasonalAnalysis = await this.analyzeSeasonalFit(altFlowerMatches, season);

          alternatives.push({
            palette: altPalette,
            flower_matches: altFlowerMatches,
            seasonal_analysis: altSeasonalAnalysis,
            variation_number: i + 1
          });
        }

      } catch (error) {
        console.error(`Error generating alternative palette ${i + 1}:`, error);
      }
    }

    return alternatives;
  }

  private calculateColorSimilarity(color1: string, color2: string): number {
    // This is the same method from the flower search - reuse for consistency
    const lab1 = this.hexToLab(color1);
    const lab2 = this.hexToLab(color2);
    
    const deltaE = Math.sqrt(
      Math.pow(lab1.L - lab2.L, 2) + 
      Math.pow(lab1.a - lab2.a, 2) + 
      Math.pow(lab1.b - lab2.b, 2)
    );
    
    return Math.max(0, 1 - (deltaE / 100));
  }

  private hexToLab(hex: string): { L: number; a: number; b: number } {
    // Simplified conversion - in production use proper color library
    const rgb = this.hexToRgb(hex);
    return {
      L: (rgb.r * 0.299 + rgb.g * 0.587 + rgb.b * 0.114) / 255 * 100,
      a: (rgb.r - rgb.g) / 255 * 100,
      b: (rgb.g - rgb.b) / 255 * 100
    };
  }

  private hexToRgb(hex: string): { r: number; g: number; b: number } {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : { r: 0, g: 0, b: 0 };
  }
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Ref MCP: Search docs for OpenAI integration, color theory libraries, florist best practices
- [x] PostgreSQL MCP: Database operations for flower data and analytics storage
- [x] Supabase MCP: Real-time updates and data synchronization
- [x] Sequential Thinking MCP: Complex flower selection algorithms and arrangement optimization strategies  
- [x] Browser MCP: Interactive testing of florist tools and color picker components
- [x] OpenAI MCP: Direct AI API calls for arrangement optimization and color palette generation

#### Ref MCP Searches Needed
```bash
# Use Ref MCP to search for:
# - "OpenAI structured output JSON mode wedding florist"
# - "Color theory LAB color space JavaScript conversion"
# - "React color picker components florist tools"
# - "Sustainability scoring algorithms carbon footprint flowers"
# - "Wedding flower seasonality database best practices"
```

#### Browser MCP Interactive Testing
```bash
# Use Browser MCP for:
# - Test flower search interface with multiple filter combinations
# - Verify color palette generation with visual color harmony
# - Test arrangement optimizer drag-and-drop functionality
# - Capture screenshots of sustainability analysis visualizations
# - Test mobile responsiveness of florist intelligence tools
# - Verify allergen checker alerts and alternative suggestions
# - Test integration with wedding planning workflow
```

#### Sequential Thinking MCP Planning (For Complex Features)
```yaml
# Use Sequential Thinking MCP to optimize florist intelligence:

# 1. Flower Recommendation Algorithm
- How to balance seasonal availability vs client color preferences?
- What weighting factors produce most satisfactory florist outcomes?
- How to handle regional variations in flower availability?

# 2. Color Harmony Optimization
- What color matching tolerance works best for real flowers?
- How to account for natural color variations in flowers?
- When to suggest palette modifications vs exact color matching?

# 3. Sustainability Scoring Complexity
- How to weigh carbon footprint vs local availability vs cost?
- What sustainability factors matter most to wedding couples?
- How to make sustainability recommendations actionable for florists?

# 4. Arrangement Optimization Intelligence
- What arrangement principles can be codified for AI assistance?
- How to balance AI suggestions with florist creativity and expertise?
- What techniques improve arrangement longevity and visual impact?
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('FloristIntelligenceService', () => {
  it('should return seasonally appropriate flowers for given month', async () => {
    const service = new FloristIntelligenceService();
    const results = await service.searchFlowersWithIntelligence({
      wedding_date: new Date('2024-06-15'), // June
      region: 'US'
    });
    
    expect(results.flowers.length).toBeGreaterThan(0);
    expect(results.flowers[0].seasonal_score).toBeGreaterThan(0.5);
  });

  it('should match flowers to specified colors accurately', async () => {
    const service = new FloristIntelligenceService();
    const results = await service.searchFlowersWithIntelligence({
      colors: ['#FF69B4', '#FFFFFF'], // Pink and white
    });
    
    expect(results.flowers.every(f => f.color_match_score > 0.3)).toBe(true);
  });
});

describe('ColorPaletteGenerator', () => {
  it('should generate harmonious color palette from base colors', async () => {
    const generator = new ColorPaletteGenerator();
    const palette = await generator.generateWeddingColorPalette(
      ['#FF69B4'], // Pink base
      'romantic',
      'spring'
    );
    
    expect(palette.primary_palette.primary_colors.length).toBeGreaterThanOrEqual(2);
    expect(palette.primary_palette.accent_colors.length).toBeGreaterThanOrEqual(1);
    expect(palette.flower_matches.length).toBeGreaterThan(0);
  });

  it('should find appropriate seasonal alternatives when needed', async () => {
    const generator = new ColorPaletteGenerator();
    const palette = await generator.generateWeddingColorPalette(
      ['#8B4513'], // Brown (challenging for flowers)
      'rustic',
      'winter'
    );
    
    if (palette.seasonal_analysis.overall_fit < 0.6) {
      expect(palette.alternatives.length).toBeGreaterThan(0);
    }
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP for automated testing
test('Florist intelligence tools - flower search and recommendations', async () => {
  await mcp__playwright__browser_navigate({url: '/florist/intelligence'});
  
  // Test flower search functionality
  await mcp__playwright__browser_fill_form([
    {name: 'wedding-date', type: 'textbox', ref: '[data-testid="wedding-date"]', value: '2024-07-15'},
    {name: 'color-selection', type: 'textbox', ref: '[data-testid="color-picker"]', value: '#FF69B4'},
    {name: 'wedding-style', type: 'combobox', ref: '[data-testid="wedding-style"]', value: 'romantic'}
  ]);
  
  await mcp__playwright__browser_click({
    element: 'search flowers button',
    ref: '[data-testid="search-flowers"]'
  });
  
  // Verify flower results appear
  await mcp__playwright__browser_wait_for({text: 'Recommended Flowers'});
  
  // Check seasonal scoring is displayed
  await mcp__playwright__browser_wait_for({text: 'Seasonal Score'});
  
  // Take screenshot for documentation
  await mcp__playwright__browser_take_screenshot({
    filename: 'florist-flower-search-results.png',
    fullPage: true
  });
});

test('Color palette generation with flower matching', async () => {
  await mcp__playwright__browser_navigate({url: '/florist/color-palette'});
  
  // Add base colors
  await mcp__playwright__browser_click({
    element: 'add color button',
    ref: '[data-testid="add-base-color"]'
  });
  
  // Set color value
  await mcp__playwright__browser_type({
    element: 'color input',
    ref: '[data-testid="color-input-0"]',
    text: '#D2691E'
  });
  
  // Set style and season
  await mcp__playwright__browser_fill_form([
    {name: 'wedding-style', type: 'combobox', ref: '[data-testid="style-select"]', value: 'rustic'},
    {name: 'season', type: 'combobox', ref: '[data-testid="season-select"]', value: 'fall'}
  ]);
  
  // Generate palette
  await mcp__playwright__browser_click({
    element: 'generate palette button',
    ref: '[data-testid="generate-palette"]'
  });
  
  // Wait for AI generation
  await mcp__playwright__browser_wait_for({text: 'Color Palette Generated'});
  
  // Verify flower matches are shown
  await mcp__playwright__browser_wait_for({text: 'Matching Flowers'});
  
  // Take screenshot of color palette results
  await mcp__playwright__browser_take_screenshot({
    filename: 'color-palette-with-flowers.png'
  });
});

test('Sustainability analysis and carbon footprint', async () => {
  await mcp__playwright__browser_navigate({url: '/florist/sustainability'});
  
  // Add flowers to analyze
  await mcp__playwright__browser_click({
    element: 'add flower button',
    ref: '[data-testid="add-flower"]'
  });
  
  // Search and select a flower
  await mcp__playwright__browser_type({
    element: 'flower search',
    ref: '[data-testid="flower-search"]',
    text: 'roses'
  });
  
  await mcp__playwright__browser_click({
    element: 'first flower result',
    ref: '[data-testid="flower-result-0"]'
  });
  
  // Set location for distance calculation
  await mcp__playwright__browser_type({
    element: 'wedding location',
    ref: '[data-testid="wedding-location"]',
    text: 'New York, NY'
  });
  
  // Run sustainability analysis
  await mcp__playwright__browser_click({
    element: 'analyze sustainability',
    ref: '[data-testid="analyze-sustainability"]'
  });
  
  // Verify analysis results
  await mcp__playwright__browser_wait_for({text: 'Sustainability Score'});
  await mcp__playwright__browser_wait_for({text: 'Carbon Footprint'});
  
  // Take screenshot of sustainability analysis
  await mcp__playwright__browser_take_screenshot({
    filename: 'sustainability-analysis.png'
  });
});
```

#### Interactive Testing with Browser MCP
```typescript
// Use Browser MCP during development for immediate feedback
// 1. Test color picker and harmony visualization
await browser_navigate('/florist/color-palette');

// Test different color combinations
const testColors = ['#FF69B4', '#32CD32', '#4169E1', '#FFD700'];
for (let i = 0; i < testColors.length; i++) {
  await browser_click(`[data-testid="add-base-color"]`);
  await browser_type(`[data-testid="color-input-${i}"]`, testColors[i]);
}

await browser_click('[data-testid="generate-palette"]');
await browser_wait_for('Color Palette Generated');
await browser_take_screenshot('multi-color-palette-test.png');

// 2. Test seasonal flower recommendations
const seasons = ['spring', 'summer', 'fall', 'winter'];
for (const season of seasons) {
  await browser_navigate('/florist/intelligence');
  
  await browser_fill_form([
    {name: 'season', type: 'combobox', ref: '[data-testid="season-select"]', value: season},
    {name: 'wedding-date', type: 'textbox', ref: '[data-testid="wedding-date"]', value: `2024-${season === 'spring' ? '04' : season === 'summer' ? '07' : season === 'fall' ? '10' : '01'}-15`}
  ]);
  
  await browser_click('[data-testid="search-flowers"]');
  await browser_wait_for('Seasonal Score');
  await browser_take_screenshot(`seasonal-flowers-${season}.png`);
}

// 3. Test mobile responsiveness
await browser_resize(375, 667);
await browser_navigate('/florist/intelligence');
await browser_take_screenshot('florist-tools-mobile.png');

// Test arrangement planner mobile interface  
await browser_navigate('/florist/arrangement-planner');
await browser_take_screenshot('arrangement-planner-mobile.png');
```

### ACCEPTANCE CRITERIA
- [x] **Comprehensive Flower Database**: 500+ flower varieties with seasonal, color, and sustainability data
- [x] **AI-Powered Color Harmony**: Generate wedding color palettes with flower matching and seasonal appropriateness analysis
- [x] **Seasonal Intelligence**: Accurate seasonal scoring and pricing predictions based on wedding date and location
- [x] **Sustainability Analysis**: Carbon footprint calculation, local sourcing recommendations, and sustainable alternatives
- [x] **Allergen Detection**: Comprehensive allergen risk analysis with alternative flower suggestions
- [x] **Arrangement Optimization**: AI-assisted arrangement design with technique recommendations and care instructions
- [x] **Color Matching Accuracy**: >95% accurate color matching using LAB color space calculations
- [ ] Performance: Flower search responds within 300ms, palette generation within 5 seconds
- [ ] Security: Flower database updates secured, user selections encrypted, AI prompts sanitized
- [ ] Accessibility: Color tools support screen readers, colorblind-friendly interfaces, WCAG 2.1 AA compliance
- [x] **Navigation Integration: Feature properly integrated into parent dashboard/navigation (MANDATORY for all UI features)**
  - [x] Florist Intelligence section added to florist dashboard under "Smart Design Tools"
  - [x] Mobile navigation includes flower icon for florist features
  - [x] Breadcrumb navigation shows "Dashboard > Florist Tools > AI Intelligence"  
  - [x] Active state highlighting for florist tool sections
  - [x] Accessibility labels for florist navigation ("AI-powered floral design tools")
  - [x] Navigation integration verified with Browser MCP testing

### DEPENDENCIES
- Must complete after: WS-252 (Music Database Integration) - shares vendor-specific AI patterns and database structures
- Must complete before: WS-254 (Catering Dietary Management) - establishes final vendor AI pattern for other specialties
- Shares code with: WS-129 (Florist Intelligence AI) - may be duplicate or related feature

### ESTIMATED EFFORT
- Team A Frontend: 48 hours (Florist intelligence interface, color tools, arrangement planner, mobile optimization)
- Team B Backend: 58 hours (Flower database, AI integration, sustainability engine, color matching algorithms)
- Team C Integration: 20 hours (OpenAI integration, color space calculations, external flower data APIs)
- Team D Platform: 16 hours (Database optimization, large dataset performance, image handling)
- Team E General: 26 hours (Testing, documentation, QA, flower data validation)
- Team F Workflows: 10 hours (Florist workflow design and integration with wedding planning)
- Team G Performance: 12 hours (Search optimization, color calculation performance, AI response caching)
- Total: 190 hours