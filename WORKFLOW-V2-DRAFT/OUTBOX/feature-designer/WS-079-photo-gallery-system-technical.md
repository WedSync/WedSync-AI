# TECHNICAL SPECIFICATION: WS-079 - Photo Gallery System
## Generated by Feature Development Session - August 22, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding photographer managing 2,000+ photos from Saturday's wedding
**I want to:** Create organized galleries that couples and vendors can access immediately
**So that:** The couple sees their sneak peeks within hours, and vendors get photos they need for marketing (with permission)

**Real Wedding Scenario:**
A photographer finishes a wedding at 10 PM. By tradition, couples expect "sneak peek" photos on social media the next morning. Currently, photographers manually upload to multiple platforms, send individual links to vendors, and manage access permissions separately. With our gallery system, they upload once, create "Sneak Peek" and "Vendor Marketing" galleries with different access levels, and everyone gets automatic notifications. The venue gets approved photos for their Instagram by 8 AM.

### SPECIFICATION SOURCE
- **Feature ID:** WS-079
- **Original Spec:** Wedding photo organization and sharing system
- **Current Implementation:** 0% complete
- **Files to Modify:**
  - /wedsync/src/app/(dashboard)/layout.tsx (add photos menu)
- **New Files to Create:**
  - /wedsync/src/app/(dashboard)/photos/page.tsx
  - /wedsync/src/app/(dashboard)/photos/galleries/[id]/page.tsx
  - /wedsync/src/app/(dashboard)/photos/upload/page.tsx
  - /wedsync/src/app/api/photos/galleries/route.ts
  - /wedsync/src/app/api/photos/upload/route.ts
  - /wedsync/src/app/api/photos/galleries/[id]/share/route.ts
  - /wedsync/src/components/photos/PhotoGallery.tsx
  - /wedsync/src/components/photos/PhotoUpload.tsx
  - /wedsync/src/components/photos/GalleryManager.tsx
  - /wedsync/src/lib/services/photoService.ts
  - /wedsync/src/lib/storage/photoStorage.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Photo galleries
CREATE TABLE IF NOT EXISTS photo_galleries (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  couple_id UUID NOT NULL REFERENCES couples(id),
  photographer_id UUID NOT NULL REFERENCES auth.users(id),
  gallery_name VARCHAR(255) NOT NULL,
  gallery_type VARCHAR(50) DEFAULT 'wedding', -- 'wedding', 'engagement', 'sneak_peek', 'vendor_marketing'
  description TEXT,
  cover_photo_url VARCHAR(500),
  is_public BOOLEAN DEFAULT false,
  password_protected BOOLEAN DEFAULT false,
  access_password VARCHAR(255), -- hashed
  download_enabled BOOLEAN DEFAULT true,
  watermark_enabled BOOLEAN DEFAULT false,
  expiry_date TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Photo items
CREATE TABLE IF NOT EXISTS gallery_photos (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  gallery_id UUID NOT NULL REFERENCES photo_galleries(id) ON DELETE CASCADE,
  photo_url VARCHAR(500) NOT NULL,
  thumbnail_url VARCHAR(500),
  original_filename VARCHAR(255),
  file_size INTEGER,
  width INTEGER,
  height INTEGER,
  taken_at TIMESTAMP WITH TIME ZONE,
  camera_info JSONB, -- EXIF data
  tags TEXT[], -- searchable tags
  is_featured BOOLEAN DEFAULT false,
  upload_order INTEGER DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Gallery access permissions
CREATE TABLE IF NOT EXISTS gallery_access (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  gallery_id UUID NOT NULL REFERENCES photo_galleries(id) ON DELETE CASCADE,
  user_email VARCHAR(255) NOT NULL,
  user_name VARCHAR(255),
  access_level VARCHAR(50) DEFAULT 'view', -- 'view', 'download', 'comment'
  granted_by UUID REFERENCES auth.users(id),
  granted_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  last_accessed TIMESTAMP WITH TIME ZONE,
  
  UNIQUE(gallery_id, user_email)
);

-- Photo likes/favorites
CREATE TABLE IF NOT EXISTS photo_favorites (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  photo_id UUID NOT NULL REFERENCES gallery_photos(id) ON DELETE CASCADE,
  user_email VARCHAR(255) NOT NULL,
  user_name VARCHAR(255),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  
  UNIQUE(photo_id, user_email)
);

CREATE INDEX idx_photo_galleries_couple ON photo_galleries(couple_id);
CREATE INDEX idx_gallery_photos_gallery ON gallery_photos(gallery_id);
CREATE INDEX idx_gallery_photos_featured ON gallery_photos(is_featured) WHERE is_featured = true;
CREATE INDEX idx_gallery_access_email ON gallery_access(user_email);
```

#### API Endpoints Required
```typescript
// GET /api/photos/galleries - Get user's photo galleries
interface GetGalleriesResponse {
  galleries: {
    id: string;
    name: string;
    type: string;
    photoCount: number;
    coverPhoto?: string;
    isPublic: boolean;
    passwordProtected: boolean;
    downloadEnabled: boolean;
    createdAt: string;
    accessLevel?: 'view' | 'download' | 'comment';
  }[];
}

// POST /api/photos/upload - Upload photos to gallery
interface PhotoUploadRequest {
  galleryId: string;
  photos: {
    file: File;
    filename: string;
    tags?: string[];
  }[];
}

// POST /api/photos/galleries - Create new gallery
interface CreateGalleryRequest {
  name: string;
  type: 'wedding' | 'engagement' | 'sneak_peek' | 'vendor_marketing';
  description?: string;
  isPublic: boolean;
  passwordProtected: boolean;
  password?: string;
  downloadEnabled: boolean;
  watermarkEnabled: boolean;
  expiryDate?: string;
}
```

#### Frontend Components Required
```typescript
// Component: PhotoGallery
// Location: /src/components/photos/PhotoGallery.tsx

interface PhotoGalleryProps {
  galleryId: string;
  accessLevel: 'view' | 'download' | 'comment';
  showFavorites?: boolean;
}

// Key functionality:
- Infinite scroll loading
- Lightbox view with navigation
- Download individual or bulk photos
- Favorite/like system
- Search and filter by tags
- Responsive masonry layout
- Keyboard navigation support

// Component: PhotoUpload
// Location: /src/components/photos/PhotoUpload.tsx

interface PhotoUploadProps {
  galleryId: string;
  onUploadComplete: (photos: Photo[]) => void;
}

// Key functionality:
- Drag and drop interface
- Multiple file selection
- Upload progress tracking
- Auto-tagging from EXIF data
- Batch operations
- Preview before upload
- Error handling and retry
```

### CODE EXAMPLES

#### Example 1: Photo Gallery with Infinite Scroll
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { useEffect, useState, useCallback } from 'react';
import { supabase } from '@/lib/supabase';
import { useInView } from 'react-intersection-observer';

export function PhotoGallery({ galleryId, accessLevel }: PhotoGalleryProps) {
  const [photos, setPhotos] = useState<Photo[]>([]);
  const [loading, setLoading] = useState(false);
  const [page, setPage] = useState(0);
  const [hasMore, setHasMore] = useState(true);
  const { ref, inView } = useInView();
  
  const loadPhotos = useCallback(async (pageNum: number) => {
    if (loading) return;
    
    setLoading(true);
    const { data, error } = await supabase
      .from('gallery_photos')
      .select(`
        id,
        photo_url,
        thumbnail_url,
        original_filename,
        width,
        height,
        tags,
        is_featured,
        photo_favorites(user_email)
      `)
      .eq('gallery_id', galleryId)
      .order('upload_order', { ascending: true })
      .range(pageNum * 20, (pageNum + 1) * 20 - 1);
    
    if (data) {
      if (pageNum === 0) {
        setPhotos(data);
      } else {
        setPhotos(prev => [...prev, ...data]);
      }
      setHasMore(data.length === 20);
    }
    setLoading(false);
  }, [galleryId, loading]);
  
  useEffect(() => {
    loadPhotos(0);
  }, [galleryId]);
  
  useEffect(() => {
    if (inView && hasMore && !loading) {
      const nextPage = page + 1;
      setPage(nextPage);
      loadPhotos(nextPage);
    }
  }, [inView, hasMore, loading, page, loadPhotos]);
  
  const toggleFavorite = async (photoId: string) => {
    const user = await getCurrentUser();
    
    // Check if already favorited
    const { data: existing } = await supabase
      .from('photo_favorites')
      .select('id')
      .eq('photo_id', photoId)
      .eq('user_email', user.email)
      .single();
    
    if (existing) {
      // Remove favorite
      await supabase
        .from('photo_favorites')
        .delete()
        .eq('photo_id', photoId)
        .eq('user_email', user.email);
    } else {
      // Add favorite
      await supabase
        .from('photo_favorites')
        .insert({
          photo_id: photoId,
          user_email: user.email,
          user_name: user.name
        });
    }
    
    // Update local state
    setPhotos(prev => prev.map(photo => 
      photo.id === photoId 
        ? { ...photo, isFavorited: !photo.isFavorited }
        : photo
    ));
  };
  
  const downloadPhoto = async (photoUrl: string, filename: string) => {
    if (accessLevel !== 'download') {
      alert('Download not permitted for this gallery');
      return;
    }
    
    const response = await fetch(`/api/photos/download?url=${encodeURIComponent(photoUrl)}`);
    const blob = await response.blob();
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    window.URL.revokeObjectURL(url);
  };
  
  return (
    <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
      {photos.map((photo) => (
        <div key={photo.id} className="relative group">
          <img
            src={photo.thumbnail_url}
            alt={photo.original_filename}
            className="w-full h-64 object-cover rounded-lg cursor-pointer"
            onClick={() => openLightbox(photo)}
          />
          
          <div className="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity">
            <button
              onClick={() => toggleFavorite(photo.id)}
              className={`p-1 rounded ${photo.isFavorited ? 'text-red-500' : 'text-white'}`}
            >
              <HeartIcon className="w-6 h-6" />
            </button>
            
            {accessLevel === 'download' && (
              <button
                onClick={() => downloadPhoto(photo.photo_url, photo.original_filename)}
                className="p-1 rounded text-white"
              >
                <DownloadIcon className="w-6 h-6" />
              </button>
            )}
          </div>
          
          {photo.is_featured && (
            <div className="absolute top-2 left-2">
              <span className="bg-yellow-500 text-white px-2 py-1 rounded text-xs">
                Featured
              </span>
            </div>
          )}
        </div>
      ))}
      
      {hasMore && (
        <div ref={ref} className="col-span-full text-center py-4">
          {loading ? 'Loading more photos...' : 'Load more'}
        </div>
      )}
    </div>
  );
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [ ] Context7: Load docs for image processing, file uploads, storage
- [ ] Playwright: Test photo gallery interface and uploads
- [ ] Filesystem: Access image optimization libraries

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/vercel/next.js", "file upload api routes", 2500);
await mcp__context7__get-library-docs("/supabase/storage-js", "image upload resize", 3000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('Photo Service', () => {
  it('should upload photos with metadata', async () => {
    const result = await photoService.uploadPhoto(mockFile, 'gallery-123');
    expect(result.url).toBeTruthy();
    expect(result.thumbnailUrl).toBeTruthy();
    expect(result.metadata.width).toBeGreaterThan(0);
  });
  
  it('should handle gallery access permissions', async () => {
    await photoService.grantAccess('gallery-123', 'user@example.com', 'download');
    const access = await photoService.checkAccess('gallery-123', 'user@example.com');
    expect(access.level).toBe('download');
  });
});
```

#### E2E Tests Required
```typescript
test('Photo gallery upload and sharing', async () => {
  await mcp__playwright__browser_navigate({url: '/photos/upload'});
  
  // Upload photos
  await mcp__playwright__browser_file_upload({
    paths: ['/path/to/test-wedding-photo.jpg']
  });
  
  // Wait for upload completion
  await mcp__playwright__browser_wait_for({text: "Upload complete"});
  
  // Share gallery
  await mcp__playwright__browser_click({
    element: "Share gallery button",
    ref: "button[data-testid='share-gallery']"
  });
  
  // Add email access
  await mcp__playwright__browser_type({
    element: "Email input",
    ref: "input[name='email']",
    text: "vendor@example.com"
  });
  
  await mcp__playwright__browser_click({
    element: "Grant access button",
    ref: "button[type='submit']"
  });
  
  await mcp__playwright__browser_wait_for({text: "Access granted"});
});
```

### ACCEPTANCE CRITERIA
- [ ] Upload multiple photos with drag-and-drop
- [ ] Automatic thumbnail generation
- [ ] Password protection for galleries
- [ ] Email-based access sharing
- [ ] Download individual or bulk photos
- [ ] Infinite scroll loading
- [ ] Mobile-responsive gallery view
- [ ] Search and filter by tags
- [ ] EXIF data extraction and display

### DEPENDENCIES
- Must complete after: WS-074/075 (User accounts)
- Must complete before: Vendor marketing features
- Shares code with: File storage system, user management

### ESTIMATED EFFORT
- Team C Integration: 24 hours (File upload, storage, image processing)
- Team B Backend: 20 hours (Gallery management, access control)
- Total: 44 hours