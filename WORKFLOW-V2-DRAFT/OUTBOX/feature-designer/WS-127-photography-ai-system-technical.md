# TECHNICAL SPECIFICATION: WS-127 - Photography AI System
## Generated by Feature Development Session - 2025-01-23

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding photographer managing 15 weddings per month across different venues and lighting conditions
**I want to:** Generate AI-powered shot lists and timeline recommendations based on venue, season, and lighting
**So that:** I reduce 2 hours of pre-wedding planning per client and never miss critical golden hour opportunities

**Real Wedding Scenario:**
A photographer books a wedding at a new vineyard venue for October. Instead of manually researching sunset times, analyzing venue photos, and creating shot lists from scratch, they enter the venue location and date. The AI calculates exact golden hour times (5:47 PM - 6:23 PM), generates a venue-specific shot list including "vineyard row portraits" and "barrel room group shots," and suggests optimal timeline placement for each photo session.

### SPECIFICATION SOURCE
- **Feature ID:** WS-127
- **Original Spec:** /CORE-SPECIFICATIONS/04-AI-INTEGRATION/05-Vendor-Specific/01-photography-ai md.md
- **Current Implementation:** 0% complete
- **Files to Modify:** None (new feature)
- **New Files to Create:**
  - /src/lib/ai/photography-ai.ts
  - /src/lib/services/photo-time-calculator.ts
  - /src/app/api/photography/shot-list/route.ts
  - /src/app/api/photography/timeline/route.ts
  - /src/components/photography/ShotListGenerator.tsx
  - /src/components/photography/PhotoTimelineOptimizer.tsx

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Venue photography intelligence
CREATE TABLE IF NOT EXISTS photo_venue_data (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  venue_id UUID REFERENCES venues(id),
  venue_name TEXT NOT NULL,
  coordinates POINT NOT NULL,
  best_photo_spots JSONB DEFAULT '[]',
  lighting_analysis JSONB DEFAULT '{}',
  seasonal_notes TEXT,
  photographer_tips TEXT[] DEFAULT '{}',
  weather_backup_spots JSONB DEFAULT '[]',
  ai_analyzed BOOLEAN DEFAULT false,
  last_updated TIMESTAMP DEFAULT NOW(),
  created_at TIMESTAMP DEFAULT NOW()
);

-- Generated shot lists
CREATE TABLE IF NOT EXISTS ai_shot_lists (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  photographer_id UUID REFERENCES user_profiles(id),
  client_id UUID REFERENCES clients(id),
  venue_id UUID REFERENCES venues(id),
  wedding_style TEXT,
  guest_count INTEGER,
  shot_categories JSONB NOT NULL, -- {must_have: [], family: [], creative: []}
  timeline_suggestions JSONB,
  special_requests TEXT,
  generated_at TIMESTAMP DEFAULT NOW(),
  customized BOOLEAN DEFAULT false
);

-- Optimal photo timing calculations
CREATE TABLE IF NOT EXISTS photo_timing_cache (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  venue_coordinates POINT NOT NULL,
  wedding_date DATE NOT NULL,
  sunrise_time TIMESTAMP,
  sunset_time TIMESTAMP,
  golden_hour_morning TIMESTAMP,
  golden_hour_evening TIMESTAMP,
  blue_hour TIMESTAMP,
  calculated_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(venue_coordinates, wedding_date)
);
```

#### API Endpoints Required
```typescript
// POST /api/photography/shot-list/generate
interface GenerateShotListRequest {
  venueId: string;
  weddingStyle: 'traditional' | 'modern' | 'rustic' | 'elegant' | 'bohemian';
  guestCount: number;
  specialRequests?: string;
  photographerId: string;
}

interface GenerateShotListResponse {
  success: boolean;
  data: {
    shotList: ShotListCategory[];
    venueSpecificShots: string[];
    timelineRecommendations: TimelineSlot[];
  };
}

// GET /api/photography/timeline/optimal-times
interface OptimalTimesRequest {
  venueCoordinates: { lat: number; lng: number };
  weddingDate: string;
}

interface OptimalTimesResponse {
  success: boolean;
  data: {
    sunrise: string;
    goldenHourMorning: string;
    sunset: string;
    goldenHourEvening: string;
    blueHour: string;
    recommendations: TimelineRecommendation[];
  };
}
```

#### Frontend Components Required
```typescript
// Component: ShotListGenerator
// Location: /src/components/photography/ShotListGenerator.tsx

interface ShotListGeneratorProps {
  clientId: string;
  venueData: VenueData;
  onShotListGenerated: (shotList: ShotListCategory[]) => void;
}

interface ShotListCategory {
  category: 'must_have' | 'family' | 'creative' | 'venue_specific';
  shots: Shot[];
  estimatedTime: number; // minutes
  optimalTiming: string; // 'golden_hour', 'ceremony', 'reception'
}

interface Shot {
  description: string;
  importance: 'critical' | 'recommended' | 'optional';
  location: string;
  lightingRequirement: string;
  equipment?: string[];
}

// Key functionality:
- Wedding style selection interface
- AI-generated shot list display with categorization
- Drag-and-drop shot prioritization
- Timeline integration with optimal timing suggestions
- Venue-specific shot recommendations
```

#### Integration Points
```typescript
// Service: PhotographyAIService
// Dependencies: OpenAI, Sunrise-Sunset API, Venue data, Weather API

class PhotographyAIService {
  async generateShotList(weddingDetails: WeddingInfo): Promise<ShotListCategory[]> {
    // AI-powered shot list generation
    // Venue-specific analysis
    // Style-based customization
    // Timeline optimization
  }
  
  async calculateOptimalTimes(venue: VenueData, date: Date): Promise<PhotoTiming> {
    // Sunrise/sunset API integration
    // Golden hour calculations
    // Seasonal adjustments
    // Weather contingency planning
  }
}
```

### CODE EXAMPLES

#### Example 1: AI Shot List Generation and Timing Optimization
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { OpenAI } from 'openai';
import { supabase } from '@/lib/supabase';

export class PhotographyAI {
  private openai = new OpenAI({
    apiKey: process.env.OPENAI_API_KEY
  });

  async generateShotList(weddingDetails: {
    venue: string;
    style: string;
    guestCount: number;
    specialRequests?: string;
    coordinates: { lat: number; lng: number };
    date: Date;
  }): Promise<ShotListCategory[]> {
    
    // Step 1: Get venue-specific intelligence
    const venueData = await this.getVenueIntelligence(weddingDetails.venue);
    
    // Step 2: Calculate optimal photo timing
    const photoTiming = await this.calculateOptimalTimes(
      weddingDetails.coordinates, 
      weddingDetails.date
    );
    
    // Step 3: Generate AI shot list
    const prompt = `Generate a comprehensive wedding shot list for:
    
    Venue: ${weddingDetails.venue}
    Style: ${weddingDetails.style}
    Guest Count: ${weddingDetails.guestCount}
    Special Requests: ${weddingDetails.specialRequests || 'None'}
    
    Venue Features: ${venueData.features.join(', ')}
    Best Photo Spots: ${venueData.photoSpots.join(', ')}
    
    Golden Hour: ${photoTiming.goldenHourEvening}
    Sunset: ${photoTiming.sunset}
    
    Return JSON with categories: must_have, family_portraits, creative_shots, venue_specific.
    Each shot should include: description, importance level, optimal timing, location.
    Focus on wedding photography best practices and this specific venue's opportunities.`;

    const completion = await this.openai.chat.completions.create({
      model: 'gpt-4',
      messages: [{ role: 'system', content: prompt }],
      response_format: { type: 'json_object' },
      temperature: 0.3 // Lower for consistency
    });

    const shotListData = JSON.parse(completion.choices[0].message.content);
    
    // Step 4: Structure and enhance the response
    const shotList = this.formatShotList(shotListData, photoTiming);
    
    // Step 5: Save generated shot list
    await this.saveShotList(shotList, weddingDetails);
    
    return shotList;
  }
  
  async calculateOptimalTimes(
    coordinates: { lat: number; lng: number }, 
    date: Date
  ): Promise<PhotoTiming> {
    // Check cache first
    const cached = await this.getCachedTiming(coordinates, date);
    if (cached) return cached;
    
    // Call sunrise-sunset API
    const dateStr = date.toISOString().split('T')[0];
    const response = await fetch(
      `https://api.sunrise-sunset.org/json?lat=${coordinates.lat}&lng=${coordinates.lng}&date=${dateStr}&formatted=0`
    );
    
    const data = await response.json();
    
    const photoTiming: PhotoTiming = {
      sunrise: new Date(data.results.sunrise),
      sunset: new Date(data.results.sunset),
      goldenHourMorning: this.addMinutes(new Date(data.results.sunrise), 60),
      goldenHourEvening: this.subtractMinutes(new Date(data.results.sunset), 60),
      blueHour: this.addMinutes(new Date(data.results.sunset), 30),
      recommendations: this.generateTimelineRecommendations(data.results)
    };
    
    // Cache the results
    await supabase.from('photo_timing_cache').insert({
      venue_coordinates: `(${coordinates.lat},${coordinates.lng})`,
      wedding_date: date,
      sunrise_time: photoTiming.sunrise,
      sunset_time: photoTiming.sunset,
      golden_hour_morning: photoTiming.goldenHourMorning,
      golden_hour_evening: photoTiming.goldenHourEvening,
      blue_hour: photoTiming.blueHour
    });
    
    return photoTiming;
  }
  
  private async getVenueIntelligence(venueName: string): Promise<VenueIntelligence> {
    // Check existing venue data
    const { data } = await supabase
      .from('photo_venue_data')
      .select('*')
      .ilike('venue_name', `%${venueName}%`)
      .single();
      
    if (data) {
      return {
        features: data.lighting_analysis.features || [],
        photoSpots: data.best_photo_spots || [],
        tips: data.photographer_tips || []
      };
    }
    
    // If no existing data, return generic recommendations
    return {
      features: ['natural lighting', 'architectural elements'],
      photoSpots: ['ceremony site', 'reception area', 'entrance'],
      tips: ['Scout location in advance', 'Plan for weather backup']
    };
  }
  
  private formatShotList(aiResponse: any, timing: PhotoTiming): ShotListCategory[] {
    const categories: ShotListCategory[] = [];
    
    // Process each category from AI response
    Object.entries(aiResponse).forEach(([categoryName, shots]: [string, any[]]) => {
      if (Array.isArray(shots)) {
        categories.push({
          category: categoryName as any,
          shots: shots.map(shot => ({
            description: shot.description,
            importance: shot.importance || 'recommended',
            location: shot.location || 'venue',
            lightingRequirement: this.determineLighting(shot, timing),
            equipment: shot.equipment || []
          })),
          estimatedTime: shots.length * 3, // 3 minutes per shot estimate
          optimalTiming: this.determineOptimalTiming(categoryName, timing)
        });
      }
    });
    
    return categories;
  }
  
  private addMinutes(date: Date, minutes: number): Date {
    return new Date(date.getTime() + minutes * 60000);
  }
  
  private subtractMinutes(date: Date, minutes: number): Date {
    return new Date(date.getTime() - minutes * 60000);
  }
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [ ] Context7: Load docs for photography APIs and timing calculations
- [ ] Playwright: Test shot list generation and timeline optimization UI
- [ ] Filesystem: Access venue data and photo timing cache

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/openai/openai-node", "structured output", 2000);
// External API documentation for sunrise-sunset calculations
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('PhotographyAI', () => {
  it('should generate venue-specific shot list for rustic wedding', async () => {
    const weddingDetails = {
      venue: 'Rustic Barn Venue',
      style: 'rustic',
      guestCount: 120,
      coordinates: { lat: 40.7128, lng: -74.0060 },
      date: new Date('2025-06-15')
    };
    
    const shotList = await photographyAI.generateShotList(weddingDetails);
    
    expect(shotList).toHaveLength(4); // 4 categories
    expect(shotList[0].category).toBe('must_have');
    expect(shotList.some(cat => 
      cat.shots.some(shot => shot.description.toLowerCase().includes('barn'))
    )).toBe(true);
  });
  
  it('should calculate accurate golden hour times', async () => {
    const coordinates = { lat: 40.7128, lng: -74.0060 }; // NYC
    const date = new Date('2025-06-21'); // Summer solstice
    
    const timing = await photographyAI.calculateOptimalTimes(coordinates, date);
    
    expect(timing.goldenHourEvening).toBeInstanceOf(Date);
    expect(timing.goldenHourEvening.getTime()).toBeLessThan(timing.sunset.getTime());
    expect(timing.blueHour.getTime()).toBeGreaterThan(timing.sunset.getTime());
  });
  
  it('should cache venue timing calculations', async () => {
    const coords = { lat: 34.0522, lng: -118.2437 };
    const date = new Date('2025-08-15');
    
    await photographyAI.calculateOptimalTimes(coords, date);
    
    // Verify cache entry exists
    const { data } = await supabase
      .from('photo_timing_cache')
      .select('*')
      .eq('wedding_date', date.toISOString().split('T')[0])
      .single();
      
    expect(data).toBeDefined();
    expect(data.sunrise_time).toBeDefined();
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Photography AI workflow', async () => {
  await mcp__playwright__browser_navigate({url: '/photography/shot-list'});
  
  // Fill wedding details
  await mcp__playwright__browser_select_option({
    element: 'Wedding Style Dropdown',
    ref: 'select[name="weddingStyle"]',
    values: ['rustic']
  });
  
  await mcp__playwright__browser_type({
    element: 'Guest Count Input',
    ref: 'input[name="guestCount"]',
    text: '150'
  });
  
  await mcp__playwright__browser_click({element: 'Generate Shot List Button', ref: 'button[type="submit"]'});
  
  // Wait for AI generation
  await mcp__playwright__browser_wait_for({text: 'Shot list generated successfully'});
  
  // Verify shot categories are displayed
  await mcp__playwright__browser_wait_for({text: 'Must Have Shots'});
  await mcp__playwright__browser_wait_for({text: 'Golden Hour:'});
  
  await mcp__playwright__browser_snapshot();
});
```

### ACCEPTANCE CRITERIA
- [ ] Generate venue-specific shot lists with 90% photographer approval rate
- [ ] Calculate accurate sunrise/sunset times within 2-minute precision
- [ ] Provide golden hour recommendations for all wedding dates
- [ ] Support 5 wedding styles (traditional, modern, rustic, elegant, bohemian)
- [ ] Cache venue analysis to improve performance (sub-3-second response)
- [ ] Include weather backup location suggestions
- [ ] Generate timeline recommendations aligned with optimal lighting

### DEPENDENCIES
- Must complete after: None - Can start immediately
- Must complete before: Timeline builder integration features
- Shares code with: AI content generation infrastructure, venue data management

### ESTIMATED EFFORT
- Team A Frontend: 22 hours (Shot list UI, timeline optimizer, venue analysis display)
- Team B Backend: 18 hours (AI integration, timing calculations, venue intelligence)
- Team C Integration: 10 hours (External APIs, caching, venue data processing)
- Total: 50 hours