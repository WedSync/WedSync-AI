# TECHNICAL SPECIFICATION: WS-354 - Invoice Generator System
## Generated by Feature Development Session - 2025-01-20

### USER STORY & BUSINESS CONTEXT
**As a:** Wedding supplier (photographer, venue, caterer, florist, planner)
**I want to:** Generate professional invoices automatically from contracts, track payments, and manage billing workflows
**So that:** I can reduce invoicing time by 90%, eliminate payment delays, and maintain cash flow with automated payment reminders

**Real Wedding Scenario:**
Emma, a wedding photographer, just finished a couple's engagement shoot. Instead of manually creating an invoice in Word and calculating complex package pricing, she opens WedSync and clicks "Generate Invoice" on the completed milestone. The system automatically pulls pricing from the signed contract, applies any discounts, calculates tax, and generates a branded PDF invoice in seconds. It emails the invoice to the couple with a Stripe payment link, automatically schedules follow-up reminders, and updates her cash flow dashboard. When payment is received, it automatically marks the invoice as paid and triggers the next milestone invoice.

**Business Impact:**
- 82% of wedding suppliers spend 2-4 hours per week on manual invoicing
- 45% experience cash flow issues due to late payments
- 67% lose money on forgotten or delayed invoicing
- Average 18-day payment delay with manual invoicing vs 7 days with automated systems
- 23% of supplier disputes involve unclear or incorrect billing

### SPECIFICATION SOURCE
- **Feature ID:** WS-354
- **Original Spec:** /CORE-SPECIFICATIONS/billing-automation/invoice-generator/
- **Current Implementation:** 0% complete (new feature)
- **Files to Modify:**
  - Contract management system integration
  - Payment processing interfaces
  - Email notification system
- **New Files to Create:**
  - Invoice generation engine
  - Payment tracking dashboard
  - Automated reminder system
  - Tax calculation service

### TECHNICAL DESIGN

#### Database Schema Required

```sql
-- Invoice templates and configuration
CREATE TABLE invoice_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
  template_name VARCHAR(255) NOT NULL,
  template_description TEXT,
  
  -- Template structure and content
  template_content JSONB NOT NULL DEFAULT '{
    "header": {
      "show_logo": true,
      "show_business_details": true,
      "show_invoice_number": true,
      "show_invoice_date": true,
      "show_due_date": true
    },
    "line_items": {
      "show_description": true,
      "show_quantity": true,
      "show_unit_price": true,
      "show_total": true,
      "allow_discounts": true
    },
    "footer": {
      "show_payment_terms": true,
      "show_bank_details": false,
      "show_thank_you_message": true,
      "custom_notes": ""
    }
  }',
  
  -- Styling and branding
  template_styling JSONB DEFAULT '{
    "primary_color": "#2D3748",
    "secondary_color": "#4A5568",
    "accent_color": "#3182CE",
    "font_family": "Inter",
    "font_size": 11,
    "logo_position": "top-left",
    "layout": "modern"
  }',
  
  -- Automation settings
  automation_settings JSONB DEFAULT '{
    "auto_send_on_generation": false,
    "payment_reminder_days": [7, 3, 1],
    "overdue_reminder_days": [1, 7, 14, 30],
    "auto_apply_late_fees": false,
    "late_fee_percentage": 0.0,
    "payment_terms_days": 30,
    "auto_mark_paid_on_payment": true
  }',
  
  -- Usage tracking
  usage_count INTEGER DEFAULT 0,
  last_used_at TIMESTAMPTZ,
  is_default BOOLEAN DEFAULT FALSE,
  template_status VARCHAR(20) CHECK (template_status IN ('active', 'draft', 'archived')) DEFAULT 'active',
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(supplier_id, template_name)
);

-- Core invoices table
CREATE TABLE invoices (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
  template_id UUID REFERENCES invoice_templates(id),
  contract_id UUID REFERENCES contracts(id) ON DELETE SET NULL,
  wedding_id UUID REFERENCES weddings(id) ON DELETE SET NULL,
  couple_id UUID REFERENCES couples(id) ON DELETE SET NULL,
  
  -- Invoice identification
  invoice_number VARCHAR(50) NOT NULL,
  invoice_reference VARCHAR(100), -- Custom reference
  
  -- Invoice details
  invoice_date DATE NOT NULL DEFAULT CURRENT_DATE,
  due_date DATE NOT NULL,
  
  -- Customer information
  bill_to_name VARCHAR(255) NOT NULL,
  bill_to_email VARCHAR(255) NOT NULL,
  bill_to_address TEXT,
  bill_to_phone VARCHAR(50),
  
  -- Amounts and calculations
  subtotal_amount DECIMAL(12,2) NOT NULL DEFAULT 0.00,
  discount_amount DECIMAL(12,2) DEFAULT 0.00,
  discount_percentage DECIMAL(5,2) DEFAULT 0.00,
  tax_amount DECIMAL(12,2) DEFAULT 0.00,
  tax_percentage DECIMAL(5,4) DEFAULT 0.0000, -- VAT rate
  total_amount DECIMAL(12,2) NOT NULL,
  amount_paid DECIMAL(12,2) DEFAULT 0.00,
  amount_due DECIMAL(12,2) GENERATED ALWAYS AS (total_amount - amount_paid) STORED,
  
  -- Status and workflow
  invoice_status VARCHAR(50) CHECK (invoice_status IN (
    'draft', 'sent', 'viewed', 'partial_payment', 'paid', 'overdue', 'cancelled', 'refunded'
  )) DEFAULT 'draft',
  
  -- Payment tracking
  payment_method VARCHAR(50),
  payment_reference VARCHAR(255),
  payment_terms VARCHAR(255) DEFAULT 'Net 30',
  late_fee_applied DECIMAL(12,2) DEFAULT 0.00,
  
  -- Delivery and tracking
  sent_to_email VARCHAR(255),
  sent_at TIMESTAMPTZ,
  first_viewed_at TIMESTAMPTZ,
  last_viewed_at TIMESTAMPTZ,
  view_count INTEGER DEFAULT 0,
  download_count INTEGER DEFAULT 0,
  
  -- File management
  file_path TEXT, -- Generated PDF location
  file_size INTEGER,
  
  -- Currency and locale
  currency_code CHAR(3) DEFAULT 'GBP',
  locale_code VARCHAR(5) DEFAULT 'en-GB',
  
  -- Notes and custom fields
  public_notes TEXT, -- Visible to client
  private_notes TEXT, -- Internal only
  custom_fields JSONB DEFAULT '{}',
  
  -- Automation tracking
  reminder_count INTEGER DEFAULT 0,
  last_reminder_sent_at TIMESTAMPTZ,
  next_reminder_due_at TIMESTAMPTZ,
  
  -- Search indexing
  search_vector TSVECTOR GENERATED ALWAYS AS (
    to_tsvector('english', 
      invoice_number || ' ' || 
      bill_to_name || ' ' || 
      COALESCE(invoice_reference, '') || ' ' ||
      COALESCE(public_notes, '')
    )
  ) STORED,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(supplier_id, invoice_number)
);

-- Invoice line items
CREATE TABLE invoice_line_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  invoice_id UUID NOT NULL REFERENCES invoices(id) ON DELETE CASCADE,
  
  -- Line item details
  line_order INTEGER NOT NULL DEFAULT 1,
  item_description TEXT NOT NULL,
  item_category VARCHAR(100), -- e.g., 'photography', 'extras', 'travel'
  
  -- Pricing and quantities
  quantity DECIMAL(10,3) DEFAULT 1.000,
  unit_price DECIMAL(12,2) NOT NULL,
  line_discount_amount DECIMAL(12,2) DEFAULT 0.00,
  line_discount_percentage DECIMAL(5,2) DEFAULT 0.00,
  line_total DECIMAL(12,2) GENERATED ALWAYS AS (
    (quantity * unit_price) - line_discount_amount - ((quantity * unit_price) * line_discount_percentage / 100)
  ) STORED,
  
  -- Tax handling
  is_taxable BOOLEAN DEFAULT TRUE,
  tax_rate DECIMAL(5,4) DEFAULT 0.0000,
  
  -- Contract integration
  contract_line_item_id UUID, -- Link to original contract item
  milestone_id UUID, -- If invoicing a specific milestone
  
  -- Custom data
  custom_data JSONB DEFAULT '{}',
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Payment records linked to invoices
CREATE TABLE invoice_payments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  invoice_id UUID NOT NULL REFERENCES invoices(id) ON DELETE CASCADE,
  
  -- Payment details
  payment_amount DECIMAL(12,2) NOT NULL,
  payment_date DATE NOT NULL DEFAULT CURRENT_DATE,
  payment_method VARCHAR(50) NOT NULL, -- 'stripe', 'bank_transfer', 'cash', 'cheque'
  payment_reference VARCHAR(255),
  
  -- Payment processor integration
  stripe_payment_intent_id VARCHAR(255),
  stripe_charge_id VARCHAR(255),
  processor_fee_amount DECIMAL(12,2) DEFAULT 0.00,
  net_payment_amount DECIMAL(12,2) GENERATED ALWAYS AS (payment_amount - processor_fee_amount) STORED,
  
  -- Status and verification
  payment_status VARCHAR(50) CHECK (payment_status IN (
    'pending', 'processing', 'completed', 'failed', 'cancelled', 'refunded'
  )) DEFAULT 'completed',
  
  -- Refund handling
  refunded_amount DECIMAL(12,2) DEFAULT 0.00,
  refund_reason TEXT,
  refunded_at TIMESTAMPTZ,
  
  -- Notes and metadata
  payment_notes TEXT,
  metadata JSONB DEFAULT '{}',
  
  -- Reconciliation
  is_reconciled BOOLEAN DEFAULT FALSE,
  reconciled_at TIMESTAMPTZ,
  reconciled_by UUID REFERENCES users(id),
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Invoice reminders and communications
CREATE TABLE invoice_reminders (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  invoice_id UUID NOT NULL REFERENCES invoices(id) ON DELETE CASCADE,
  
  -- Reminder details
  reminder_type VARCHAR(50) CHECK (reminder_type IN (
    'payment_due', 'overdue', 'final_notice', 'thank_you', 'payment_confirmation'
  )) NOT NULL,
  
  -- Scheduling
  scheduled_for TIMESTAMPTZ NOT NULL,
  sent_at TIMESTAMPTZ,
  
  -- Communication details
  recipient_email VARCHAR(255) NOT NULL,
  subject_line TEXT NOT NULL,
  message_content TEXT NOT NULL,
  
  -- Delivery tracking
  email_delivered BOOLEAN DEFAULT FALSE,
  email_opened BOOLEAN DEFAULT FALSE,
  email_clicked BOOLEAN DEFAULT FALSE,
  
  -- Status
  reminder_status VARCHAR(30) CHECK (reminder_status IN (
    'scheduled', 'sent', 'delivered', 'failed', 'cancelled'
  )) DEFAULT 'scheduled',
  
  -- Automation tracking
  is_automated BOOLEAN DEFAULT TRUE,
  
  -- Error handling
  delivery_attempts INTEGER DEFAULT 0,
  last_error TEXT,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Invoice numbering sequences
CREATE TABLE invoice_number_sequences (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
  
  -- Sequence configuration
  sequence_name VARCHAR(100) DEFAULT 'default',
  sequence_prefix VARCHAR(20) DEFAULT 'INV',
  sequence_separator VARCHAR(5) DEFAULT '-',
  sequence_suffix VARCHAR(20) DEFAULT '',
  
  -- Numbering pattern
  current_number INTEGER NOT NULL DEFAULT 1,
  increment_by INTEGER DEFAULT 1,
  minimum_digits INTEGER DEFAULT 4, -- Zero-pad to this width
  
  -- Date-based numbering
  reset_annually BOOLEAN DEFAULT FALSE,
  reset_monthly BOOLEAN DEFAULT FALSE,
  include_year BOOLEAN DEFAULT FALSE,
  include_month BOOLEAN DEFAULT FALSE,
  
  -- Usage tracking
  last_used_at TIMESTAMPTZ,
  last_generated_number VARCHAR(50),
  
  -- Status
  is_active BOOLEAN DEFAULT TRUE,
  is_default BOOLEAN DEFAULT FALSE,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(supplier_id, sequence_name)
);

-- Tax configuration for suppliers
CREATE TABLE supplier_tax_settings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
  
  -- Tax registration
  tax_registered BOOLEAN DEFAULT FALSE,
  tax_registration_number VARCHAR(50),
  tax_registration_country CHAR(2) DEFAULT 'GB',
  
  -- Default tax rates
  default_tax_rate DECIMAL(5,4) DEFAULT 0.2000, -- 20% UK VAT
  tax_rate_name VARCHAR(50) DEFAULT 'VAT',
  
  -- Tax-inclusive pricing
  prices_include_tax BOOLEAN DEFAULT FALSE,
  
  -- Tax exemptions and special cases
  tax_exempt_services TEXT[], -- Array of service categories that are tax-exempt
  
  -- Reporting preferences
  tax_reporting_method VARCHAR(20) CHECK (tax_reporting_method IN ('cash', 'accrual')) DEFAULT 'accrual',
  
  -- Configuration
  is_active BOOLEAN DEFAULT TRUE,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(supplier_id)
);

-- Invoice analytics and reporting
CREATE TABLE invoice_analytics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
  invoice_id UUID REFERENCES invoices(id) ON DELETE SET NULL,
  
  -- Event tracking
  event_type VARCHAR(50) CHECK (event_type IN (
    'invoice_created', 'invoice_sent', 'invoice_viewed', 'invoice_downloaded',
    'payment_received', 'reminder_sent', 'invoice_cancelled', 'invoice_refunded'
  )) NOT NULL,
  
  -- Context data
  event_data JSONB DEFAULT '{}',
  session_id UUID,
  user_agent TEXT,
  ip_address INET,
  
  -- Metrics
  amount_involved DECIMAL(12,2),
  response_time_ms INTEGER,
  
  -- Attribution
  campaign_source VARCHAR(100),
  utm_parameters JSONB DEFAULT '{}',
  
  recorded_at TIMESTAMPTZ DEFAULT NOW()
);

-- Recurring invoice templates
CREATE TABLE recurring_invoice_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
  template_id UUID REFERENCES invoice_templates(id),
  
  -- Recurrence configuration
  template_name VARCHAR(255) NOT NULL,
  recurrence_pattern VARCHAR(20) CHECK (recurrence_pattern IN (
    'weekly', 'bi_weekly', 'monthly', 'quarterly', 'semi_annual', 'annual'
  )) NOT NULL,
  recurrence_interval INTEGER DEFAULT 1, -- Every N periods
  
  -- Schedule
  start_date DATE NOT NULL,
  end_date DATE,
  max_occurrences INTEGER,
  
  -- Invoice details template
  base_invoice_data JSONB NOT NULL, -- Template for creating invoices
  
  -- Status and tracking
  current_occurrences INTEGER DEFAULT 0,
  next_invoice_date DATE,
  last_generated_at TIMESTAMPTZ,
  
  -- Settings
  is_active BOOLEAN DEFAULT TRUE,
  auto_send BOOLEAN DEFAULT FALSE,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(supplier_id, template_name)
);

-- Indexing for performance
CREATE INDEX idx_invoices_supplier ON invoices(supplier_id);
CREATE INDEX idx_invoices_status ON invoices(invoice_status);
CREATE INDEX idx_invoices_due_date ON invoices(due_date);
CREATE INDEX idx_invoices_invoice_date ON invoices(invoice_date DESC);
CREATE INDEX idx_invoices_amount_due ON invoices(amount_due DESC);
CREATE INDEX idx_invoices_search ON invoices USING GIN(search_vector);
CREATE INDEX idx_invoices_customer_email ON invoices(bill_to_email);

CREATE INDEX idx_invoice_line_items_invoice ON invoice_line_items(invoice_id);
CREATE INDEX idx_invoice_line_items_order ON invoice_line_items(invoice_id, line_order);

CREATE INDEX idx_invoice_payments_invoice ON invoice_payments(invoice_id);
CREATE INDEX idx_invoice_payments_date ON invoice_payments(payment_date DESC);
CREATE INDEX idx_invoice_payments_status ON invoice_payments(payment_status);
CREATE INDEX idx_invoice_payments_stripe_intent ON invoice_payments(stripe_payment_intent_id);

CREATE INDEX idx_invoice_reminders_invoice ON invoice_reminders(invoice_id);
CREATE INDEX idx_invoice_reminders_scheduled ON invoice_reminders(scheduled_for);
CREATE INDEX idx_invoice_reminders_status ON invoice_reminders(reminder_status);

CREATE INDEX idx_invoice_analytics_supplier ON invoice_analytics(supplier_id);
CREATE INDEX idx_invoice_analytics_event ON invoice_analytics(event_type);
CREATE INDEX idx_invoice_analytics_recorded ON invoice_analytics(recorded_at DESC);

CREATE INDEX idx_recurring_templates_supplier ON recurring_invoice_templates(supplier_id);
CREATE INDEX idx_recurring_templates_next_date ON recurring_invoice_templates(next_invoice_date);
CREATE INDEX idx_recurring_templates_active ON recurring_invoice_templates(is_active);

-- Insert default invoice template
INSERT INTO invoice_templates (supplier_id, template_name, template_description, is_default)
SELECT 
  s.id,
  'Default Invoice Template',
  'Professional invoice template with modern styling',
  TRUE
FROM suppliers s
WHERE NOT EXISTS (
  SELECT 1 FROM invoice_templates it WHERE it.supplier_id = s.id AND it.is_default = TRUE
);

-- Insert default invoice number sequence
INSERT INTO invoice_number_sequences (supplier_id, is_default)
SELECT s.id, TRUE
FROM suppliers s
WHERE NOT EXISTS (
  SELECT 1 FROM invoice_number_sequences ins WHERE ins.supplier_id = s.id AND ins.is_default = TRUE
);
```

#### API Endpoints Required

```typescript
// Invoice management interfaces
interface Invoice {
  id: string;
  supplier_id: string;
  template_id?: string;
  contract_id?: string;
  wedding_id?: string;
  couple_id?: string;
  invoice_number: string;
  invoice_reference?: string;
  invoice_date: string;
  due_date: string;
  bill_to_name: string;
  bill_to_email: string;
  bill_to_address?: string;
  bill_to_phone?: string;
  subtotal_amount: number;
  discount_amount: number;
  discount_percentage: number;
  tax_amount: number;
  tax_percentage: number;
  total_amount: number;
  amount_paid: number;
  amount_due: number;
  invoice_status: 'draft' | 'sent' | 'viewed' | 'partial_payment' | 'paid' | 'overdue' | 'cancelled' | 'refunded';
  payment_method?: string;
  payment_reference?: string;
  payment_terms: string;
  late_fee_applied: number;
  sent_to_email?: string;
  sent_at?: string;
  first_viewed_at?: string;
  last_viewed_at?: string;
  view_count: number;
  download_count: number;
  file_path?: string;
  file_size?: number;
  currency_code: string;
  locale_code: string;
  public_notes?: string;
  private_notes?: string;
  custom_fields: Record<string, any>;
  reminder_count: number;
  last_reminder_sent_at?: string;
  next_reminder_due_at?: string;
  created_at: string;
  updated_at: string;
}

interface InvoiceLineItem {
  id: string;
  invoice_id: string;
  line_order: number;
  item_description: string;
  item_category?: string;
  quantity: number;
  unit_price: number;
  line_discount_amount: number;
  line_discount_percentage: number;
  line_total: number;
  is_taxable: boolean;
  tax_rate: number;
  contract_line_item_id?: string;
  milestone_id?: string;
  custom_data: Record<string, any>;
  created_at: string;
  updated_at: string;
}

interface InvoiceTemplate {
  id: string;
  supplier_id: string;
  template_name: string;
  template_description?: string;
  template_content: {
    header: {
      show_logo: boolean;
      show_business_details: boolean;
      show_invoice_number: boolean;
      show_invoice_date: boolean;
      show_due_date: boolean;
    };
    line_items: {
      show_description: boolean;
      show_quantity: boolean;
      show_unit_price: boolean;
      show_total: boolean;
      allow_discounts: boolean;
    };
    footer: {
      show_payment_terms: boolean;
      show_bank_details: boolean;
      show_thank_you_message: boolean;
      custom_notes: string;
    };
  };
  template_styling: {
    primary_color: string;
    secondary_color: string;
    accent_color: string;
    font_family: string;
    font_size: number;
    logo_position: 'top-left' | 'top-center' | 'top-right';
    layout: string;
  };
  automation_settings: {
    auto_send_on_generation: boolean;
    payment_reminder_days: number[];
    overdue_reminder_days: number[];
    auto_apply_late_fees: boolean;
    late_fee_percentage: number;
    payment_terms_days: number;
    auto_mark_paid_on_payment: boolean;
  };
  usage_count: number;
  last_used_at?: string;
  is_default: boolean;
  template_status: 'active' | 'draft' | 'archived';
  created_at: string;
  updated_at: string;
}

// API request/response interfaces
interface CreateInvoiceRequest {
  template_id?: string;
  contract_id?: string;
  wedding_id?: string;
  couple_id?: string;
  bill_to_name: string;
  bill_to_email: string;
  bill_to_address?: string;
  bill_to_phone?: string;
  due_date: string;
  payment_terms?: string;
  public_notes?: string;
  private_notes?: string;
  custom_fields?: Record<string, any>;
  line_items: Array<{
    item_description: string;
    item_category?: string;
    quantity: number;
    unit_price: number;
    line_discount_amount?: number;
    line_discount_percentage?: number;
    is_taxable?: boolean;
    contract_line_item_id?: string;
    milestone_id?: string;
  }>;
  discount_amount?: number;
  discount_percentage?: number;
  tax_percentage?: number;
  auto_send?: boolean;
}

interface UpdateInvoiceRequest extends Partial<CreateInvoiceRequest> {
  invoice_id: string;
  invoice_status?: Invoice['invoice_status'];
}

interface InvoiceListResponse {
  invoices: Invoice[];
  total_count: number;
  total_amount_due: number;
  overdue_count: number;
  overdue_amount: number;
  statistics: {
    draft_count: number;
    sent_count: number;
    paid_count: number;
    overdue_count: number;
    total_revenue: number;
    average_payment_days: number;
  };
  pagination: {
    page: number;
    limit: number;
    total_pages: number;
  };
}

interface InvoiceGenerationResponse {
  success: boolean;
  invoice: Invoice;
  line_items: InvoiceLineItem[];
  file_url?: string;
  payment_link?: string;
  message?: string;
}

interface RecordPaymentRequest {
  invoice_id: string;
  payment_amount: number;
  payment_date: string;
  payment_method: 'stripe' | 'bank_transfer' | 'cash' | 'cheque' | 'other';
  payment_reference?: string;
  payment_notes?: string;
  stripe_payment_intent_id?: string;
  processor_fee_amount?: number;
}

interface InvoiceAnalyticsResponse {
  supplier_id: string;
  period_stats: {
    total_invoiced: number;
    total_paid: number;
    total_outstanding: number;
    invoice_count: number;
    payment_count: number;
    average_invoice_amount: number;
    average_payment_time: number;
  };
  monthly_revenue: Array<{
    month: string;
    invoiced_amount: number;
    paid_amount: number;
    outstanding_amount: number;
  }>;
  payment_methods: Array<{
    method: string;
    transaction_count: number;
    total_amount: number;
    percentage: number;
  }>;
  overdue_analysis: {
    total_overdue_amount: number;
    overdue_invoice_count: number;
    average_days_overdue: number;
  };
  top_customers: Array<{
    customer_name: string;
    customer_email: string;
    total_invoiced: number;
    total_paid: number;
    invoice_count: number;
  }>;
}

interface SendInvoiceRequest {
  invoice_id: string;
  recipient_email?: string;
  subject_line?: string;
  message_content?: string;
  include_payment_link: boolean;
  send_copy_to_supplier: boolean;
  schedule_for?: string; // Optional future send date
}

interface BulkInvoiceActionRequest {
  invoice_ids: string[];
  action: 'send' | 'mark_paid' | 'cancel' | 'send_reminder' | 'export';
  action_data?: Record<string, any>;
}
```

### CODE EXAMPLES

#### Example 1: Invoice Generator Component

```tsx
'use client';

import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Badge } from '@/components/ui/badge';
import { Separator } from '@/components/ui/separator';
import { Label } from '@/components/ui/label';
import { 
  FileText, Send, Save, Plus, Trash2, Calculator, 
  CreditCard, Calendar, User, MapPin, Phone, Mail,
  Percent, DollarSign, Eye, Download, Copy
} from 'lucide-react';
import { Invoice, InvoiceLineItem, CreateInvoiceRequest } from '@/types/invoices';

interface InvoiceGeneratorProps {
  contractId?: string;
  weddingId?: string;
  onSave: (invoice: CreateInvoiceRequest) => void;
  onSend: (invoiceId: string, sendOptions: any) => void;
  onPreview: (invoice: CreateInvoiceRequest) => void;
}

export default function InvoiceGenerator({
  contractId,
  weddingId,
  onSave,
  onSend,
  onPreview
}: InvoiceGeneratorProps) {
  const [invoiceData, setInvoiceData] = useState<CreateInvoiceRequest>({
    bill_to_name: '',
    bill_to_email: '',
    bill_to_address: '',
    bill_to_phone: '',
    due_date: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0], // 30 days from now
    payment_terms: 'Net 30',
    public_notes: '',
    private_notes: '',
    line_items: [
      {
        item_description: '',
        quantity: 1,
        unit_price: 0,
        is_taxable: true
      }
    ],
    discount_percentage: 0,
    tax_percentage: 20, // UK VAT
    auto_send: false
  });

  const [calculations, setCalculations] = useState({
    subtotal: 0,
    discount: 0,
    tax: 0,
    total: 0
  });

  // Calculate totals whenever line items or discounts change
  useEffect(() => {
    const subtotal = invoiceData.line_items.reduce((sum, item) => {
      const lineTotal = item.quantity * item.unit_price;
      const lineDiscount = item.line_discount_amount || 0;
      const lineDiscountPercent = item.line_discount_percentage || 0;
      return sum + lineTotal - lineDiscount - (lineTotal * lineDiscountPercent / 100);
    }, 0);

    const discountAmount = invoiceData.discount_amount || 0;
    const discountPercent = (subtotal * (invoiceData.discount_percentage || 0)) / 100;
    const totalDiscount = discountAmount + discountPercent;

    const taxableAmount = subtotal - totalDiscount;
    const taxAmount = (taxableAmount * (invoiceData.tax_percentage || 0)) / 100;

    const total = taxableAmount + taxAmount;

    setCalculations({
      subtotal,
      discount: totalDiscount,
      tax: taxAmount,
      total
    });
  }, [invoiceData.line_items, invoiceData.discount_amount, invoiceData.discount_percentage, invoiceData.tax_percentage]);

  const handleInputChange = (field: keyof CreateInvoiceRequest, value: any) => {
    setInvoiceData(prev => ({ ...prev, [field]: value }));
  };

  const handleLineItemChange = (index: number, field: string, value: any) => {
    const newLineItems = [...invoiceData.line_items];
    newLineItems[index] = { ...newLineItems[index], [field]: value };
    setInvoiceData(prev => ({ ...prev, line_items: newLineItems }));
  };

  const addLineItem = () => {
    const newLineItem = {
      item_description: '',
      quantity: 1,
      unit_price: 0,
      is_taxable: true
    };
    setInvoiceData(prev => ({
      ...prev,
      line_items: [...prev.line_items, newLineItem]
    }));
  };

  const removeLineItem = (index: number) => {
    if (invoiceData.line_items.length > 1) {
      const newLineItems = invoiceData.line_items.filter((_, i) => i !== index);
      setInvoiceData(prev => ({ ...prev, line_items: newLineItems }));
    }
  };

  const handleSave = () => {
    onSave(invoiceData);
  };

  const handlePreview = () => {
    onPreview(invoiceData);
  };

  const formatCurrency = (amount: number) => {
    return new Intl.NumberFormat('en-GB', {
      style: 'currency',
      currency: 'GBP'
    }).format(amount);
  };

  return (
    <div className="max-w-5xl mx-auto p-6 space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-gray-900">Create Invoice</h1>
          <p className="text-gray-600 mt-1">
            Generate professional invoices for your wedding services
          </p>
        </div>
        
        <div className="flex items-center space-x-3">
          <Button variant="outline" onClick={handlePreview}>
            <Eye className="w-4 h-4 mr-2" />
            Preview
          </Button>
          <Button variant="outline" onClick={handleSave}>
            <Save className="w-4 h-4 mr-2" />
            Save Draft
          </Button>
          <Button 
            onClick={() => {
              setInvoiceData(prev => ({ ...prev, auto_send: true }));
              handleSave();
            }}
          >
            <Send className="w-4 h-4 mr-2" />
            Generate & Send
          </Button>
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Main Invoice Form */}
        <div className="lg:col-span-2 space-y-6">
          {/* Customer Information */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center space-x-2">
                <User className="w-5 h-5" />
                <span>Bill To</span>
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div className="space-y-2">
                  <Label htmlFor="bill_to_name">Name *</Label>
                  <Input
                    id="bill_to_name"
                    value={invoiceData.bill_to_name}
                    onChange={(e) => handleInputChange('bill_to_name', e.target.value)}
                    placeholder="Customer name"
                  />
                </div>
                
                <div className="space-y-2">
                  <Label htmlFor="bill_to_email">Email *</Label>
                  <Input
                    id="bill_to_email"
                    type="email"
                    value={invoiceData.bill_to_email}
                    onChange={(e) => handleInputChange('bill_to_email', e.target.value)}
                    placeholder="customer@example.com"
                  />
                </div>
                
                <div className="space-y-2">
                  <Label htmlFor="bill_to_phone">Phone</Label>
                  <Input
                    id="bill_to_phone"
                    type="tel"
                    value={invoiceData.bill_to_phone}
                    onChange={(e) => handleInputChange('bill_to_phone', e.target.value)}
                    placeholder="+44 7700 900000"
                  />
                </div>
                
                <div className="space-y-2">
                  <Label htmlFor="due_date">Due Date *</Label>
                  <Input
                    id="due_date"
                    type="date"
                    value={invoiceData.due_date}
                    onChange={(e) => handleInputChange('due_date', e.target.value)}
                  />
                </div>
              </div>
              
              <div className="space-y-2">
                <Label htmlFor="bill_to_address">Address</Label>
                <Textarea
                  id="bill_to_address"
                  value={invoiceData.bill_to_address}
                  onChange={(e) => handleInputChange('bill_to_address', e.target.value)}
                  placeholder="Customer's billing address"
                  rows={3}
                />
              </div>
            </CardContent>
          </Card>

          {/* Line Items */}
          <Card>
            <CardHeader>
              <div className="flex items-center justify-between">
                <CardTitle className="flex items-center space-x-2">
                  <FileText className="w-5 h-5" />
                  <span>Invoice Items</span>
                </CardTitle>
                <Button
                  variant="outline"
                  size="sm"
                  onClick={addLineItem}
                >
                  <Plus className="w-4 h-4 mr-2" />
                  Add Item
                </Button>
              </div>
            </CardHeader>
            <CardContent className="space-y-4">
              {invoiceData.line_items.map((item, index) => (
                <Card key={index} className="border-l-4 border-blue-500">
                  <CardContent className="p-4 space-y-4">
                    <div className="flex items-center justify-between">
                      <Badge variant="secondary">Item {index + 1}</Badge>
                      {invoiceData.line_items.length > 1 && (
                        <Button
                          variant="outline"
                          size="sm"
                          onClick={() => removeLineItem(index)}
                        >
                          <Trash2 className="w-4 h-4" />
                        </Button>
                      )}
                    </div>
                    
                    <div className="space-y-2">
                      <Label>Description *</Label>
                      <Textarea
                        value={item.item_description}
                        onChange={(e) => handleLineItemChange(index, 'item_description', e.target.value)}
                        placeholder="Wedding photography services, engagement shoot, etc."
                        rows={2}
                      />
                    </div>
                    
                    <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
                      <div className="space-y-2">
                        <Label>Quantity</Label>
                        <Input
                          type="number"
                          step="0.01"
                          min="0"
                          value={item.quantity}
                          onChange={(e) => handleLineItemChange(index, 'quantity', parseFloat(e.target.value) || 0)}
                        />
                      </div>
                      
                      <div className="space-y-2">
                        <Label>Unit Price (Â£)</Label>
                        <Input
                          type="number"
                          step="0.01"
                          min="0"
                          value={item.unit_price}
                          onChange={(e) => handleLineItemChange(index, 'unit_price', parseFloat(e.target.value) || 0)}
                        />
                      </div>
                      
                      <div className="space-y-2">
                        <Label>Discount (%)</Label>
                        <Input
                          type="number"
                          step="0.01"
                          min="0"
                          max="100"
                          value={item.line_discount_percentage || 0}
                          onChange={(e) => handleLineItemChange(index, 'line_discount_percentage', parseFloat(e.target.value) || 0)}
                        />
                      </div>
                      
                      <div className="space-y-2">
                        <Label>Line Total</Label>
                        <div className="p-2 bg-gray-50 rounded text-right font-medium">
                          {formatCurrency(
                            (item.quantity * item.unit_price) * 
                            (1 - ((item.line_discount_percentage || 0) / 100))
                          )}
                        </div>
                      </div>
                    </div>
                    
                    <div className="flex items-center space-x-2">
                      <input
                        type="checkbox"
                        id={`taxable_${index}`}
                        checked={item.is_taxable}
                        onChange={(e) => handleLineItemChange(index, 'is_taxable', e.target.checked)}
                        className="rounded"
                      />
                      <Label htmlFor={`taxable_${index}`}>Taxable item</Label>
                    </div>
                  </CardContent>
                </Card>
              ))}
            </CardContent>
          </Card>

          {/* Discounts and Adjustments */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center space-x-2">
                <Percent className="w-5 h-5" />
                <span>Discounts & Tax</span>
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div className="space-y-2">
                  <Label htmlFor="discount_percentage">Overall Discount (%)</Label>
                  <Input
                    id="discount_percentage"
                    type="number"
                    step="0.01"
                    min="0"
                    max="100"
                    value={invoiceData.discount_percentage || 0}
                    onChange={(e) => handleInputChange('discount_percentage', parseFloat(e.target.value) || 0)}
                  />
                </div>
                
                <div className="space-y-2">
                  <Label htmlFor="tax_percentage">Tax Rate (%)</Label>
                  <Input
                    id="tax_percentage"
                    type="number"
                    step="0.01"
                    min="0"
                    max="100"
                    value={invoiceData.tax_percentage || 0}
                    onChange={(e) => handleInputChange('tax_percentage', parseFloat(e.target.value) || 0)}
                  />
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Notes */}
          <Card>
            <CardHeader>
              <CardTitle>Notes & Terms</CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="space-y-2">
                <Label htmlFor="public_notes">Public Notes (visible to customer)</Label>
                <Textarea
                  id="public_notes"
                  value={invoiceData.public_notes}
                  onChange={(e) => handleInputChange('public_notes', e.target.value)}
                  placeholder="Thank you for your business..."
                  rows={3}
                />
              </div>
              
              <div className="space-y-2">
                <Label htmlFor="private_notes">Private Notes (internal only)</Label>
                <Textarea
                  id="private_notes"
                  value={invoiceData.private_notes}
                  onChange={(e) => handleInputChange('private_notes', e.target.value)}
                  placeholder="Internal notes about this invoice..."
                  rows={3}
                />
              </div>
              
              <div className="space-y-2">
                <Label htmlFor="payment_terms">Payment Terms</Label>
                <Select
                  value={invoiceData.payment_terms}
                  onValueChange={(value) => handleInputChange('payment_terms', value)}
                >
                  <SelectTrigger>
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="Due on Receipt">Due on Receipt</SelectItem>
                    <SelectItem value="Net 7">Net 7 days</SelectItem>
                    <SelectItem value="Net 15">Net 15 days</SelectItem>
                    <SelectItem value="Net 30">Net 30 days</SelectItem>
                    <SelectItem value="Net 60">Net 60 days</SelectItem>
                    <SelectItem value="Net 90">Net 90 days</SelectItem>
                  </SelectContent>
                </Select>
              </div>
            </CardContent>
          </Card>
        </div>

        {/* Invoice Summary */}
        <div className="space-y-6">
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center space-x-2">
                <Calculator className="w-5 h-5" />
                <span>Invoice Summary</span>
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="space-y-3">
                <div className="flex justify-between">
                  <span className="text-gray-600">Subtotal:</span>
                  <span>{formatCurrency(calculations.subtotal)}</span>
                </div>
                
                {calculations.discount > 0 && (
                  <div className="flex justify-between text-red-600">
                    <span>Discount:</span>
                    <span>-{formatCurrency(calculations.discount)}</span>
                  </div>
                )}
                
                <div className="flex justify-between">
                  <span className="text-gray-600">Tax ({invoiceData.tax_percentage}%):</span>
                  <span>{formatCurrency(calculations.tax)}</span>
                </div>
                
                <Separator />
                
                <div className="flex justify-between text-lg font-bold">
                  <span>Total:</span>
                  <span>{formatCurrency(calculations.total)}</span>
                </div>
              </div>
              
              <div className="pt-4 space-y-3">
                <div className="text-sm text-gray-600">
                  <div className="flex items-center justify-between">
                    <span>Due Date:</span>
                    <span>{new Date(invoiceData.due_date).toLocaleDateString('en-GB')}</span>
                  </div>
                  <div className="flex items-center justify-between">
                    <span>Payment Terms:</span>
                    <span>{invoiceData.payment_terms}</span>
                  </div>
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Quick Actions */}
          <Card>
            <CardHeader>
              <CardTitle>Quick Actions</CardTitle>
            </CardHeader>
            <CardContent className="space-y-3">
              <Button variant="outline" className="w-full justify-start">
                <Copy className="w-4 h-4 mr-2" />
                Duplicate Invoice
              </Button>
              
              <Button variant="outline" className="w-full justify-start">
                <Calendar className="w-4 h-4 mr-2" />
                Schedule Send
              </Button>
              
              <Button variant="outline" className="w-full justify-start">
                <Download className="w-4 h-4 mr-2" />
                Export PDF
              </Button>
              
              <Button variant="outline" className="w-full justify-start">
                <CreditCard className="w-4 h-4 mr-2" />
                Payment Link
              </Button>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
}
```

#### Example 2: Invoice Generation Service

```typescript
// /src/lib/services/invoice-generation-service.ts
import { createClient } from '@/lib/supabase/server';
import { generateInvoicePDF } from '@/lib/pdf/invoice-pdf-generator';
import { sendInvoiceEmail } from '@/lib/email/invoice-email-service';
import { createStripePaymentLink } from '@/lib/stripe/payment-links';
import { Invoice, InvoiceLineItem, CreateInvoiceRequest, InvoiceTemplate } from '@/types/invoices';

export class InvoiceGenerationService {
  private supabase = createClient();

  async generateInvoice(request: CreateInvoiceRequest): Promise<{
    invoice: Invoice;
    line_items: InvoiceLineItem[];
    file_url?: string;
    payment_link?: string;
  }> {
    try {
      // 1. Get next invoice number
      const invoiceNumber = await this.generateInvoiceNumber(request.supplier_id);
      
      // 2. Calculate totals
      const calculations = this.calculateInvoiceTotals(request);
      
      // 3. Create invoice record
      const invoiceData = {
        supplier_id: request.supplier_id || this.getCurrentSupplierId(),
        template_id: request.template_id,
        contract_id: request.contract_id,
        wedding_id: request.wedding_id,
        couple_id: request.couple_id,
        invoice_number: invoiceNumber,
        invoice_reference: request.invoice_reference,
        invoice_date: new Date().toISOString().split('T')[0],
        due_date: request.due_date,
        bill_to_name: request.bill_to_name,
        bill_to_email: request.bill_to_email,
        bill_to_address: request.bill_to_address,
        bill_to_phone: request.bill_to_phone,
        subtotal_amount: calculations.subtotal,
        discount_amount: calculations.discountAmount,
        discount_percentage: request.discount_percentage || 0,
        tax_amount: calculations.taxAmount,
        tax_percentage: request.tax_percentage || 0,
        total_amount: calculations.total,
        payment_terms: request.payment_terms || 'Net 30',
        public_notes: request.public_notes,
        private_notes: request.private_notes,
        custom_fields: request.custom_fields || {},
        currency_code: 'GBP',
        locale_code: 'en-GB',
        invoice_status: 'draft' as const
      };

      const { data: invoice, error: invoiceError } = await this.supabase
        .from('invoices')
        .insert(invoiceData)
        .select()
        .single();

      if (invoiceError) {
        throw new Error(`Failed to create invoice: ${invoiceError.message}`);
      }

      // 4. Create line items
      const lineItemsData = request.line_items.map((item, index) => ({
        invoice_id: invoice.id,
        line_order: index + 1,
        item_description: item.item_description,
        item_category: item.item_category,
        quantity: item.quantity,
        unit_price: item.unit_price,
        line_discount_amount: item.line_discount_amount || 0,
        line_discount_percentage: item.line_discount_percentage || 0,
        is_taxable: item.is_taxable !== false, // Default to true
        tax_rate: item.is_taxable !== false ? (request.tax_percentage || 0) / 100 : 0,
        contract_line_item_id: item.contract_line_item_id,
        milestone_id: item.milestone_id,
        custom_data: item.custom_data || {}
      }));

      const { data: lineItems, error: lineItemsError } = await this.supabase
        .from('invoice_line_items')
        .insert(lineItemsData)
        .select();

      if (lineItemsError) {
        throw new Error(`Failed to create line items: ${lineItemsError.message}`);
      }

      // 5. Generate PDF
      const template = await this.getInvoiceTemplate(request.template_id, invoice.supplier_id);
      const pdfBuffer = await generateInvoicePDF(invoice, lineItems, template);
      
      // 6. Upload PDF to storage
      const filePath = await this.uploadInvoicePDF(invoice.id, pdfBuffer, invoiceNumber);
      
      // 7. Update invoice with file path
      const { data: updatedInvoice } = await this.supabase
        .from('invoices')
        .update({ 
          file_path: filePath,
          file_size: Math.round(pdfBuffer.length / 1024) // KB
        })
        .eq('id', invoice.id)
        .select()
        .single();

      // 8. Create Stripe payment link
      const paymentLink = await this.createPaymentLink(updatedInvoice);

      // 9. Send invoice if requested
      if (request.auto_send) {
        await this.sendInvoice(updatedInvoice.id, {
          include_payment_link: true,
          send_copy_to_supplier: true
        });
      }

      // 10. Log analytics
      await this.logInvoiceGeneration(updatedInvoice.id);

      // 11. Update template usage
      if (request.template_id) {
        await this.incrementTemplateUsage(request.template_id);
      }

      return {
        invoice: updatedInvoice,
        line_items: lineItems,
        file_url: this.getPublicFileUrl(filePath),
        payment_link: paymentLink?.url
      };

    } catch (error) {
      console.error('Invoice generation failed:', error);
      throw new Error(`Failed to generate invoice: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  private async generateInvoiceNumber(supplierId: string): Promise<string> {
    // Get or create invoice number sequence
    const { data: sequence, error } = await this.supabase
      .from('invoice_number_sequences')
      .select('*')
      .eq('supplier_id', supplierId)
      .eq('is_default', true)
      .single();

    if (error || !sequence) {
      throw new Error('Invoice number sequence not found');
    }

    // Generate the next invoice number
    const paddedNumber = sequence.current_number.toString().padStart(sequence.minimum_digits, '0');
    let invoiceNumber = sequence.sequence_prefix;
    
    if (sequence.include_year) {
      invoiceNumber += new Date().getFullYear().toString().substr(-2);
    }
    
    if (sequence.include_month) {
      invoiceNumber += (new Date().getMonth() + 1).toString().padStart(2, '0');
    }
    
    invoiceNumber += sequence.sequence_separator + paddedNumber;
    
    if (sequence.sequence_suffix) {
      invoiceNumber += sequence.sequence_suffix;
    }

    // Update sequence for next use
    await this.supabase
      .from('invoice_number_sequences')
      .update({
        current_number: sequence.current_number + sequence.increment_by,
        last_used_at: new Date().toISOString(),
        last_generated_number: invoiceNumber
      })
      .eq('id', sequence.id);

    return invoiceNumber;
  }

  private calculateInvoiceTotals(request: CreateInvoiceRequest): {
    subtotal: number;
    discountAmount: number;
    taxAmount: number;
    total: number;
  } {
    // Calculate line items subtotal
    const subtotal = request.line_items.reduce((sum, item) => {
      const lineTotal = item.quantity * item.unit_price;
      const lineDiscount = (item.line_discount_amount || 0) + 
                          (lineTotal * (item.line_discount_percentage || 0) / 100);
      return sum + (lineTotal - lineDiscount);
    }, 0);

    // Calculate overall discount
    const discountAmount = (request.discount_amount || 0) + 
                          (subtotal * (request.discount_percentage || 0) / 100);

    // Calculate tax on discounted amount
    const taxableAmount = subtotal - discountAmount;
    const taxAmount = taxableAmount * (request.tax_percentage || 0) / 100;

    // Calculate total
    const total = taxableAmount + taxAmount;

    return {
      subtotal,
      discountAmount,
      taxAmount,
      total: Math.round(total * 100) / 100 // Round to 2 decimal places
    };
  }

  private async getInvoiceTemplate(templateId?: string, supplierId?: string): Promise<InvoiceTemplate | null> {
    if (!templateId && !supplierId) return null;

    let query = this.supabase.from('invoice_templates').select('*');

    if (templateId) {
      query = query.eq('id', templateId);
    } else if (supplierId) {
      query = query.eq('supplier_id', supplierId).eq('is_default', true);
    }

    const { data, error } = await query.single();

    if (error) {
      console.error('Error fetching invoice template:', error);
      return null;
    }

    return data;
  }

  private async uploadInvoicePDF(invoiceId: string, pdfBuffer: Buffer, invoiceNumber: string): Promise<string> {
    const fileName = `invoice-${invoiceNumber}-${Date.now()}.pdf`;
    const filePath = `invoices/${invoiceId}/${fileName}`;
    
    const { error } = await this.supabase.storage
      .from('invoices')
      .upload(filePath, pdfBuffer, {
        contentType: 'application/pdf',
        upsert: true
      });

    if (error) {
      throw new Error(`Failed to upload invoice PDF: ${error.message}`);
    }

    return filePath;
  }

  private async createPaymentLink(invoice: Invoice): Promise<{ url: string } | null> {
    try {
      return await createStripePaymentLink({
        amount: Math.round(invoice.total_amount * 100), // Convert to pence
        currency: invoice.currency_code.toLowerCase(),
        description: `Invoice ${invoice.invoice_number} - ${invoice.bill_to_name}`,
        metadata: {
          invoice_id: invoice.id,
          invoice_number: invoice.invoice_number,
          supplier_id: invoice.supplier_id
        }
      });
    } catch (error) {
      console.error('Failed to create payment link:', error);
      return null;
    }
  }

  private getPublicFileUrl(filePath: string): string {
    const { data } = this.supabase.storage
      .from('invoices')
      .getPublicUrl(filePath);
    
    return data.publicUrl;
  }

  private getCurrentSupplierId(): string {
    // Get from authenticated user context
    // This would be implemented based on your auth system
    throw new Error('Supplier ID not available');
  }

  private async sendInvoice(invoiceId: string, options: {
    include_payment_link: boolean;
    send_copy_to_supplier: boolean;
  }): Promise<void> {
    const { data: invoice } = await this.supabase
      .from('invoices')
      .select('*')
      .eq('id', invoiceId)
      .single();

    if (!invoice) return;

    await sendInvoiceEmail(invoice, {
      includePaymentLink: options.include_payment_link,
      sendCopyToSupplier: options.send_copy_to_supplier
    });

    // Update invoice status and tracking
    await this.supabase
      .from('invoices')
      .update({
        invoice_status: 'sent',
        sent_to_email: invoice.bill_to_email,
        sent_at: new Date().toISOString()
      })
      .eq('id', invoiceId);
  }

  private async logInvoiceGeneration(invoiceId: string): Promise<void> {
    await this.supabase
      .from('invoice_analytics')
      .insert({
        supplier_id: this.getCurrentSupplierId(),
        invoice_id: invoiceId,
        event_type: 'invoice_created'
      });
  }

  private async incrementTemplateUsage(templateId: string): Promise<void> {
    await this.supabase.rpc('increment_invoice_template_usage', {
      template_id: templateId
    });
  }

  // Payment recording methods
  async recordPayment(request: {
    invoice_id: string;
    payment_amount: number;
    payment_date: string;
    payment_method: string;
    payment_reference?: string;
    payment_notes?: string;
    stripe_payment_intent_id?: string;
    processor_fee_amount?: number;
  }): Promise<void> {
    // Create payment record
    const { error: paymentError } = await this.supabase
      .from('invoice_payments')
      .insert({
        invoice_id: request.invoice_id,
        payment_amount: request.payment_amount,
        payment_date: request.payment_date,
        payment_method: request.payment_method,
        payment_reference: request.payment_reference,
        payment_notes: request.payment_notes,
        stripe_payment_intent_id: request.stripe_payment_intent_id,
        processor_fee_amount: request.processor_fee_amount || 0,
        payment_status: 'completed'
      });

    if (paymentError) {
      throw new Error(`Failed to record payment: ${paymentError.message}`);
    }

    // Update invoice amounts
    await this.supabase.rpc('update_invoice_payments', {
      invoice_id: request.invoice_id
    });

    // Check if invoice is fully paid
    const { data: invoice } = await this.supabase
      .from('invoices')
      .select('total_amount, amount_paid')
      .eq('id', request.invoice_id)
      .single();

    if (invoice && invoice.amount_paid >= invoice.total_amount) {
      await this.supabase
        .from('invoices')
        .update({ invoice_status: 'paid' })
        .eq('id', request.invoice_id);
    } else if (invoice && invoice.amount_paid > 0) {
      await this.supabase
        .from('invoices')
        .update({ invoice_status: 'partial_payment' })
        .eq('id', request.invoice_id);
    }

    // Log payment event
    await this.supabase
      .from('invoice_analytics')
      .insert({
        supplier_id: this.getCurrentSupplierId(),
        invoice_id: request.invoice_id,
        event_type: 'payment_received',
        amount_involved: request.payment_amount
      });
  }

  // Analytics methods
  async getInvoiceAnalytics(supplierId: string, periodStart: string, periodEnd: string): Promise<any> {
    const { data, error } = await this.supabase
      .rpc('get_invoice_analytics', {
        supplier_id: supplierId,
        period_start: periodStart,
        period_end: periodEnd
      });

    if (error) {
      throw new Error(`Failed to fetch analytics: ${error.message}`);
    }

    return data;
  }
}

// PostgreSQL functions needed for the service
/*
-- Function to increment template usage
CREATE OR REPLACE FUNCTION increment_invoice_template_usage(template_id UUID)
RETURNS VOID AS $$
BEGIN
  UPDATE invoice_templates 
  SET usage_count = usage_count + 1,
      last_used_at = NOW()
  WHERE id = template_id;
END;
$$ LANGUAGE plpgsql;

-- Function to update invoice payment totals
CREATE OR REPLACE FUNCTION update_invoice_payments(invoice_id UUID)
RETURNS VOID AS $$
BEGIN
  UPDATE invoices 
  SET amount_paid = (
    SELECT COALESCE(SUM(payment_amount), 0)
    FROM invoice_payments 
    WHERE invoice_payments.invoice_id = update_invoice_payments.invoice_id
    AND payment_status = 'completed'
  )
  WHERE id = invoice_id;
END;
$$ LANGUAGE plpgsql;

-- Function to get comprehensive invoice analytics
CREATE OR REPLACE FUNCTION get_invoice_analytics(supplier_id UUID, period_start DATE, period_end DATE)
RETURNS TABLE(
  total_invoiced NUMERIC,
  total_paid NUMERIC,
  total_outstanding NUMERIC,
  invoice_count BIGINT,
  paid_invoice_count BIGINT,
  overdue_count BIGINT,
  average_payment_days NUMERIC
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    COALESCE(SUM(i.total_amount), 0) as total_invoiced,
    COALESCE(SUM(i.amount_paid), 0) as total_paid,
    COALESCE(SUM(i.amount_due), 0) as total_outstanding,
    COUNT(i.id) as invoice_count,
    COUNT(CASE WHEN i.invoice_status = 'paid' THEN 1 END) as paid_invoice_count,
    COUNT(CASE WHEN i.due_date < CURRENT_DATE AND i.amount_due > 0 THEN 1 END) as overdue_count,
    COALESCE(AVG(
      CASE 
        WHEN i.invoice_status = 'paid' 
        THEN EXTRACT(days FROM (
          SELECT MIN(p.payment_date) 
          FROM invoice_payments p 
          WHERE p.invoice_id = i.id 
          AND p.payment_status = 'completed'
        ) - i.invoice_date)
        ELSE NULL
      END
    ), 0) as average_payment_days
  FROM invoices i
  WHERE i.supplier_id = get_invoice_analytics.supplier_id
  AND i.invoice_date BETWEEN period_start AND period_end;
END;
$$ LANGUAGE plpgsql;
*/
```

### ACCEPTANCE CRITERIA
- [ ] **Invoice Creation & Management**
  - Create invoices manually or from contract milestones
  - Professional templates with customizable branding
  - Line item management with quantities, prices, discounts, and tax
  - Invoice numbering with customizable sequences
  - Draft, send, and track invoice status

- [ ] **Automated Calculations**
  - Real-time calculation of subtotals, discounts, taxes, and totals
  - Support for line-item level discounts and overall invoice discounts
  - Configurable tax rates with supplier tax settings
  - Currency formatting and multi-currency support
  - Accurate rounding and precision handling

- [ ] **Payment Processing Integration**
  - Stripe payment link generation for online payments
  - Payment recording and reconciliation
  - Partial payment tracking
  - Multiple payment method support (card, bank transfer, cash, cheque)
  - Processor fee tracking and reporting

- [ ] **Professional PDF Generation**
  - Branded PDF invoices with supplier logo and styling
  - Customizable templates and layouts
  - Professional formatting with proper alignment and spacing
  - Multi-page support for detailed invoices
  - Watermarking and security options

- [ ] **Automated Workflows**
  - Scheduled invoice generation from contracts
  - Automatic payment reminders based on due dates
  - Overdue invoice notifications
  - Payment confirmation emails
  - Status updates and workflow progression

- [ ] **Customer Communication**
  - Email delivery with tracking (opened, clicked, downloaded)
  - Customizable email templates and messaging
  - Payment links embedded in emails
  - Customer portal for viewing and paying invoices
  - Mobile-responsive invoice viewing

- [ ] **Analytics & Reporting**
  - Cash flow forecasting and analysis
  - Payment performance metrics
  - Customer payment behavior insights
  - Revenue tracking and reporting
  - Outstanding invoice management

- [ ] **Integration Requirements**
  - Contract system integration for automated invoicing
  - Wedding timeline integration for milestone billing
  - Accounting system export capabilities
  - Email service integration (Resend)
  - Calendar integration for due date management

- [ ] **Security & Compliance**
  - Secure payment processing (PCI compliance)
  - Data encryption at rest and in transit
  - Audit trail for all invoice operations
  - Access control and permission management
  - GDPR-compliant data handling

- [ ] **Mobile Optimization**
  - Responsive invoice creation interface for tablets
  - Mobile invoice viewing and payment
  - Touch-optimized PDF viewing
  - Mobile receipt capture and payment recording
  - Push notifications for payment updates

### DEPENDENCIES
- Must complete after: Document template system, contract management, payment processing setup
- Must complete before: Accounting integration, client portal, automated billing cycles
- Shares code with: PDF generation service, email delivery system, payment processing, contract management
- External dependencies: Stripe API, email service, PDF generation library, file storage

### ESTIMATED EFFORT
- **Team A Frontend**: 36 hours
  - Invoice creation interface (18h)
  - Invoice listing and management (10h)
  - Payment recording interface (8h)
- **Team B Backend**: 32 hours
  - Database schema and API endpoints (14h)
  - Invoice generation service (12h)
  - Payment processing integration (6h)
- **Team C Integration**: 24 hours
  - PDF generation engine (12h)
  - Email delivery integration (6h)
  - Stripe payment links integration (6h)
- **Team D Platform**: 18 hours
  - Performance optimization (8h)
  - Security implementation (6h)
  - Analytics and reporting (4h)
- **Team E General**: 14 hours
  - Testing and quality assurance (10h)
  - Documentation and user guides (4h)
- **Total**: 124 hours

### TECHNICAL NOTES
1. **PDF Generation**: Use Puppeteer or similar for consistent, professional invoice PDFs
2. **Payment Links**: Integrate Stripe Payment Links API for seamless online payments
3. **Number Sequences**: Implement robust invoice numbering with configurable patterns
4. **Tax Calculation**: Support complex tax scenarios including VAT, exemptions, and inclusive pricing
5. **Rounding**: Use proper decimal handling for financial calculations to avoid rounding errors
6. **Performance**: Implement caching for frequently accessed invoices and templates
7. **Backup Strategy**: Regular backup of invoice data with long-term retention
8. **Compliance**: Maintain audit trails for all financial transactions and changes

### BUSINESS IMPACT
This invoice generator system transforms the billing process for wedding suppliers by:

- **Reducing invoicing time by 90%** from manual creation to automated generation
- **Improving cash flow** through faster invoice delivery and integrated payment links
- **Decreasing payment delays** from 18 days to under 7 days on average
- **Eliminating billing errors** through automated calculations and template standardization
- **Increasing payment conversion rates** with seamless online payment options
- **Providing financial insights** through comprehensive analytics and reporting

The system directly addresses one of the most time-consuming aspects of supplier operations while improving customer experience and reducing administrative overhead.