# TECHNICAL SPECIFICATION: WS-201 - Webhook Endpoints
## Generated by Feature Development Session - August 25, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** WedSync platform integration specialist enabling real-time data synchronization with external systems
**I want to:** Implement comprehensive webhook endpoints with secure event delivery, retry mechanisms, and monitoring
**So that:** I can ensure that when couples submit consultation forms, photography suppliers' CRMs are instantly notified; when wedding dates change, venue booking systems receive immediate updates; and when clients complete journeys, email automation platforms trigger follow-up sequences, all while maintaining security, reliability, and audit trails for compliance with wedding industry data protection requirements

**Real Wedding Scenario:**
A premium photography supplier integrates their custom CRM with WedSync to manage 50+ weddings per season. When couples submit photography consultation forms through WedSync, webhooks instantly notify their CRM system, triggering automated booking confirmations and calendar updates. During peak season, the webhook system delivers 200+ notifications daily while maintaining 99.9% reliability through exponential backoff retries. When their email marketing platform receives wedding completion webhooks, it automatically triggers post-wedding portfolio delivery sequences. The webhook monitoring dashboard shows delivery success rates, helps troubleshoot integration issues, and provides audit trails for client data processing compliance during GDPR inquiries.

### SPECIFICATION SOURCE
- **Feature ID:** WS-201
- **Original Spec:** /CORE-SPECIFICATIONS/01-TECHNICAL-ARCHITECTURE/03-API-Architecture/06-webhook-endpoints md.md
- **Current Implementation:** 0% complete (new)
- **Files to Modify:** None (new feature)
- **New Files to Create:** 
  - `/wedsync/lib/webhooks/webhook-manager.ts`
  - `/wedsync/lib/webhooks/webhook-security.ts`
  - `/wedsync/lib/webhooks/delivery-queue.ts`
  - `/wedsync/lib/webhooks/retry-handler.ts`
  - `/wedsync/supabase/functions/webhook-delivery/index.ts`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Webhook endpoint registration and management
CREATE TABLE webhook_endpoints (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Endpoint identification
  endpoint_url TEXT NOT NULL,
  secret_key TEXT NOT NULL, -- For HMAC signing
  description TEXT,
  
  -- Owner information
  supplier_id UUID NOT NULL REFERENCES suppliers(id),
  created_by UUID NOT NULL REFERENCES users(id),
  
  -- Event subscriptions
  subscribed_events TEXT[] NOT NULL, -- ['client.created', 'form.submitted', etc.]
  event_filters JSONB, -- Additional filtering criteria
  
  -- Configuration
  is_active BOOLEAN DEFAULT TRUE,
  is_verified BOOLEAN DEFAULT FALSE, -- Whether test delivery succeeded
  max_retry_attempts INTEGER DEFAULT 5,
  timeout_seconds INTEGER DEFAULT 30,
  
  -- Wedding industry context
  vendor_type TEXT, -- Type of vendor using this webhook
  integration_type TEXT CHECK (integration_type IN (
    'crm_integration', 'email_automation', 'booking_system', 
    'analytics_platform', 'custom_application', 'other'
  )),
  business_critical BOOLEAN DEFAULT FALSE, -- High priority delivery
  
  -- Security settings
  require_https BOOLEAN DEFAULT TRUE,
  allowed_ip_ranges TEXT[], -- Optional IP whitelist
  
  -- Status tracking
  last_successful_delivery TIMESTAMPTZ,
  consecutive_failures INTEGER DEFAULT 0,
  total_deliveries INTEGER DEFAULT 0,
  total_failures INTEGER DEFAULT 0,
  
  -- Automatic management
  auto_disabled_at TIMESTAMPTZ, -- When automatically disabled due to failures
  auto_disable_threshold INTEGER DEFAULT 10, -- Consecutive failures before disable
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_webhooks_supplier ON webhook_endpoints(supplier_id, is_active);
CREATE INDEX idx_webhooks_active ON webhook_endpoints(is_active, created_at DESC);

-- Webhook event definitions and metadata
CREATE TABLE webhook_event_types (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  event_type TEXT UNIQUE NOT NULL, -- 'client.created', 'form.submitted', etc.
  
  -- Event metadata
  category TEXT NOT NULL, -- 'client_management', 'form_system', 'journey_tracking'
  description TEXT NOT NULL,
  priority_level TEXT NOT NULL CHECK (priority_level IN ('low', 'medium', 'high', 'critical')),
  
  -- Wedding industry context
  applies_to_vendor_types TEXT[], -- ['photographer', 'venue'] if specific to vendor types
  requires_premium_subscription BOOLEAN DEFAULT FALSE,
  
  -- Payload configuration
  payload_schema JSONB NOT NULL, -- JSON schema for event payload
  includes_sensitive_data BOOLEAN DEFAULT FALSE,
  max_payload_size_kb INTEGER DEFAULT 100,
  
  -- Delivery settings
  supports_batching BOOLEAN DEFAULT FALSE,
  max_batch_size INTEGER DEFAULT 1,
  delivery_timeout_seconds INTEGER DEFAULT 30,
  
  -- Status and versioning
  is_active BOOLEAN DEFAULT TRUE,
  api_version TEXT NOT NULL DEFAULT 'v1',
  introduced_in_version TEXT NOT NULL,
  deprecated_in_version TEXT,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Webhook delivery queue and tracking
CREATE TABLE webhook_deliveries (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Event and delivery details
  event_id UUID UNIQUE NOT NULL, -- Idempotency key
  event_type TEXT NOT NULL,
  webhook_endpoint_id UUID NOT NULL REFERENCES webhook_endpoints(id),
  
  -- Payload and delivery
  payload JSONB NOT NULL,
  signature TEXT NOT NULL, -- HMAC-SHA256 signature
  delivery_url TEXT NOT NULL,
  
  -- Attempt tracking
  attempt_number INTEGER NOT NULL DEFAULT 1,
  max_attempts INTEGER NOT NULL DEFAULT 5,
  status TEXT NOT NULL CHECK (status IN (
    'pending', 'delivered', 'failed', 'permanently_failed', 'retrying'
  )),
  
  -- Delivery results
  http_status_code INTEGER,
  response_body TEXT,
  response_headers JSONB,
  delivery_duration_ms INTEGER,
  error_message TEXT,
  
  -- Timing
  scheduled_at TIMESTAMPTZ DEFAULT NOW(),
  attempted_at TIMESTAMPTZ,
  delivered_at TIMESTAMPTZ,
  next_retry_at TIMESTAMPTZ,
  
  -- Business context
  supplier_id UUID NOT NULL REFERENCES suppliers(id),
  triggered_by_user_id UUID REFERENCES users(id),
  
  -- Wedding industry context
  related_client_id UUID REFERENCES clients(id),
  related_form_id UUID REFERENCES forms(id),
  wedding_date DATE, -- If event relates to specific wedding
  vendor_type TEXT,
  
  -- Retry configuration
  exponential_backoff BOOLEAN DEFAULT TRUE,
  base_retry_delay_seconds INTEGER DEFAULT 60,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_deliveries_status ON webhook_deliveries(status, scheduled_at);
CREATE INDEX idx_deliveries_endpoint ON webhook_deliveries(webhook_endpoint_id, created_at DESC);
CREATE INDEX idx_deliveries_retry ON webhook_deliveries(next_retry_at, status) WHERE status = 'retrying';
CREATE INDEX idx_deliveries_event_id ON webhook_deliveries(event_id); -- For idempotency checks

-- Webhook delivery analytics and monitoring
CREATE TABLE webhook_analytics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  measurement_date DATE NOT NULL,
  webhook_endpoint_id UUID NOT NULL REFERENCES webhook_endpoints(id),
  
  -- Delivery metrics
  total_events_triggered INTEGER NOT NULL DEFAULT 0,
  successful_deliveries INTEGER NOT NULL DEFAULT 0,
  failed_deliveries INTEGER NOT NULL DEFAULT 0,
  permanently_failed_deliveries INTEGER NOT NULL DEFAULT 0,
  
  -- Performance metrics
  avg_delivery_time_ms INTEGER,
  min_delivery_time_ms INTEGER,
  max_delivery_time_ms INTEGER,
  p95_delivery_time_ms INTEGER,
  
  -- Retry metrics
  total_retries INTEGER DEFAULT 0,
  avg_retries_per_event DECIMAL(4,2),
  events_requiring_retries INTEGER DEFAULT 0,
  
  -- Event type breakdown
  event_type_breakdown JSONB, -- {'client.created': 50, 'form.submitted': 120}
  
  -- Response code breakdown
  response_code_breakdown JSONB, -- {'200': 150, '404': 5, '500': 2}
  
  -- Wedding business metrics
  supplier_id UUID NOT NULL REFERENCES suppliers(id),
  vendor_type TEXT,
  peak_season_multiplier DECIMAL(3,2), -- Higher volume during wedding season
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(measurement_date, webhook_endpoint_id)
);

-- Dead letter queue for permanently failed webhooks
CREATE TABLE webhook_dead_letter_queue (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Original delivery information
  original_delivery_id UUID NOT NULL REFERENCES webhook_deliveries(id),
  event_id UUID NOT NULL,
  event_type TEXT NOT NULL,
  webhook_endpoint_id UUID NOT NULL REFERENCES webhook_endpoints(id),
  
  -- Failure details
  final_error_message TEXT NOT NULL,
  final_http_status_code INTEGER,
  total_attempts_made INTEGER NOT NULL,
  failure_category TEXT NOT NULL CHECK (failure_category IN (
    'endpoint_unreachable', 'authentication_failed', 'timeout', 
    'invalid_response', 'rate_limited', 'client_error', 'server_error'
  )),
  
  -- Payload preservation
  original_payload JSONB NOT NULL,
  
  -- Business context
  supplier_id UUID NOT NULL REFERENCES suppliers(id),
  business_impact TEXT, -- Description of potential business impact
  
  -- Resolution tracking
  status TEXT DEFAULT 'unresolved' CHECK (status IN (
    'unresolved', 'investigating', 'resolved', 'endpoint_fixed', 'ignored'
  )),
  resolved_at TIMESTAMPTZ,
  resolution_notes TEXT,
  manual_replay_attempted BOOLEAN DEFAULT FALSE,
  
  -- Alert tracking
  support_notified BOOLEAN DEFAULT FALSE,
  supplier_notified BOOLEAN DEFAULT FALSE,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_dlq_status ON webhook_dead_letter_queue(status, created_at DESC);
CREATE INDEX idx_dlq_supplier ON webhook_dead_letter_queue(supplier_id, status);

-- Webhook security audit log
CREATE TABLE webhook_security_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Security event details
  event_type TEXT NOT NULL CHECK (event_type IN (
    'invalid_signature', 'replay_attack', 'rate_limit_exceeded', 
    'suspicious_payload', 'ip_blocked', 'endpoint_verification_failed'
  )),
  webhook_endpoint_id UUID REFERENCES webhook_endpoints(id),
  
  -- Request details
  source_ip INET NOT NULL,
  user_agent TEXT,
  request_headers JSONB,
  
  -- Security context
  signature_provided TEXT,
  signature_expected TEXT,
  timestamp_skew_seconds INTEGER,
  
  -- Business context
  supplier_id UUID REFERENCES suppliers(id),
  
  -- Response action
  action_taken TEXT NOT NULL CHECK (action_taken IN (
    'blocked', 'logged', 'rate_limited', 'endpoint_disabled', 'alerted'
  )),
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_webhook_security_events ON webhook_security_events(event_type, created_at DESC);
```

#### API Endpoints Required
```typescript
// Webhook management endpoints
// POST /api/webhooks/endpoints
interface CreateWebhookEndpointRequest {
  url: string;
  events: string[];
  description?: string;
  eventFilters?: Record<string, any>;
  integrationType: 'crm_integration' | 'email_automation' | 'booking_system' | 'other';
  businessCritical?: boolean;
}

interface CreateWebhookEndpointResponse {
  success: boolean;
  data: {
    id: string;
    url: string;
    secret: string;
    verificationToken: string;
    testDeliveryUrl: string;
  };
}

// GET /api/webhooks/analytics
interface WebhookAnalyticsResponse {
  success: boolean;
  data: {
    deliveryMetrics: {
      totalDeliveries: number;
      successfulDeliveries: number;
      failedDeliveries: number;
      averageDeliveryTime: number;
    };
    endpointPerformance: EndpointPerformance[];
    eventTypeBreakdown: EventTypeMetrics[];
    deadLetterQueueSize: number;
  };
}
```

#### Frontend Components Required
```typescript
// Component: WebhookDashboard
// Location: /src/components/webhooks/WebhookDashboard.tsx

interface Props {
  webhookEndpoints: WebhookEndpoint[];
  deliveryMetrics: DeliveryMetrics[];
  eventTypes: WebhookEventType[];
}

// Key functionality:
- Webhook endpoint management with URL validation and test delivery capabilities
- Real-time delivery monitoring with success/failure rates and response time tracking
- Event subscription configuration with wedding industry specific event filtering
- Dead letter queue management with manual replay and troubleshooting tools
```

#### Integration Points
```typescript
// Service: WebhookManager
// Dependencies: Event system, queue management, security validation, retry handling

class WebhookManager {
  async deliverWebhook(event: WebhookEvent, endpoint: WebhookEndpoint): Promise<DeliveryResult> {
    // Secure webhook delivery with HMAC signing and retry logic
  }
  
  async processEventQueue(): Promise<void> {
    // Background processing of webhook delivery queue with exponential backoff
  }
}
```

### CODE EXAMPLES

#### Example 1: Comprehensive Webhook Delivery System
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
// lib/webhooks/webhook-manager.ts

import { createClient } from '@supabase/supabase-js';
import crypto from 'crypto';
import { v4 as uuidv4 } from 'uuid';

// Wedding industry webhook events
export enum WedSyncWebhookEvent {
  // Client management events
  CLIENT_CREATED = 'client.created',
  CLIENT_UPDATED = 'client.updated',
  CLIENT_DELETED = 'client.deleted',
  CLIENT_INVITED = 'client.invited',
  CLIENT_ONBOARDED = 'client.onboarded',
  
  // Form system events
  FORM_CREATED = 'form.created',
  FORM_SUBMITTED = 'form.submitted',
  FORM_COMPLETED = 'form.completed',
  FORM_RESPONSE_RECEIVED = 'form.response_received',
  
  // Journey tracking events
  JOURNEY_STARTED = 'journey.started',
  JOURNEY_STEP_COMPLETED = 'journey.step_completed',
  JOURNEY_COMPLETED = 'journey.completed',
  JOURNEY_ABANDONED = 'journey.abandoned',
  
  // Wedding timeline events
  WEDDING_DATE_CHANGED = 'wedding.date_changed',
  VENUE_CONFIRMED = 'wedding.venue_confirmed',
  GUEST_COUNT_UPDATED = 'wedding.guest_count_updated',
  
  // Supplier business events
  SUPPLIER_UPGRADED = 'supplier.upgraded',
  SUPPLIER_DOWNGRADED = 'supplier.downgraded',
  PORTFOLIO_UPDATED = 'supplier.portfolio_updated',
  
  // System events
  PAYMENT_SUCCEEDED = 'payment.succeeded',
  PAYMENT_FAILED = 'payment.failed',
  SUBSCRIPTION_RENEWED = 'subscription.renewed',
  SUBSCRIPTION_CANCELLED = 'subscription.cancelled'
}

export class WedSyncWebhookManager {
  private supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_KEY!
  );

  // Webhook event schemas for validation and documentation
  private readonly EVENT_SCHEMAS = {
    [WedSyncWebhookEvent.CLIENT_CREATED]: {
      description: 'Triggered when a new client is added to a supplier\'s account',
      priority: 'high',
      schema: {
        type: 'object',
        properties: {
          client: {
            type: 'object',
            properties: {
              id: { type: 'string', format: 'uuid' },
              couple_name: { type: 'string' },
              wedding_date: { type: 'string', format: 'date' },
              venue_name: { type: ['string', 'null'] },
              guest_count: { type: ['number', 'null'] },
              contact_email: { type: 'string', format: 'email' },
              status: { type: 'string', enum: ['active', 'pending'] },
              created_at: { type: 'string', format: 'date-time' }
            },
            required: ['id', 'couple_name', 'wedding_date', 'contact_email', 'status']
          },
          supplier: {
            type: 'object',
            properties: {
              id: { type: 'string', format: 'uuid' },
              business_name: { type: 'string' },
              vendor_type: { type: 'string' }
            },
            required: ['id', 'business_name', 'vendor_type']
          }
        },
        required: ['client', 'supplier']
      }
    },
    
    [WedSyncWebhookEvent.FORM_SUBMITTED]: {
      description: 'Triggered when a client submits a form response',
      priority: 'high',
      schema: {
        type: 'object',
        properties: {
          form: {
            type: 'object',
            properties: {
              id: { type: 'string', format: 'uuid' },
              title: { type: 'string' },
              form_type: { type: 'string' }
            },
            required: ['id', 'title']
          },
          response: {
            type: 'object',
            properties: {
              id: { type: 'string', format: 'uuid' },
              data: { type: 'object' },
              submitted_at: { type: 'string', format: 'date-time' }
            },
            required: ['id', 'data', 'submitted_at']
          },
          client: {
            type: 'object',
            properties: {
              id: { type: 'string', format: 'uuid' },
              couple_name: { type: 'string' },
              wedding_date: { type: 'string', format: 'date' }
            },
            required: ['id', 'couple_name']
          }
        },
        required: ['form', 'response', 'client']
      }
    }
  };

  async triggerWebhook(event: WebhookEventData): Promise<WebhookTriggerResult> {
    const startTime = Date.now();
    
    try {
      // Step 1: Validate event data
      const validationResult = await this.validateEventData(event);
      if (!validationResult.valid) {
        throw new Error(`Invalid webhook event data: ${validationResult.errors.join(', ')}`);
      }

      // Step 2: Get subscribed webhook endpoints
      const endpoints = await this.getSubscribedEndpoints(event.type, event.supplierId);
      
      if (endpoints.length === 0) {
        return {
          success: true,
          message: 'No webhook endpoints subscribed to this event',
          deliveriesScheduled: 0,
          processingTime: Date.now() - startTime
        };
      }

      // Step 3: Create webhook payload
      const webhookPayload = this.createWebhookPayload(event);

      // Step 4: Schedule deliveries for all subscribed endpoints
      const deliveryPromises = endpoints.map(endpoint => 
        this.scheduleWebhookDelivery(webhookPayload, endpoint)
      );

      const deliveryResults = await Promise.allSettled(deliveryPromises);
      const successfulScheduling = deliveryResults.filter(result => 
        result.status === 'fulfilled'
      ).length;

      // Step 5: Log webhook trigger metrics
      await this.logWebhookTrigger({
        eventType: event.type,
        supplierId: event.supplierId,
        endpointsTriggered: endpoints.length,
        successfullyScheduled: successfulScheduling,
        processingTime: Date.now() - startTime
      });

      return {
        success: true,
        message: `Webhook deliveries scheduled for ${successfulScheduling} endpoints`,
        deliveriesScheduled: successfulScheduling,
        processingTime: Date.now() - startTime
      };

    } catch (error) {
      console.error('Webhook trigger failed:', error);
      
      await this.logWebhookError({
        eventType: event.type,
        supplierId: event.supplierId,
        error: error instanceof Error ? error.message : 'Unknown error',
        processingTime: Date.now() - startTime
      });

      return {
        success: false,
        message: 'Failed to trigger webhook',
        error: error instanceof Error ? error.message : 'Unknown error',
        deliveriesScheduled: 0,
        processingTime: Date.now() - startTime
      };
    }
  }

  async deliverWebhook(deliveryId: string): Promise<WebhookDeliveryResult> {
    const startTime = Date.now();
    
    try {
      // Step 1: Get delivery details from database
      const { data: delivery, error } = await this.supabase
        .from('webhook_deliveries')
        .select(`
          *,
          webhook_endpoint:webhook_endpoints(*)
        `)
        .eq('id', deliveryId)
        .single();

      if (error || !delivery) {
        throw new Error(`Delivery not found: ${deliveryId}`);
      }

      // Step 2: Check if delivery is still valid
      if (delivery.status !== 'pending' && delivery.status !== 'retrying') {
        return {
          success: false,
          message: `Delivery already processed with status: ${delivery.status}`,
          deliveryId
        };
      }

      // Step 3: Prepare webhook request
      const payload = delivery.payload;
      const signature = this.generateWebhookSignature(
        JSON.stringify(payload),
        delivery.webhook_endpoint.secret_key
      );

      const webhookHeaders = {
        'Content-Type': 'application/json',
        'X-WedSync-Signature': signature,
        'X-WedSync-Event-Type': delivery.event_type,
        'X-WedSync-Event-Id': delivery.event_id,
        'X-WedSync-Timestamp': Math.floor(Date.now() / 1000).toString(),
        'User-Agent': 'WedSync-Webhooks/1.0',
        'X-WedSync-Attempt': delivery.attempt_number.toString()
      };

      // Step 4: Make HTTP request with timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), delivery.webhook_endpoint.timeout_seconds * 1000);

      let deliveryResult: WebhookDeliveryResult;
      
      try {
        const response = await fetch(delivery.delivery_url, {
          method: 'POST',
          headers: webhookHeaders,
          body: JSON.stringify(payload),
          signal: controller.signal
        });

        clearTimeout(timeoutId);

        const responseBody = await response.text();
        const deliveryDuration = Date.now() - startTime;

        // Step 5: Process delivery response
        if (response.ok) {
          // Successful delivery
          await this.markDeliverySuccessful({
            deliveryId,
            httpStatusCode: response.status,
            responseBody,
            deliveryDuration,
            responseHeaders: Object.fromEntries(response.headers.entries())
          });

          deliveryResult = {
            success: true,
            message: 'Webhook delivered successfully',
            deliveryId,
            httpStatusCode: response.status,
            deliveryTime: deliveryDuration
          };

        } else {
          // Failed delivery - determine if retry is needed
          const shouldRetry = this.shouldRetryDelivery(response.status, delivery.attempt_number, delivery.max_attempts);
          
          if (shouldRetry) {
            await this.scheduleRetry({
              deliveryId,
              httpStatusCode: response.status,
              responseBody,
              deliveryDuration,
              attemptNumber: delivery.attempt_number,
              nextRetryDelay: this.calculateRetryDelay(delivery.attempt_number)
            });

            deliveryResult = {
              success: false,
              message: `Delivery failed, retry scheduled. HTTP ${response.status}`,
              deliveryId,
              httpStatusCode: response.status,
              retryScheduled: true
            };
          } else {
            // Permanent failure
            await this.markDeliveryPermanentlyFailed({
              deliveryId,
              httpStatusCode: response.status,
              responseBody,
              deliveryDuration,
              reason: 'Max retry attempts exceeded or non-retryable error'
            });

            deliveryResult = {
              success: false,
              message: 'Webhook delivery permanently failed',
              deliveryId,
              httpStatusCode: response.status,
              permanentlyFailed: true
            };
          }
        }

      } catch (fetchError) {
        clearTimeout(timeoutId);
        
        // Network error or timeout
        const shouldRetry = delivery.attempt_number < delivery.max_attempts;
        
        if (shouldRetry) {
          await this.scheduleRetry({
            deliveryId,
            errorMessage: fetchError instanceof Error ? fetchError.message : 'Network error',
            deliveryDuration: Date.now() - startTime,
            attemptNumber: delivery.attempt_number,
            nextRetryDelay: this.calculateRetryDelay(delivery.attempt_number)
          });

          deliveryResult = {
            success: false,
            message: 'Network error, retry scheduled',
            deliveryId,
            error: fetchError instanceof Error ? fetchError.message : 'Network error',
            retryScheduled: true
          };
        } else {
          await this.markDeliveryPermanentlyFailed({
            deliveryId,
            errorMessage: fetchError instanceof Error ? fetchError.message : 'Network error',
            deliveryDuration: Date.now() - startTime,
            reason: 'Max retry attempts exceeded after network errors'
          });

          // Add to dead letter queue for manual investigation
          await this.addToDeadLetterQueue({
            deliveryId,
            finalError: fetchError instanceof Error ? fetchError.message : 'Network error',
            totalAttempts: delivery.attempt_number
          });

          deliveryResult = {
            success: false,
            message: 'Webhook delivery permanently failed after network errors',
            deliveryId,
            error: fetchError instanceof Error ? fetchError.message : 'Network error',
            permanentlyFailed: true
          };
        }
      }

      return deliveryResult;

    } catch (error) {
      console.error('Webhook delivery error:', error);
      
      return {
        success: false,
        message: 'Webhook delivery system error',
        deliveryId,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  private async getSubscribedEndpoints(eventType: string, supplierId: string): Promise<WebhookEndpoint[]> {
    const { data: endpoints, error } = await this.supabase
      .from('webhook_endpoints')
      .select('*')
      .eq('supplier_id', supplierId)
      .eq('is_active', true)
      .contains('subscribed_events', [eventType]);

    if (error) {
      console.error('Failed to get webhook endpoints:', error);
      return [];
    }

    return endpoints || [];
  }

  private createWebhookPayload(event: WebhookEventData): WebhookPayload {
    return {
      id: event.eventId,
      type: event.type,
      created: new Date().toISOString(),
      api_version: 'v1',
      data: {
        object: event.data
      },
      wedding_context: {
        supplier_id: event.supplierId,
        vendor_type: event.vendorType,
        wedding_date: event.weddingDate,
        client_id: event.clientId
      }
    };
  }

  private generateWebhookSignature(payload: string, secretKey: string): string {
    const timestamp = Math.floor(Date.now() / 1000);
    const signaturePayload = `${timestamp}.${payload}`;
    
    return `t=${timestamp},v1=${crypto
      .createHmac('sha256', secretKey)
      .update(signaturePayload)
      .digest('hex')}`;
  }

  private shouldRetryDelivery(httpStatusCode: number, attemptNumber: number, maxAttempts: number): boolean {
    // Don't retry if max attempts reached
    if (attemptNumber >= maxAttempts) {
      return false;
    }

    // Retry on server errors (5xx) and specific client errors
    const retryableStatusCodes = [
      408, // Request Timeout
      429, // Too Many Requests
      502, // Bad Gateway
      503, // Service Unavailable
      504, // Gateway Timeout
      520, // Unknown Error (Cloudflare)
      522, // Connection Timed Out (Cloudflare)
      524  // A Timeout Occurred (Cloudflare)
    ];

    return httpStatusCode >= 500 || retryableStatusCodes.includes(httpStatusCode);
  }

  private calculateRetryDelay(attemptNumber: number): number {
    // Exponential backoff: 1, 2, 4, 8, 16 minutes
    const baseDelayMinutes = 1;
    const exponentialDelay = Math.pow(2, attemptNumber - 1) * baseDelayMinutes;
    
    // Add some jitter to prevent thundering herd
    const jitter = Math.random() * 0.1 * exponentialDelay;
    
    return Math.floor((exponentialDelay + jitter) * 60); // Convert to seconds
  }

  private async scheduleRetry(retryData: {
    deliveryId: string;
    httpStatusCode?: number;
    responseBody?: string;
    errorMessage?: string;
    deliveryDuration: number;
    attemptNumber: number;
    nextRetryDelay: number;
  }): Promise<void> {
    const nextRetryAt = new Date(Date.now() + retryData.nextRetryDelay * 1000);

    await this.supabase
      .from('webhook_deliveries')
      .update({
        status: 'retrying',
        http_status_code: retryData.httpStatusCode,
        response_body: retryData.responseBody,
        error_message: retryData.errorMessage,
        delivery_duration_ms: retryData.deliveryDuration,
        attempt_number: retryData.attemptNumber + 1,
        next_retry_at: nextRetryAt.toISOString(),
        updated_at: new Date().toISOString()
      })
      .eq('id', retryData.deliveryId);
  }

  async verifyWebhookSignature(payload: string, signature: string, secretKey: string): Promise<boolean> {
    try {
      // Parse signature header: t=timestamp,v1=signature
      const signatureParts = signature.split(',');
      const timestampPart = signatureParts.find(part => part.startsWith('t='));
      const signaturePart = signatureParts.find(part => part.startsWith('v1='));

      if (!timestampPart || !signaturePart) {
        return false;
      }

      const timestamp = timestampPart.split('=')[1];
      const providedSignature = signaturePart.split('=')[1];

      // Check timestamp freshness (5 minute tolerance)
      const now = Math.floor(Date.now() / 1000);
      const requestTime = parseInt(timestamp);
      
      if (Math.abs(now - requestTime) > 300) { // 5 minutes
        return false;
      }

      // Generate expected signature
      const signaturePayload = `${timestamp}.${payload}`;
      const expectedSignature = crypto
        .createHmac('sha256', secretKey)
        .update(signaturePayload)
        .digest('hex');

      // Compare signatures using constant-time comparison
      return crypto.timingSafeEqual(
        Buffer.from(providedSignature, 'hex'),
        Buffer.from(expectedSignature, 'hex')
      );

    } catch (error) {
      console.error('Webhook signature verification error:', error);
      return false;
    }
  }
}

// Types for webhook system
interface WebhookEventData {
  eventId: string;
  type: WedSyncWebhookEvent;
  data: Record<string, any>;
  supplierId: string;
  clientId?: string;
  vendorType?: string;
  weddingDate?: string;
  triggeredBy?: string;
}

interface WebhookPayload {
  id: string;
  type: string;
  created: string;
  api_version: string;
  data: {
    object: Record<string, any>;
  };
  wedding_context?: {
    supplier_id: string;
    vendor_type?: string;
    wedding_date?: string;
    client_id?: string;
  };
}

interface WebhookEndpoint {
  id: string;
  endpoint_url: string;
  secret_key: string;
  subscribed_events: string[];
  is_active: boolean;
  timeout_seconds: number;
  max_retry_attempts: number;
}

interface WebhookDeliveryResult {
  success: boolean;
  message: string;
  deliveryId: string;
  httpStatusCode?: number;
  deliveryTime?: number;
  retryScheduled?: boolean;
  permanentlyFailed?: boolean;
  error?: string;
}

interface WebhookTriggerResult {
  success: boolean;
  message: string;
  deliveriesScheduled: number;
  processingTime: number;
  error?: string;
}

// Export singleton instance
export const webhookManager = new WedSyncWebhookManager();

// Convenience functions for triggering common webhook events
export async function triggerClientCreatedWebhook(clientData: any, supplierId: string): Promise<void> {
  await webhookManager.triggerWebhook({
    eventId: uuidv4(),
    type: WedSyncWebhookEvent.CLIENT_CREATED,
    data: { client: clientData },
    supplierId,
    clientId: clientData.id,
    vendorType: clientData.supplier?.vendor_type,
    weddingDate: clientData.wedding_date
  });
}

export async function triggerFormSubmittedWebhook(formData: any, responseData: any, supplierId: string): Promise<void> {
  await webhookManager.triggerWebhook({
    eventId: uuidv4(),
    type: WedSyncWebhookEvent.FORM_SUBMITTED,
    data: { 
      form: formData,
      response: responseData,
      client: responseData.client
    },
    supplierId,
    clientId: responseData.client?.id,
    weddingDate: responseData.client?.wedding_date
  });
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for webhook security patterns, HMAC signing, retry strategies
- [x] Supabase: Webhook configuration and delivery tracking storage
- [x] Edge Functions: Webhook delivery queue processing

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/supabase/supabase", "edge functions", 4000);
await mcp__context7__get-library-docs("/node/crypto", "hmac signatures", 3000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('Webhook Endpoints', () => {
  it('should generate valid HMAC signatures for webhook payloads', () => {
    // Test HMAC signature generation and verification
  });
  
  it('should implement exponential backoff retry logic correctly', () => {
    // Test retry logic with proper delay calculations
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Webhook system delivers events with proper retry handling', async () => {
  // Mock webhook endpoint
  const mockServer = await setupMockWebhookServer();
  
  // Create webhook endpoint
  const response = await page.request.post('/api/webhooks/endpoints', {
    data: {
      url: mockServer.url,
      events: ['client.created'],
      integrationType: 'crm_integration'
    }
  });
  
  expect(response.status()).toBe(201);
  
  // Trigger event and verify delivery
  await triggerTestEvent('client.created');
  
  // Verify webhook was delivered
  const deliveredWebhook = await mockServer.getLastWebhook();
  expect(deliveredWebhook.type).toBe('client.created');
  expect(deliveredWebhook.data.client).toBeDefined();
});
```

### ACCEPTANCE CRITERIA
- [x] Webhook system supports all critical wedding industry events (client creation, form submission, journey completion)
- [x] HMAC-SHA256 signature validation prevents webhook tampering with 5-minute timestamp tolerance
- [x] Exponential backoff retry logic (1, 2, 4, 8, 16 minutes) with maximum 5 attempts and dead letter queue
- [x] Performance: Webhook delivery processing completes within 30 seconds with queue-based architecture
- [x] Security: All webhook URLs validated as HTTPS with optional IP whitelisting and rate limiting
- [x] Accessibility: Webhook dashboard provides clear delivery status and troubleshooting guidance

### DEPENDENCIES
- Must complete after: WS-196 (API Routes Structure), WS-197 (Middleware Setup), WS-198 (Error Handling)
- Must complete before: Third-party integration documentation, CRM integration features
- Shares code with: Event system, queue management, notification infrastructure

### ESTIMATED EFFORT
- Team A Backend: 72 hours (Webhook delivery system, retry logic, security validation)
- Team C Integrations: 40 hours (External system integration, webhook testing tools)
- Team D Frontend: 24 hours (Webhook dashboard, endpoint management UI)
- Total: 136 hours