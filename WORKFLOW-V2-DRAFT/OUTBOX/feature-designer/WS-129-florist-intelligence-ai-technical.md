# TECHNICAL SPECIFICATION: WS-129 - Florist Intelligence AI
## Generated by Feature Development Session - 2025-01-23

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding florist designing 120+ arrangements per year with varying seasonal availability and sustainability concerns
**I want to:** Access AI-powered flower selection that considers seasonality, color harmony, sustainability, and allergen compatibility
**So that:** I reduce 3 hours per consultation spent on flower research and eliminate client disappointment from unavailable or problematic flower choices

**Real Wedding Scenario:**
A couple wants "dusty rose and eucalyptus" for their November outdoor wedding in Chicago. Instead of manually checking seasonal charts and allergen lists, the florist enters the color scheme and date. The AI suggests alternatives like "mauve chrysanthemums with silver brunia" (in season, allergy-friendly), calculates sustainability scores based on local growing regions, and generates care timelines to ensure peak freshness on wedding day.

### SPECIFICATION SOURCE
- **Feature ID:** WS-129
- **Original Spec:** /CORE-SPECIFICATIONS/04-AI-INTEGRATION/05-Vendor-Specific/03-florist-intelligence md.md
- **Current Implementation:** 0% complete
- **Files to Modify:** None (new feature)
- **New Files to Create:**
  - /src/lib/florist/flower-intelligence.ts
  - /src/lib/florist/color-harmony.ts
  - /src/lib/florist/sustainability-engine.ts
  - /src/app/api/florist/flowers/search/route.ts
  - /src/app/api/florist/arrangements/optimize/route.ts
  - /src/components/florist/FlowerSearchInterface.tsx
  - /src/components/florist/ColorPaletteGenerator.tsx

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Comprehensive flower variety database
CREATE TABLE IF NOT EXISTS flower_varieties (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  common_name TEXT NOT NULL,
  scientific_name TEXT UNIQUE NOT NULL,
  family_name TEXT,
  color_variants JSONB NOT NULL DEFAULT '[]',
  seasonality JSONB NOT NULL DEFAULT '{"peak": [], "available": [], "scarce": []}',
  characteristics JSONB NOT NULL DEFAULT '{}',
  wedding_uses JSONB NOT NULL DEFAULT '{}',
  growing_regions TEXT[] DEFAULT '{}',
  sustainability_score DECIMAL(3,2) CHECK (sustainability_score >= 0 AND sustainability_score <= 1),
  allergen_info JSONB DEFAULT '{}',
  care_instructions JSONB DEFAULT '{}',
  average_price_per_stem DECIMAL(6,2),
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Seasonal pricing and availability
CREATE TABLE IF NOT EXISTS flower_pricing (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  flower_id UUID REFERENCES flower_varieties(id),
  region TEXT NOT NULL,
  month INTEGER CHECK (month >= 1 AND month <= 12),
  availability_score DECIMAL(3,2) CHECK (availability_score >= 0 AND availability_score <= 1),
  price_multiplier DECIMAL(3,2) DEFAULT 1.0,
  notes TEXT,
  updated_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(flower_id, region, month)
);

-- Color matching and harmony
CREATE TABLE IF NOT EXISTS color_matches (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  flower_id UUID REFERENCES flower_varieties(id),
  color_hex TEXT NOT NULL,
  color_name TEXT,
  color_family TEXT,
  match_accuracy DECIMAL(3,2) CHECK (match_accuracy >= 0 AND match_accuracy <= 1),
  seasonal_variation TEXT,
  created_at TIMESTAMP DEFAULT NOW(),
  INDEX idx_color_hex (color_hex),
  INDEX idx_color_family (color_family)
);

-- Generated arrangement plans
CREATE TABLE IF NOT EXISTS arrangement_plans (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  florist_id UUID REFERENCES user_profiles(id),
  client_id UUID REFERENCES clients(id),
  arrangement_type TEXT NOT NULL,
  size_category TEXT NOT NULL,
  flower_composition JSONB NOT NULL,
  color_scheme JSONB NOT NULL,
  sustainability_score DECIMAL(3,2),
  allergen_score DECIMAL(3,2),
  estimated_cost DECIMAL(8,2),
  care_timeline JSONB,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Sustainability tracking
CREATE TABLE IF NOT EXISTS sustainability_analysis (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  arrangement_id UUID REFERENCES arrangement_plans(id),
  carbon_footprint DECIMAL(8,2),
  local_sourcing_score DECIMAL(3,2),
  seasonal_appropriateness DECIMAL(3,2),
  water_usage_score DECIMAL(3,2),
  recommendations JSONB DEFAULT '[]',
  calculated_at TIMESTAMP DEFAULT NOW()
);
```

#### API Endpoints Required
```typescript
// GET /api/florist/flowers/search
interface FlowerSearchRequest {
  colors?: string[];
  weddingDate?: string;
  location?: string;
  weddingStyle?: string;
  budgetPerArrangement?: number;
  allergenSensitive?: boolean;
  sustainabilityMinimum?: number;
}

interface FlowerSearchResponse {
  success: boolean;
  data: {
    flowers: FlowerMatch[];
    seasonalAlternatives: FlowerMatch[];
    sustainableOptions: FlowerMatch[];
    colorHarmonies: ColorHarmony[];
  };
}

// POST /api/florist/arrangements/optimize
interface ArrangementOptimizationRequest {
  requirements: {
    type: string;
    size: string;
    colors: string[];
    budget: number;
    season: string;
    style: string;
    venue: string;
  };
  constraints: {
    allergens?: string[];
    sustainabilityRequired?: boolean;
    localSourceOnly?: boolean;
  };
}

// POST /api/florist/colors/harmony
interface ColorHarmonyRequest {
  baseColors: string[];
  weddingStyle: string;
  season: string;
}
```

#### Frontend Components Required
```typescript
// Component: FlowerIntelligenceInterface
// Location: /src/components/florist/FlowerSearchInterface.tsx

interface FloristIntelligenceProps {
  weddingDetails: WeddingDetails;
  onFlowerSelected: (flowers: FlowerMatch[]) => void;
  sustainabilityFocus?: boolean;
}

interface FlowerMatch {
  flower: FlowerVariety;
  seasonalScore: number;
  sustainabilityScore: number;
  priceMultiplier: number;
  allergensPresent: string[];
  availabilityCalendar: SeasonalAvailability;
}

interface FlowerVariety {
  id: string;
  commonName: string;
  scientificName: string;
  colors: Color[];
  characteristics: {
    fragrance: 'none' | 'light' | 'moderate' | 'strong';
    lifespan: number;
    stemLength: { min: number; max: number };
  };
  weddingUse: {
    bouquet: boolean;
    centerpiece: boolean;
    ceremony: boolean;
    boutonniere: boolean;
  };
}

// Key functionality:
- Seasonal availability filtering and scoring
- Color harmony analysis and suggestions
- Sustainability score calculation and alternatives
- Allergen detection and safe alternatives
- Real-time pricing based on seasonality
- Arrangement optimization recommendations
```

#### Integration Points
```typescript
// Service: FloristIntelligenceService
// Dependencies: OpenAI, Color analysis APIs, Sustainability databases

class FloristIntelligenceService {
  async searchFlowers(criteria: SearchCriteria): Promise<FlowerMatch[]> {
    // Seasonal availability analysis
    // Color harmony matching
    // Sustainability scoring
    // Allergen compatibility checking
  }
  
  async optimizeArrangement(requirements: ArrangementRequirements): Promise<ArrangementPlan> {
    // AI-powered arrangement design
    // Cost optimization
    // Care timeline generation
    // Alternative suggestions
  }
}
```

### CODE EXAMPLES

#### Example 1: AI-Powered Flower Selection with Seasonality
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { OpenAI } from 'openai';
import { supabase } from '@/lib/supabase';

export class FloristIntelligence {
  private openai = new OpenAI({
    apiKey: process.env.OPENAI_API_KEY
  });

  async searchFlowersWithIntelligence(
    criteria: {
      colors: string[];
      weddingDate: Date;
      location: string;
      style: string;
      sustainabilityRequired: boolean;
      allergens: string[];
    }
  ): Promise<FlowerMatch[]> {
    
    // Step 1: Get seasonal context
    const month = criteria.weddingDate.getMonth() + 1;
    const season = this.determineSeason(criteria.weddingDate, criteria.location);
    
    // Step 2: Query flower database with seasonal scoring
    const { data: baseFlowers } = await supabase
      .from('flower_varieties')
      .select(`
        *,
        color_matches!inner(*),
        flower_pricing(*)
      `)
      .contains('color_matches.color_hex', criteria.colors);

    // Step 3: Apply seasonal scoring
    const seasonallyScored = baseFlowers.map(flower => {
      const seasonalScore = this.calculateSeasonalScore(flower, month);
      const priceMultiplier = this.getPriceMultiplier(flower, month, criteria.location);
      
      return {
        flower,
        seasonalScore,
        priceMultiplier,
        available: seasonalScore > 0.3
      };
    }).filter(f => f.available);

    // Step 4: Sustainability analysis if required
    if (criteria.sustainabilityRequired) {
      for (const match of seasonallyScored) {
        match.sustainabilityScore = await this.calculateSustainabilityScore(
          match.flower,
          criteria.location,
          criteria.weddingDate
        );
      }
    }

    // Step 5: Allergen filtering
    const allergenFiltered = criteria.allergens.length > 0 
      ? seasonallyScored.filter(match => 
          !this.hasAllergenConflicts(match.flower, criteria.allergens)
        )
      : seasonallyScored;

    // Step 6: AI-enhanced recommendations
    const aiEnhanced = await this.enhanceWithAI(allergenFiltered, criteria);

    return this.rankMatches(aiEnhanced);
  }

  private calculateSeasonalScore(flower: any, month: number): number {
    const seasonality = flower.seasonality;
    
    if (seasonality.peak?.includes(month)) return 1.0;
    if (seasonality.available?.includes(month)) return 0.8;
    if (seasonality.scarce?.includes(month)) return 0.3;
    
    return 0.1; // Out of season
  }

  async generateColorHarmony(
    baseColors: string[],
    style: 'romantic' | 'modern' | 'rustic' | 'classic',
    season: string
  ): Promise<ColorHarmony> {
    
    const prompt = `As a professional wedding florist and color expert, create a harmonious color palette:

    Base Colors: ${baseColors.join(', ')}
    Wedding Style: ${style}
    Season: ${season}
    
    Generate:
    1. 2-3 complementary colors that enhance the base colors
    2. 2-3 accent colors for depth and interest
    3. 1-2 neutral colors for balance
    4. Specific flower varieties that naturally exhibit these colors
    5. Seasonal appropriateness for ${season}
    
    Consider color theory principles: complementary, analogous, and triadic harmonies.
    Ensure colors work well in both natural and artificial lighting.
    
    Return as JSON with hex codes, color names, and flower recommendations.`;

    const completion = await this.openai.chat.completions.create({
      model: 'gpt-4',
      messages: [{
        role: 'system',
        content: 'You are a master florist with expertise in color theory and seasonal flower availability.'
      }, {
        role: 'user',
        content: prompt
      }],
      response_format: { type: 'json_object' },
      temperature: 0.4
    });

    const harmony = JSON.parse(completion.choices[0].message.content);
    
    // Enhance with database flower matches
    return await this.enhanceColorHarmonyWithFlowers(harmony);
  }

  async calculateSustainabilityScore(
    flower: any,
    weddingLocation: string,
    weddingDate: Date
  ): Promise<SustainabilityScore> {
    
    const analysis = {
      localSourcing: 0,
      seasonalAppropriateness: 0,
      carbonFootprint: 0,
      waterUsage: 0,
      farmingPractices: 0
    };

    // Calculate distance from primary growing regions
    const distances = flower.growing_regions.map(region => 
      this.calculateDistance(region, weddingLocation)
    );
    const minDistance = Math.min(...distances);
    
    // Local sourcing score (closer = better)
    analysis.localSourcing = Math.max(0, 1 - (minDistance / 2000)); // 2000 miles max

    // Seasonal appropriateness
    const month = weddingDate.getMonth() + 1;
    analysis.seasonalAppropriateness = this.calculateSeasonalScore(flower, month);

    // Carbon footprint estimation
    analysis.carbonFootprint = 1 - (minDistance * 0.001); // Simple linear model

    // Water usage score (from database)
    analysis.waterUsage = flower.sustainability_score || 0.5;

    // Farming practices (from database)
    analysis.farmingPractices = flower.sustainability_score || 0.5;

    const overallScore = (
      analysis.localSourcing * 0.3 +
      analysis.seasonalAppropriateness * 0.25 +
      analysis.carbonFootprint * 0.2 +
      analysis.waterUsage * 0.15 +
      analysis.farmingPractices * 0.1
    );

    return {
      overallScore,
      breakdown: analysis,
      recommendations: await this.generateSustainabilityRecommendations(overallScore, analysis)
    };
  }

  async optimizeArrangement(requirements: ArrangementRequirements): Promise<ArrangementPlan> {
    const prompt = `Create an optimal wedding flower arrangement:

    Type: ${requirements.type}
    Size: ${requirements.size}
    Colors: ${requirements.colors.join(', ')}
    Budget: $${requirements.budget}
    Style: ${requirements.style}
    Season: ${requirements.season}
    Venue: ${requirements.venue}
    
    Design requirements:
    1. Flower selection with specific quantities
    2. Foliage and filler recommendations
    3. Construction technique and mechanics
    4. Care instructions and timeline
    5. Setup and maintenance schedule
    
    Consider:
    - Flower longevity for event duration
    - Color harmony and visual impact
    - Seasonal availability and cost
    - Venue lighting and environment
    - Transportation and setup logistics
    
    Return detailed JSON with flower list, quantities, techniques, and timeline.`;

    const completion = await this.openai.chat.completions.create({
      model: 'gpt-4',
      messages: [{
        role: 'system',
        content: 'You are a master wedding florist with 20+ years of experience designing award-winning arrangements.'
      }, {
        role: 'user',
        content: prompt
      }],
      response_format: { type: 'json_object' },
      temperature: 0.3
    });

    const plan = JSON.parse(completion.choices[0].message.content);
    
    // Enhance with real-time data
    return await this.enhanceArrangementPlan(plan, requirements);
  }

  private calculateDistance(region1: string, region2: string): number {
    // Simplified distance calculation - in production, use proper geocoding
    const coordinates = {
      'california': { lat: 36.7783, lng: -119.4179 },
      'florida': { lat: 27.6648, lng: -81.5158 },
      'colombia': { lat: 4.5709, lng: -74.2973 },
      'ecuador': { lat: -1.8312, lng: -78.1834 }
    };
    
    const coord1 = coordinates[region1.toLowerCase()];
    const coord2 = coordinates[region2.toLowerCase()];
    
    if (!coord1 || !coord2) return 1000; // Default distance
    
    // Haversine formula for great-circle distance
    const R = 3959; // Earth's radius in miles
    const dLat = (coord2.lat - coord1.lat) * Math.PI / 180;
    const dLng = (coord2.lng - coord1.lng) * Math.PI / 180;
    
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(coord1.lat * Math.PI / 180) * Math.cos(coord2.lat * Math.PI / 180) *
              Math.sin(dLng/2) * Math.sin(dLng/2);
    
    return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  }
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [ ] Context7: Load docs for color theory and floral design APIs
- [ ] Playwright: Test flower selection interface and arrangement optimizer
- [ ] Filesystem: Access flower database and image assets

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/openai/openai-node", "structured output", 2500);
// External documentation for color harmony and seasonal flower availability
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('FloristIntelligence', () => {
  it('should calculate seasonal availability scores correctly', () => {
    const flower = {
      seasonality: {
        peak: [6, 7, 8], // June, July, August
        available: [5, 9],
        scarce: [10, 11]
      }
    };
    
    expect(florist.calculateSeasonalScore(flower, 7)).toBe(1.0); // Peak season
    expect(florist.calculateSeasonalScore(flower, 5)).toBe(0.8); // Available
    expect(florist.calculateSeasonalScore(flower, 10)).toBe(0.3); // Scarce
    expect(florist.calculateSeasonalScore(flower, 2)).toBe(0.1); // Out of season
  });

  it('should generate appropriate color harmonies', async () => {
    const harmony = await florist.generateColorHarmony(
      ['#E8B4CB'], // Dusty rose
      'romantic',
      'fall'
    );
    
    expect(harmony.complementaryColors).toBeDefined();
    expect(harmony.flowerRecommendations).toHaveLength.greaterThan(0);
    expect(harmony.seasonalAppropriate).toBe(true);
  });

  it('should calculate sustainability scores accurately', async () => {
    const flower = {
      growing_regions: ['california'],
      sustainability_score: 0.8
    };
    
    const score = await florist.calculateSustainabilityScore(
      flower,
      'los angeles',
      new Date('2025-06-15')
    );
    
    expect(score.overallScore).toBeGreaterThan(0.7); // Local and sustainable
    expect(score.breakdown.localSourcing).toBeGreaterThan(0.8);
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Florist intelligence workflow', async () => {
  await mcp__playwright__browser_navigate({url: '/florist/flowers'});
  
  // Set wedding details
  await mcp__playwright__browser_type({
    element: 'Wedding Date Input',
    ref: 'input[name="weddingDate"]',
    text: '2025-11-15'
  });
  
  await mcp__playwright__browser_type({
    element: 'Color Input',
    ref: 'input[name="colorScheme"]',
    text: '#E8B4CB,#C7A8A8'
  });
  
  await mcp__playwright__browser_click({element: 'Find Flowers Button', ref: 'button[type="submit"]'});
  
  // Wait for AI analysis
  await mcp__playwright__browser_wait_for({text: 'Seasonal recommendations'});
  await mcp__playwright__browser_wait_for({text: 'Sustainability score'});
  
  // Test arrangement optimizer
  await mcp__playwright__browser_click({element: 'Optimize Arrangement', ref: 'button.optimize'});
  await mcp__playwright__browser_wait_for({text: 'Arrangement plan generated'});
  
  await mcp__playwright__browser_snapshot();
});
```

### ACCEPTANCE CRITERIA
- [ ] Search 500+ flower varieties with seasonal availability data
- [ ] Generate color harmonies with 90%+ designer approval rate
- [ ] Calculate sustainability scores including carbon footprint and local sourcing
- [ ] Detect allergen conflicts with 95%+ accuracy
- [ ] Provide seasonal alternatives when primary choices unavailable
- [ ] Generate arrangement plans with detailed care timelines
- [ ] Support real-time pricing based on seasonality and location
- [ ] Include weather resilience recommendations for outdoor weddings

### DEPENDENCIES
- Must complete after: None - Can start immediately
- Must complete before: Wedding timeline and vendor coordination features
- Shares code with: AI content generation, seasonal data processing, sustainability tracking

### ESTIMATED EFFORT
- Team A Frontend: 26 hours (Search interface, color harmony tool, arrangement optimizer)
- Team B Backend: 32 hours (Flower database, AI analysis, sustainability calculations)
- Team C Integration: 18 hours (Seasonal data processing, color analysis APIs, sustainability databases)
- Total: 76 hours