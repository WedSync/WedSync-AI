# TECHNICAL SPECIFICATION: WS-007 - Main Dashboard Layout
## Generated by Feature Development Session - 2025-08-21

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding venue coordinator starting my workday
**I want to:** See all critical information and quick actions on my main dashboard in a organized layout
**So that:** I can identify urgent tasks, check today's activities, and take common actions within 10 seconds instead of navigating through 5+ different pages for 3+ minutes

**Real Wedding Scenario:**
A venue coordinator arrives at work and needs to quickly assess: 1) Which weddings are this weekend (4 total), 2) Any forms overdue (2 couples haven't submitted guest counts), 3) Weather concerns for outdoor ceremonies (rain forecast Saturday), 4) New inquiries to respond to (3 pending). Currently they check email, calendar, weather app, spreadsheet, and CRM separately taking 5+ minutes. With a unified dashboard, all critical info appears instantly in priority zones - weather alerts at top, overdue forms highlighted, weekend timeline visible, quick actions ready - reducing morning briefing from 5 minutes to 30 seconds.

### SPECIFICATION SOURCE
- **Feature ID:** WS-007
- **Original Spec:** /CORE-SPECIFICATIONS/02-WEDSYNC-SUPPLIER-PLATFORM/02-Dashboard/01-main-dashboard-layout md.md
- **Current Implementation:** 0% complete
- **Files to Modify:** None - new feature
- **New Files to Create:**
  - /src/app/(dashboard)/page.tsx
  - /src/components/dashboard/DashboardLayout.tsx
  - /src/components/dashboard/DashboardGrid.tsx
  - /src/components/dashboard/QuickActionsBar.tsx
  - /src/components/dashboard/TodaysFocusWidget.tsx
  - /src/components/dashboard/DashboardCustomizer.tsx
  - /src/lib/stores/dashboardStore.ts
  - /src/app/api/dashboard/data/route.ts
  - /src/app/api/dashboard/preferences/route.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Dashboard widget preferences per user
CREATE TABLE IF NOT EXISTS dashboard_preferences (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  layout_config JSONB NOT NULL DEFAULT '{}', -- Widget positions and sizes
  visible_widgets TEXT[] DEFAULT ARRAY['todays_tasks', 'client_activity', 'wedding_countdown', 'performance_metrics'],
  collapsed_sections TEXT[] DEFAULT ARRAY[]::TEXT[],
  default_view TEXT DEFAULT 'overview',
  refresh_interval INTEGER DEFAULT 300000, -- 5 minutes in ms
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  
  UNIQUE(user_id)
);

-- Dashboard data cache for performance
CREATE TABLE IF NOT EXISTS dashboard_data_cache (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  widget_type TEXT NOT NULL,
  data_payload JSONB NOT NULL,
  cache_key TEXT NOT NULL,
  expires_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP DEFAULT NOW(),
  
  UNIQUE(user_id, cache_key)
);

-- Quick actions usage analytics
CREATE TABLE IF NOT EXISTS quick_action_analytics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  action_type TEXT NOT NULL,
  action_context JSONB DEFAULT '{}',
  usage_count INTEGER DEFAULT 1,
  last_used_at TIMESTAMP DEFAULT NOW(),
  created_at TIMESTAMP DEFAULT NOW(),
  
  UNIQUE(user_id, action_type)
);

-- Widget performance metrics
CREATE TABLE IF NOT EXISTS widget_performance (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  widget_type TEXT NOT NULL,
  load_time_ms INTEGER NOT NULL,
  data_freshness_seconds INTEGER NOT NULL,
  user_id UUID REFERENCES auth.users(id),
  created_at TIMESTAMP DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_dashboard_preferences_user_id ON dashboard_preferences(user_id);
CREATE INDEX idx_dashboard_cache_user_widget ON dashboard_data_cache(user_id, widget_type);
CREATE INDEX idx_dashboard_cache_expires ON dashboard_data_cache(expires_at);
CREATE INDEX idx_quick_actions_user_id ON quick_action_analytics(user_id);
```

#### API Endpoints Required
```typescript
// GET /api/dashboard/data
interface DashboardDataRequest {
  widgets?: string[]; // Specific widgets to load
  refresh?: boolean; // Force refresh cache
}

interface DashboardDataResponse {
  success: boolean;
  data: {
    todaysTasks: {
      forms: Array<{
        id: string;
        clientName: string;
        formName: string;
        dueDate: string;
        priority: 'high' | 'medium' | 'low';
      }>;
      meetings: Array<{
        id: string;
        clientName: string;
        type: string;
        startTime: string;
        joinLink?: string;
      }>;
      journeyMilestones: Array<{
        id: string;
        clientName: string;
        milestoneName: string;
        scheduledTime: string;
      }>;
    };
    clientActivity: Array<{
      id: string;
      clientName: string;
      activityType: string;
      description: string;
      timestamp: string;
      urgent: boolean;
    }>;
    weddingCountdown: {
      nextWedding: {
        id: string;
        coupleNames: string;
        date: string;
        venue: string;
        daysRemaining: number;
        weatherForecast?: WeatherData;
      };
      upcomingCount: number;
    };
    performanceMetrics: {
      thisWeek: {
        formsCompleted: number;
        responseTime: number; // hours
        clientSatisfaction: number; // 1-5
        activeJourneys: number;
      };
      trends: {
        formsCompletedChange: number; // %
        responseTimeChange: number; // %
      };
    };
    alerts: Array<{
      id: string;
      type: 'weather' | 'overdue' | 'urgent' | 'system';
      title: string;
      message: string;
      actionUrl?: string;
      dismissible: boolean;
    }>;
  };
  cacheInfo: {
    lastUpdated: string;
    nextRefresh: string;
  };
}

// PATCH /api/dashboard/preferences
interface UpdateDashboardPreferencesRequest {
  layoutConfig?: {
    widgets: Array<{
      id: string;
      x: number;
      y: number;
      width: number;
      height: number;
    }>;
  };
  visibleWidgets?: string[];
  collapsedSections?: string[];
  defaultView?: string;
  refreshInterval?: number;
}

// POST /api/dashboard/quick-action
interface QuickActionRequest {
  actionType: 'new_client' | 'create_form' | 'send_message' | 'import_clients' | 'start_journey';
  context?: Record<string, any>;
}

interface QuickActionResponse {
  success: boolean;
  data: {
    actionUrl?: string; // For navigation actions
    modalData?: any; // For modal actions
    completed?: boolean; // For immediate actions
  };
}
```

#### Frontend Components Required
```typescript
// Component: DashboardLayout
// Location: /src/components/dashboard/DashboardLayout.tsx

interface DashboardLayoutProps {
  children: React.ReactNode;
  sidebarCollapsed?: boolean;
  onSidebarToggle: () => void;
}

// Key functionality:
- Responsive 3-column layout (sidebar, main, aside)
- Persistent top navigation with search
- Contextual sidebar with collapsible sections
- Main content area with grid system
- Mobile: Single column with bottom navigation
- Keyboard shortcuts (Cmd+K for search)

// Component: DashboardGrid
// Location: /src/components/dashboard/DashboardGrid.tsx

interface DashboardGridProps {
  widgets: WidgetConfig[];
  onWidgetResize: (widgetId: string, dimensions: Dimensions) => void;
  onWidgetMove: (widgetId: string, position: Position) => void;
  customizable?: boolean;
}

// Key functionality:
- CSS Grid with auto-placement
- Drag-and-drop widget repositioning
- Resize handles on widgets
- Responsive breakpoints (lg, md, sm)
- Widget lazy loading for performance
- Auto-save layout changes

// Component: QuickActionsBar
// Location: /src/components/dashboard/QuickActionsBar.tsx

interface QuickActionsBarProps {
  actions: QuickAction[];
  recentActions: string[];
  onActionClick: (action: string) => void;
}

// Key functionality:
- Prominent action buttons with icons
- Recently used actions prioritization
- Keyboard shortcuts display
- Loading states during action execution
- Success/error feedback
- Mobile: Floating action button

// Component: TodaysFocusWidget
// Location: /src/components/dashboard/TodaysFocusWidget.tsx

interface TodaysFocusWidgetProps {
  tasks: TodaysTask[];
  onTaskComplete: (taskId: string) => void;
  onTaskClick: (task: TodaysTask) => void;
}

// Key functionality:
- Prioritized task list with urgency indicators
- One-click task completion
- Quick access to forms and meetings
- Time-sensitive highlighting
- Real-time updates via WebSocket
- Collapsible sections by type
```

#### Integration Points
```typescript
// Store: dashboardStore
// Dependencies: zustand, react-grid-layout, supabase

interface DashboardStore {
  data: DashboardData | null;
  preferences: DashboardPreferences;
  loading: boolean;
  lastRefresh: Date | null;
  
  fetchDashboardData: (refresh?: boolean) => Promise<void>;
  updatePreferences: (updates: Partial<DashboardPreferences>) => Promise<void>;
  moveWidget: (widgetId: string, position: Position) => void;
  resizeWidget: (widgetId: string, dimensions: Dimensions) => void;
  toggleWidget: (widgetId: string, visible: boolean) => void;
  
  executeQuickAction: (action: string, context?: any) => Promise<void>;
  trackQuickActionUsage: (action: string) => void;
  
  subscribeToRealTimeUpdates: () => void;
  unsubscribeFromRealTimeUpdates: () => void;
}

// Real-time dashboard updates
export class DashboardRealTimeUpdater {
  private subscription: RealtimeSubscription | null = null;
  
  subscribe(userId: string, onUpdate: (data: Partial<DashboardData>) => void) {
    this.subscription = supabase
      .channel(`dashboard:${userId}`)
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: 'client_activity'
      }, (payload) => {
        // Update activity feed in real-time
        onUpdate({ 
          clientActivity: [payload.new, ...dashboardStore.data?.clientActivity] 
        });
      })
      .on('postgres_changes', {
        event: 'UPDATE',
        schema: 'public',
        table: 'form_responses'
      }, (payload) => {
        // Update forms completion status
        this.refreshTodaysTasks();
      })
      .subscribe();
  }
  
  private async refreshTodaysTasks() {
    const { data } = await supabase.rpc('get_todays_tasks', {
      supplier_id: auth.user?.id
    });
    
    dashboardStore.getState().updateData({ todaysTasks: data });
  }
}

// Widget performance monitoring
export function trackWidgetPerformance(widgetType: string, startTime: number) {
  const loadTime = Date.now() - startTime;
  
  // Only track if performance is concerning
  if (loadTime > 1000) {
    supabase
      .from('widget_performance')
      .insert({
        widget_type: widgetType,
        load_time_ms: loadTime,
        data_freshness_seconds: calculateDataFreshness(widgetType)
      });
  }
}
```

### CODE EXAMPLES

#### Example 1: Responsive Dashboard Grid with Drag & Drop
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { Responsive, WidthProvider } from 'react-grid-layout';
import { useDashboardStore } from '@/lib/stores/dashboardStore';

const ResponsiveGridLayout = WidthProvider(Responsive);

export function DashboardGrid() {
  const { preferences, updatePreferences } = useDashboardStore();
  
  // Step 1: Define responsive breakpoints and layouts
  const breakpoints = { lg: 1200, md: 996, sm: 768, xs: 480, xxs: 0 };
  const cols = { lg: 12, md: 10, sm: 6, xs: 4, xxs: 2 };
  
  // Step 2: Configure widgets with responsive layouts
  const layouts = {
    lg: [
      { i: 'todays-tasks', x: 0, y: 0, w: 6, h: 8, minW: 4, minH: 6 },
      { i: 'client-activity', x: 6, y: 0, w: 6, h: 8, minW: 4, minH: 6 },
      { i: 'wedding-countdown', x: 0, y: 8, w: 4, h: 4, minW: 3, minH: 3 },
      { i: 'performance-metrics', x: 4, y: 8, w: 8, h: 4, minW: 4, minH: 3 }
    ],
    md: [
      { i: 'todays-tasks', x: 0, y: 0, w: 5, h: 8 },
      { i: 'client-activity', x: 5, y: 0, w: 5, h: 8 },
      { i: 'wedding-countdown', x: 0, y: 8, w: 5, h: 4 },
      { i: 'performance-metrics', x: 5, y: 8, w: 5, h: 4 }
    ],
    sm: [
      { i: 'todays-tasks', x: 0, y: 0, w: 6, h: 6 },
      { i: 'client-activity', x: 0, y: 6, w: 6, h: 6 },
      { i: 'wedding-countdown', x: 0, y: 12, w: 6, h: 4 },
      { i: 'performance-metrics', x: 0, y: 16, w: 6, h: 4 }
    ]
  };
  
  // Step 3: Handle layout changes with debouncing
  const handleLayoutChange = useCallback(
    debounce((layout: Layout[], allLayouts: Layouts) => {
      updatePreferences({
        layoutConfig: { widgets: layout }
      });
    }, 1000),
    [updatePreferences]
  );
  
  // Step 4: Render widgets dynamically
  const renderWidget = (widgetId: string) => {
    const widgetComponents = {
      'todays-tasks': <TodaysFocusWidget />,
      'client-activity': <ClientActivityWidget />,
      'wedding-countdown': <WeddingCountdownWidget />,
      'performance-metrics': <PerformanceMetricsWidget />
    };
    
    return (
      <div key={widgetId} className="dashboard-widget">
        <Suspense fallback={<WidgetSkeleton />}>
          {widgetComponents[widgetId]}
        </Suspense>
      </div>
    );
  };
  
  return (
    <ResponsiveGridLayout
      className="dashboard-grid"
      layouts={layouts}
      breakpoints={breakpoints}
      cols={cols}
      rowHeight={60}
      margin={[16, 16]}
      containerPadding={[16, 16]}
      onLayoutChange={handleLayoutChange}
      isDraggable={preferences.customizable}
      isResizable={preferences.customizable}
      useCSSTransforms={true}
      preventCollision={false}
    >
      {preferences.visibleWidgets.map(renderWidget)}
    </ResponsiveGridLayout>
  );
}
```

#### Example 2: Real-time Dashboard Data Management
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { useEffect, useRef } from 'react';
import { supabase } from '@/lib/supabase';

export function useDashboardRealTime() {
  const { data, updateData } = useDashboardStore();
  const subscriptionsRef = useRef<RealtimeSubscription[]>([]);
  
  useEffect(() => {
    const userId = auth.user?.id;
    if (!userId) return;
    
    // Step 1: Subscribe to client activity updates
    const activitySubscription = supabase
      .channel(`client_activity:${userId}`)
      .on('postgres_changes', {
        event: 'INSERT',
        schema: 'public',
        table: 'client_activity',
        filter: `supplier_id=eq.${userId}`
      }, (payload) => {
        // Add new activity to the top of the feed
        updateData(current => ({
          ...current,
          clientActivity: [payload.new, ...(current?.clientActivity || [])].slice(0, 20)
        }));
      })
      .subscribe();
    
    // Step 2: Subscribe to form completion updates
    const formsSubscription = supabase
      .channel(`forms:${userId}`)
      .on('postgres_changes', {
        event: 'UPDATE',
        schema: 'public',
        table: 'form_responses'
      }, async (payload) => {
        // Refresh today's tasks when forms are completed
        if (payload.new.status === 'completed') {
          const { data: updatedTasks } = await supabase.rpc('get_todays_tasks', {
            supplier_id: userId
          });
          
          updateData(current => ({
            ...current,
            todaysTasks: updatedTasks
          }));
        }
      })
      .subscribe();
    
    // Step 3: Subscribe to journey milestone updates
    const journeySubscription = supabase
      .channel(`journeys:${userId}`)
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: 'journey_executions'
      }, (payload) => {
        // Update journey-related tasks and activities
        refreshJourneyData();
      })
      .subscribe();
    
    subscriptionsRef.current = [
      activitySubscription,
      formsSubscription,
      journeySubscription
    ];
    
    // Step 4: Cleanup subscriptions
    return () => {
      subscriptionsRef.current.forEach(sub => {
        supabase.removeChannel(sub);
      });
    };
  }, [auth.user?.id]);
  
  // Step 5: Periodic data refresh for non-real-time widgets
  useEffect(() => {
    const refreshInterval = setInterval(() => {
      // Refresh performance metrics every 5 minutes
      refreshPerformanceMetrics();
      
      // Refresh weather data every 30 minutes
      refreshWeatherData();
    }, 5 * 60 * 1000);
    
    return () => clearInterval(refreshInterval);
  }, []);
  
  const refreshJourneyData = async () => {
    try {
      const { data: journeyTasks } = await supabase.rpc('get_journey_milestones', {
        supplier_id: auth.user?.id,
        date_filter: new Date().toISOString().split('T')[0]
      });
      
      updateData(current => ({
        ...current,
        todaysTasks: {
          ...current?.todaysTasks,
          journeyMilestones: journeyTasks
        }
      }));
    } catch (error) {
      console.error('Failed to refresh journey data:', error);
    }
  };
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for grid layout, real-time updates
- [ ] Playwright: Test dashboard responsiveness and interactions
- [x] Filesystem: Access dashboard component directories

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/react-grid-layout/react-grid-layout", "responsive layouts", 3000);
await mcp__context7__get-library-docs("/supabase/supabase", "realtime subscriptions", 2000);
await mcp__context7__get-library-docs("/radix-ui/primitives", "dashboard components", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('Dashboard Layout', () => {
  it('should render all widgets based on preferences', () => {
    const preferences = {
      visibleWidgets: ['todays-tasks', 'client-activity'],
      layoutConfig: { widgets: [] }
    };
    
    render(<DashboardGrid preferences={preferences} />);
    
    expect(screen.getByTestId('todays-tasks-widget')).toBeInTheDocument();
    expect(screen.getByTestId('client-activity-widget')).toBeInTheDocument();
  });
  
  it('should handle widget drag and drop', () => {
    const onLayoutChange = jest.fn();
    render(<DashboardGrid onLayoutChange={onLayoutChange} />);
    
    // Simulate drag and drop
    fireEvent.dragStart(screen.getByTestId('todays-tasks-widget'));
    fireEvent.drop(screen.getByTestId('drop-zone'));
    
    expect(onLayoutChange).toHaveBeenCalled();
  });
  
  it('should adapt layout for mobile screens', () => {
    Object.defineProperty(window, 'innerWidth', { value: 480 });
    
    render(<DashboardGrid />);
    
    // Should stack widgets vertically on mobile
    const grid = screen.getByClassName('dashboard-grid');
    expect(grid).toHaveClass('mobile-layout');
  });
});

describe('Real-time Updates', () => {
  it('should update activity feed in real-time', async () => {
    const { result } = renderHook(() => useDashboardRealTime());
    
    // Simulate new activity
    act(() => {
      supabase.channel.emit('postgres_changes', {
        new: { id: '1', activity_type: 'form_completed' }
      });
    });
    
    await waitFor(() => {
      expect(result.current.data.clientActivity[0].id).toBe('1');
    });
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Dashboard loads and displays widgets', async () => {
  await mcp__playwright__browser_navigate({url: '/dashboard'});
  
  // Verify main widgets appear
  await mcp__playwright__browser_wait_for({text: "Today's Focus"});
  await mcp__playwright__browser_wait_for({text: "Client Activity"});
  await mcp__playwright__browser_wait_for({text: "Wedding Countdown"});
  
  await mcp__playwright__browser_snapshot();
});

test('Widget customization works', async () => {
  await mcp__playwright__browser_navigate({url: '/dashboard'});
  
  // Enable customization mode
  await mcp__playwright__browser_click({
    element: 'Customize dashboard',
    ref: '[data-testid="customize-dashboard"]'
  });
  
  // Drag widget to new position
  await mcp__playwright__browser_drag({
    startElement: 'Today\'s Tasks widget',
    startRef: '[data-testid="todays-tasks-widget"]',
    endElement: 'Drop zone',
    endRef: '[data-testid="drop-zone-2"]'
  });
  
  // Save changes
  await mcp__playwright__browser_click({
    element: 'Save layout',
    ref: '[data-testid="save-layout"]'
  });
  
  // Verify layout persisted
  await mcp__playwright__browser_navigate({url: '/dashboard'});
  await mcp__playwright__browser_wait_for({text: 'Layout saved'});
});

test('Quick actions work correctly', async () => {
  await mcp__playwright__browser_navigate({url: '/dashboard'});
  
  // Test new client quick action
  await mcp__playwright__browser_click({
    element: 'Add client button',
    ref: '[data-testid="quick-action-new-client"]'
  });
  
  // Verify modal opens
  await mcp__playwright__browser_wait_for({text: 'New Client'});
  
  // Test create form quick action
  await mcp__playwright__browser_click({
    element: 'Create form button',
    ref: '[data-testid="quick-action-create-form"]'
  });
  
  // Verify navigation
  await mcp__playwright__browser_wait_for({url: '/forms/create'});
});
```

### ACCEPTANCE CRITERIA
- [ ] 3-column responsive layout adapts to desktop, tablet, mobile
- [ ] All 4 priority widgets load in under 3 seconds
- [ ] Drag-and-drop widget repositioning works on desktop
- [ ] Widget preferences persist across sessions
- [ ] Real-time updates appear without page refresh
- [ ] Quick actions execute in under 2 seconds
- [ ] Mobile bottom navigation provides access to all sections
- [ ] Dashboard data refreshes automatically every 5 minutes
- [ ] Keyboard shortcuts work (Cmd+K for search)
- [ ] Loading states prevent layout shift
- [ ] Error states handle network failures gracefully
- [ ] Performance: Time to first meaningful content under 2 seconds

### DEPENDENCIES
- Must complete after: None (foundational feature)
- Must complete before: WS-008 (Navigation), WS-009 (Widgets), WS-010 (Activity Feed)
- Shares code with: All dashboard-related features

### ESTIMATED EFFORT
- Team A Frontend: 28 hours
- Team B Backend: 12 hours
- Team C Integration: 8 hours
- Total: 48 hours