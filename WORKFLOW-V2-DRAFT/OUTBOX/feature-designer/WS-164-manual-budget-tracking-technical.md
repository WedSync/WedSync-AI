# TECHNICAL SPECIFICATION: WS-164 - Manual Budget Tracking
## Generated by Feature Development Session - August 23, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding couple tracking expenses across multiple categories
**I want to:** Manually log wedding expenses with receipts and payment status
**So that:** I can see exactly where my money is going and stay within budget for each category

**Real Wedding Scenario:**
A couple currently keeps wedding receipts in a shoebox and tracks expenses in spreadsheets. With this feature, they photograph a $1,200 florist receipt and log it as "Reception centerpieces - Paid via credit card" which automatically updates their Flowers category from "$2,000 budgeted, $800 spent" to "$2,000 budgeted, $2,000 spent (100% used)."

### SPECIFICATION SOURCE
- **Feature ID:** WS-164
- **Original Spec:** /CORE-SPECIFICATIONS/03-WEDME-COUPLE-PLATFORM/08-Budget-Tracker/02-manual-tracking md.md
- **Current Implementation:** 0% complete (new)
- **Files to Modify:** Extend WS-163 budget categories system
- **New Files to Create:** 
  - `/src/components/budget/ExpenseTracker.tsx`
  - `/src/components/budget/ExpenseForm.tsx` 
  - `/src/components/budget/ReceiptUpload.tsx`
  - `/src/lib/services/expenseService.ts`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Manual expense tracking (extends budget_expenses from WS-163)
ALTER TABLE budget_expenses ADD COLUMN IF NOT EXISTS 
  payment_method VARCHAR(50) CHECK (payment_method IN ('cash', 'credit_card', 'debit_card', 'check', 'bank_transfer', 'other'));

ALTER TABLE budget_expenses ADD COLUMN IF NOT EXISTS 
  receipt_uploaded BOOLEAN DEFAULT false;

ALTER TABLE budget_expenses ADD COLUMN IF NOT EXISTS 
  tax_amount DECIMAL(10,2) DEFAULT 0;

ALTER TABLE budget_expenses ADD COLUMN IF NOT EXISTS 
  tip_amount DECIMAL(10,2) DEFAULT 0;

ALTER TABLE budget_expenses ADD COLUMN IF NOT EXISTS 
  installment_plan JSONB; -- For multi-payment tracking

-- Receipt storage
CREATE TABLE IF NOT EXISTS expense_receipts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  expense_id UUID REFERENCES budget_expenses(id) ON DELETE CASCADE,
  couple_id UUID REFERENCES couples(id),
  file_name VARCHAR(255),
  file_url TEXT NOT NULL,
  file_size INTEGER,
  file_type VARCHAR(50),
  upload_date TIMESTAMPTZ DEFAULT NOW(),
  ocr_text TEXT, -- Extracted text for searchability
  amount_extracted DECIMAL(10,2), -- Amount found via OCR
  vendor_extracted VARCHAR(255) -- Vendor name found via OCR
);

-- Budget alerts and notifications
CREATE TABLE IF NOT EXISTS budget_alerts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  couple_id UUID REFERENCES couples(id),
  category_id UUID REFERENCES budget_categories(id),
  alert_type VARCHAR(50) CHECK (alert_type IN ('approaching_limit', 'over_budget', 'unusual_expense', 'payment_reminder')),
  threshold_percentage INTEGER, -- Alert when spending reaches X% of budget
  message TEXT,
  is_active BOOLEAN DEFAULT true,
  last_triggered TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Expense templates for common wedding costs
CREATE TABLE IF NOT EXISTS expense_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  category_id UUID REFERENCES budget_categories(id),
  template_name VARCHAR(255),
  typical_amount_range JSONB, -- {"min": 500, "max": 2000}
  common_vendors TEXT[],
  payment_schedule VARCHAR(50), -- 'deposit_then_balance', 'full_upfront', 'installments'
  notes TEXT
);

-- Indexes for performance
CREATE INDEX idx_budget_expenses_payment_date ON budget_expenses(payment_date);
CREATE INDEX idx_budget_expenses_status ON budget_expenses(status);
CREATE INDEX idx_expense_receipts_expense_id ON expense_receipts(expense_id);
CREATE INDEX idx_budget_alerts_couple_id ON budget_alerts(couple_id);
```

#### API Endpoints Required
```typescript
// POST /api/expenses
interface CreateExpenseRequest {
  category_id: string;
  title: string;
  amount: number;
  payment_method: string;
  status: 'paid' | 'pending' | 'overdue';
  payment_date?: string;
  vendor_name?: string;
  notes?: string;
  tax_amount?: number;
  tip_amount?: number;
  installment_plan?: {
    total_payments: number;
    current_payment: number;
    remaining_amount: number;
  };
}

// POST /api/expenses/:id/receipt
interface UploadReceiptRequest {
  file: File;
  extract_data: boolean; // Whether to run OCR
}

interface UploadReceiptResponse {
  success: boolean;
  data: {
    receipt_id: string;
    file_url: string;
    extracted_data?: {
      amount: number;
      vendor: string;
      date: string;
      confidence_score: number;
    };
  };
}

// GET /api/expenses/search/:couple_id
interface ExpenseSearchRequest {
  query?: string;
  category_id?: string;
  payment_method?: string;
  status?: string;
  date_from?: string;
  date_to?: string;
  min_amount?: number;
  max_amount?: number;
}

// POST /api/budget/alerts
interface CreateBudgetAlertRequest {
  category_id: string;
  alert_type: string;
  threshold_percentage: number;
  message?: string;
}

// GET /api/expenses/analytics/:couple_id
interface ExpenseAnalyticsResponse {
  success: boolean;
  data: {
    monthly_spending: Array<{
      month: string;
      amount: number;
      category_breakdown: Record<string, number>;
    }>;
    payment_method_breakdown: Record<string, number>;
    vendor_spending: Array<{
      vendor: string;
      total_spent: number;
      expense_count: number;
    }>;
    upcoming_payments: Array<{
      title: string;
      amount: number;
      due_date: string;
      status: string;
    }>;
  };
}
```

#### Integration Points
```typescript
// Service: ExpenseService
// Dependencies: Budget service, file storage service, OCR service

class ExpenseService {
  async createExpense(expenseData: CreateExpenseData): Promise<BudgetExpense> {
    // Create expense record
    const expense = await this.insertExpense(expenseData);
    
    // Update category totals (handled by database triggers from WS-163)
    
    // Check for budget alerts
    await this.checkBudgetAlerts(expenseData.category_id, expense.amount);
    
    // If installment plan, create reminders for future payments
    if (expenseData.installment_plan) {
      await this.createInstallmentReminders(expense);
    }
    
    return expense;
  }
  
  async uploadReceipt(expenseId: string, file: File, extractData: boolean): Promise<ReceiptUploadResult> {
    // Upload file to storage (Supabase Storage)
    const filePath = `receipts/${expenseId}/${Date.now()}-${file.name}`;
    const { data: uploadData, error } = await supabase.storage
      .from('expense-receipts')
      .upload(filePath, file);
    
    if (error) throw error;
    
    const receipt = await this.createReceiptRecord({
      expense_id: expenseId,
      file_name: file.name,
      file_url: uploadData.path,
      file_size: file.size,
      file_type: file.type
    });
    
    let extractedData = null;
    if (extractData) {
      // Use OCR service to extract receipt data
      extractedData = await this.extractReceiptData(uploadData.path);
      
      if (extractedData.confidence_score > 0.8) {
        // Auto-suggest corrections to expense if OCR is confident
        await this.suggestExpenseCorrections(expenseId, extractedData);
      }
    }
    
    // Mark expense as having receipt
    await supabase
      .from('budget_expenses')
      .update({ receipt_uploaded: true })
      .eq('id', expenseId);
    
    return { receipt, extracted_data: extractedData };
  }
  
  async checkBudgetAlerts(categoryId: string, expenseAmount: number): Promise<void> {
    const category = await this.getBudgetCategory(categoryId);
    const alerts = await this.getActiveBudgetAlerts(categoryId);
    
    for (const alert of alerts) {
      const spentPercentage = ((category.spent + expenseAmount) / category.budget_allocated) * 100;
      
      if (spentPercentage >= alert.threshold_percentage) {
        await this.triggerBudgetAlert(alert, {
          current_spent: category.spent + expenseAmount,
          budget_allocated: category.budget_allocated,
          percentage_used: spentPercentage
        });
      }
    }
  }
  
  async searchExpenses(coupleId: string, filters: ExpenseSearchFilters): Promise<BudgetExpense[]> {
    let query = supabase
      .from('budget_expenses')
      .select(`
        *,
        budget_categories!inner(name, color),
        expense_receipts(file_url, file_name)
      `)
      .eq('couple_id', coupleId);
    
    if (filters.query) {
      query = query.or(`title.ilike.%${filters.query}%,vendor_name.ilike.%${filters.query}%,notes.ilike.%${filters.query}%`);
    }
    
    if (filters.category_id) {
      query = query.eq('category_id', filters.category_id);
    }
    
    if (filters.status) {
      query = query.eq('status', filters.status);
    }
    
    if (filters.date_from || filters.date_to) {
      if (filters.date_from) query = query.gte('payment_date', filters.date_from);
      if (filters.date_to) query = query.lte('payment_date', filters.date_to);
    }
    
    if (filters.min_amount || filters.max_amount) {
      if (filters.min_amount) query = query.gte('amount', filters.min_amount);
      if (filters.max_amount) query = query.lte('amount', filters.max_amount);
    }
    
    const { data, error } = await query.order('payment_date', { ascending: false });
    
    if (error) throw error;
    return data || [];
  }
}
```

### CODE EXAMPLES

#### Example 1: Expense Tracker Component
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
'use client';

import { useState, useEffect } from 'react';
import { supabase } from '@/lib/supabase';
import { BudgetExpense, BudgetCategory } from '@/types/budget';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Select } from '@/components/ui/select';
import { Badge } from '@/components/ui/badge';
import { format } from 'date-fns';

export function ExpenseTracker({ 
  coupleId, 
  categories 
}: {
  coupleId: string;
  categories: BudgetCategory[];
}) {
  const [expenses, setExpenses] = useState<BudgetExpense[]>([]);
  const [filteredExpenses, setFilteredExpenses] = useState<BudgetExpense[]>([]);
  const [loading, setLoading] = useState(true);
  const [showExpenseForm, setShowExpenseForm] = useState(false);
  
  // Filter state
  const [searchQuery, setSearchQuery] = useState('');
  const [categoryFilter, setCategoryFilter] = useState('');
  const [statusFilter, setStatusFilter] = useState('');
  const [paymentMethodFilter, setPaymentMethodFilter] = useState('');

  useEffect(() => {
    fetchExpenses();
  }, [coupleId]);

  useEffect(() => {
    applyFilters();
  }, [expenses, searchQuery, categoryFilter, statusFilter, paymentMethodFilter]);

  const fetchExpenses = async () => {
    const { data, error } = await supabase
      .from('budget_expenses')
      .select(`
        *,
        budget_categories!inner(name, color, icon),
        expense_receipts(id, file_url, file_name)
      `)
      .eq('couple_id', coupleId)
      .order('created_at', { ascending: false });
    
    if (error) throw error;
    setExpenses(data || []);
    setLoading(false);
  };

  const applyFilters = () => {
    let filtered = [...expenses];
    
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      filtered = filtered.filter(expense => 
        expense.title.toLowerCase().includes(query) ||
        expense.vendor_name?.toLowerCase().includes(query) ||
        expense.notes?.toLowerCase().includes(query)
      );
    }
    
    if (categoryFilter) {
      filtered = filtered.filter(expense => expense.category_id === categoryFilter);
    }
    
    if (statusFilter) {
      filtered = filtered.filter(expense => expense.status === statusFilter);
    }
    
    if (paymentMethodFilter) {
      filtered = filtered.filter(expense => expense.payment_method === paymentMethodFilter);
    }
    
    setFilteredExpenses(filtered);
  };

  const deleteExpense = async (expenseId: string) => {
    if (!confirm('Are you sure you want to delete this expense?')) return;
    
    const { error } = await supabase
      .from('budget_expenses')
      .delete()
      .eq('id', expenseId);
    
    if (!error) {
      setExpenses(expenses.filter(e => e.id !== expenseId));
    }
  };

  const getStatusColor = (status: string) => {
    return status === 'paid' ? 'bg-green-100 text-green-800' :
           status === 'pending' ? 'bg-yellow-100 text-yellow-800' :
           'bg-red-100 text-red-800';
  };

  const getTotalAmount = () => {
    return filteredExpenses.reduce((sum, expense) => sum + expense.amount, 0);
  };

  const getExpensesByCategory = () => {
    return filteredExpenses.reduce((acc, expense) => {
      const categoryName = expense.budget_categories.name;
      acc[categoryName] = (acc[categoryName] || 0) + expense.amount;
      return acc;
    }, {} as Record<string, number>);
  };

  if (loading) return <div>Loading expenses...</div>;

  return (
    <div className="expense-tracker space-y-6">
      {/* Header with Add Button */}
      <div className="flex justify-between items-center">
        <h2 className="text-2xl font-bold">Expense Tracker</h2>
        <Button onClick={() => setShowExpenseForm(true)}>
          Add Expense
        </Button>
      </div>

      {/* Summary Stats */}
      <div className="stats-grid grid grid-cols-1 md:grid-cols-4 gap-4">
        <div className="stat-card bg-white p-4 border rounded-lg">
          <div className="text-sm text-gray-500">Total Expenses</div>
          <div className="text-2xl font-bold">${getTotalAmount().toLocaleString()}</div>
        </div>
        
        <div className="stat-card bg-white p-4 border rounded-lg">
          <div className="text-sm text-gray-500">Tracked Items</div>
          <div className="text-2xl font-bold">{filteredExpenses.length}</div>
        </div>
        
        <div className="stat-card bg-white p-4 border rounded-lg">
          <div className="text-sm text-gray-500">Pending Payments</div>
          <div className="text-2xl font-bold">
            {filteredExpenses.filter(e => e.status === 'pending').length}
          </div>
        </div>
        
        <div className="stat-card bg-white p-4 border rounded-lg">
          <div className="text-sm text-gray-500">With Receipts</div>
          <div className="text-2xl font-bold">
            {filteredExpenses.filter(e => e.receipt_uploaded).length}
          </div>
        </div>
      </div>

      {/* Filters */}
      <div className="filters-section bg-gray-50 p-4 rounded-lg">
        <div className="grid grid-cols-1 md:grid-cols-5 gap-4">
          <Input
            placeholder="Search expenses..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
          />
          
          <Select
            value={categoryFilter}
            onValueChange={setCategoryFilter}
            placeholder="All Categories"
          >
            <option value="">All Categories</option>
            {categories.map(category => (
              <option key={category.id} value={category.id}>
                {category.icon} {category.name}
              </option>
            ))}
          </Select>
          
          <Select
            value={statusFilter}
            onValueChange={setStatusFilter}
            placeholder="All Statuses"
          >
            <option value="">All Statuses</option>
            <option value="paid">Paid</option>
            <option value="pending">Pending</option>
            <option value="overdue">Overdue</option>
          </Select>
          
          <Select
            value={paymentMethodFilter}
            onValueChange={setPaymentMethodFilter}
            placeholder="Payment Method"
          >
            <option value="">All Methods</option>
            <option value="credit_card">Credit Card</option>
            <option value="debit_card">Debit Card</option>
            <option value="cash">Cash</option>
            <option value="check">Check</option>
            <option value="bank_transfer">Bank Transfer</option>
          </Select>
          
          <Button
            variant="outline"
            onClick={() => {
              setSearchQuery('');
              setCategoryFilter('');
              setStatusFilter('');
              setPaymentMethodFilter('');
            }}
          >
            Clear Filters
          </Button>
        </div>
      </div>

      {/* Expenses List */}
      <div className="expenses-list space-y-3">
        {filteredExpenses.length === 0 ? (
          <div className="text-center py-8 text-gray-500">
            <p>No expenses found matching your filters.</p>
          </div>
        ) : (
          filteredExpenses.map(expense => (
            <div key={expense.id} className="expense-card bg-white border rounded-lg p-4">
              <div className="flex justify-between items-start">
                <div className="flex-1">
                  <div className="flex items-center space-x-3 mb-2">
                    <span className="text-xl">{expense.budget_categories.icon}</span>
                    <div>
                      <div className="font-semibold">{expense.title}</div>
                      <div className="text-sm text-gray-600">
                        {expense.budget_categories.name}
                        {expense.vendor_name && ` â€¢ ${expense.vendor_name}`}
                      </div>
                    </div>
                  </div>
                  
                  {expense.notes && (
                    <div className="text-sm text-gray-600 mb-2">
                      {expense.notes}
                    </div>
                  )}
                  
                  <div className="flex items-center space-x-4 text-sm">
                    <div>
                      <span className="text-gray-500">Amount:</span>
                      <span className="font-medium ml-1">
                        ${expense.amount.toLocaleString()}
                      </span>
                      {expense.tax_amount > 0 && (
                        <span className="text-gray-500 ml-1">
                          (+${expense.tax_amount} tax)
                        </span>
                      )}
                    </div>
                    
                    {expense.payment_date && (
                      <div>
                        <span className="text-gray-500">Date:</span>
                        <span className="ml-1">
                          {format(new Date(expense.payment_date), 'MMM d, yyyy')}
                        </span>
                      </div>
                    )}
                    
                    {expense.payment_method && (
                      <div>
                        <span className="text-gray-500">Method:</span>
                        <span className="ml-1 capitalize">
                          {expense.payment_method.replace('_', ' ')}
                        </span>
                      </div>
                    )}
                  </div>
                </div>
                
                <div className="flex items-center space-x-2">
                  <Badge className={getStatusColor(expense.status)}>
                    {expense.status}
                  </Badge>
                  
                  {expense.receipt_uploaded && (
                    <Badge variant="outline" className="text-green-600">
                      ðŸ“„ Receipt
                    </Badge>
                  )}
                  
                  {expense.installment_plan && (
                    <Badge variant="outline" className="text-blue-600">
                      ðŸ’³ Installment
                    </Badge>
                  )}
                  
                  <Button
                    size="sm"
                    variant="ghost"
                    onClick={() => deleteExpense(expense.id)}
                    className="text-red-500 hover:text-red-700"
                  >
                    Delete
                  </Button>
                </div>
              </div>
            </div>
          ))
        )}
      </div>

      {/* Category Breakdown */}
      {filteredExpenses.length > 0 && (
        <div className="category-breakdown bg-white border rounded-lg p-4">
          <h3 className="font-semibold mb-3">Spending by Category</h3>
          <div className="space-y-2">
            {Object.entries(getExpensesByCategory())
              .sort(([,a], [,b]) => b - a)
              .map(([category, amount]) => (
                <div key={category} className="flex justify-between">
                  <span>{category}</span>
                  <span className="font-medium">${amount.toLocaleString()}</span>
                </div>
              ))}
          </div>
        </div>
      )}
    </div>
  );
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for file upload, OCR libraries
- [x] Playwright: Test expense tracking workflows
- [x] Filesystem: Access expense components

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/supabase/supabase-js", "file storage", 2000);
await mcp__context7__get-library-docs("/tesseract.js/tesseract.js", "ocr text extraction", 1500);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('ExpenseService', () => {
  it('should create expense and update category totals', async () => {
    const expense = await service.createExpense({
      category_id: 'flowers-category',
      amount: 500
    });
    
    const category = await service.getBudgetCategory('flowers-category');
    expect(category.spent).toBe(500);
  });

  it('should trigger budget alerts when threshold exceeded', async () => {
    await service.checkBudgetAlerts('category-id', 1000);
    // Verify alert notification sent
  });
});
```

#### E2E Tests Required
```typescript
test('Manual expense tracking flow', async () => {
  await mcp__playwright__browser_navigate({url: '/budget'});
  
  // Add new expense
  await mcp__playwright__browser_click({
    element: 'Add Expense button',
    ref: 'button[data-testid="add-expense"]'
  });
  
  // Fill expense form
  await mcp__playwright__browser_type({
    element: 'Expense title input',
    ref: 'input[name="title"]',
    text: 'Wedding cake deposit'
  });
  
  // Upload receipt
  await mcp__playwright__browser_file_upload({
    paths: ['/test-assets/sample-receipt.jpg']
  });
  
  await mcp__playwright__browser_snapshot();
});
```

### ACCEPTANCE CRITERIA
- [x] Manual expense entry with receipt upload functionality
- [x] OCR text extraction for automatic expense data filling
- [x] Expense categorization with real-time budget impact
- [x] Search and filter expenses by multiple criteria
- [x] Payment method and installment plan tracking
- [x] Budget alerts when spending thresholds are exceeded
- [x] Receipt storage and organization system
- [x] Expense analytics and spending trends
- [x] Performance: Expense creation <1s, search results <500ms
- [x] Security: All expenses scoped to couple_id with RLS policies
- [x] Accessibility: Screen reader support for expense status indicators

### DEPENDENCIES
- Must complete after: WS-163 (Budget Categories)
- Must complete before: None
- Shares code with: Budget management and file storage systems

### ESTIMATED EFFORT
- Team A Frontend: 26 hours
- Team B Backend: 22 hours
- Team C Integration: 14 hours
- Total: 62 hours