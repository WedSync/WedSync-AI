# TECHNICAL SPECIFICATION: WS-138 - Touch Optimization
## Generated by Feature Development Session - 2025-08-24

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding photographer on wedding day
**I want to:** Easily navigate and interact with WedSync app using one hand while managing camera equipment
**So that:** I can quickly access shot lists, timeline, and contacts without fumbling with small touch targets or accidental taps

**Real Wedding Scenario:**
A photographer at a wedding ceremony needs to check their shot list while holding a camera. With touch optimization, all buttons are minimum 48px, they can swipe between screens one-handed, and large touch targets prevent missed taps during critical moments.

### SPECIFICATION SOURCE
- **Feature ID:** WS-138
- **Original Spec:** /CORE-SPECIFICATIONS/09-MOBILE-OPTIMIZATION/04-touch-optimization md.md
- **Current Implementation:** 0% complete
- **Files to Modify:** 
  - /src/styles/globals.css
  - /src/components/ui/Button.tsx
  - /src/components/ui/Input.tsx
  - /src/components/layout/MobileNavigation.tsx
  - /src/hooks/useSwipeNavigation.ts
  - /src/hooks/useHapticFeedback.ts
- **New Files to Create:**
  - /src/components/ui/TouchInput.tsx
  - /src/components/ui/PullToRefresh.tsx
  - /src/components/wedding-day/QuickActions.tsx
  - /src/hooks/useKeyboardVisibility.ts
  - /src/hooks/useInfiniteScroll.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- No database changes required for touch optimization
-- This is purely a frontend enhancement
```

#### API Endpoints Required
```typescript
// No new API endpoints required
// Touch optimization is client-side only
```

#### Frontend Components Required
```typescript
// Component: TouchInput
// Location: /src/components/ui/TouchInput.tsx

interface TouchInputProps {
  type: string;
  label: string;
  placeholder?: string;
  value?: string;
  onChange?: (value: string) => void;
}

// Component: PullToRefresh
// Location: /src/components/ui/PullToRefresh.tsx

interface PullToRefreshProps {
  onRefresh: () => Promise<void>;
  children: React.ReactNode;
}

// Component: MobileNavigation  
// Location: /src/components/layout/MobileNavigation.tsx

interface NavItem {
  id: string;
  label: string;
  icon: React.ComponentType;
  hasNotification?: boolean;
}

// Component: WeddingDayQuickActions
// Location: /src/components/wedding-day/QuickActions.tsx

interface QuickAction {
  id: string;
  label: string;
  icon: React.ComponentType;
  action: () => void;
  color: string;
}

// Key functionality:
- Minimum 48px touch targets for all interactive elements
- Haptic feedback on critical actions
- Swipe navigation between screens
- Pull-to-refresh on data lists
- One-handed thumb-friendly navigation
- Touch feedback animations with scale/opacity
```

#### Integration Points
```typescript
// Service: TouchOptimizationService
// Dependencies: React, Next.js, Tailwind CSS

class TouchOptimizationService {
  static applyTouchStyles(element: HTMLElement) {
    // Apply minimum touch target sizes
    element.style.minHeight = '48px';
    element.style.minWidth = '48px';
  }

  static preventIOSZoom(inputElement: HTMLInputElement) {
    // Set font-size to 16px to prevent iOS zoom
    inputElement.style.fontSize = '16px';
  }

  static enableSafeAreaSupport() {
    // Add safe area padding for devices with notches
    document.documentElement.style.setProperty('--safe-area-top', 'env(safe-area-inset-top)');
  }
}
```

### CODE EXAMPLES

#### Example 1: Touch-Optimized Button Component
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import React from 'react';
import { cn } from '@/lib/utils';

interface TouchButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary';
  size?: 'sm' | 'md' | 'lg';
  children: React.ReactNode;
}

export const TouchButton: React.FC<TouchButtonProps> = ({
  variant = 'primary',
  size = 'md',
  className,
  children,
  ...props
}) => {
  const baseClasses = `
    relative overflow-hidden transition-all duration-150
    active:scale-98 active:opacity-90
    touch-manipulation -webkit-tap-highlight-color-transparent
  `;
  
  const sizeClasses = {
    sm: 'min-h-[44px] min-w-[44px] px-4 py-2 text-sm',
    md: 'min-h-[48px] min-w-[48px] px-6 py-3 text-base', 
    lg: 'min-h-[56px] min-w-[120px] px-8 py-4 text-lg'
  };

  const variantClasses = {
    primary: 'bg-primary-600 text-white hover:bg-primary-700',
    secondary: 'bg-gray-200 text-gray-900 hover:bg-gray-300'
  };

  return (
    <button
      className={cn(
        baseClasses,
        sizeClasses[size],
        variantClasses[variant],
        className
      )}
      {...props}
    >
      {children}
    </button>
  );
};
```

#### Example 2: Swipe Navigation Hook
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { useRef, useCallback } from 'react';
import { useRouter } from 'next/router';

interface SwipeGesture {
  startX: number;
  startY: number;
  currentX: number;
  currentY: number;
  timestamp: number;
}

export const useSwipeNavigation = () => {
  const router = useRouter();
  const gestureRef = useRef<SwipeGesture | null>(null);

  const handleTouchStart = useCallback((e: TouchEvent) => {
    const touch = e.touches[0];
    gestureRef.current = {
      startX: touch.clientX,
      startY: touch.clientY,
      currentX: touch.clientX,
      currentY: touch.clientY,
      timestamp: Date.now()
    };
  }, []);

  const handleTouchEnd = useCallback((e: TouchEvent) => {
    if (!gestureRef.current) return;

    const touch = e.changedTouches[0];
    const deltaX = touch.clientX - gestureRef.current.startX;
    const deltaY = touch.clientY - gestureRef.current.startY;
    const timeDelta = Date.now() - gestureRef.current.timestamp;

    // Horizontal swipe detection (min 50px, max 300ms)
    if (Math.abs(deltaX) > 50 && Math.abs(deltaY) < 50 && timeDelta < 300) {
      if (deltaX > 0) {
        router.back(); // Swipe right - go back
      }
      // Swipe left could navigate forward if in a workflow
    }

    gestureRef.current = null;
  }, [router]);

  return {
    handleTouchStart,
    handleTouchEnd,
    gestureHandlers: {
      onTouchStart: handleTouchStart,
      onTouchEnd: handleTouchEnd
    }
  };
};
```

### MCP SERVER USAGE

#### Required MCP Servers
- [ ] Context7: Load docs for React hooks, CSS touch properties
- [ ] Playwright: Test touch interactions and gesture recognition
- [ ] Filesystem: Access component and styling files

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/facebook/react", "hooks useRef useState", 2000);
await mcp__context7__get-library-docs("/tailwindcss/tailwindcss", "responsive design touch", 1500);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('TouchButton', () => {
  it('should have minimum 48px touch target', () => {
    render(<TouchButton>Test</TouchButton>);
    const button = screen.getByRole('button');
    expect(button).toHaveStyle('min-height: 48px');
    expect(button).toHaveStyle('min-width: 48px');
  });

  it('should provide active state feedback', () => {
    render(<TouchButton>Test</TouchButton>);
    const button = screen.getByRole('button');
    fireEvent.touchStart(button);
    expect(button).toHaveClass('active:scale-98');
  });
});

describe('SwipeNavigation', () => {
  it('should detect horizontal swipe gestures', () => {
    const mockRouter = { back: jest.fn() };
    const { handleTouchStart, handleTouchEnd } = useSwipeNavigation();
    
    // Simulate swipe right gesture
    const startEvent = createTouchEvent('touchstart', 100, 200);
    const endEvent = createTouchEvent('touchend', 200, 200);
    
    handleTouchStart(startEvent);
    handleTouchEnd(endEvent);
    
    expect(mockRouter.back).toHaveBeenCalled();
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Touch interactions work on mobile viewport', async () => {
  await mcp__playwright__browser_resize({ width: 375, height: 667 });
  await mcp__playwright__browser_navigate({ url: '/dashboard' });
  
  // Test touch target sizes
  await mcp__playwright__browser_snapshot();
  const buttons = await page.locator('button').all();
  
  for (const button of buttons) {
    const box = await button.boundingBox();
    expect(box.height).toBeGreaterThanOrEqual(44);
    expect(box.width).toBeGreaterThanOrEqual(44);
  }
});

test('Swipe navigation between pages', async () => {
  await mcp__playwright__browser_navigate({ url: '/clients/123' });
  await mcp__playwright__browser_snapshot();
  
  // Simulate swipe right gesture
  await page.touchscreen.tap(100, 300);
  await page.mouse.move(100, 300);
  await page.mouse.move(200, 300);
  await page.touchscreen.tap(200, 300);
  
  // Should navigate back
  expect(page.url()).toContain('/clients');
});
```

### ACCEPTANCE CRITERIA
- [ ] All interactive elements have minimum 48px touch targets
- [ ] Form inputs don't trigger zoom on iOS (16px+ font-size)
- [ ] Swipe gestures work for navigation (right swipe = back)
- [ ] Pull-to-refresh implemented on data lists
- [ ] Touch feedback provides visual/haptic response within 100ms
- [ ] Bottom navigation optimized for thumb reach
- [ ] Performance: Touch response under 16ms for 60fps
- [ ] Security: No sensitive data in touch event logs
- [ ] Accessibility: All touch targets work with screen readers

### DEPENDENCIES
- Must complete after: WS-136 (Responsive Design System)
- Must complete before: WS-145 (Performance Targets)
- Shares code with: WS-137 (PWA Configuration), WS-144 (Offline Functionality)

### ESTIMATED EFFORT
- Team A Frontend: 32 hours (components, styling, gestures)
- Team B Backend: 0 hours (frontend-only feature)
- Team C Integration: 8 hours (testing, accessibility)
- Total: 40 hours