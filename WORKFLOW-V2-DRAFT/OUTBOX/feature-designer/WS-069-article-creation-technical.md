# TECHNICAL SPECIFICATION: WS-069 - Article Creation
## Generated by Feature Development Session - August 21, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding florist
**I want to:** Create and publish educational articles about seasonal flower choices, arrangement styles, and color palettes that automatically appear in relevant client dashboards
**So that:** I can establish expertise, answer common questions once instead of repeatedly, and help couples make informed decisions which reduces consultation time by 40%

**Real Wedding Scenario:**
A florist answers the same questions 50+ times per season: "What flowers are in season for July?", "How many centerpieces do I need for 150 guests?", "What's the difference between cascade and round bouquets?" With article creation, they write comprehensive guides once ("July Wedding Flowers: 15 Stunning In-Season Options"), these articles auto-appear in July wedding client dashboards, couples arrive at consultations already educated, and the florist's website SEO improves, attracting 30% more organic leads.

### SPECIFICATION SOURCE
- **Feature ID:** WS-069
- **Original Spec:** /CORE-SPECIFICATIONS/02-WEDSYNC-SUPPLIER-PLATFORM/09-Documents-Articles/02-article-creation md.md
- **Current Implementation:** 0% complete
- **Files to Modify:** None
- **New Files to Create:** 
  - `/wedsync/src/components/articles/ArticleEditor.tsx`
  - `/wedsync/src/components/articles/ArticleLibrary.tsx`
  - `/wedsync/src/components/articles/SEOOptimizer.tsx`
  - `/wedsync/src/components/articles/PublishingScheduler.tsx`
  - `/wedsync/src/components/articles/ArticleAnalytics.tsx`
  - `/wedsync/src/lib/services/article-service.ts`
  - `/wedsync/src/lib/services/content-distribution.ts`
  - `/wedsync/src/app/api/articles/route.ts`
  - `/wedsync/src/app/api/articles/[id]/publish/route.ts`
  - `/wedsync/src/types/articles.ts`
  - `/wedsync/supabase/migrations/032_article_creation_system.sql`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Articles and educational content
CREATE TABLE IF NOT EXISTS articles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  title VARCHAR(255) NOT NULL,
  slug VARCHAR(255) NOT NULL,
  excerpt TEXT,
  content TEXT NOT NULL,
  content_json JSONB, -- For rich editor structured data
  featured_image_url TEXT,
  article_type article_type NOT NULL,
  status article_status NOT NULL DEFAULT 'draft',
  published_at TIMESTAMPTZ,
  scheduled_for TIMESTAMPTZ,
  author_name VARCHAR(255),
  author_bio TEXT,
  reading_time_minutes INTEGER,
  word_count INTEGER,
  is_featured BOOLEAN DEFAULT false,
  view_count INTEGER DEFAULT 0,
  engagement_score DECIMAL(3,2) DEFAULT 0,
  seo_config JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id, slug)
);

CREATE TYPE article_type AS ENUM (
  'how_to_guide',
  'planning_tips',
  'seasonal_advice',
  'trend_report',
  'portfolio_story',
  'real_wedding',
  'venue_showcase',
  'styled_shoot',
  'faq_compilation',
  'educational'
);

CREATE TYPE article_status AS ENUM (
  'draft',
  'review',
  'scheduled',
  'published',
  'archived'
);

-- Article categories and tags
CREATE TABLE IF NOT EXISTS article_categories (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  category_name VARCHAR(100) NOT NULL,
  category_slug VARCHAR(100) NOT NULL,
  description TEXT,
  parent_category_id UUID REFERENCES article_categories(id) ON DELETE CASCADE,
  display_order INTEGER DEFAULT 0,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id, category_slug)
);

CREATE TABLE IF NOT EXISTS article_tags (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tag_name VARCHAR(50) NOT NULL,
  tag_slug VARCHAR(50) NOT NULL,
  usage_count INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(tag_slug)
);

-- Article categorization and tagging
CREATE TABLE IF NOT EXISTS article_category_mappings (
  article_id UUID REFERENCES articles(id) ON DELETE CASCADE,
  category_id UUID REFERENCES article_categories(id) ON DELETE CASCADE,
  PRIMARY KEY (article_id, category_id)
);

CREATE TABLE IF NOT EXISTS article_tag_mappings (
  article_id UUID REFERENCES articles(id) ON DELETE CASCADE,
  tag_id UUID REFERENCES article_tags(id) ON DELETE CASCADE,
  PRIMARY KEY (article_id, tag_id)
);

-- Article media and embeds
CREATE TABLE IF NOT EXISTS article_media (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  article_id UUID REFERENCES articles(id) ON DELETE CASCADE,
  media_type media_type NOT NULL,
  media_url TEXT NOT NULL,
  thumbnail_url TEXT,
  caption TEXT,
  alt_text VARCHAR(255),
  display_order INTEGER DEFAULT 0,
  metadata JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TYPE media_type AS ENUM (
  'image',
  'video',
  'gallery',
  'embed',
  'document'
);

-- Article distribution and visibility
CREATE TABLE IF NOT EXISTS article_distribution (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  article_id UUID REFERENCES articles(id) ON DELETE CASCADE,
  distribution_channel distribution_channel NOT NULL,
  distribution_config JSONB NOT NULL,
  scheduled_at TIMESTAMPTZ,
  distributed_at TIMESTAMPTZ,
  status distribution_status DEFAULT 'pending',
  metrics JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TYPE distribution_channel AS ENUM (
  'client_dashboard',
  'email_newsletter',
  'social_media',
  'rss_feed',
  'website',
  'partner_platform'
);

CREATE TYPE distribution_status AS ENUM (
  'pending',
  'scheduled',
  'distributed',
  'failed'
);

-- Article targeting rules for smart distribution
CREATE TABLE IF NOT EXISTS article_targeting_rules (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  article_id UUID REFERENCES articles(id) ON DELETE CASCADE,
  rule_type targeting_rule_type NOT NULL,
  rule_config JSONB NOT NULL,
  priority INTEGER DEFAULT 0,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TYPE targeting_rule_type AS ENUM (
  'wedding_month',    -- Show July flower articles to July weddings
  'venue_type',       -- Show barn articles to barn venue couples
  'package_level',    -- Show luxury content to premium packages
  'timeline_stage',   -- Show planning guides 6 months out
  'service_category', -- Show photo tips to photography clients
  'location_based'    -- Show local venue guides
);

-- Article analytics and engagement
CREATE TABLE IF NOT EXISTS article_analytics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  article_id UUID REFERENCES articles(id) ON DELETE CASCADE,
  view_date DATE NOT NULL,
  unique_views INTEGER DEFAULT 0,
  total_views INTEGER DEFAULT 0,
  avg_read_time_seconds INTEGER,
  bounce_rate DECIMAL(3,2),
  share_count INTEGER DEFAULT 0,
  conversion_count INTEGER DEFAULT 0,
  engagement_actions JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(article_id, view_date)
);

-- Article SEO metadata
CREATE TABLE IF NOT EXISTS article_seo (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  article_id UUID REFERENCES articles(id) ON DELETE CASCADE UNIQUE,
  meta_title VARCHAR(60),
  meta_description VARCHAR(160),
  canonical_url TEXT,
  og_title VARCHAR(60),
  og_description VARCHAR(160),
  og_image_url TEXT,
  keywords TEXT[],
  schema_markup JSONB,
  robots_directives VARCHAR(100) DEFAULT 'index,follow',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- RLS policies
ALTER TABLE articles ENABLE ROW LEVEL SECURITY;
ALTER TABLE article_categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE article_tags ENABLE ROW LEVEL SECURITY;
ALTER TABLE article_media ENABLE ROW LEVEL SECURITY;
ALTER TABLE article_distribution ENABLE ROW LEVEL SECURITY;
ALTER TABLE article_targeting_rules ENABLE ROW LEVEL SECURITY;
ALTER TABLE article_analytics ENABLE ROW LEVEL SECURITY;
ALTER TABLE article_seo ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can manage their own articles" ON articles
  FOR ALL USING (auth.uid() = user_id);

CREATE POLICY "Published articles are publicly readable" ON articles
  FOR SELECT USING (status = 'published');

CREATE POLICY "Users can manage their own categories" ON article_categories
  FOR ALL USING (auth.uid() = user_id);

CREATE POLICY "Users can manage their article media" ON article_media
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM articles 
      WHERE articles.id = article_media.article_id 
      AND articles.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can manage their article distribution" ON article_distribution
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM articles 
      WHERE articles.id = article_distribution.article_id 
      AND articles.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can view their article analytics" ON article_analytics
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM articles 
      WHERE articles.id = article_analytics.article_id 
      AND articles.user_id = auth.uid()
    )
  );
```

#### API Endpoints Required
```typescript
// POST /api/articles
interface CreateArticleRequest {
  title: string;
  content: string;
  contentJson?: any; // Rich editor JSON structure
  excerpt?: string;
  articleType: ArticleType;
  categories?: string[];
  tags?: string[];
  featuredImageUrl?: string;
  seoConfig?: SEOConfiguration;
  targetingRules?: TargetingRule[];
}

interface CreateArticleResponse {
  success: boolean;
  data: {
    article: Article;
    slug: string;
    previewUrl: string;
  };
}

// PUT /api/articles/[id]
interface UpdateArticleRequest {
  title?: string;
  content?: string;
  excerpt?: string;
  status?: ArticleStatus;
  scheduledFor?: string;
  seoConfig?: SEOConfiguration;
  targetingRules?: TargetingRule[];
}

// POST /api/articles/[id]/publish
interface PublishArticleRequest {
  publishImmediately?: boolean;
  scheduledFor?: string;
  distributionChannels?: DistributionChannel[];
  notifySubscribers?: boolean;
}

interface PublishArticleResponse {
  success: boolean;
  data: {
    articleId: string;
    publishedAt?: string;
    scheduledFor?: string;
    publicUrl: string;
    distributionStatus: Record<string, string>;
  };
}

// GET /api/articles
interface GetArticlesRequest {
  status?: ArticleStatus;
  category?: string;
  tags?: string[];
  searchQuery?: string;
  sortBy?: 'recent' | 'popular' | 'engagement';
}

interface GetArticlesResponse {
  success: boolean;
  data: {
    articles: Article[];
    categories: ArticleCategory[];
    popularTags: Tag[];
    totalCount: number;
  };
}

// POST /api/articles/[id]/distribute
interface DistributeArticleRequest {
  channels: Array<{
    channel: DistributionChannel;
    config: any;
    scheduledAt?: string;
  }>;
}

interface DistributeArticleResponse {
  success: boolean;
  data: {
    distributionIds: string[];
    estimatedReach: number;
    scheduledDistributions: number;
  };
}

// GET /api/articles/[id]/analytics
interface GetArticleAnalyticsResponse {
  success: boolean;
  data: {
    totalViews: number;
    uniqueViews: number;
    avgReadTime: number;
    engagementRate: number;
    conversionRate: number;
    shareCount: number;
    viewTrend: Array<{date: string; views: number}>;
    topReferrers: Array<{source: string; count: number}>;
    clientEngagement: {
      dashboardViews: number;
      clickThroughRate: number;
    };
  };
}

// POST /api/articles/seo-check
interface SEOCheckRequest {
  title: string;
  content: string;
  metaDescription?: string;
  targetKeywords?: string[];
}

interface SEOCheckResponse {
  success: boolean;
  data: {
    score: number; // 0-100
    recommendations: Array<{
      type: string;
      message: string;
      priority: 'high' | 'medium' | 'low';
    }>;
    keywordDensity: Record<string, number>;
    readabilityScore: number;
  };
}

// GET /api/articles/suggestions
interface GetArticleSuggestionsRequest {
  clientWeddingMonth?: string;
  venueType?: string;
  serviceCategory?: string;
}

interface GetArticleSuggestionsResponse {
  success: boolean;
  data: {
    suggestions: Array<{
      title: string;
      reason: string;
      expectedViews: number;
      keywords: string[];
    }>;
    trendingTopics: string[];
    competitorArticles: Array<{title: string; url: string}>;
  };
}
```

#### Frontend Components Required
```typescript
// Component: ArticleEditor
// Location: /src/components/articles/ArticleEditor.tsx

interface ArticleEditorProps {
  article?: Article;
  onSave: (article: Partial<Article>) => Promise<void>;
  onPublish: (article: Article) => Promise<void>;
  onPreview: (article: Article) => void;
}

// Key functionality:
- Rich text editor with wedding-specific content blocks
- Image gallery and video embed tools
- Table builder for pricing/package information
- Real-time word count and reading time estimation
- Auto-save with version history
- SEO preview and optimization panel
- Mobile preview mode
- Template library for common article types

// Component: ArticleLibrary
// Location: /src/components/articles/ArticleLibrary.tsx

interface ArticleLibraryProps {
  articles: Article[];
  onArticleSelect: (article: Article) => void;
  onBulkAction: (action: string, articleIds: string[]) => void;
}

// Key functionality:
- Grid/list view toggle with article thumbnails
- Status filters (draft, published, scheduled)
- Category and tag filtering
- Search with content indexing
- Bulk operations (publish, archive, delete)
- Analytics preview cards
- Quick edit actions
- Article performance indicators

// Component: SEOOptimizer
// Location: /src/components/articles/SEOOptimizer.tsx

interface SEOOptimizerProps {
  content: string;
  title: string;
  currentSEO?: SEOConfiguration;
  onSEOUpdate: (seo: SEOConfiguration) => void;
}

// Key functionality:
- Meta title/description editor with character limits
- Keyword density analyzer
- Readability score calculator
- Internal linking suggestions
- Schema markup generator for wedding content
- Social media preview cards
- Competitor analysis integration
- SEO score with actionable recommendations

// Component: PublishingScheduler
// Location: /src/components/articles/PublishingScheduler.tsx

interface PublishingSchedulerProps {
  article: Article;
  onSchedule: (schedule: PublishingSchedule) => void;
}

// Key functionality:
- Calendar interface for scheduling
- Distribution channel selection
- Target audience configuration
- Timezone handling for global reach
- Recurring publication options
- Social media integration
- Email newsletter queuing
- Client dashboard targeting rules

// Component: ArticleAnalytics
// Location: /src/components/articles/ArticleAnalytics.tsx

interface ArticleAnalyticsProps {
  articleId: string;
  dateRange?: DateRange;
}

// Key functionality:
- View count and trend charts
- Engagement metrics visualization
- Read time distribution
- Conversion tracking
- Social share analytics
- Client dashboard performance
- SEO performance metrics
- Content recommendations based on data
```

#### Integration Points
```typescript
// Service: ArticleService
// Dependencies: Content Storage, SEO Service, Distribution Service

class ArticleService {
  async createArticle(
    articleData: CreateArticleRequest,
    userId: string
  ): Promise<Article> {
    // 1. Generate SEO-friendly slug from title
    // 2. Process content for readability and structure
    // 3. Extract and optimize images
    // 4. Calculate reading time and word count
    // 5. Apply auto-categorization based on content
    // 6. Set up targeting rules for wedding contexts
    // 7. Create article record with metadata
  }

  async publishArticle(
    articleId: string,
    publishConfig: PublishArticleRequest
  ): Promise<void> {
    // 1. Validate article completeness
    // 2. Optimize content for distribution
    // 3. Generate distribution-specific versions
    // 4. Schedule or immediately publish
    // 5. Trigger distribution to selected channels
    // 6. Update article status and timestamps
    // 7. Send notifications to subscribers
  }

  async distributeToClientDashboards(
    articleId: string,
    targetingRules: TargetingRule[]
  ): Promise<void> {
    // 1. Get article content and metadata
    // 2. Find matching clients based on targeting rules
    // 3. Add article to relevant dashboard sections
    // 4. Track distribution for analytics
    // 5. Send notifications if configured
  }

  async analyzeArticlePerformance(
    articleId: string,
    dateRange: DateRange
  ): Promise<ArticleAnalytics> {
    // 1. Aggregate view and engagement data
    // 2. Calculate conversion metrics
    // 3. Analyze traffic sources
    // 4. Compare with similar articles
    // 5. Generate optimization recommendations
  }

  async suggestArticleTopics(
    userId: string,
    context: BusinessContext
  ): Promise<ArticleSuggestion[]> {
    // 1. Analyze upcoming client weddings
    // 2. Check seasonal trends and dates
    // 3. Review popular search queries
    // 4. Identify content gaps
    // 5. Generate topic suggestions with rationale
  }
}

// Service: ContentDistributionService
// Dependencies: Email Service, Social Media APIs, Client Dashboard

class ContentDistributionService {
  async distributeArticle(
    article: Article,
    channels: DistributionChannel[]
  ): Promise<DistributionResult> {
    // 1. Prepare channel-specific content versions
    // 2. Apply formatting for each platform
    // 3. Schedule or publish immediately
    // 4. Track distribution status
    // 5. Monitor engagement metrics
  }

  async targetClientsByWeddingContext(
    article: Article,
    targetingRules: TargetingRule[]
  ): Promise<Client[]> {
    // 1. Parse targeting rules (wedding month, venue type, etc.)
    // 2. Query matching clients
    // 3. Apply priority and relevance scoring
    // 4. Return targeted client list
  }

  async generateRSSFeed(userId: string): Promise<string> {
    // 1. Get published articles
    // 2. Format as RSS XML
    // 3. Include media and metadata
    // 4. Cache for performance
  }
}
```

### CODE EXAMPLES

#### Example 1: Smart Article Distribution with Wedding Context
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { supabase } from '@/lib/supabase';
import { generateSlug } from '@/lib/utils/slug';

export async function createAndDistributeWeddingArticle(
  articleData: CreateArticleRequest,
  userId: string
): Promise<Article> {
  // Step 1: Generate SEO-friendly slug
  const slug = generateSlug(articleData.title);
  
  // Step 2: Process content and calculate metrics
  const wordCount = articleData.content.split(/\s+/).length;
  const readingTime = Math.ceil(wordCount / 200); // 200 words per minute
  
  // Step 3: Auto-detect wedding-related keywords for targeting
  const weddingKeywords = detectWeddingKeywords(articleData.content);
  const articleType = detectArticleType(articleData.title, weddingKeywords);
  
  // Step 4: Create article record
  const { data: article, error: articleError } = await supabase
    .from('articles')
    .insert({
      user_id: userId,
      title: articleData.title,
      slug,
      excerpt: articleData.excerpt || generateExcerpt(articleData.content),
      content: articleData.content,
      content_json: articleData.contentJson,
      featured_image_url: articleData.featuredImageUrl,
      article_type: articleType,
      status: 'draft',
      word_count: wordCount,
      reading_time_minutes: readingTime,
      seo_config: articleData.seoConfig || {}
    })
    .select()
    .single();
    
  if (articleError) throw articleError;
  
  // Step 5: Apply smart targeting rules based on content
  await createTargetingRules(article.id, weddingKeywords);
  
  // Step 6: Add categories and tags
  if (articleData.categories) {
    await assignCategories(article.id, articleData.categories);
  }
  
  if (articleData.tags) {
    await assignTags(article.id, articleData.tags);
  }
  
  return article;
}

function detectWeddingKeywords(content: string): WeddingKeywords {
  const contentLower = content.toLowerCase();
  
  const keywords: WeddingKeywords = {
    seasons: [],
    months: [],
    venueTypes: [],
    styles: [],
    services: []
  };
  
  // Detect seasons
  const seasons = ['spring', 'summer', 'fall', 'autumn', 'winter'];
  keywords.seasons = seasons.filter(season => contentLower.includes(season));
  
  // Detect months
  const months = ['january', 'february', 'march', 'april', 'may', 'june', 
                  'july', 'august', 'september', 'october', 'november', 'december'];
  keywords.months = months.filter(month => contentLower.includes(month));
  
  // Detect venue types
  const venueTypes = ['barn', 'beach', 'garden', 'ballroom', 'estate', 
                      'vineyard', 'church', 'outdoor', 'indoor'];
  keywords.venueTypes = venueTypes.filter(venue => contentLower.includes(venue));
  
  // Detect wedding styles
  const styles = ['rustic', 'elegant', 'bohemian', 'vintage', 'modern', 
                  'traditional', 'destination', 'intimate', 'luxury'];
  keywords.styles = styles.filter(style => contentLower.includes(style));
  
  // Detect service categories
  const services = ['photography', 'flowers', 'florist', 'catering', 'music', 
                   'dj', 'venue', 'dress', 'cake', 'decoration'];
  keywords.services = services.filter(service => contentLower.includes(service));
  
  return keywords;
}

async function createTargetingRules(
  articleId: string,
  keywords: WeddingKeywords
): Promise<void> {
  const rules: TargetingRule[] = [];
  
  // Create month-based targeting rules
  if (keywords.months.length > 0) {
    for (const month of keywords.months) {
      rules.push({
        article_id: articleId,
        rule_type: 'wedding_month',
        rule_config: {
          months: [month],
          showBeforeMonths: 6, // Show 6 months before wedding
          showAfterMonths: 0
        },
        priority: 10
      });
    }
  }
  
  // Create venue-based targeting rules
  if (keywords.venueTypes.length > 0) {
    rules.push({
      article_id: articleId,
      rule_type: 'venue_type',
      rule_config: {
        venueTypes: keywords.venueTypes,
        matchType: 'any' // Match any of the venue types
      },
      priority: 8
    });
  }
  
  // Create season-based targeting rules
  if (keywords.seasons.length > 0) {
    rules.push({
      article_id: articleId,
      rule_type: 'wedding_month',
      rule_config: {
        seasons: keywords.seasons,
        showBeforeMonths: 4
      },
      priority: 7
    });
  }
  
  // Insert all targeting rules
  if (rules.length > 0) {
    await supabase
      .from('article_targeting_rules')
      .insert(rules);
  }
}

export async function distributeArticleToClients(
  articleId: string
): Promise<DistributionResult> {
  // Step 1: Get article and its targeting rules
  const { data: article } = await supabase
    .from('articles')
    .select(`
      *,
      targeting_rules:article_targeting_rules(*),
      categories:article_category_mappings(
        category:article_categories(*)
      )
    `)
    .eq('id', articleId)
    .single();
    
  if (!article) throw new Error('Article not found');
  
  // Step 2: Find matching clients based on targeting rules
  const targetedClients = await findTargetedClients(article.targeting_rules);
  
  // Step 3: Add article to client dashboards
  const distributions = await Promise.all(
    targetedClients.map(async (client) => {
      // Check if article is relevant to client
      const relevanceScore = calculateRelevance(article, client);
      
      if (relevanceScore > 0.5) { // Threshold for relevance
        // Add to client's dashboard article section
        await addArticleToClientDashboard(article, client);
        
        // Track distribution
        return await supabase
          .from('article_distribution')
          .insert({
            article_id: articleId,
            distribution_channel: 'client_dashboard',
            distribution_config: {
              client_id: client.id,
              relevance_score: relevanceScore,
              placement: determinePlacement(relevanceScore)
            },
            distributed_at: new Date().toISOString(),
            status: 'distributed'
          })
          .select()
          .single();
      }
      
      return null;
    })
  );
  
  // Step 4: Send notifications for high-relevance articles
  const highRelevanceDistributions = distributions.filter(
    d => d && d.distribution_config.relevance_score > 0.8
  );
  
  for (const distribution of highRelevanceDistributions) {
    await sendArticleNotification(
      distribution.distribution_config.client_id,
      article
    );
  }
  
  return {
    totalDistributed: distributions.filter(d => d !== null).length,
    targetedClients: targetedClients.length,
    notificationsSent: highRelevanceDistributions.length
  };
}

async function findTargetedClients(
  targetingRules: TargetingRule[]
): Promise<Client[]> {
  let query = supabase
    .from('clients')
    .select(`
      *,
      wedding_details:wedding_details(*)
    `);
  
  // Apply targeting rules to query
  for (const rule of targetingRules) {
    switch (rule.rule_type) {
      case 'wedding_month':
        if (rule.rule_config.months) {
          // Find clients with weddings in specified months
          const months = rule.rule_config.months.map(m => 
            getMonthNumber(m)
          );
          
          // This would need a more complex query in practice
          // to extract month from wedding_date
        }
        break;
        
      case 'venue_type':
        if (rule.rule_config.venueTypes) {
          query = query.in('wedding_details.venue_type', rule.rule_config.venueTypes);
        }
        break;
        
      case 'timeline_stage':
        // Calculate based on days until wedding
        const daysUntil = rule.rule_config.daysUntilWedding;
        const targetDate = new Date();
        targetDate.setDate(targetDate.getDate() + daysUntil);
        
        query = query.eq('wedding_date', targetDate.toISOString().split('T')[0]);
        break;
    }
  }
  
  const { data: clients } = await query;
  return clients || [];
}

function calculateRelevance(article: Article, client: Client): number {
  let score = 0;
  const weights = {
    monthMatch: 0.3,
    venueMatch: 0.25,
    styleMatch: 0.2,
    timelineMatch: 0.15,
    categoryMatch: 0.1
  };
  
  // Month relevance
  const clientWeddingMonth = new Date(client.wedding_date).getMonth();
  const articleMonths = extractMonthsFromContent(article.content);
  if (articleMonths.includes(clientWeddingMonth)) {
    score += weights.monthMatch;
  }
  
  // Venue type relevance
  if (client.wedding_details?.venue_type) {
    const venueMatches = article.content.toLowerCase()
      .includes(client.wedding_details.venue_type.toLowerCase());
    if (venueMatches) {
      score += weights.venueMatch;
    }
  }
  
  // Timeline relevance (how close to wedding)
  const daysUntilWedding = Math.ceil(
    (new Date(client.wedding_date).getTime() - Date.now()) / (1000 * 60 * 60 * 24)
  );
  
  if (article.article_type === 'planning_tips' && daysUntilWedding > 90) {
    score += weights.timelineMatch; // Planning articles for early stage
  } else if (article.article_type === 'how_to_guide' && daysUntilWedding < 30) {
    score += weights.timelineMatch; // How-to guides for final preparations
  }
  
  return Math.min(score, 1); // Cap at 1.0
}

export async function optimizeArticleForSEO(
  articleId: string,
  targetKeywords: string[]
): Promise<SEOScore> {
  // Step 1: Get article content
  const { data: article } = await supabase
    .from('articles')
    .select('*')
    .eq('id', articleId)
    .single();
    
  if (!article) throw new Error('Article not found');
  
  // Step 2: Analyze content for SEO
  const analysis = {
    titleLength: article.title.length,
    titleKeywords: targetKeywords.filter(kw => 
      article.title.toLowerCase().includes(kw.toLowerCase())
    ),
    contentKeywordDensity: calculateKeywordDensity(article.content, targetKeywords),
    readabilityScore: calculateReadabilityScore(article.content),
    metaDescriptionLength: article.seo_config?.meta_description?.length || 0,
    hasImages: article.featured_image_url ? 1 : 0,
    internalLinks: countInternalLinks(article.content),
    headingStructure: analyzeHeadingStructure(article.content)
  };
  
  // Step 3: Calculate SEO score
  let score = 0;
  const recommendations: string[] = [];
  
  // Title optimization (15 points)
  if (analysis.titleLength >= 30 && analysis.titleLength <= 60) {
    score += 10;
  } else {
    recommendations.push('Title should be between 30-60 characters');
  }
  
  if (analysis.titleKeywords.length > 0) {
    score += 5;
  } else {
    recommendations.push('Include target keywords in title');
  }
  
  // Content optimization (40 points)
  const idealDensity = 0.015; // 1.5% keyword density
  const densityDiff = Math.abs(analysis.contentKeywordDensity - idealDensity);
  if (densityDiff < 0.005) {
    score += 20;
  } else if (densityDiff < 0.01) {
    score += 10;
  } else {
    recommendations.push('Optimize keyword density (target: 1-2%)');
  }
  
  if (analysis.readabilityScore > 60) {
    score += 20;
  } else {
    recommendations.push('Improve readability with shorter sentences and paragraphs');
  }
  
  // Meta description (15 points)
  if (analysis.metaDescriptionLength >= 120 && analysis.metaDescriptionLength <= 160) {
    score += 15;
  } else {
    recommendations.push('Meta description should be 120-160 characters');
  }
  
  // Media and structure (30 points)
  if (analysis.hasImages) {
    score += 10;
  } else {
    recommendations.push('Add featured image for better engagement');
  }
  
  if (analysis.internalLinks >= 2) {
    score += 10;
  } else {
    recommendations.push('Add internal links to related articles');
  }
  
  if (analysis.headingStructure.hasH1 && analysis.headingStructure.hasH2) {
    score += 10;
  } else {
    recommendations.push('Use proper heading hierarchy (H1, H2, H3)');
  }
  
  // Step 4: Update article SEO record
  await supabase
    .from('article_seo')
    .upsert({
      article_id: articleId,
      meta_title: article.title.substring(0, 60),
      meta_description: article.excerpt?.substring(0, 160) || 
                       generateMetaDescription(article.content),
      keywords: targetKeywords,
      updated_at: new Date().toISOString()
    });
  
  return {
    score,
    recommendations,
    analysis
  };
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for rich text editors, SEO libraries
- [x] Filesystem: Access existing content management components
- [x] Memory: Store article templates and SEO patterns

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/facebook/lexical", "rich text editor", 3000);
await mcp__context7__get-library-docs("/vercel/seo", "seo optimization", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('ArticleService', () => {
  it('should detect wedding keywords for smart targeting', () => {
    const content = 'Beautiful July wedding flowers including roses and peonies for barn venues';
    const keywords = detectWeddingKeywords(content);
    
    expect(keywords.months).toContain('july');
    expect(keywords.venueTypes).toContain('barn');
    expect(keywords.services).toContain('flowers');
  });

  it('should calculate article relevance for client targeting', () => {
    const article = createTestArticle({
      content: 'Spring wedding at garden venues',
      article_type: 'planning_tips'
    });
    
    const client = createTestClient({
      wedding_date: '2025-04-15', // Spring wedding
      venue_type: 'garden'
    });
    
    const relevance = calculateRelevance(article, client);
    expect(relevance).toBeGreaterThan(0.7); // High relevance
  });

  it('should generate SEO recommendations', async () => {
    const article = createTestArticle({
      title: 'Wedding', // Too short
      content: 'Short content', // Too short
      seo_config: {}
    });
    
    const seoScore = await optimizeArticleForSEO(article.id, ['wedding', 'planning']);
    expect(seoScore.score).toBeLessThan(50);
    expect(seoScore.recommendations).toContain('Title should be between 30-60 characters');
  });

  it('should schedule article distribution correctly', async () => {
    const article = createTestArticle({ status: 'scheduled' });
    const publishDate = new Date();
    publishDate.setDate(publishDate.getDate() + 7); // 1 week from now
    
    await scheduleArticlePublication(article.id, publishDate);
    
    const scheduled = await getScheduledArticles();
    expect(scheduled).toContainEqual(
      expect.objectContaining({ id: article.id })
    );
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Article creation and distribution workflow', async () => {
  await mcp__playwright__browser_navigate({url: '/articles/new'});
  
  // Write article title
  await mcp__playwright__browser_type({
    element: 'article title input',
    ref: 'input[name="title"]',
    text: 'Top 10 July Wedding Flowers for Garden Venues'
  });
  
  // Write article content with rich editor
  await mcp__playwright__browser_click({element: 'editor content area', ref: '[data-testid="article-editor"]'});
  await mcp__playwright__browser_type({
    element: 'editor content',
    ref: '[contenteditable="true"]',
    text: 'July weddings in garden venues offer unique opportunities for stunning floral arrangements...'
  });
  
  // Add featured image
  await mcp__playwright__browser_file_upload({
    paths: ['/path/to/july-flowers.jpg']
  });
  
  // Configure SEO
  await mcp__playwright__browser_click({element: 'SEO settings tab', ref: 'button[data-tab="seo"]'});
  await mcp__playwright__browser_type({
    element: 'meta description textarea',
    ref: 'textarea[name="metaDescription"]',
    text: 'Discover the best flowers for July garden weddings including roses, peonies, and seasonal blooms'
  });
  
  // Set targeting rules
  await mcp__playwright__browser_click({element: 'targeting tab', ref: 'button[data-tab="targeting"]'});
  await mcp__playwright__browser_select_option({
    element: 'target month select',
    ref: 'select[name="targetMonth"]',
    values: ['july']
  });
  
  await mcp__playwright__browser_select_option({
    element: 'venue type select',
    ref: 'select[name="venueType"]',
    values: ['garden']
  });
  
  // Save as draft
  await mcp__playwright__browser_click({element: 'save draft button', ref: 'button[data-testid="save-draft"]'});
  await mcp__playwright__browser_wait_for({text: 'Article saved'});
  
  // Preview article
  await mcp__playwright__browser_click({element: 'preview button', ref: 'button[data-testid="preview-article"]'});
  await mcp__playwright__browser_wait_for({text: 'Top 10 July Wedding Flowers'});
  
  // Publish and distribute
  await mcp__playwright__browser_click({element: 'publish button', ref: 'button[data-testid="publish-article"]'});
  
  // Select distribution channels
  await mcp__playwright__browser_click({element: 'client dashboards checkbox', ref: 'input[value="client_dashboard"]'});
  await mcp__playwright__browser_click({element: 'email newsletter checkbox', ref: 'input[value="email_newsletter"]'});
  
  await mcp__playwright__browser_click({element: 'confirm publish button', ref: 'button[data-testid="confirm-publish"]'});
  
  // Verify publication
  await mcp__playwright__browser_wait_for({text: 'Article published successfully'});
  await mcp__playwright__browser_wait_for({text: 'Distributed to 15 matching clients'});
  
  // Check analytics
  await mcp__playwright__browser_navigate({url: '/articles'});
  await mcp__playwright__browser_wait_for({text: 'Top 10 July Wedding Flowers'});
  await mcp__playwright__browser_wait_for({text: 'Published'});
  
  // Verify accessibility
  await mcp__playwright__browser_evaluate({
    function: '() => axe.run()'
  });
});
```

### ACCEPTANCE CRITERIA
- [x] Rich text editor with wedding-specific content blocks and media embedding
- [x] Smart article targeting based on wedding month, venue type, and timeline
- [x] SEO optimization with score, recommendations, and keyword analysis
- [x] Multi-channel distribution (client dashboards, email, social, RSS)
- [x] Analytics tracking with engagement metrics and conversion data
- [x] Performance: Article publishing completes within 5 seconds
- [x] Security: Content sanitization and access control via RLS
- [x] Accessibility: Editor and article display meet WCAG 2.1 AA standards

### DEPENDENCIES
- Must complete after: WS-068 (Document Storage)
- Must complete before: WS-070 (FAQ Management)
- Shares code with: Document system, client dashboard, email service

### ESTIMATED EFFORT
- Team A Frontend: 32 hours (Rich editor, SEO tools, analytics dashboard)
- Team B Backend: 24 hours (Database schema, API endpoints, distribution system)
- Team D Full-stack: 16 hours (Targeting engine, content optimization)
- Total: 72 hours