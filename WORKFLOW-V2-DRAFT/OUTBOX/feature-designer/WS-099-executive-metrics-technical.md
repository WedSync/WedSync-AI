# TECHNICAL SPECIFICATION: WS-099 - Executive Metrics Dashboard
## Generated by Feature Development Session - August 22, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** WedSync executive monitoring platform growth
**I want to:** Track how many wedding vendors are successfully coordinating with couples using our platform
**So that:** I can measure business impact on the wedding industry and make data-driven decisions about features

**Real Wedding Scenario:**
A venue coordinator using WedSync helps coordinate 15 weddings this month, connecting with photographers, florists, and caterers for each event. The executive dashboard shows this as increased "active collaborations" and "vendor-to-vendor connections," proving the platform's core value of reducing wedding coordination friction. This data drives decisions about which coordination features to enhance.

### SPECIFICATION SOURCE
- **Feature ID:** WS-099
- **Original Spec:** /CORE-SPECIFICATIONS/07-ADMIN-DASHBOARD/01-Overview/01-executive-metrics md.md
- **Current Implementation:** 0% complete
- **Files to Modify:**
  - `/wedsync/app/api/metrics/executive/route.ts` (create new)
  - `/wedsync/lib/metrics/aggregator.ts` (create new)
- **New Files to Create:**
  - `/wedsync/src/components/admin/ExecutiveDashboard.tsx`
  - `/wedsync/src/components/admin/MetricCard.tsx`
  - `/wedsync/src/hooks/useRealtimeMetrics.ts`
  - `/wedsync/supabase/migrations/20250822000002_executive_metrics_views.sql`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Materialized view for daily metrics
CREATE MATERIALIZED VIEW daily_metrics AS
SELECT 
  DATE(created_at) as date,
  COUNT(DISTINCT user_id) FILTER (WHERE user_type = 'supplier') as active_suppliers,
  COUNT(DISTINCT user_id) FILTER (WHERE user_type = 'couple') as active_couples,
  AVG(session_duration) as avg_session_duration,
  COUNT(*) as total_sessions
FROM user_sessions
WHERE created_at >= CURRENT_DATE - INTERVAL '90 days'
GROUP BY DATE(created_at);

CREATE INDEX idx_daily_metrics_date ON daily_metrics(date);

-- Revenue metrics view
CREATE MATERIALIZED VIEW revenue_metrics AS
SELECT 
  DATE_TRUNC('month', created_at) as month,
  SUM(amount) as mrr,
  COUNT(*) as active_subscriptions,
  COUNT(*) FILTER (WHERE created_at >= DATE_TRUNC('month', CURRENT_DATE)) as new_subscriptions
FROM subscriptions 
WHERE status = 'active'
GROUP BY DATE_TRUNC('month', created_at);

-- Collaboration tracking for wedding coordination
CREATE TABLE IF NOT EXISTS vendor_collaborations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  client_id UUID REFERENCES clients(id),
  vendor1_id UUID REFERENCES user_profiles(id),
  vendor2_id UUID REFERENCES user_profiles(id),
  collaboration_type VARCHAR(50) NOT NULL, -- 'timeline_sync', 'document_share', 'message_thread'
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  last_activity TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Wedding coordination metrics
CREATE MATERIALIZED VIEW coordination_metrics AS
SELECT 
  DATE(created_at) as date,
  COUNT(DISTINCT client_id) as weddings_coordinated,
  COUNT(DISTINCT vendor1_id) + COUNT(DISTINCT vendor2_id) as vendors_collaborating,
  AVG(
    EXTRACT(EPOCH FROM (last_activity - created_at)) / 3600
  ) as avg_coordination_hours
FROM vendor_collaborations
WHERE created_at >= CURRENT_DATE - INTERVAL '30 days'
GROUP BY DATE(created_at);
```

#### API Endpoints Required
```typescript
// GET /api/metrics/executive
interface ExecutiveMetricsResponse {
  revenue: {
    mrr: number;
    arr: number;
    growth: number; // Month-over-month percentage
    churn: number;
  };
  coordination: {
    weddingsCoordinated: number; // This month
    activeVendorPairs: number;
    avgCoordinationTime: number; // Hours per wedding
    vendorSatisfactionScore: number;
  };
  users: {
    totalSuppliers: number;
    totalCouples: number;
    activeSuppliers: number; // Last 30 days
    activeCouples: number;
    newSignupsToday: number;
  };
  engagement: {
    dailyActiveUsers: number;
    weeklyActiveUsers: number;
    monthlyActiveUsers: number;
    averageSessionDuration: number;
  };
  lastUpdated: string;
}

// GET /api/metrics/drill-down/:metric
interface DrillDownResponse {
  metric: string;
  timeRange: string;
  data: Array<{
    date: string;
    value: number;
    breakdown?: Record<string, number>;
  }>;
}

// GET /api/metrics/export
// Returns CSV/Excel export of metrics
```

#### Frontend Components Required
```typescript
// Component: ExecutiveDashboard
// Location: /src/components/admin/ExecutiveDashboard.tsx

interface Props {
  dateRange?: { start: Date; end: Date };
  refreshInterval?: number; // milliseconds
}

// Key functionality:
- Real-time metrics display with auto-refresh
- Drill-down capability for each metric
- Export functionality for board reports
- Responsive grid layout with metric cards

// Component: MetricCard
// Location: /src/components/admin/MetricCard.tsx

interface Props {
  title: string;
  value: string | number;
  change?: number; // percentage change
  trend?: 'up' | 'down' | 'stable';
  status?: 'success' | 'warning' | 'error';
  target?: number;
  benchmark?: string;
  onDrillDown?: () => void;
}

// Key functionality:
- Displays metric with trend indicators
- Color-coded status based on performance
- Click-through to detailed views
- Responsive design for mobile/desktop

// Component: MetricsChart
// Location: /src/components/admin/MetricsChart.tsx

interface Props {
  data: Array<{ date: string; value: number }>;
  type: 'line' | 'bar' | 'area';
  title: string;
  yAxisLabel: string;
}

// Key functionality:
- Interactive charts using Recharts
- Time range selection
- Tooltip with detailed information
- Export chart as image
```

#### Integration Points
```typescript
// Service: MetricsAggregator
// Dependencies: Supabase, Redis for caching

class MetricsAggregator {
  async getExecutiveMetrics(): Promise<ExecutiveMetrics> {
    // Check Redis cache first (5-minute TTL)
    const cached = await redis.get('executive_metrics');
    if (cached) return JSON.parse(cached);
    
    // Calculate fresh metrics
    const [revenue, coordination, users, engagement] = await Promise.all([
      this.calculateRevenue(),
      this.calculateCoordination(),
      this.calculateUsers(),
      this.calculateEngagement()
    ]);
    
    const metrics = { revenue, coordination, users, engagement };
    
    // Cache for 5 minutes
    await redis.setex('executive_metrics', 300, JSON.stringify(metrics));
    
    return metrics;
  }
  
  private async calculateCoordination() {
    // Focus on wedding coordination value - the core business
    const result = await supabase
      .from('coordination_metrics')
      .select('*')
      .gte('date', 'CURRENT_DATE - INTERVAL \'30 days\'');
    
    return {
      weddingsCoordinated: result.reduce((sum, day) => sum + day.weddings_coordinated, 0),
      activeVendorPairs: result.reduce((sum, day) => sum + day.vendors_collaborating, 0),
      avgCoordinationTime: result.reduce((sum, day) => sum + day.avg_coordination_hours, 0) / result.length
    };
  }
}

// Hook: useRealtimeMetrics
export function useRealtimeMetrics(refreshInterval: number = 30000) {
  // WebSocket connection for real-time updates
  // Polls API every 30 seconds by default
  // Returns loading state and error handling
}
```

### CODE EXAMPLES

#### Example 1: Real-time Metrics API Implementation
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { createClient } from '@supabase/supabase-js';
import { Redis } from '@upstash/redis';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_KEY!
);

const redis = new Redis({
  url: process.env.UPSTASH_REDIS_URL!,
  token: process.env.UPSTASH_REDIS_TOKEN!
});

export async function GET() {
  try {
    // Check cache first
    const cached = await redis.get('executive_metrics');
    if (cached) {
      return Response.json(JSON.parse(cached));
    }
    
    // Calculate revenue metrics
    const { data: revenueData } = await supabase
      .from('revenue_metrics')
      .select('*')
      .order('month', { ascending: false })
      .limit(2);
    
    const currentMonth = revenueData[0];
    const previousMonth = revenueData[1];
    const growth = previousMonth 
      ? ((currentMonth.mrr - previousMonth.mrr) / previousMonth.mrr) * 100
      : 0;
    
    // Calculate coordination metrics (core wedding business value)
    const { data: coordinationData } = await supabase
      .from('coordination_metrics')
      .select('*')
      .gte('date', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString());
    
    const metrics = {
      revenue: {
        mrr: currentMonth?.mrr || 0,
        arr: (currentMonth?.mrr || 0) * 12,
        growth,
        churn: 0 // Calculate from subscription cancellations
      },
      coordination: {
        weddingsCoordinated: coordinationData.reduce((sum, day) => sum + day.weddings_coordinated, 0),
        activeVendorPairs: coordinationData.reduce((sum, day) => sum + day.vendors_collaborating, 0),
        avgCoordinationTime: coordinationData.reduce((sum, day) => sum + day.avg_coordination_hours, 0) / coordinationData.length
      },
      lastUpdated: new Date().toISOString()
    };
    
    // Cache for 5 minutes
    await redis.setex('executive_metrics', 300, JSON.stringify(metrics));
    
    return Response.json(metrics);
    
  } catch (error) {
    console.error('Executive metrics error:', error);
    return Response.json({ error: 'Failed to fetch metrics' }, { status: 500 });
  }
}
```

#### Example 2: Real-time Dashboard Component
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';

interface ExecutiveMetrics {
  revenue: { mrr: number; growth: number };
  coordination: { weddingsCoordinated: number; activeVendorPairs: number };
  users: { activeSuppliers: number; activeCouples: number };
}

export function ExecutiveDashboard() {
  const [metrics, setMetrics] = useState<ExecutiveMetrics | null>(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    const fetchMetrics = async () => {
      try {
        const response = await fetch('/api/metrics/executive');
        const data = await response.json();
        setMetrics(data);
      } catch (error) {
        console.error('Failed to fetch metrics:', error);
      } finally {
        setLoading(false);
      }
    };
    
    fetchMetrics();
    const interval = setInterval(fetchMetrics, 30000); // Refresh every 30 seconds
    
    return () => clearInterval(interval);
  }, []);
  
  if (loading) return <div>Loading metrics...</div>;
  if (!metrics) return <div>Failed to load metrics</div>;
  
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 p-6">
      <Card>
        <CardHeader className="pb-2">
          <CardTitle className="text-sm font-medium">Monthly Revenue</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">${metrics.revenue.mrr.toLocaleString()}</div>
          <p className="text-xs text-muted-foreground">
            {metrics.revenue.growth > 0 ? '+' : ''}{metrics.revenue.growth.toFixed(1)}% from last month
          </p>
        </CardContent>
      </Card>
      
      <Card>
        <CardHeader className="pb-2">
          <CardTitle className="text-sm font-medium">Weddings Coordinated</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">{metrics.coordination.weddingsCoordinated}</div>
          <p className="text-xs text-muted-foreground">This month</p>
        </CardContent>
      </Card>
      
      <Card>
        <CardHeader className="pb-2">
          <CardTitle className="text-sm font-medium">Active Vendor Pairs</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">{metrics.coordination.activeVendorPairs}</div>
          <p className="text-xs text-muted-foreground">Collaborating on weddings</p>
        </CardContent>
      </Card>
      
      <Card>
        <CardHeader className="pb-2">
          <CardTitle className="text-sm font-medium">Active Users</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">
            {metrics.users.activeSuppliers + metrics.users.activeCouples}
          </div>
          <p className="text-xs text-muted-foreground">
            {metrics.users.activeSuppliers} suppliers, {metrics.users.activeCouples} couples
          </p>
        </CardContent>
      </Card>
    </div>
  );
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [ ] Context7: Load docs for Recharts, dashboard libraries
- [ ] PostgreSQL: Create materialized views and optimization
- [ ] Filesystem: Create dashboard components

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/recharts/recharts", "charts", 2000);
await mcp__context7__get-library-docs("/upstash/upstash-redis", "caching", 1500);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('Executive Metrics', () => {
  it('should calculate revenue metrics correctly', () => {
    // Test MRR, ARR, and growth calculations
  });
  
  it('should track wedding coordination metrics', () => {
    // Test vendor collaboration and wedding count tracking
  });
  
  it('should cache metrics for performance', () => {
    // Test Redis caching with TTL
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Executive dashboard displays all metrics', async () => {
  await mcp__playwright__browser_navigate({url: '/admin/dashboard'});
  await mcp__playwright__browser_snapshot();
  // Verify all metric cards are present and show data
});
```

### ACCEPTANCE CRITERIA
- [ ] Dashboard displays 4 key metric categories (revenue, coordination, users, engagement)
- [ ] Metrics refresh automatically every 30 seconds
- [ ] All metrics show trend indicators (up/down/stable)
- [ ] Drill-down functionality works for each metric
- [ ] Performance: Dashboard loads under 2 seconds
- [ ] Security: Admin-only access with proper authentication
- [ ] Accessibility: Dashboard meets WCAG 2.1 AA standards

### DEPENDENCIES
- Must complete after: Analytics infrastructure, User tracking system
- Must complete before: Board reporting features
- Shares code with: WS-120 (MRR Tracking), WS-100 (System Health)

### ESTIMATED EFFORT
- Team A Frontend: 14 hours (dashboard UI, charts, real-time updates)
- Team B Backend: 12 hours (metrics API, database views, caching)
- Team C Integration: 4 hours (WebSocket setup, export functionality)
- Total: 30 hours