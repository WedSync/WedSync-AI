# TECHNICAL SPECIFICATION: WS-304 - Supplier Dashboard Section Overview
## Generated by Feature Development Session - 2025-01-26

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding photographer/venue coordinator/supplier
**I want to:** Access a centralized dashboard command center for all my wedding operations
**So that:** I can save 2+ hours daily managing multiple weddings without switching between tools

**Real Wedding Scenario:**
A photographer managing 8 concurrent weddings currently jumps between 5+ apps to track timelines, client details, and deliverables. With this unified dashboard, they see all critical information in one place, reducing context switching by 90% and preventing missed deadlines.

### SPECIFICATION SOURCE
- **Feature ID:** WS-304
- **Original Spec:** /CORE-SPECIFICATIONS/02-WEDSYNC-SUPPLIER-PLATFORM/02-Dashboard.md
- **Current Implementation:** 70% complete (individual components exist, need integration)
- **Files to Modify:** 
  - /wedsync/src/app/(dashboard)/dashboard/page.tsx
  - /wedsync/src/components/dashboard/DashboardLayout.tsx
  - /wedsync/src/lib/services/dashboard-service.ts
- **New Files to Create:**
  - /wedsync/src/components/dashboard/DashboardOrchestrator.tsx
  - /wedsync/src/hooks/useDashboardState.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Dashboard preferences and layout configurations
CREATE TABLE IF NOT EXISTS dashboard_configurations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id),
  widget_layout JSONB DEFAULT '{"columns": 3, "widgets": []}',
  collapsed_sections JSONB DEFAULT '[]',
  quick_actions JSONB DEFAULT '[]',
  theme_preferences JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Dashboard activity tracking
CREATE TABLE IF NOT EXISTS dashboard_activity (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id),
  action_type TEXT NOT NULL,
  entity_type TEXT,
  entity_id UUID,
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create indexes for performance
CREATE INDEX idx_dashboard_config_user ON dashboard_configurations(user_id);
CREATE INDEX idx_dashboard_activity_user_time ON dashboard_activity(user_id, created_at DESC);
```

#### API Endpoints Required
```typescript
// GET /api/dashboard/overview
interface DashboardOverviewResponse {
  widgets: {
    todayWeddings: number;
    upcomingTasks: number;
    unrepliedMessages: number;
    pendingForms: number;
  };
  recentActivity: ActivityItem[];
  quickActions: QuickAction[];
}

// PUT /api/dashboard/configuration
interface UpdateConfigurationRequest {
  widgetLayout?: WidgetLayout;
  collapsedSections?: string[];
  quickActions?: string[];
}

// GET /api/dashboard/performance-metrics
interface PerformanceMetricsResponse {
  loadTime: number;
  dataFreshness: string;
  cacheHitRate: number;
}
```

#### Frontend Components Required
```typescript
// Component: DashboardOrchestrator
// Location: /src/components/dashboard/DashboardOrchestrator.tsx

interface DashboardOrchestratorProps {
  userId: string;
  organizationId: string;
}

// Key functionality:
- Coordinate all dashboard widgets
- Manage real-time updates via websockets
- Handle progressive loading for performance
- Orchestrate data fetching with React Query
- Implement responsive grid layout
```

#### Integration Points
```typescript
// Service: DashboardDataAggregator
// Dependencies: ClientService, JourneyService, FormService, CommunicationsService

class DashboardDataAggregator {
  async aggregateOverviewData(userId: string) {
    // Parallel data fetching from multiple services
    // Implement caching strategy
    // Transform data for widgets
  }

  async trackUserAction(action: UserAction) {
    // Log dashboard interactions
    // Update activity feed
  }
}
```

### CODE EXAMPLES

#### Example 1: Dashboard State Management
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { create } from 'zustand';
import { supabase } from '@/lib/supabase';

interface DashboardState {
  widgets: WidgetData[];
  loading: boolean;
  error: Error | null;
  refreshInterval: number;
}

const useDashboardStore = create<DashboardState>((set, get) => ({
  widgets: [],
  loading: false,
  error: null,
  refreshInterval: 30000, // 30 seconds

  fetchDashboardData: async (userId: string) => {
    set({ loading: true, error: null });
    
    try {
      // Parallel fetch all widget data
      const [weddings, tasks, messages] = await Promise.all([
        supabase.from('clients').select('*').eq('wedding_date', 'today'),
        supabase.from('tasks').select('*').eq('status', 'pending'),
        supabase.from('messages').select('*').eq('read', false)
      ]);
      
      set({ 
        widgets: formatWidgetData(weddings, tasks, messages),
        loading: false 
      });
    } catch (error) {
      set({ error, loading: false });
    }
  }
}));
```

#### Example 2: Real-time Dashboard Updates
```typescript
// WebSocket integration for live updates
import { useEffect } from 'react';
import { RealtimeChannel } from '@supabase/supabase-js';

export function useDashboardRealtime(userId: string) {
  useEffect(() => {
    const channel = supabase
      .channel(`dashboard:${userId}`)
      .on('postgres_changes', 
        { event: '*', schema: 'public', table: 'clients' },
        (payload) => {
          // Update dashboard widgets in real-time
          updateWidgetData(payload);
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [userId]);
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load Next.js App Router patterns, Zustand documentation
- [x] Supabase: Real-time subscriptions, database operations
- [x] Filesystem: Access component and service files

#### Context7 Queries Needed
```typescript
await mcp__context7__resolve-library-id("next.js");
await mcp__context7__get-library-docs("/vercel/next.js", "app router dashboard patterns", 3000);
await mcp__context7__get-library-docs("/pmndrs/zustand", "state management", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('DashboardOrchestrator', () => {
  it('should aggregate data from multiple sources', async () => {
    const mockData = await aggregateOverviewData('user-123');
    expect(mockData).toHaveProperty('widgets');
    expect(mockData.widgets.todayWeddings).toBeGreaterThanOrEqual(0);
  });

  it('should handle partial data failures gracefully', () => {
    // Test resilience when one service fails
  });

  it('should respect user layout preferences', () => {
    // Verify custom widget arrangements persist
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Dashboard loads with all widgets', async () => {
  await mcp__playwright__browser_navigate({url: '/dashboard'});
  await mcp__playwright__browser_snapshot();
  // Verify all critical widgets visible
  // Test responsive layout on mobile
  // Verify real-time updates work
});
```

### ACCEPTANCE CRITERIA
- [ ] Dashboard loads in under 2 seconds on average connection
- [ ] All widgets update in real-time without page refresh
- [ ] Mobile responsive with touch-optimized interactions
- [ ] Customizable widget layout persists between sessions
- [ ] Activity feed shows last 50 actions with infinite scroll
- [ ] Quick actions execute in under 500ms
- [ ] Accessibility: WCAG 2.1 AA compliant

### DEPENDENCIES
- Must complete after: Individual widget components (WS-007 through WS-020)
- Must complete before: Client-specific dashboards (WS-312)
- Shares code with: Activity feed (WS-010), Priority widgets (WS-009)

### ESTIMATED EFFORT
- Team A Frontend: 24 hours
- Team B Backend: 16 hours
- Team C Integration: 8 hours
- Team D Platform: 4 hours
- Team E General: 4 hours
- Team F Workflows: 0 hours
- Team G Performance: 8 hours
- Total: 64 hours