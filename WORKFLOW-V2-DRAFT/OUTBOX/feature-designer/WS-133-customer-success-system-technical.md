# TECHNICAL SPECIFICATION: WS-133 - Customer Success System
## Generated by Feature Development Session - 2025-01-23

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** WedSync customer success manager overseeing 500+ wedding supplier accounts
**I want to:** Proactively identify at-risk customers, prevent churn, and drive feature adoption through automated interventions
**So that:** We maintain 95%+ customer satisfaction, reduce churn to <5% monthly, and increase lifetime value by 40%

**Real Business Scenario:**
A wedding photographer hasn't logged in for 12 days after initial onboarding. The system automatically flags them as "at-risk" with a health score of 35/100. It triggers a personalized email sequence, schedules a customer success call, and offers a complimentary setup session. The intervention prevents churn, the photographer goes on to generate $8,400 in additional revenue using WedSync, and becomes a platform advocate who refers 3 new customers.

### SPECIFICATION SOURCE
- **Feature ID:** WS-133
- **Original Spec:** /CORE-SPECIFICATIONS/13-BUSINESS-OPERATIONS/03-customer-success md.md
- **Current Implementation:** 0% complete
- **Files to Modify:** None (new feature)
- **New Files to Create:**
  - /src/lib/customer-success/health-scoring.ts
  - /src/lib/customer-success/intervention-engine.ts
  - /src/lib/customer-success/onboarding-tracker.ts
  - /src/lib/customer-success/churn-predictor.ts
  - /src/app/api/customer-success/health-score/route.ts
  - /src/app/api/customer-success/interventions/route.ts
  - /src/app/api/customer-success/onboarding/route.ts
  - /src/components/customer-success/HealthDashboard.tsx
  - /src/components/customer-success/InterventionPanel.tsx
  - /src/components/customer-success/OnboardingProgress.tsx

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Customer health scoring and risk assessment
CREATE TABLE IF NOT EXISTS customer_health (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES user_profiles(id),
  health_score INTEGER NOT NULL CHECK (health_score >= 0 AND health_score <= 100),
  risk_level TEXT NOT NULL CHECK (risk_level IN ('healthy', 'at_risk', 'critical')),
  last_login TIMESTAMP,
  days_since_last_login INTEGER GENERATED ALWAYS AS (
    CASE 
      WHEN last_login IS NULL THEN NULL
      ELSE EXTRACT(DAYS FROM (NOW() - last_login))
    END
  ) STORED,
  feature_adoption_score DECIMAL(3,2) NOT NULL DEFAULT 0, -- 0.00 to 1.00
  client_engagement_score DECIMAL(3,2) NOT NULL DEFAULT 0,
  support_ticket_score DECIMAL(3,2) NOT NULL DEFAULT 1.00, -- 1.00 is good (no tickets)
  billing_health_score DECIMAL(3,2) NOT NULL DEFAULT 1.00, -- 1.00 is good (no issues)
  calculated_at TIMESTAMP DEFAULT NOW(),
  previous_score INTEGER,
  score_trend TEXT CHECK (score_trend IN ('improving', 'stable', 'declining')),
  intervention_triggered BOOLEAN DEFAULT false,
  next_review_date TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(supplier_id, DATE(calculated_at))
);

-- Success milestones and onboarding progress
CREATE TABLE IF NOT EXISTS success_milestones (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES user_profiles(id),
  milestone_type TEXT NOT NULL, -- 'account_setup', 'first_client', 'first_form', 'first_journey', 'ten_clients', 'first_automation'
  milestone_name TEXT NOT NULL,
  milestone_description TEXT,
  target_days INTEGER, -- Expected days to achieve milestone
  achieved_at TIMESTAMP,
  days_to_achieve INTEGER,
  celebrated BOOLEAN DEFAULT false,
  celebration_sent_at TIMESTAMP,
  is_critical_path BOOLEAN DEFAULT false, -- Must complete for successful onboarding
  weight_score INTEGER DEFAULT 10, -- Points contribution to health score
  created_at TIMESTAMP DEFAULT NOW()
);

-- Customer success interactions and interventions
CREATE TABLE IF NOT EXISTS support_interactions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES user_profiles(id),
  interaction_type TEXT NOT NULL, -- 'onboarding_call', 'check_in', 'technical_support', 'churn_prevention', 'upgrade_consultation'
  triggered_by TEXT, -- 'health_score', 'manual', 'milestone_failure', 'billing_issue', 'support_ticket'
  cs_agent_id UUID REFERENCES user_profiles(id),
  scheduled_at TIMESTAMP,
  completed_at TIMESTAMP,
  duration_minutes INTEGER,
  outcome TEXT, -- 'successful', 'needs_followup', 'escalated', 'churned', 'upgraded'
  notes TEXT,
  satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
  action_items JSONB DEFAULT '[]', -- [{"task": "...", "due_date": "...", "assigned_to": "..."}]
  followup_required BOOLEAN DEFAULT false,
  followup_scheduled_at TIMESTAMP,
  resolution_time_hours DECIMAL(6,2),
  created_at TIMESTAMP DEFAULT NOW()
);

-- Automated intervention campaigns
CREATE TABLE IF NOT EXISTS automated_interventions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  intervention_name TEXT NOT NULL,
  trigger_conditions JSONB NOT NULL, -- {"health_score": "<40", "days_since_login": ">7"}
  target_audience TEXT[], -- ['new_users', 'at_risk', 'power_users']
  intervention_type TEXT NOT NULL, -- 'email_sequence', 'in_app_message', 'phone_call', 'feature_tour'
  content_template TEXT,
  personalization_fields JSONB DEFAULT '{}',
  delay_hours INTEGER DEFAULT 0, -- Delay before triggering
  max_frequency_days INTEGER DEFAULT 7, -- Don't repeat within X days
  success_metrics TEXT[], -- ['login', 'feature_use', 'health_score_increase']
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Intervention execution tracking
CREATE TABLE IF NOT EXISTS intervention_executions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  intervention_id UUID REFERENCES automated_interventions(id),
  supplier_id UUID REFERENCES user_profiles(id),
  triggered_at TIMESTAMP DEFAULT NOW(),
  trigger_reason TEXT, -- What caused this intervention
  health_score_at_trigger INTEGER,
  executed_at TIMESTAMP,
  completed_at TIMESTAMP,
  success_measured BOOLEAN DEFAULT false,
  success_achieved BOOLEAN DEFAULT false,
  improvement_metrics JSONB DEFAULT '{}', -- {"health_score_change": +15, "login_within_24h": true}
  cost_to_execute DECIMAL(8,2) DEFAULT 0,
  estimated_retention_value DECIMAL(10,2), -- LTV saved if successful
  outcome_notes TEXT
);

-- Feature adoption tracking
CREATE TABLE IF NOT EXISTS feature_adoption (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES user_profiles(id),
  feature_key TEXT NOT NULL, -- 'client_management', 'form_builder', 'journey_automation', 'analytics'
  first_used_at TIMESTAMP,
  last_used_at TIMESTAMP,
  usage_frequency TEXT, -- 'daily', 'weekly', 'monthly', 'rarely'
  adoption_stage TEXT DEFAULT 'never_used', -- 'never_used', 'trial', 'adopting', 'power_user', 'churned'
  usage_count INTEGER DEFAULT 0,
  value_realization_score DECIMAL(3,2) DEFAULT 0, -- How much value they're getting
  abandonment_risk DECIMAL(3,2) DEFAULT 0, -- Risk of stopping use
  last_calculated TIMESTAMP DEFAULT NOW(),
  UNIQUE(supplier_id, feature_key)
);

-- Churn prediction and early warning
CREATE TABLE IF NOT EXISTS churn_predictions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES user_profiles(id),
  prediction_date DATE DEFAULT CURRENT_DATE,
  churn_probability DECIMAL(3,2) NOT NULL, -- 0.00 to 1.00
  churn_risk_level TEXT GENERATED ALWAYS AS (
    CASE 
      WHEN churn_probability >= 0.8 THEN 'critical'
      WHEN churn_probability >= 0.6 THEN 'high'
      WHEN churn_probability >= 0.4 THEN 'medium'
      ELSE 'low'
    END
  ) STORED,
  prediction_factors JSONB NOT NULL, -- {"low_engagement": 0.3, "billing_issues": 0.2, "no_recent_login": 0.5}
  predicted_churn_date DATE,
  model_version TEXT DEFAULT 'v1.0',
  model_confidence DECIMAL(3,2), -- How confident the model is
  intervention_recommended BOOLEAN DEFAULT false,
  intervention_priority INTEGER, -- 1-5 scale
  ltv_at_risk DECIMAL(10,2), -- Lifetime value that could be lost
  prevention_cost_estimate DECIMAL(8,2),
  created_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(supplier_id, prediction_date)
);

-- Customer success team performance metrics
CREATE TABLE IF NOT EXISTS cs_performance_metrics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  cs_agent_id UUID REFERENCES user_profiles(id),
  metric_date DATE DEFAULT CURRENT_DATE,
  accounts_managed INTEGER DEFAULT 0,
  interactions_completed INTEGER DEFAULT 0,
  avg_satisfaction_rating DECIMAL(3,2),
  churn_prevented INTEGER DEFAULT 0,
  accounts_upgraded INTEGER DEFAULT 0,
  avg_time_to_resolution_hours DECIMAL(6,2),
  health_score_improvements INTEGER DEFAULT 0,
  total_ltv_impact DECIMAL(12,2) DEFAULT 0, -- Total LTV impact from their work
  created_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(cs_agent_id, metric_date)
);
```

#### API Endpoints Required
```typescript
// GET /api/customer-success/health-score/:userId
interface HealthScoreResponse {
  success: boolean;
  healthScore: {
    current: number;
    previous: number;
    trend: 'improving' | 'stable' | 'declining';
    riskLevel: 'healthy' | 'at_risk' | 'critical';
    breakdown: {
      loginFrequency: number;
      featureAdoption: number;
      clientEngagement: number;
      supportHealth: number;
      billingHealth: number;
    };
    recommendations: Recommendation[];
    nextReviewDate: string;
  };
}

// POST /api/customer-success/interventions/trigger
interface TriggerInterventionRequest {
  userId: string;
  interventionType: 'email_sequence' | 'phone_call' | 'feature_tour' | 'personalized_support';
  reason: string;
  priority: 'low' | 'medium' | 'high' | 'critical';
  customization?: {
    message: string;
    timeline: string;
    specialOffers: string[];
  };
}

// GET /api/customer-success/churn-predictions
interface ChurnPredictionsResponse {
  success: boolean;
  predictions: {
    userId: string;
    churnProbability: number;
    riskLevel: 'low' | 'medium' | 'high' | 'critical';
    predictedChurnDate: string;
    factors: {
      [factor: string]: number;
    };
    recommendedActions: string[];
    ltvAtRisk: number;
    preventionCost: number;
  }[];
  totalAtRisk: number;
  totalLtvAtRisk: number;
}

// POST /api/customer-success/onboarding/milestone
interface MilestoneCompletionRequest {
  userId: string;
  milestoneType: string;
  metadata?: {
    timeToComplete: number;
    assistanceRequired: boolean;
    satisfactionRating: number;
  };
}
```

#### Frontend Components Required
```typescript
// Component: HealthDashboard
// Location: /src/components/customer-success/HealthDashboard.tsx

interface HealthDashboardProps {
  filters: CustomerFilters;
  onInterventionTrigger: (userId: string, type: InterventionType) => void;
}

interface CustomerHealthMetrics {
  userId: string;
  businessName: string;
  healthScore: number;
  riskLevel: 'healthy' | 'at_risk' | 'critical';
  daysSinceLastLogin: number;
  subscriptionTier: string;
  monthlyRevenue: number;
  churnProbability: number;
  lastInteraction?: string;
  urgentActions: UrgentAction[];
}

interface UrgentAction {
  type: 'call_required' | 'email_bounce' | 'billing_issue' | 'feature_abandonment';
  description: string;
  priority: 'low' | 'medium' | 'high' | 'critical';
  dueDate: string;
  estimatedEffort: string;
}

interface OnboardingProgress {
  userId: string;
  currentStep: number;
  totalSteps: number;
  milestonesCompleted: number;
  totalMilestones: number;
  daysInOnboarding: number;
  expectedCompletionDate: string;
  blockers: OnboardingBlocker[];
  nextActions: NextAction[];
}

// Key functionality:
- Real-time health score monitoring with trend analysis
- Automated intervention triggering and tracking
- Onboarding milestone progress visualization
- Churn risk alerts with prevention recommendations
- Customer success team performance dashboard
- Bulk intervention management for at-risk segments
```

#### Integration Points
```typescript
// Service: CustomerSuccessEngine
// Dependencies: Health scoring, churn prediction, intervention automation, analytics

class CustomerSuccessEngine {
  async calculateHealthScore(userId: string): Promise<HealthScoreResult> {
    // Analyze login frequency, feature adoption, client engagement
    // Weight factors based on subscription tier and user segment
    // Compare against cohort benchmarks
    // Predict trajectory and recommend interventions
  }
  
  async predictChurnRisk(userId: string): Promise<ChurnPrediction> {
    // Machine learning model using historical churn patterns
    // Analyze engagement drop-offs, billing issues, support interactions
    // Calculate probability and recommend prevention strategies
  }
  
  async executeIntervention(userId: string, intervention: InterventionPlan): Promise<void> {
    // Trigger automated sequences or manual outreach
    // Track intervention progress and effectiveness
    // Measure success metrics and ROI
  }
}
```

### CODE EXAMPLES

#### Example 1: Health Score Calculation and Automated Intervention System
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { differenceInDays, subDays } from 'date-fns';

interface HealthScoreFactors {
  loginFrequency: number;
  featureAdoption: number;
  clientEngagement: number;
  supportTicketHistory: number;
  billingHealth: number;
  onboardingProgress: number;
}

interface HealthWeights {
  login: number;
  features: number;
  engagement: number;
  support: number;
  billing: number;
  onboarding: number;
}

// Different weights for different user segments
const HEALTH_WEIGHTS: { [segment: string]: HealthWeights } = {
  'new_user': { // First 30 days
    login: 0.25,
    features: 0.20,
    engagement: 0.15,
    support: 0.15,
    billing: 0.05,
    onboarding: 0.20
  },
  'established': { // 30+ days
    login: 0.20,
    features: 0.25,
    engagement: 0.25,
    support: 0.15,
    billing: 0.10,
    onboarding: 0.05
  },
  'power_user': { // High engagement
    login: 0.15,
    features: 0.30,
    engagement: 0.30,
    support: 0.10,
    billing: 0.10,
    onboarding: 0.05
  }
};

export class CustomerSuccessEngine {
  private supabase = createClient();

  async calculateHealthScore(userId: string): Promise<HealthScoreResult> {
    try {
      // Get user segment to apply appropriate weights
      const userSegment = await this.determineUserSegment(userId);
      const weights = HEALTH_WEIGHTS[userSegment];

      // Calculate individual factor scores
      const factors = await this.calculateHealthFactors(userId);
      
      // Calculate weighted health score
      const healthScore = Math.round(
        factors.loginFrequency * weights.login * 100 +
        factors.featureAdoption * weights.features * 100 +
        factors.clientEngagement * weights.engagement * 100 +
        factors.supportTicketHistory * weights.support * 100 +
        factors.billingHealth * weights.billing * 100 +
        factors.onboardingProgress * weights.onboarding * 100
      );

      // Determine risk level
      const riskLevel = this.determineRiskLevel(healthScore);
      
      // Get previous score for trend analysis
      const { data: previousHealth } = await this.supabase
        .from('customer_health')
        .select('health_score')
        .eq('supplier_id', userId)
        .order('calculated_at', { ascending: false })
        .limit(1)
        .single();

      const trend = previousHealth ? this.calculateTrend(healthScore, previousHealth.health_score) : 'stable';

      // Save new health score
      await this.supabase
        .from('customer_health')
        .upsert({
          supplier_id: userId,
          health_score: healthScore,
          risk_level: riskLevel,
          feature_adoption_score: factors.featureAdoption,
          client_engagement_score: factors.clientEngagement,
          support_ticket_score: factors.supportTicketHistory,
          billing_health_score: factors.billingHealth,
          calculated_at: new Date().toISOString(),
          previous_score: previousHealth?.health_score,
          score_trend: trend,
          next_review_date: subDays(new Date(), -7).toISOString() // Next review in 7 days
        });

      // Check if intervention is needed
      if (healthScore < 60 || riskLevel === 'critical') {
        await this.triggerAutomatedIntervention(userId, healthScore, riskLevel);
      }

      return {
        success: true,
        healthScore,
        riskLevel,
        trend,
        factors: {
          loginFrequency: Math.round(factors.loginFrequency * 100),
          featureAdoption: Math.round(factors.featureAdoption * 100),
          clientEngagement: Math.round(factors.clientEngagement * 100),
          supportHealth: Math.round(factors.supportTicketHistory * 100),
          billingHealth: Math.round(factors.billingHealth * 100),
          onboardingProgress: Math.round(factors.onboardingProgress * 100)
        },
        recommendations: await this.generateRecommendations(userId, factors)
      };

    } catch (error) {
      console.error('Health score calculation failed:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Health calculation failed'
      };
    }
  }

  private async calculateHealthFactors(userId: string): Promise<HealthScoreFactors> {
    // 1. Login Frequency Score (0-1)
    const { data: user } = await this.supabase
      .from('user_profiles')
      .select('last_login, created_at')
      .eq('id', userId)
      .single();

    const daysSinceLogin = user?.last_login ? 
      differenceInDays(new Date(), new Date(user.last_login)) : 999;
    
    const loginScore = Math.max(0, Math.min(1, (14 - daysSinceLogin) / 14));

    // 2. Feature Adoption Score (0-1)
    const { data: featureUsage } = await this.supabase
      .from('feature_adoption')
      .select('adoption_stage')
      .eq('supplier_id', userId);

    const totalFeatures = 8; // Core features
    const adoptedFeatures = featureUsage?.filter(f => 
      ['adopting', 'power_user'].includes(f.adoption_stage)
    ).length || 0;
    
    const featureScore = adoptedFeatures / totalFeatures;

    // 3. Client Engagement Score (0-1)
    const thirtyDaysAgo = subDays(new Date(), 30).toISOString();
    
    const { count: activeClients } = await this.supabase
      .from('clients')
      .select('*', { count: 'exact', head: true })
      .eq('supplier_id', userId)
      .gte('last_activity', thirtyDaysAgo);

    const { count: totalClients } = await this.supabase
      .from('clients')
      .select('*', { count: 'exact', head: true })
      .eq('supplier_id', userId);

    const engagementScore = totalClients > 0 ? (activeClients || 0) / totalClients : 0;

    // 4. Support Ticket Health (0-1, where 1 = no issues)
    const { data: recentTickets } = await this.supabase
      .from('support_interactions')
      .select('outcome, satisfaction_rating')
      .eq('supplier_id', userId)
      .gte('created_at', thirtyDaysAgo);

    let supportScore = 1.0; // Start with perfect score
    if (recentTickets && recentTickets.length > 0) {
      const avgSatisfaction = recentTickets
        .filter(t => t.satisfaction_rating)
        .reduce((sum, t) => sum + t.satisfaction_rating, 0) / recentTickets.length;
      
      supportScore = Math.max(0.3, avgSatisfaction / 5); // Don't go below 0.3
    }

    // 5. Billing Health (0-1)
    const { data: subscription } = await this.supabase
      .from('user_subscriptions')
      .select('status')
      .eq('user_id', userId)
      .single();

    const billingScore = subscription?.status === 'active' ? 1.0 : 0.2;

    // 6. Onboarding Progress (0-1)
    const { data: milestones } = await this.supabase
      .from('success_milestones')
      .select('achieved_at, is_critical_path')
      .eq('supplier_id', userId);

    const criticalMilestones = milestones?.filter(m => m.is_critical_path) || [];
    const completedCritical = criticalMilestones.filter(m => m.achieved_at).length;
    const onboardingScore = criticalMilestones.length > 0 ? 
      completedCritical / criticalMilestones.length : 1.0;

    return {
      loginFrequency: loginScore,
      featureAdoption: featureScore,
      clientEngagement: engagementScore,
      supportTicketHistory: supportScore,
      billingHealth: billingScore,
      onboardingProgress: onboardingScore
    };
  }

  private determineRiskLevel(healthScore: number): 'healthy' | 'at_risk' | 'critical' {
    if (healthScore >= 75) return 'healthy';
    if (healthScore >= 50) return 'at_risk';
    return 'critical';
  }

  private calculateTrend(current: number, previous: number): 'improving' | 'stable' | 'declining' {
    const change = current - previous;
    if (Math.abs(change) <= 5) return 'stable';
    return change > 0 ? 'improving' : 'declining';
  }

  async triggerAutomatedIntervention(
    userId: string, 
    healthScore: number, 
    riskLevel: string
  ): Promise<void> {
    try {
      // Find applicable interventions
      const interventions = await this.getApplicableInterventions(userId, healthScore, riskLevel);
      
      for (const intervention of interventions) {
        // Check if intervention was recently executed
        const { data: recentExecution } = await this.supabase
          .from('intervention_executions')
          .select('triggered_at')
          .eq('intervention_id', intervention.id)
          .eq('supplier_id', userId)
          .gte('triggered_at', subDays(new Date(), intervention.max_frequency_days).toISOString())
          .single();

        if (!recentExecution) {
          await this.executeIntervention(userId, intervention, healthScore);
        }
      }
    } catch (error) {
      console.error('Automated intervention failed:', error);
    }
  }

  private async executeIntervention(
    userId: string,
    intervention: any,
    healthScore: number
  ): Promise<void> {
    // Log intervention execution
    const { data: execution } = await this.supabase
      .from('intervention_executions')
      .insert({
        intervention_id: intervention.id,
        supplier_id: userId,
        trigger_reason: `Health score: ${healthScore}`,
        health_score_at_trigger: healthScore
      })
      .select('*')
      .single();

    // Execute based on intervention type
    switch (intervention.intervention_type) {
      case 'email_sequence':
        await this.sendPersonalizedEmail(userId, intervention, execution.id);
        break;
      
      case 'in_app_message':
        await this.createInAppMessage(userId, intervention);
        break;
      
      case 'phone_call':
        await this.scheduleCustomerSuccessCall(userId, intervention, execution.id);
        break;
      
      case 'feature_tour':
        await this.triggerFeatureTour(userId, intervention);
        break;
      
      default:
        console.warn(`Unknown intervention type: ${intervention.intervention_type}`);
    }

    // Mark as executed
    await this.supabase
      .from('intervention_executions')
      .update({
        executed_at: new Date().toISOString()
      })
      .eq('id', execution.id);
  }

  private async sendPersonalizedEmail(
    userId: string,
    intervention: any,
    executionId: string
  ): Promise<void> {
    // Get user context for personalization
    const { data: user } = await this.supabase
      .from('user_profiles')
      .select('first_name, business_name, vendor_type')
      .eq('id', userId)
      .single();

    const { data: recentActivity } = await this.supabase
      .from('feature_adoption')
      .select('feature_key, last_used_at')
      .eq('supplier_id', userId)
      .order('last_used_at', { ascending: false })
      .limit(3);

    // Personalize email content
    const personalizedContent = this.personalizeEmailContent(
      intervention.content_template,
      {
        firstName: user?.first_name,
        businessName: user?.business_name,
        vendorType: user?.vendor_type,
        recentFeatures: recentActivity?.map(f => f.feature_key) || [],
        executionId
      }
    );

    // Send via email service
    await this.sendEmail({
      to: user?.email,
      subject: `${user?.first_name}, let's get your ${user?.vendor_type} business back on track`,
      content: personalizedContent,
      trackingId: executionId
    });
  }

  async predictChurnRisk(userId: string): Promise<ChurnPrediction> {
    try {
      // Get comprehensive user data for prediction
      const userData = await this.gatherChurnPredictionData(userId);
      
      // Apply churn prediction model
      const churnFactors = {
        declining_health_score: this.calculateHealthDeclineRisk(userData.healthHistory),
        low_engagement: this.calculateEngagementRisk(userData.featureUsage),
        billing_issues: this.calculateBillingRisk(userData.billingEvents),
        support_dissatisfaction: this.calculateSupportRisk(userData.supportInteractions),
        competitor_activity: this.calculateCompetitorRisk(userData.vendorType),
        seasonal_factors: this.calculateSeasonalRisk(new Date(), userData.vendorType)
      };

      // Weighted churn probability calculation
      const churnProbability = 
        churnFactors.declining_health_score * 0.25 +
        churnFactors.low_engagement * 0.20 +
        churnFactors.billing_issues * 0.20 +
        churnFactors.support_dissatisfaction * 0.15 +
        churnFactors.competitor_activity * 0.10 +
        churnFactors.seasonal_factors * 0.10;

      const riskLevel = this.determineChurnRiskLevel(churnProbability);
      
      // Calculate potential impact
      const { data: subscription } = await this.supabase
        .from('user_subscriptions')
        .select('tier:subscription_tiers(price_monthly)')
        .eq('user_id', userId)
        .single();

      const monthlyRevenue = subscription?.tier?.price_monthly || 0;
      const estimatedLtv = monthlyRevenue * 18; // 18 month average LTV
      const ltvAtRisk = churnProbability * estimatedLtv;

      // Save prediction
      await this.supabase
        .from('churn_predictions')
        .upsert({
          supplier_id: userId,
          prediction_date: new Date().toISOString().split('T')[0],
          churn_probability: churnProbability,
          prediction_factors: churnFactors,
          predicted_churn_date: this.calculatePredictedChurnDate(churnProbability),
          ltv_at_risk: ltvAtRisk,
          prevention_cost_estimate: Math.min(ltvAtRisk * 0.1, 500), // 10% of LTV, max $500
          intervention_recommended: churnProbability >= 0.6,
          intervention_priority: this.calculateInterventionPriority(churnProbability, ltvAtRisk)
        });

      return {
        success: true,
        churnProbability,
        riskLevel,
        factors: churnFactors,
        ltvAtRisk,
        recommendedActions: this.generateChurnPreventionActions(churnFactors),
        interventionUrgency: churnProbability >= 0.8 ? 'immediate' : 
                           churnProbability >= 0.6 ? 'urgent' : 'monitor'
      };

    } catch (error) {
      console.error('Churn prediction failed:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Churn prediction failed'
      };
    }
  }

  private generateChurnPreventionActions(factors: any): string[] {
    const actions: string[] = [];
    
    if (factors.declining_health_score > 0.6) {
      actions.push('Schedule immediate customer success call');
      actions.push('Offer personalized onboarding session');
    }
    
    if (factors.low_engagement > 0.5) {
      actions.push('Send feature discovery email sequence');
      actions.push('Offer complimentary setup consultation');
    }
    
    if (factors.billing_issues > 0.3) {
      actions.push('Resolve billing concerns immediately');
      actions.push('Offer payment plan or discount');
    }
    
    if (factors.support_dissatisfaction > 0.4) {
      actions.push('Assign dedicated customer success manager');
      actions.push('Provide priority support channel');
    }

    return actions;
  }
}

// Background job for daily health score updates
export async function runDailyHealthScoreUpdate() {
  const supabase = createClient();
  const customerSuccess = new CustomerSuccessEngine();
  
  // Get all active users
  const { data: users } = await supabase
    .from('user_profiles')
    .select('id')
    .eq('account_status', 'active');

  if (!users) return;

  // Process in batches to avoid overwhelming the system
  const batchSize = 50;
  for (let i = 0; i < users.length; i += batchSize) {
    const batch = users.slice(i, i + batchSize);
    
    await Promise.all(
      batch.map(user => 
        customerSuccess.calculateHealthScore(user.id).catch(error => 
          console.error(`Health score failed for user ${user.id}:`, error)
        )
      )
    );
    
    // Brief pause between batches
    await new Promise(resolve => setTimeout(resolve, 100));
  }
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [ ] Context7: Load customer success best practices and churn prediction models
- [ ] Playwright: Test customer health dashboards, intervention flows, and onboarding progress
- [ ] PostgreSQL: Manage customer health data, intervention tracking, and analytics

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/customer-success/health-scoring", "customer health metrics and scoring", 3000);
await mcp__context7__get-library-docs("/machine-learning/churn-prediction", "churn prediction models", 2500);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('CustomerSuccessEngine', () => {
  it('should calculate accurate health scores based on user activity', async () => {
    const userId = 'test-user-id';
    const mockUserData = {
      lastLogin: subDays(new Date(), 3),
      featuresUsed: 6,
      totalFeatures: 8,
      activeClients: 8,
      totalClients: 10,
      supportSatisfaction: 4.5
    };
    
    const healthScore = await customerSuccess.calculateHealthScore(userId);
    
    expect(healthScore.healthScore).toBeGreaterThan(70);
    expect(healthScore.riskLevel).toBe('healthy');
    expect(healthScore.factors.loginFrequency).toBeGreaterThan(80);
  });

  it('should trigger interventions for at-risk customers', async () => {
    const userId = 'at-risk-user-id';
    const lowHealthScore = 35;
    
    await customerSuccess.triggerAutomatedIntervention(userId, lowHealthScore, 'critical');
    
    const { data: executions } = await supabase
      .from('intervention_executions')
      .select('*')
      .eq('supplier_id', userId);
      
    expect(executions).toHaveLength.greaterThan(0);
    expect(executions[0].health_score_at_trigger).toBe(35);
  });

  it('should predict churn risk accurately', async () => {
    const userId = 'churn-risk-user-id';
    const mockRiskFactors = {
      declining_health_score: 0.7,
      low_engagement: 0.6,
      billing_issues: 0.3,
      support_dissatisfaction: 0.4
    };
    
    const prediction = await customerSuccess.predictChurnRisk(userId);
    
    expect(prediction.churnProbability).toBeGreaterThan(0.5);
    expect(prediction.riskLevel).toBeOneOf(['high', 'critical']);
    expect(prediction.recommendedActions).toHaveLength.greaterThan(0);
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Customer success dashboard and intervention workflow', async () => {
  await mcp__playwright__browser_navigate({url: '/admin/customer-success'});
  
  // View health score dashboard
  await mcp__playwright__browser_wait_for({text: 'Customer Health Overview'});
  
  // Filter for at-risk customers
  await mcp__playwright__browser_click({
    element: 'Risk Level Filter',
    ref: 'select[name="riskLevel"]'
  });
  
  await mcp__playwright__browser_select_option({
    element: 'Risk Level Filter',
    ref: 'select[name="riskLevel"]',
    values: ['at_risk']
  });
  
  // Trigger intervention for specific customer
  await mcp__playwright__browser_click({
    element: 'Customer Row Actions',
    ref: 'tr[data-user-id="test-user"] button.actions'
  });
  
  await mcp__playwright__browser_click({
    element: 'Schedule Call Action',
    ref: 'button[data-action="schedule_call"]'
  });
  
  // Fill intervention details
  await mcp__playwright__browser_type({
    element: 'Intervention Notes',
    ref: 'textarea[name="interventionNotes"]',
    text: 'Customer showing declining engagement, needs personalized onboarding support'
  });
  
  await mcp__playwright__browser_click({
    element: 'Schedule Intervention',
    ref: 'button[type="submit"]'
  });
  
  // Verify intervention was scheduled
  await mcp__playwright__browser_wait_for({text: 'Intervention Scheduled'});
  
  await mcp__playwright__browser_snapshot();
});

test('Churn prediction and prevention workflow', async () => {
  // Set user in high churn risk state via API
  await fetch('/api/test/set-churn-risk', {
    method: 'POST',
    body: JSON.stringify({
      userId: 'test-user',
      churnProbability: 0.85,
      riskFactors: {
        declining_health_score: 0.8,
        low_engagement: 0.7,
        billing_issues: 0.2
      }
    })
  });
  
  await mcp__playwright__browser_navigate({url: '/admin/churn-predictions'});
  
  // View high-risk customers
  await mcp__playwright__browser_wait_for({text: 'Critical Risk'});
  await mcp__playwright__browser_wait_for({text: '85% churn probability'});
  
  // Execute immediate intervention
  await mcp__playwright__browser_click({
    element: 'Immediate Action Button',
    ref: 'button.immediate-intervention'
  });
  
  // Select intervention type
  await mcp__playwright__browser_select_option({
    element: 'Intervention Type',
    ref: 'select[name="interventionType"]',
    values: ['personalized_call']
  });
  
  // Add custom message
  await mcp__playwright__browser_type({
    element: 'Custom Message',
    ref: 'textarea[name="customMessage"]',
    text: 'Hi [firstName], I noticed you might be facing some challenges with WedSync. Let me help you get the most value from our platform.'
  });
  
  await mcp__playwright__browser_click({
    element: 'Execute Intervention',
    ref: 'button.execute-intervention'
  });
  
  // Verify intervention execution
  await mcp__playwright__browser_wait_for({text: 'Intervention Executed'});
  await mcp__playwright__browser_wait_for({text: 'Estimated LTV Protected:'});
  
  await mcp__playwright__browser_snapshot();
});
```

### ACCEPTANCE CRITERIA
- [ ] Calculate health scores for 100% of active customers daily
- [ ] Achieve health score accuracy of 85%+ vs actual churn outcomes
- [ ] Reduce customer churn rate by 40% through proactive interventions
- [ ] Automate 80% of customer success interventions
- [ ] Predict churn risk 30+ days in advance with 75%+ accuracy
- [ ] Track and optimize intervention success rates
- [ ] Support customer success team of 5+ agents with performance metrics
- [ ] Generate actionable insights for 10+ customer success KPIs
- [ ] Integrate with email automation and support ticket systems
- [ ] Process health score calculations within 60 seconds per customer

### DEPENDENCIES
- Must complete after: WS-132 (Trial Management System) - Requires trial data integration
- Must complete before: WS-134 (Marketing Automation) - Provides customer intelligence
- Shares code with: User analytics, subscription management, communication systems

### ESTIMATED EFFORT
- Team A Frontend: 24 hours (Health dashboards, intervention management, analytics views)
- Team B Backend: 38 hours (Health scoring engine, churn prediction, intervention automation)
- Team C Integration: 20 hours (Email integration, support ticket analysis, data pipeline)
- Total: 82 hours