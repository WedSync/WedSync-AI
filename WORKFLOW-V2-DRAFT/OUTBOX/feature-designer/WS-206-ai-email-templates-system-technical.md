# TECHNICAL SPECIFICATION: WS-206 - AI Email Templates System
## Generated by Feature Development Session - 2025-08-25

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding photographer who sends 50+ emails per week to couples
**I want to:** Generate professional, personalized email templates instantly for each stage of the wedding journey
**So that:** I can respond to inquiries in 2 minutes instead of 20 minutes, saving 15 hours per week on email writing

**Real Wedding Scenario:**
A photographer receives an inquiry at 9pm about a beach wedding. Instead of spending 20 minutes crafting a perfect response, they select "inquiry stage, outdoor venue, friendly tone" and the AI generates 5 personalized email variants mentioning their beach wedding experience, asking about the couple's vision, and including relevant portfolio links. They pick the best variant, tweak one sentence, and send. Total time: 2 minutes. Without this, they'd either send a generic template that converts poorly or spend valuable evening time writing custom emails.

### SPECIFICATION SOURCE
- **Feature ID:** WS-206
- **Original Spec:** /CORE-SPECIFICATIONS/04-AI-INTEGRATION/03-Content-Generation/01-email-templates md.md
- **Current Implementation:** 0% complete
- **Files to Modify:**
  - /wedsync/src/app/api/communications/route.ts
  - /wedsync/src/components/communications/EmailComposer.tsx
- **New Files to Create:**
  - /wedsync/src/lib/ai/email-template-generator.ts
  - /wedsync/src/lib/ai/email-personalization-engine.ts
  - /wedsync/src/lib/ai/merge-tag-processor.ts
  - /wedsync/src/components/ai/EmailTemplateGenerator.tsx
  - /wedsync/src/components/ai/TemplateVariantSelector.tsx
  - /wedsync/src/types/ai-email.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- AI-generated email templates storage
CREATE TABLE IF NOT EXISTS email_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES suppliers(id) ON DELETE CASCADE,
  template_name TEXT NOT NULL,
  vendor_type TEXT CHECK (vendor_type IN ('photographer', 'dj', 'caterer', 'venue', 'florist', 'planner')),
  stage TEXT CHECK (stage IN ('inquiry', 'booking', 'planning', 'final', 'post')),
  tone TEXT CHECK (tone IN ('formal', 'friendly', 'casual')),
  subject TEXT NOT NULL,
  body TEXT NOT NULL,
  merge_tags TEXT[] DEFAULT ARRAY[]::TEXT[],
  ai_generated BOOLEAN DEFAULT false,
  ai_model TEXT,
  ai_prompt_used TEXT,
  performance_metrics JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  last_used_at TIMESTAMP WITH TIME ZONE,
  use_count INTEGER DEFAULT 0
);

-- Template variants for A/B testing
CREATE TABLE IF NOT EXISTS email_template_variants (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  parent_template_id UUID REFERENCES email_templates(id) ON DELETE CASCADE,
  variant_label TEXT NOT NULL,
  subject TEXT NOT NULL,
  body TEXT NOT NULL,
  performance_score DECIMAL(3,2) DEFAULT 0.00,
  open_rate DECIMAL(3,2),
  response_rate DECIMAL(3,2),
  send_count INTEGER DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Email personalization rules
CREATE TABLE IF NOT EXISTS email_personalization_rules (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES suppliers(id) ON DELETE CASCADE,
  rule_type TEXT NOT NULL,
  condition JSONB NOT NULL,
  content_addition TEXT NOT NULL,
  priority INTEGER DEFAULT 0,
  active BOOLEAN DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Template usage analytics
CREATE TABLE IF NOT EXISTS email_template_analytics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id UUID REFERENCES email_templates(id) ON DELETE CASCADE,
  variant_id UUID REFERENCES email_template_variants(id) ON DELETE CASCADE,
  sent_to_email TEXT NOT NULL,
  sent_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  opened_at TIMESTAMP WITH TIME ZONE,
  clicked_at TIMESTAMP WITH TIME ZONE,
  replied_at TIMESTAMP WITH TIME ZONE,
  conversion_event TEXT,
  conversion_at TIMESTAMP WITH TIME ZONE
);

-- Supplier brand voice settings
CREATE TABLE IF NOT EXISTS supplier_brand_voice (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES suppliers(id) ON DELETE CASCADE UNIQUE,
  brand_personality TEXT[],
  forbidden_phrases TEXT[],
  signature_style TEXT,
  include_portfolio_links BOOLEAN DEFAULT true,
  include_testimonials BOOLEAN DEFAULT false,
  custom_instructions TEXT,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_email_templates_supplier ON email_templates(supplier_id);
CREATE INDEX idx_email_templates_stage ON email_templates(vendor_type, stage);
CREATE INDEX idx_template_variants_parent ON email_template_variants(parent_template_id);
CREATE INDEX idx_template_analytics_template ON email_template_analytics(template_id);
```

#### API Endpoints Required
```typescript
// POST /api/ai/email-templates/generate
interface GenerateTemplateRequest {
  vendorType: 'photographer' | 'dj' | 'caterer' | 'venue' | 'florist' | 'planner';
  stage: 'inquiry' | 'booking' | 'planning' | 'final' | 'post';
  tone: 'formal' | 'friendly' | 'casual';
  includeElements: string[]; // ['pricing', 'timeline', 'next-steps', 'portfolio']
  clientContext?: {
    coupleName?: string;
    weddingDate?: string;
    venue?: string;
    guestCount?: number;
    style?: string;
  };
  variantCount?: number; // Default: 5
}

interface GenerateTemplateResponse {
  success: boolean;
  templates: {
    id: string;
    subject: string;
    body: string;
    mergeTags: string[];
    score: number; // AI confidence score
  }[];
  generationTime: number;
}

// POST /api/ai/email-templates/personalize
interface PersonalizeTemplateRequest {
  templateId: string;
  clientId: string;
  additionalContext?: Record<string, any>;
}

interface PersonalizeTemplateResponse {
  success: boolean;
  personalizedEmail: {
    subject: string;
    body: string;
    addedPersonalization: string[];
  };
}

// GET /api/ai/email-templates/library
interface GetTemplateLibraryRequest {
  vendorType?: string;
  stage?: string;
  aiGenerated?: boolean;
  sortBy?: 'performance' | 'recent' | 'popular';
}

interface GetTemplateLibraryResponse {
  templates: {
    id: string;
    name: string;
    subject: string;
    preview: string;
    stage: string;
    performanceScore: number;
    useCount: number;
  }[];
  totalCount: number;
}

// POST /api/ai/email-templates/test
interface TestTemplateRequest {
  templateId: string;
  testEmails: string[];
  includeVariants?: boolean;
}

interface TestTemplateResponse {
  success: boolean;
  testsSent: number;
  variantIds?: string[];
}
```

#### Frontend Components Required
```typescript
// Component: EmailTemplateGenerator
// Location: /src/components/ai/EmailTemplateGenerator.tsx

interface EmailTemplateGeneratorProps {
  vendorType: string;
  onTemplateGenerated: (templates: EmailTemplate[]) => void;
  clientContext?: ClientContext;
}

// Key functionality:
- Stage selector (inquiry, booking, etc.)
- Tone selector (formal, friendly, casual)
- Element checkboxes (pricing, timeline, etc.)
- Generate button with loading state
- Display 5 generated variants
- Preview each variant
- Select and edit capability

// Component: TemplateVariantSelector
// Location: /src/components/ai/TemplateVariantSelector.tsx

interface TemplateVariantSelectorProps {
  variants: EmailTemplate[];
  onSelect: (template: EmailTemplate) => void;
  onEdit: (template: EmailTemplate) => void;
}

// Key functionality:
- Card view of variants
- Subject line preview
- Body preview (first 100 chars)
- AI confidence score display
- Quick select button
- Edit button for customization
- A/B test toggle

// Component: EmailPersonalizationPanel
// Location: /src/components/ai/EmailPersonalizationPanel.tsx

interface EmailPersonalizationPanelProps {
  template: string;
  client: Client;
  onPersonalize: (personalized: string) => void;
}

// Key functionality:
- Show merge tags available
- Preview with real data
- Add personalization rules
- Toggle auto-personalization
- Manual override options
```

#### Integration Points
```typescript
// Service: EmailTemplateAI
// Dependencies: OpenAI API, template storage, analytics

class EmailTemplateAI {
  private openai: OpenAI;
  private brandVoice: BrandVoiceSettings;
  
  async generateTemplates(request: EmailGeneratorRequest): Promise<EmailTemplate[]> {
    // Build context-aware prompt
    const prompt = this.buildPrompt(request);
    
    // Generate multiple variants
    const variants = await Promise.all(
      Array.from({ length: request.variantCount || 5 }).map(() =>
        this.generateSingleTemplate(prompt, request)
      )
    );
    
    // Add merge tags
    return variants.map(v => this.addMergeTags(v, request.vendorType));
  }
  
  private buildPrompt(request: EmailGeneratorRequest): string {
    // Construct detailed prompt with context
    // Include vendor type specifics
    // Add brand voice instructions
    // Specify required elements
  }
  
  private async generateSingleTemplate(
    prompt: string,
    request: EmailGeneratorRequest
  ): Promise<RawTemplate> {
    // Call OpenAI API
    // Parse response
    // Validate output
    // Return template
  }
  
  private addMergeTags(template: RawTemplate, vendorType: string): EmailTemplate {
    // Add vendor-specific merge tags
    // Format for Handlebars/Liquid
    // Return enhanced template
  }
}

// Service: EmailPersonalizationEngine
class EmailPersonalizationEngine {
  async personalize(
    template: string,
    client: Client,
    rules?: PersonalizationRule[]
  ): Promise<string> {
    // Apply merge tags
    // Add dynamic content
    // Apply personalization rules
    // Return personalized email
  }
}
```

### CODE EXAMPLES

#### Example 1: AI Template Generation
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { OpenAI } from 'openai';
import { supabase } from '@/lib/supabase';

export class EmailTemplateGenerator {
  private openai: OpenAI;
  
  constructor() {
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });
  }
  
  async generateTemplates(request: EmailGeneratorRequest): Promise<EmailTemplate[]> {
    // Step 1: Build comprehensive prompt
    const systemPrompt = `You are an expert wedding industry email writer.
    Generate professional, personalized emails for ${request.vendorType}.
    Stage: ${request.stage}
    Tone: ${request.tone}
    Must include: ${request.includeElements.join(', ')}`;
    
    const userPrompt = this.buildUserPrompt(request);
    
    // Step 2: Generate variants in parallel
    const promises = Array.from({ length: request.variantCount || 5 }).map(async (_, index) => {
      const response = await this.openai.chat.completions.create({
        model: 'gpt-4',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: `${userPrompt}\n\nVariant ${index + 1}: Make this unique.` }
        ],
        temperature: 0.7 + (index * 0.05), // Vary temperature for diversity
        max_tokens: 500
      });
      
      return this.parseEmailResponse(response.choices[0].message.content);
    });
    
    const variants = await Promise.all(promises);
    
    // Step 3: Add merge tags and store
    const templatesWithTags = variants.map(variant => {
      const mergeTags = this.extractMergeTags(request.vendorType, request.stage);
      return {
        ...variant,
        subject: this.injectMergeTags(variant.subject, mergeTags),
        body: this.injectMergeTags(variant.body, mergeTags),
        mergeTags
      };
    });
    
    // Step 4: Store in database
    const { data: savedTemplates } = await supabase
      .from('email_templates')
      .insert(
        templatesWithTags.map(t => ({
          supplier_id: request.supplierId,
          vendor_type: request.vendorType,
          stage: request.stage,
          tone: request.tone,
          subject: t.subject,
          body: t.body,
          merge_tags: t.mergeTags,
          ai_generated: true,
          ai_model: 'gpt-4',
          ai_prompt_used: systemPrompt
        }))
      )
      .select();
    
    return savedTemplates;
  }
  
  private extractMergeTags(vendorType: string, stage: string): string[] {
    const baseTags = ['{{couple_names}}', '{{wedding_date}}', '{{venue_name}}'];
    
    const vendorSpecificTags: Record<string, string[]> = {
      photographer: ['{{photo_style}}', '{{album_type}}', '{{hours_coverage}}'],
      dj: ['{{first_dance_song}}', '{{music_genres}}', '{{equipment_setup}}'],
      caterer: ['{{guest_count}}', '{{dietary_restrictions}}', '{{menu_style}}'],
      venue: ['{{ceremony_time}}', '{{reception_time}}', '{{room_layout}}'],
      florist: ['{{color_scheme}}', '{{flower_preferences}}', '{{ceremony_arch}}'],
      planner: ['{{planning_timeline}}', '{{vendor_list}}', '{{budget_range}}']
    };
    
    const stageTags: Record<string, string[]> = {
      inquiry: ['{{how_they_found_us}}', '{{initial_questions}}'],
      booking: ['{{contract_link}}', '{{deposit_amount}}', '{{payment_schedule}}'],
      planning: ['{{next_meeting}}', '{{pending_decisions}}', '{{timeline_link}}'],
      final: ['{{final_checklist}}', '{{day_of_contact}}', '{{arrival_time}}'],
      post: ['{{gallery_link}}', '{{review_request}}', '{{referral_incentive}}']
    };
    
    return [
      ...baseTags,
      ...(vendorSpecificTags[vendorType] || []),
      ...(stageTags[stage] || [])
    ];
  }
}
```

#### Example 2: Email Personalization Engine
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import Handlebars from 'handlebars';

export class EmailPersonalizationEngine {
  async personalizeEmail(
    template: string,
    client: Client,
    additionalContext?: Record<string, any>
  ): Promise<string> {
    // Step 1: Compile template with Handlebars
    const compiledTemplate = Handlebars.compile(template);
    
    // Step 2: Build context from client data
    const context = {
      couple_names: `${client.partner1_name} & ${client.partner2_name}`,
      wedding_date: formatDate(client.wedding_date),
      venue_name: client.venue?.name || 'your venue',
      guest_count: client.guest_count || 'your guests',
      ...additionalContext
    };
    
    // Step 3: Apply personalization rules
    const rules = await this.getPersonalizationRules(client.supplier_id);
    let personalizedContent = compiledTemplate(context);
    
    for (const rule of rules) {
      if (this.evaluateRule(rule, client)) {
        personalizedContent = this.applyRule(personalizedContent, rule);
      }
    }
    
    // Step 4: Add dynamic content based on client data
    if (client.venue?.outdoor) {
      personalizedContent += '\n\nP.S. I have extensive experience with outdoor ceremonies at your venue and know exactly how to handle the lighting!';
    }
    
    if (client.wedding_date && isDuringPeakSeason(client.wedding_date)) {
      personalizedContent += '\n\nNote: Your wedding is during peak season - I recommend booking soon to secure your date.';
    }
    
    if (client.style_preferences?.includes('vintage')) {
      personalizedContent = personalizedContent.replace(
        'my portfolio',
        'my portfolio (especially the vintage collection)'
      );
    }
    
    return personalizedContent;
  }
  
  private async getPersonalizationRules(supplierId: string): Promise<PersonalizationRule[]> {
    const { data } = await supabase
      .from('email_personalization_rules')
      .select('*')
      .eq('supplier_id', supplierId)
      .eq('active', true)
      .order('priority', { ascending: false });
    
    return data || [];
  }
  
  private evaluateRule(rule: PersonalizationRule, client: Client): boolean {
    // Evaluate JSON condition against client data
    // Example: { "venue.type": "beach", "guest_count": { ">": 100 } }
    const condition = rule.condition as any;
    
    for (const [key, value] of Object.entries(condition)) {
      const clientValue = this.getNestedValue(client, key);
      
      if (typeof value === 'object') {
        // Handle operators like >, <, >=, <=
        const operator = Object.keys(value)[0];
        const compareValue = value[operator];
        
        if (!this.compareValues(clientValue, operator, compareValue)) {
          return false;
        }
      } else {
        // Direct equality check
        if (clientValue !== value) {
          return false;
        }
      }
    }
    
    return true;
  }
}
```

#### Example 3: Template Variant Selector Component
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { useState } from 'react';
import { Card, CardHeader, CardContent } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Star, Edit, Send, TestTube } from 'lucide-react';

export function TemplateVariantSelector({
  variants,
  onSelect,
  onEdit,
  onStartABTest
}: TemplateVariantSelectorProps) {
  const [selectedIndex, setSelectedIndex] = useState<number | null>(null);
  const [abTestVariants, setABTestVariants] = useState<Set<number>>(new Set());
  
  const handleSelect = (variant: EmailTemplate, index: number) => {
    setSelectedIndex(index);
    onSelect(variant);
  };
  
  const toggleABTest = (index: number) => {
    const newSet = new Set(abTestVariants);
    if (newSet.has(index)) {
      newSet.delete(index);
    } else {
      newSet.add(index);
    }
    setABTestVariants(newSet);
  };
  
  return (
    <div className="space-y-4">
      <div className="flex justify-between items-center">
        <h3 className="text-lg font-semibold">Generated Email Variants</h3>
        {abTestVariants.size >= 2 && (
          <Button
            onClick={() => onStartABTest(Array.from(abTestVariants).map(i => variants[i]))}
            variant="outline"
          >
            <TestTube className="w-4 h-4 mr-2" />
            Start A/B Test ({abTestVariants.size} variants)
          </Button>
        )}
      </div>
      
      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
        {variants.map((variant, index) => (
          <Card
            key={variant.id}
            className={`
              cursor-pointer transition-all
              ${selectedIndex === index ? 'ring-2 ring-primary' : ''}
              ${abTestVariants.has(index) ? 'bg-blue-50' : ''}
            `}
            onClick={() => handleSelect(variant, index)}
          >
            <CardHeader className="pb-3">
              <div className="flex justify-between items-start">
                <div className="flex-1">
                  <h4 className="font-medium text-sm line-clamp-1">
                    {variant.subject}
                  </h4>
                  <div className="flex gap-2 mt-2">
                    <Badge variant="outline" className="text-xs">
                      Variant {index + 1}
                    </Badge>
                    {variant.score && (
                      <Badge variant="secondary" className="text-xs">
                        <Star className="w-3 h-3 mr-1" />
                        {(variant.score * 100).toFixed(0)}%
                      </Badge>
                    )}
                  </div>
                </div>
                
                <input
                  type="checkbox"
                  checked={abTestVariants.has(index)}
                  onChange={(e) => {
                    e.stopPropagation();
                    toggleABTest(index);
                  }}
                  className="mt-1"
                  title="Include in A/B test"
                />
              </div>
            </CardHeader>
            
            <CardContent>
              <p className="text-sm text-gray-600 line-clamp-3">
                {variant.body}
              </p>
              
              <div className="flex gap-2 mt-4">
                <Button
                  size="sm"
                  variant={selectedIndex === index ? 'default' : 'outline'}
                  onClick={(e) => {
                    e.stopPropagation();
                    handleSelect(variant, index);
                  }}
                >
                  <Send className="w-3 h-3 mr-1" />
                  Use This
                </Button>
                
                <Button
                  size="sm"
                  variant="ghost"
                  onClick={(e) => {
                    e.stopPropagation();
                    onEdit(variant);
                  }}
                >
                  <Edit className="w-3 h-3 mr-1" />
                  Edit
                </Button>
              </div>
              
              {variant.mergeTags && variant.mergeTags.length > 0 && (
                <div className="mt-3 pt-3 border-t">
                  <p className="text-xs text-gray-500">Merge tags:</p>
                  <div className="flex flex-wrap gap-1 mt-1">
                    {variant.mergeTags.slice(0, 3).map(tag => (
                      <span key={tag} className="text-xs bg-gray-100 px-1 rounded">
                        {tag}
                      </span>
                    ))}
                    {variant.mergeTags.length > 3 && (
                      <span className="text-xs text-gray-400">
                        +{variant.mergeTags.length - 3} more
                      </span>
                    )}
                  </div>
                </div>
              )}
            </CardContent>
          </Card>
        ))}
      </div>
    </div>
  );
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for OpenAI API, Handlebars templating
- [x] Playwright: Test template generation, variant selection
- [x] Filesystem: Access AI service files and components
- [ ] OpenAI MCP: Generate email content (when available)

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/openai/openai", "chat completions", 3000);
await mcp__context7__get-library-docs("/handlebars/handlebars", "template compilation", 2000);
await mcp__context7__get-library-docs("/vercel/next.js", "api routes streaming", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('EmailTemplateAI', () => {
  it('should generate 5 unique variants', async () => {
    const generator = new EmailTemplateAI();
    const variants = await generator.generateTemplates({
      vendorType: 'photographer',
      stage: 'inquiry',
      tone: 'friendly',
      includeElements: ['pricing', 'portfolio'],
      variantCount: 5
    });
    
    expect(variants).toHaveLength(5);
    // Check all variants are unique
    const subjects = new Set(variants.map(v => v.subject));
    expect(subjects.size).toBe(5);
  });
  
  it('should include required merge tags', () => {
    const tags = generator.extractMergeTags('photographer', 'booking');
    expect(tags).toContain('{{couple_names}}');
    expect(tags).toContain('{{wedding_date}}');
    expect(tags).toContain('{{contract_link}}');
  });
  
  it('should personalize based on client data', async () => {
    const engine = new EmailPersonalizationEngine();
    const personalized = await engine.personalizeEmail(
      'Hello {{couple_names}}, your wedding at {{venue_name}}...',
      mockClient
    );
    
    expect(personalized).toContain('Sarah & Mike');
    expect(personalized).toContain('Sunset Beach Resort');
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Generate and select email template', async () => {
  await mcp__playwright__browser_navigate({url: '/communications/compose'});
  
  // Open AI generator
  await mcp__playwright__browser_click({
    element: 'AI Generate button',
    ref: 'ai-generate-btn'
  });
  
  // Configure generation
  await mcp__playwright__browser_select_option({
    element: 'Stage selector',
    ref: 'stage-select',
    values: ['inquiry']
  });
  
  await mcp__playwright__browser_select_option({
    element: 'Tone selector',
    ref: 'tone-select',
    values: ['friendly']
  });
  
  // Generate templates
  await mcp__playwright__browser_click({
    element: 'Generate button',
    ref: 'generate-btn'
  });
  
  // Wait for variants
  await mcp__playwright__browser_wait_for({text: 'Variant 1'});
  
  // Select a variant
  await mcp__playwright__browser_click({
    element: 'Use This button for variant 2',
    ref: 'use-variant-2'
  });
  
  // Verify template loaded in composer
  await mcp__playwright__browser_snapshot();
});
```

### ACCEPTANCE CRITERIA
- [ ] Generate 5 unique email variants per request
- [ ] Generation completes within 10 seconds
- [ ] Include vendor-specific merge tags
- [ ] Personalization based on client data works
- [ ] A/B testing for variants enabled
- [ ] Templates stored with performance metrics
- [ ] Brand voice settings respected
- [ ] Subject lines are compelling and relevant
- [ ] Performance: API response < 10s for 5 variants
- [ ] Security: No PII in AI prompts
- [ ] Accessibility: Template preview readable by screen readers

### DEPENDENCIES
- Must complete after: OpenAI API integration setup
- Must complete before: Journey automation emails
- Shares code with: WS-207 (FAQ extraction), WS-209 (Personalization)

### ESTIMATED EFFORT
- Team A Frontend: 24 hours
- Team B Backend: 20 hours
- Team C Integration: 8 hours
- Team D Platform: 4 hours
- Team E General: 16 hours (AI implementation)
- Team F Workflows: 8 hours
- Team G Performance: 4 hours
- Total: 84 hours