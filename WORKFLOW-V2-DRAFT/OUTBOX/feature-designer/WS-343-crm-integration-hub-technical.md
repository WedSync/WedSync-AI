# TECHNICAL SPECIFICATION: WS-343 - CRM Integration Hub
## Generated by Feature Development Session - 2025-01-31

### USER STORY & BUSINESS CONTEXT
**As a:** Wedding supplier using multiple CRM systems (Tave, LightBlue, HoneyBook, etc.)
**I want to:** Seamlessly sync all my client data between WedSync and my existing CRM without duplicate entry
**So that:** I can maintain my existing workflows while gaining WedSync's powerful features, ensuring all systems stay synchronized

**Real Wedding Scenario:**
Sarah, a photographer, has 200+ clients in Tave spanning 3 years of bookings. She wants to try WedSync but can't afford to lose this data or manually re-enter everything. The CRM Integration Hub automatically imports all her Tave contacts, creates corresponding WedSync forms, and keeps both systems synchronized bidirectionally.

**Business Impact:**
- Reduces onboarding friction by 90% (major conversion blocker)
- Enables vendors to maintain existing workflows
- Creates viral growth through imported client networks
- Prevents churn from data migration fears
- 85% of photographers use Tave, LightBlue, or HoneyBook

### SPECIFICATION SOURCE
- **Feature ID:** WS-343
- **Priority Level:** HIGH PRIORITY (Core Integration)
- **Estimated Effort:** 120 hours total
- **Dependencies:** Forms system, Client management, Authentication system
- **Integration Complexity:** Very High (Multiple APIs, OAuth flows, data mapping)

### TECHNICAL DESIGN

#### Database Schema Required

```sql
-- CRM Integration Connections
CREATE TABLE crm_integrations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    crm_provider TEXT NOT NULL CHECK (crm_provider IN (
        'tave', 'lightblue', 'honeybook', 'seventeen', 'shootq', 
        'pixieset', 'iris_works', 'dubsado', 'studio_ninja', 'custom'
    )),
    connection_name TEXT NOT NULL,
    connection_status TEXT NOT NULL CHECK (connection_status IN (
        'connected', 'disconnected', 'error', 'pending_auth', 'sync_in_progress'
    )) DEFAULT 'pending_auth',
    auth_config JSONB NOT NULL DEFAULT '{}', -- OAuth tokens, API keys, etc.
    sync_config JSONB NOT NULL DEFAULT '{}', -- Sync preferences, field mappings
    last_sync_at TIMESTAMPTZ,
    last_sync_status TEXT CHECK (last_sync_status IN ('success', 'partial', 'failed')),
    sync_error_details JSONB,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(supplier_id, crm_provider, connection_name)
);

-- CRM Sync Jobs (for async processing)
CREATE TABLE crm_sync_jobs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    integration_id UUID NOT NULL REFERENCES crm_integrations(id) ON DELETE CASCADE,
    job_type TEXT NOT NULL CHECK (job_type IN (
        'full_import', 'incremental_sync', 'export_to_crm', 'field_mapping_update'
    )),
    job_status TEXT NOT NULL CHECK (job_status IN (
        'pending', 'running', 'completed', 'failed', 'cancelled'
    )) DEFAULT 'pending',
    job_config JSONB NOT NULL DEFAULT '{}',
    progress_percent INTEGER DEFAULT 0 CHECK (progress_percent >= 0 AND progress_percent <= 100),
    records_processed INTEGER DEFAULT 0,
    records_total INTEGER,
    error_details JSONB,
    started_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- CRM Field Mappings (flexible field mapping between systems)
CREATE TABLE crm_field_mappings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    integration_id UUID NOT NULL REFERENCES crm_integrations(id) ON DELETE CASCADE,
    wedsync_field TEXT NOT NULL, -- WedSync field name
    crm_field TEXT NOT NULL, -- CRM field name/path
    field_type TEXT NOT NULL CHECK (field_type IN (
        'text', 'email', 'phone', 'date', 'number', 'boolean', 'json', 'array'
    )),
    transform_rules JSONB DEFAULT '{}', -- Data transformation rules
    sync_direction TEXT NOT NULL CHECK (sync_direction IN (
        'import_only', 'export_only', 'bidirectional'
    )) DEFAULT 'bidirectional',
    is_required BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(integration_id, wedsync_field, crm_field)
);

-- CRM Sync Log (detailed sync history for debugging)
CREATE TABLE crm_sync_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    integration_id UUID NOT NULL REFERENCES crm_integrations(id) ON DELETE CASCADE,
    sync_job_id UUID REFERENCES crm_sync_jobs(id) ON DELETE SET NULL,
    record_type TEXT NOT NULL, -- 'client', 'project', 'invoice', etc.
    record_id TEXT NOT NULL, -- External CRM record ID
    wedsync_record_id UUID, -- Corresponding WedSync record ID
    action_type TEXT NOT NULL CHECK (action_type IN (
        'created', 'updated', 'deleted', 'skipped', 'error'
    )),
    action_details JSONB,
    error_message TEXT,
    processed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    INDEX (integration_id, processed_at),
    INDEX (sync_job_id),
    INDEX (record_type, record_id)
);

-- CRM Client Import Staging (temporary storage during import)
CREATE TABLE crm_client_staging (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    integration_id UUID NOT NULL REFERENCES crm_integrations(id) ON DELETE CASCADE,
    sync_job_id UUID NOT NULL REFERENCES crm_sync_jobs(id) ON DELETE CASCADE,
    external_id TEXT NOT NULL,
    raw_data JSONB NOT NULL, -- Raw CRM data
    mapped_data JSONB, -- Processed/mapped data
    import_status TEXT NOT NULL CHECK (import_status IN (
        'pending', 'processed', 'error', 'duplicate'
    )) DEFAULT 'pending',
    error_details JSONB,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    INDEX (sync_job_id, import_status),
    INDEX (integration_id, external_id)
);

-- Add CRM integration reference to clients table
ALTER TABLE clients ADD COLUMN IF NOT EXISTS crm_integration_id UUID REFERENCES crm_integrations(id) ON DELETE SET NULL;
ALTER TABLE clients ADD COLUMN IF NOT EXISTS external_crm_id TEXT;
ALTER TABLE clients ADD COLUMN IF NOT EXISTS last_crm_sync_at TIMESTAMPTZ;

-- Add indexes for better performance
CREATE INDEX IF NOT EXISTS idx_clients_crm_integration ON clients(crm_integration_id) WHERE crm_integration_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_clients_external_crm_id ON clients(external_crm_id) WHERE external_crm_id IS NOT NULL;
```

#### API Endpoints Required

```typescript
// CRM Integration Types
interface CRMIntegration {
  id: string;
  supplier_id: string;
  crm_provider: 'tave' | 'lightblue' | 'honeybook' | 'seventeen' | 'shootq' | 'pixieset' | 'iris_works' | 'dubsado' | 'studio_ninja' | 'custom';
  connection_name: string;
  connection_status: 'connected' | 'disconnected' | 'error' | 'pending_auth' | 'sync_in_progress';
  auth_config: Record<string, any>;
  sync_config: CRMSyncConfig;
  last_sync_at?: string;
  last_sync_status?: 'success' | 'partial' | 'failed';
  sync_error_details?: Record<string, any>;
  created_at: string;
  updated_at: string;
}

interface CRMSyncConfig {
  auto_sync_enabled: boolean;
  sync_interval_minutes: number; // 15, 30, 60, 240, 1440 (daily)
  sync_direction: 'import_only' | 'export_only' | 'bidirectional';
  import_historical_data: boolean;
  import_date_range?: {
    start_date: string;
    end_date: string;
  };
  field_mappings: CRMFieldMapping[];
  conflict_resolution: 'wedsync_wins' | 'crm_wins' | 'newest_wins' | 'manual_review';
  excluded_record_types: string[];
}

interface CRMFieldMapping {
  wedsync_field: string;
  crm_field: string;
  field_type: 'text' | 'email' | 'phone' | 'date' | 'number' | 'boolean' | 'json' | 'array';
  transform_rules: Record<string, any>;
  sync_direction: 'import_only' | 'export_only' | 'bidirectional';
  is_required: boolean;
}

interface CRMSyncJob {
  id: string;
  integration_id: string;
  job_type: 'full_import' | 'incremental_sync' | 'export_to_crm' | 'field_mapping_update';
  job_status: 'pending' | 'running' | 'completed' | 'failed' | 'cancelled';
  job_config: Record<string, any>;
  progress_percent: number;
  records_processed: number;
  records_total?: number;
  error_details?: Record<string, any>;
  started_at?: string;
  completed_at?: string;
  created_at: string;
}

interface CRMProvider {
  id: string;
  name: string;
  description: string;
  logo_url: string;
  auth_type: 'oauth2' | 'api_key' | 'basic_auth' | 'custom';
  auth_url?: string;
  scopes?: string[];
  supported_features: CRMFeature[];
  rate_limits: {
    requests_per_minute: number;
    requests_per_hour: number;
  };
  field_mappings: CRMProviderFieldMapping[];
}

interface CRMFeature {
  feature: 'clients' | 'projects' | 'invoices' | 'events' | 'tasks' | 'documents' | 'communications';
  supported_operations: ('read' | 'write' | 'delete')[];
  limitations?: string[];
}

interface CRMProviderFieldMapping {
  standard_field: string; // Our standard field name
  provider_field: string; // Provider's field name
  field_type: string;
  description: string;
  is_required: boolean;
  default_value?: any;
}

// API Endpoints

// GET /api/crm/providers - List supported CRM providers
interface GetCRMProvidersResponse {
  providers: CRMProvider[];
}

// GET /api/crm/integrations - List user's CRM integrations
interface GetCRMIntegrationsResponse {
  integrations: CRMIntegration[];
}

// POST /api/crm/integrations - Create new CRM integration
interface CreateCRMIntegrationRequest {
  crm_provider: string;
  connection_name: string;
  auth_config: Record<string, any>;
  sync_config: CRMSyncConfig;
}

interface CreateCRMIntegrationResponse {
  integration: CRMIntegration;
  auth_url?: string; // For OAuth flows
}

// PUT /api/crm/integrations/:id - Update CRM integration
interface UpdateCRMIntegrationRequest {
  connection_name?: string;
  sync_config?: Partial<CRMSyncConfig>;
}

interface UpdateCRMIntegrationResponse {
  integration: CRMIntegration;
}

// POST /api/crm/integrations/:id/sync - Trigger sync job
interface TriggerCRMSyncRequest {
  job_type: 'full_import' | 'incremental_sync' | 'export_to_crm';
  job_config?: Record<string, any>;
}

interface TriggerCRMSyncResponse {
  sync_job: CRMSyncJob;
}

// GET /api/crm/integrations/:id/sync-jobs - List sync jobs
interface GetSyncJobsResponse {
  sync_jobs: CRMSyncJob[];
  total: number;
  page: number;
  per_page: number;
}

// GET /api/crm/integrations/:id/sync-logs - Get sync logs
interface GetSyncLogsResponse {
  logs: CRMSyncLog[];
  total: number;
  page: number;
  per_page: number;
}

interface CRMSyncLog {
  id: string;
  integration_id: string;
  sync_job_id?: string;
  record_type: string;
  record_id: string;
  wedsync_record_id?: string;
  action_type: 'created' | 'updated' | 'deleted' | 'skipped' | 'error';
  action_details: Record<string, any>;
  error_message?: string;
  processed_at: string;
}

// DELETE /api/crm/integrations/:id - Delete integration
interface DeleteCRMIntegrationResponse {
  success: boolean;
  message: string;
}

// POST /api/crm/integrations/:id/test-connection - Test CRM connection
interface TestCRMConnectionResponse {
  success: boolean;
  connection_info: {
    provider: string;
    account_name?: string;
    available_features: string[];
    rate_limit_status: {
      remaining_requests: number;
      reset_time: string;
    };
  };
  error_message?: string;
}

// GET /api/crm/integrations/:id/field-mappings - Get field mappings
interface GetFieldMappingsResponse {
  mappings: CRMFieldMapping[];
  available_wedsync_fields: FieldDefinition[];
  available_crm_fields: FieldDefinition[];
}

interface FieldDefinition {
  name: string;
  display_name: string;
  field_type: string;
  description: string;
  is_required: boolean;
  sample_values?: string[];
}

// POST /api/crm/integrations/:id/field-mappings - Update field mappings
interface UpdateFieldMappingsRequest {
  mappings: Omit<CRMFieldMapping, 'id'>[];
}

interface UpdateFieldMappingsResponse {
  mappings: CRMFieldMapping[];
  validation_errors?: FieldMappingError[];
}

interface FieldMappingError {
  mapping_index: number;
  field: string;
  error: string;
  suggested_fix?: string;
}
```

### IMPLEMENTATION DETAILS

#### Frontend Components

```typescript
// CRM Integration Dashboard Component
import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Progress } from '@/components/ui/progress';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { 
  Settings, 
  Zap, 
  AlertCircle, 
  CheckCircle, 
  Clock, 
  RefreshCw,
  Plus,
  Trash2,
  Eye,
  ArrowRight
} from 'lucide-react';

interface CRMIntegrationDashboardProps {
  supplierId: string;
}

const CRMIntegrationDashboard: React.FC<CRMIntegrationDashboardProps> = ({ supplierId }) => {
  const [integrations, setIntegrations] = useState<CRMIntegration[]>([]);
  const [providers, setProviders] = useState<CRMProvider[]>([]);
  const [loading, setLoading] = useState(true);
  const [selectedIntegration, setSelectedIntegration] = useState<CRMIntegration | null>(null);

  useEffect(() => {
    loadIntegrations();
    loadProviders();
  }, [supplierId]);

  const loadIntegrations = async () => {
    try {
      const response = await fetch('/api/crm/integrations');
      const data: GetCRMIntegrationsResponse = await response.json();
      setIntegrations(data.integrations);
    } catch (error) {
      console.error('Failed to load CRM integrations:', error);
    }
  };

  const loadProviders = async () => {
    try {
      const response = await fetch('/api/crm/providers');
      const data: GetCRMProvidersResponse = await response.json();
      setProviders(data.providers);
    } catch (error) {
      console.error('Failed to load CRM providers:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleCreateIntegration = async (provider: CRMProvider) => {
    try {
      // Open OAuth flow or configuration modal based on provider
      if (provider.auth_type === 'oauth2') {
        // Redirect to OAuth flow
        window.location.href = `/api/crm/auth/${provider.id}?return_url=${encodeURIComponent(window.location.href)}`;
      } else {
        // Open configuration modal for API key or basic auth
        setSelectedProvider(provider);
        setShowConfigModal(true);
      }
    } catch (error) {
      console.error('Failed to create integration:', error);
    }
  };

  const handleTriggerSync = async (integrationId: string, jobType: string) => {
    try {
      const response = await fetch(`/api/crm/integrations/${integrationId}/sync`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ job_type: jobType })
      });
      
      if (response.ok) {
        await loadIntegrations(); // Refresh to show sync in progress
      }
    } catch (error) {
      console.error('Failed to trigger sync:', error);
    }
  };

  const getStatusBadge = (status: string) => {
    const badges = {
      connected: <Badge variant="success"><CheckCircle className="w-3 h-3 mr-1" />Connected</Badge>,
      disconnected: <Badge variant="secondary">Disconnected</Badge>,
      error: <Badge variant="destructive"><AlertCircle className="w-3 h-3 mr-1" />Error</Badge>,
      pending_auth: <Badge variant="warning"><Clock className="w-3 h-3 mr-1" />Pending</Badge>,
      sync_in_progress: <Badge variant="info"><RefreshCw className="w-3 h-3 mr-1 animate-spin" />Syncing</Badge>
    };
    return badges[status as keyof typeof badges] || <Badge variant="secondary">{status}</Badge>;
  };

  if (loading) {
    return <div className="flex justify-center p-8"><RefreshCw className="w-6 h-6 animate-spin" /></div>;
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-3xl font-bold">CRM Integrations</h1>
          <p className="text-muted-foreground">
            Connect your existing CRM systems to sync client data automatically
          </p>
        </div>
        <Button onClick={() => setShowProviderModal(true)}>
          <Plus className="w-4 h-4 mr-2" />
          Add Integration
        </Button>
      </div>

      {/* Overview Stats */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Active Integrations</CardTitle>
            <Zap className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              {integrations.filter(i => i.connection_status === 'connected').length}
            </div>
          </CardContent>
        </Card>
        
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Last Sync</CardTitle>
            <Clock className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              {integrations
                .filter(i => i.last_sync_at)
                .sort((a, b) => new Date(b.last_sync_at!).getTime() - new Date(a.last_sync_at!).getTime())[0]
                ?.last_sync_at 
                ? new Date(integrations[0].last_sync_at!).toLocaleDateString()
                : 'Never'
              }
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Sync Status</CardTitle>
            <RefreshCw className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              {integrations.filter(i => i.last_sync_status === 'success').length}/
              {integrations.filter(i => i.last_sync_at).length}
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Total Records</CardTitle>
            <ArrowRight className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">1,247</div>
            <p className="text-xs text-muted-foreground">Synced clients</p>
          </CardContent>
        </Card>
      </div>

      {/* Active Integrations */}
      <div className="space-y-4">
        <h2 className="text-xl font-semibold">Your Integrations</h2>
        
        {integrations.length === 0 ? (
          <Card>
            <CardContent className="p-6 text-center">
              <div className="w-16 h-16 mx-auto mb-4 bg-muted rounded-full flex items-center justify-center">
                <Zap className="w-8 h-8 text-muted-foreground" />
              </div>
              <h3 className="font-semibold mb-2">No integrations yet</h3>
              <p className="text-muted-foreground mb-4">
                Connect your CRM system to automatically sync client data and save hours of manual entry.
              </p>
              <Button onClick={() => setShowProviderModal(true)}>
                <Plus className="w-4 h-4 mr-2" />
                Add Your First Integration
              </Button>
            </CardContent>
          </Card>
        ) : (
          <div className="grid gap-4">
            {integrations.map((integration) => (
              <CRMIntegrationCard
                key={integration.id}
                integration={integration}
                onSync={handleTriggerSync}
                onConfigure={() => setSelectedIntegration(integration)}
                onDelete={() => handleDeleteIntegration(integration.id)}
              />
            ))}
          </div>
        )}
      </div>

      {/* Available Providers */}
      {integrations.length > 0 && (
        <div className="space-y-4">
          <h2 className="text-xl font-semibold">Add More Integrations</h2>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            {providers
              .filter(provider => !integrations.some(i => i.crm_provider === provider.id))
              .map((provider) => (
                <CRMProviderCard
                  key={provider.id}
                  provider={provider}
                  onConnect={() => handleCreateIntegration(provider)}
                />
              ))}
          </div>
        </div>
      )}
    </div>
  );
};

// Individual Integration Card Component
interface CRMIntegrationCardProps {
  integration: CRMIntegration;
  onSync: (integrationId: string, jobType: string) => void;
  onConfigure: () => void;
  onDelete: () => void;
}

const CRMIntegrationCard: React.FC<CRMIntegrationCardProps> = ({ 
  integration, 
  onSync, 
  onConfigure, 
  onDelete 
}) => {
  const [syncJobs, setSyncJobs] = useState<CRMSyncJob[]>([]);
  const [loadingSyncJobs, setLoadingSyncJobs] = useState(false);

  useEffect(() => {
    loadSyncJobs();
  }, [integration.id]);

  const loadSyncJobs = async () => {
    setLoadingSyncJobs(true);
    try {
      const response = await fetch(`/api/crm/integrations/${integration.id}/sync-jobs?limit=5`);
      const data: GetSyncJobsResponse = await response.json();
      setSyncJobs(data.sync_jobs);
    } catch (error) {
      console.error('Failed to load sync jobs:', error);
    } finally {
      setLoadingSyncJobs(false);
    }
  };

  const getProviderInfo = () => {
    const providerNames: Record<string, { name: string; logo: string }> = {
      tave: { name: 'Tave', logo: '/crm-logos/tave.png' },
      lightblue: { name: 'Light Blue', logo: '/crm-logos/lightblue.png' },
      honeybook: { name: 'HoneyBook', logo: '/crm-logos/honeybook.png' },
      seventeen: { name: 'Seventeen', logo: '/crm-logos/seventeen.png' },
      shootq: { name: 'ShootQ', logo: '/crm-logos/shootq.png' },
      pixieset: { name: 'Pixieset', logo: '/crm-logos/pixieset.png' },
      iris_works: { name: 'Iris Works', logo: '/crm-logos/iris-works.png' },
      dubsado: { name: 'Dubsado', logo: '/crm-logos/dubsado.png' },
      studio_ninja: { name: 'Studio Ninja', logo: '/crm-logos/studio-ninja.png' },
    };
    return providerNames[integration.crm_provider] || { 
      name: integration.crm_provider.replace('_', ' ').toUpperCase(), 
      logo: '/crm-logos/default.png' 
    };
  };

  const providerInfo = getProviderInfo();
  const latestSyncJob = syncJobs[0];

  return (
    <Card className="hover:shadow-lg transition-shadow">
      <CardHeader>
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-3">
            <img 
              src={providerInfo.logo} 
              alt={providerInfo.name}
              className="w-10 h-10 rounded-lg object-contain bg-white border"
              onError={(e) => {
                (e.target as HTMLImageElement).src = '/crm-logos/default.png';
              }}
            />
            <div>
              <CardTitle className="text-lg">{integration.connection_name}</CardTitle>
              <CardDescription>{providerInfo.name} Integration</CardDescription>
            </div>
          </div>
          <div className="flex items-center space-x-2">
            {getStatusBadge(integration.connection_status)}
            <Button variant="ghost" size="sm" onClick={onConfigure}>
              <Settings className="w-4 h-4" />
            </Button>
          </div>
        </div>
      </CardHeader>
      
      <CardContent>
        <div className="space-y-4">
          {/* Sync Status */}
          {latestSyncJob && (
            <div className="space-y-2">
              <div className="flex justify-between text-sm">
                <span className="text-muted-foreground">Latest Sync</span>
                <span className="font-medium">
                  {latestSyncJob.job_status === 'running' ? 'In Progress' : 
                   latestSyncJob.job_status === 'completed' ? 'Completed' : 
                   latestSyncJob.job_status}
                </span>
              </div>
              
              {latestSyncJob.job_status === 'running' && (
                <Progress value={latestSyncJob.progress_percent} className="h-2" />
              )}
              
              <div className="flex justify-between text-xs text-muted-foreground">
                <span>
                  {latestSyncJob.records_processed} 
                  {latestSyncJob.records_total && ` of ${latestSyncJob.records_total}`} records
                </span>
                <span>
                  {latestSyncJob.started_at ? new Date(latestSyncJob.started_at).toLocaleString() : ''}
                </span>
              </div>
            </div>
          )}

          {/* Sync Config Summary */}
          <div className="text-sm space-y-1">
            <div className="flex justify-between">
              <span className="text-muted-foreground">Auto Sync:</span>
              <span>{integration.sync_config.auto_sync_enabled ? 'Enabled' : 'Disabled'}</span>
            </div>
            <div className="flex justify-between">
              <span className="text-muted-foreground">Direction:</span>
              <span className="capitalize">
                {integration.sync_config.sync_direction.replace('_', ' ')}
              </span>
            </div>
            <div className="flex justify-between">
              <span className="text-muted-foreground">Last Sync:</span>
              <span>
                {integration.last_sync_at 
                  ? new Date(integration.last_sync_at).toLocaleString()
                  : 'Never'
                }
              </span>
            </div>
          </div>

          {/* Error Alert */}
          {integration.connection_status === 'error' && integration.sync_error_details && (
            <Alert variant="destructive">
              <AlertCircle className="h-4 w-4" />
              <AlertTitle>Sync Error</AlertTitle>
              <AlertDescription>
                {integration.sync_error_details.message || 'Unknown error occurred'}
              </AlertDescription>
            </Alert>
          )}

          {/* Action Buttons */}
          <div className="flex space-x-2">
            <Button 
              size="sm" 
              variant="outline" 
              onClick={() => onSync(integration.id, 'incremental_sync')}
              disabled={integration.connection_status !== 'connected'}
            >
              <RefreshCw className="w-3 h-3 mr-2" />
              Sync Now
            </Button>
            
            <Button 
              size="sm" 
              variant="outline"
              onClick={() => setShowSyncLogs(true)}
            >
              <Eye className="w-3 h-3 mr-2" />
              View Logs
            </Button>
            
            <Button 
              size="sm" 
              variant="ghost"
              onClick={onDelete}
              className="text-destructive hover:text-destructive"
            >
              <Trash2 className="w-3 h-3" />
            </Button>
          </div>
        </div>
      </CardContent>
    </Card>
  );
};
```

#### Backend Service Implementation

```typescript
// CRM Integration Service
import { createClient } from '@supabase/supabase-js';
import { CRMIntegration, CRMSyncJob, CRMFieldMapping } from '@/types/crm';

export class CRMIntegrationService {
  private supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );

  // Create new CRM integration
  async createIntegration(
    supplierId: string,
    crmProvider: string,
    connectionName: string,
    authConfig: Record<string, any>,
    syncConfig: any
  ): Promise<CRMIntegration> {
    const { data, error } = await this.supabase
      .from('crm_integrations')
      .insert({
        supplier_id: supplierId,
        crm_provider: crmProvider,
        connection_name: connectionName,
        auth_config: authConfig,
        sync_config: syncConfig,
        connection_status: 'pending_auth'
      })
      .select()
      .single();

    if (error) throw error;

    // Test connection immediately
    try {
      await this.testConnection(data.id);
      await this.updateConnectionStatus(data.id, 'connected');
    } catch (testError) {
      await this.updateConnectionStatus(data.id, 'error', { 
        message: 'Failed to establish connection',
        error: testError
      });
    }

    return data;
  }

  // Test CRM connection
  async testConnection(integrationId: string): Promise<boolean> {
    const integration = await this.getIntegration(integrationId);
    if (!integration) throw new Error('Integration not found');

    const provider = this.getCRMProvider(integration.crm_provider);
    
    try {
      const connectionTest = await provider.testConnection(integration.auth_config);
      return connectionTest.success;
    } catch (error) {
      console.error('Connection test failed:', error);
      return false;
    }
  }

  // Trigger sync job
  async triggerSync(
    integrationId: string, 
    jobType: 'full_import' | 'incremental_sync' | 'export_to_crm',
    jobConfig: Record<string, any> = {}
  ): Promise<CRMSyncJob> {
    // Create sync job record
    const { data: syncJob, error } = await this.supabase
      .from('crm_sync_jobs')
      .insert({
        integration_id: integrationId,
        job_type: jobType,
        job_config: jobConfig,
        job_status: 'pending'
      })
      .select()
      .single();

    if (error) throw error;

    // Queue job for processing (using background job system)
    await this.queueSyncJob(syncJob);

    return syncJob;
  }

  // Process sync job (background processing)
  async processSyncJob(syncJobId: string): Promise<void> {
    const { data: syncJob, error } = await this.supabase
      .from('crm_sync_jobs')
      .select('*, crm_integrations(*)')
      .eq('id', syncJobId)
      .single();

    if (error || !syncJob) {
      console.error('Sync job not found:', syncJobId);
      return;
    }

    try {
      // Update job status to running
      await this.updateSyncJobStatus(syncJobId, 'running');

      const integration = syncJob.crm_integrations as CRMIntegration;
      const provider = this.getCRMProvider(integration.crm_provider);

      switch (syncJob.job_type) {
        case 'full_import':
          await this.performFullImport(syncJob, integration, provider);
          break;
        case 'incremental_sync':
          await this.performIncrementalSync(syncJob, integration, provider);
          break;
        case 'export_to_crm':
          await this.performExportToCRM(syncJob, integration, provider);
          break;
        default:
          throw new Error(`Unknown job type: ${syncJob.job_type}`);
      }

      // Mark job as completed
      await this.updateSyncJobStatus(syncJobId, 'completed', {
        completed_at: new Date().toISOString()
      });

      // Update integration last sync time
      await this.supabase
        .from('crm_integrations')
        .update({ 
          last_sync_at: new Date().toISOString(),
          last_sync_status: 'success'
        })
        .eq('id', integration.id);

    } catch (error) {
      console.error('Sync job failed:', error);
      
      await this.updateSyncJobStatus(syncJobId, 'failed', {
        error_details: { 
          message: error.message,
          stack: error.stack
        }
      });

      // Update integration with error status
      await this.supabase
        .from('crm_integrations')
        .update({ 
          last_sync_status: 'failed',
          sync_error_details: { message: error.message }
        })
        .eq('id', integration.id);
    }
  }

  // Perform full import from CRM
  private async performFullImport(
    syncJob: CRMSyncJob,
    integration: CRMIntegration,
    provider: CRMProvider
  ): Promise<void> {
    console.log(`Starting full import for integration ${integration.id}`);

    // Get all clients from CRM
    const crmClients = await provider.getAllClients(
      integration.auth_config,
      integration.sync_config
    );

    let processedCount = 0;
    const totalCount = crmClients.length;

    for (const crmClient of crmClients) {
      try {
        // Stage the client data
        await this.stageClientData(syncJob.id, integration.id, crmClient);

        // Process staged data
        await this.processClientData(
          integration.id,
          crmClient,
          integration.sync_config.field_mappings
        );

        processedCount++;
        
        // Update progress
        await this.updateSyncJobProgress(
          syncJob.id,
          Math.round((processedCount / totalCount) * 100),
          processedCount,
          totalCount
        );

      } catch (error) {
        console.error(`Failed to import client ${crmClient.id}:`, error);
        
        // Log the error
        await this.logSyncAction(
          integration.id,
          syncJob.id,
          'client',
          crmClient.id,
          null,
          'error',
          { error_message: error.message },
          error.message
        );
      }

      // Rate limiting - respect CRM API limits
      await this.rateLimitDelay(provider.rate_limits.requests_per_minute);
    }
  }

  // Process individual client data
  private async processClientData(
    integrationId: string,
    crmClient: any,
    fieldMappings: CRMFieldMapping[]
  ): Promise<string | null> {
    // Map CRM fields to WedSync fields
    const mappedData = this.mapClientFields(crmClient, fieldMappings);

    // Check for existing client
    const { data: existingClient, error: checkError } = await this.supabase
      .from('clients')
      .select('id')
      .eq('crm_integration_id', integrationId)
      .eq('external_crm_id', crmClient.id)
      .single();

    if (checkError && checkError.code !== 'PGRST116') {
      throw checkError;
    }

    if (existingClient) {
      // Update existing client
      const { data: updatedClient, error: updateError } = await this.supabase
        .from('clients')
        .update({
          ...mappedData,
          last_crm_sync_at: new Date().toISOString()
        })
        .eq('id', existingClient.id)
        .select()
        .single();

      if (updateError) throw updateError;

      await this.logSyncAction(
        integrationId,
        null,
        'client',
        crmClient.id,
        updatedClient.id,
        'updated',
        { mapped_data: mappedData }
      );

      return updatedClient.id;
    } else {
      // Create new client
      const { data: newClient, error: insertError } = await this.supabase
        .from('clients')
        .insert({
          ...mappedData,
          crm_integration_id: integrationId,
          external_crm_id: crmClient.id,
          last_crm_sync_at: new Date().toISOString()
        })
        .select()
        .single();

      if (insertError) throw insertError;

      await this.logSyncAction(
        integrationId,
        null,
        'client',
        crmClient.id,
        newClient.id,
        'created',
        { mapped_data: mappedData }
      );

      return newClient.id;
    }
  }

  // Map CRM fields to WedSync fields using field mappings
  private mapClientFields(
    crmClient: any,
    fieldMappings: CRMFieldMapping[]
  ): Record<string, any> {
    const mappedData: Record<string, any> = {};

    for (const mapping of fieldMappings) {
      if (mapping.sync_direction === 'export_only') continue;

      try {
        // Get value from CRM data using field path
        const crmValue = this.getNestedValue(crmClient, mapping.crm_field);
        
        if (crmValue !== undefined && crmValue !== null) {
          // Apply field transformations
          const transformedValue = this.transformFieldValue(
            crmValue,
            mapping.field_type,
            mapping.transform_rules
          );

          mappedData[mapping.wedsync_field] = transformedValue;
        }
      } catch (error) {
        console.error(`Field mapping error for ${mapping.crm_field}:`, error);
      }
    }

    return mappedData;
  }

  // Transform field value based on type and rules
  private transformFieldValue(
    value: any,
    fieldType: string,
    transformRules: Record<string, any>
  ): any {
    switch (fieldType) {
      case 'date':
        return new Date(value).toISOString();
      
      case 'phone':
        // Normalize phone number format
        return value.replace(/[^\d+]/g, '');
      
      case 'email':
        return value.toLowerCase().trim();
      
      case 'boolean':
        return Boolean(value);
      
      case 'number':
        return Number(value);
      
      case 'json':
        return typeof value === 'string' ? JSON.parse(value) : value;
      
      case 'array':
        return Array.isArray(value) ? value : [value];
      
      default:
        return String(value).trim();
    }
  }

  // Get nested value from object using dot notation path
  private getNestedValue(obj: any, path: string): any {
    return path.split('.').reduce((current, key) => {
      return current && current[key] !== undefined ? current[key] : undefined;
    }, obj);
  }

  // Get CRM provider implementation
  private getCRMProvider(providerName: string): CRMProvider {
    switch (providerName) {
      case 'tave':
        return new TaveCRMProvider();
      case 'lightblue':
        return new LightBlueCRMProvider();
      case 'honeybook':
        return new HoneyBookCRMProvider();
      default:
        throw new Error(`Unsupported CRM provider: ${providerName}`);
    }
  }

  // Utility methods
  private async updateSyncJobStatus(
    syncJobId: string, 
    status: string, 
    updates: Record<string, any> = {}
  ): Promise<void> {
    await this.supabase
      .from('crm_sync_jobs')
      .update({ job_status: status, ...updates })
      .eq('id', syncJobId);
  }

  private async updateSyncJobProgress(
    syncJobId: string,
    progressPercent: number,
    recordsProcessed: number,
    recordsTotal?: number
  ): Promise<void> {
    await this.supabase
      .from('crm_sync_jobs')
      .update({
        progress_percent: progressPercent,
        records_processed: recordsProcessed,
        records_total: recordsTotal
      })
      .eq('id', syncJobId);
  }

  private async logSyncAction(
    integrationId: string,
    syncJobId: string | null,
    recordType: string,
    recordId: string,
    wedsyncRecordId: string | null,
    actionType: string,
    actionDetails: Record<string, any>,
    errorMessage?: string
  ): Promise<void> {
    await this.supabase
      .from('crm_sync_logs')
      .insert({
        integration_id: integrationId,
        sync_job_id: syncJobId,
        record_type: recordType,
        record_id: recordId,
        wedsync_record_id: wedsyncRecordId,
        action_type: actionType,
        action_details: actionDetails,
        error_message: errorMessage
      });
  }

  private async rateLimitDelay(requestsPerMinute: number): Promise<void> {
    const delayMs = (60 * 1000) / requestsPerMinute;
    await new Promise(resolve => setTimeout(resolve, delayMs));
  }

  private async queueSyncJob(syncJob: CRMSyncJob): Promise<void> {
    // Queue job for background processing
    // This would integrate with your job queue system (Bull, Agenda, etc.)
    setTimeout(() => {
      this.processSyncJob(syncJob.id);
    }, 1000);
  }
}
```

#### CRM Provider Implementations

```typescript
// Tave CRM Provider Implementation
export class TaveCRMProvider implements CRMProvider {
  public readonly id = 'tave';
  public readonly name = 'Tave';
  public readonly auth_type = 'api_key';
  public readonly rate_limits = {
    requests_per_minute: 60,
    requests_per_hour: 1000
  };

  async testConnection(authConfig: Record<string, any>): Promise<{ success: boolean; error?: string }> {
    try {
      const response = await fetch('https://tave.com/api/v1/studios', {
        headers: {
          'Authorization': `Bearer ${authConfig.api_key}`,
          'Content-Type': 'application/json'
        }
      });

      if (response.ok) {
        return { success: true };
      } else {
        return { success: false, error: `HTTP ${response.status}` };
      }
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  async getAllClients(authConfig: Record<string, any>, syncConfig: any): Promise<any[]> {
    const clients: any[] = [];
    let page = 1;
    let hasMore = true;

    while (hasMore) {
      try {
        const response = await fetch(`https://tave.com/api/v1/clients?page=${page}&limit=100`, {
          headers: {
            'Authorization': `Bearer ${authConfig.api_key}`,
            'Content-Type': 'application/json'
          }
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const data = await response.json();
        clients.push(...data.clients);

        hasMore = data.clients.length === 100;
        page++;

      } catch (error) {
        console.error('Error fetching Tave clients:', error);
        break;
      }

      // Rate limiting
      await new Promise(resolve => setTimeout(resolve, 1000));
    }

    return clients;
  }

  async createClient(authConfig: Record<string, any>, clientData: any): Promise<string> {
    const response = await fetch('https://tave.com/api/v1/clients', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${authConfig.api_key}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(clientData)
    });

    if (!response.ok) {
      throw new Error(`Failed to create Tave client: ${response.status}`);
    }

    const created = await response.json();
    return created.id;
  }

  async updateClient(authConfig: Record<string, any>, clientId: string, clientData: any): Promise<void> {
    const response = await fetch(`https://tave.com/api/v1/clients/${clientId}`, {
      method: 'PUT',
      headers: {
        'Authorization': `Bearer ${authConfig.api_key}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(clientData)
    });

    if (!response.ok) {
      throw new Error(`Failed to update Tave client: ${response.status}`);
    }
  }

  getDefaultFieldMappings(): CRMFieldMapping[] {
    return [
      {
        wedsync_field: 'first_name',
        crm_field: 'primary_contact.first_name',
        field_type: 'text',
        sync_direction: 'bidirectional',
        is_required: true,
        transform_rules: {}
      },
      {
        wedsync_field: 'last_name',
        crm_field: 'primary_contact.last_name',
        field_type: 'text',
        sync_direction: 'bidirectional',
        is_required: true,
        transform_rules: {}
      },
      {
        wedsync_field: 'email',
        crm_field: 'primary_contact.email',
        field_type: 'email',
        sync_direction: 'bidirectional',
        is_required: true,
        transform_rules: {}
      },
      {
        wedsync_field: 'phone',
        crm_field: 'primary_contact.phone',
        field_type: 'phone',
        sync_direction: 'bidirectional',
        is_required: false,
        transform_rules: {}
      },
      {
        wedsync_field: 'wedding_date',
        crm_field: 'jobs.0.event_date',
        field_type: 'date',
        sync_direction: 'bidirectional',
        is_required: false,
        transform_rules: {}
      },
      {
        wedsync_field: 'venue_name',
        crm_field: 'jobs.0.venue_name',
        field_type: 'text',
        sync_direction: 'bidirectional',
        is_required: false,
        transform_rules: {}
      }
    ];
  }
}

// Light Blue CRM Provider (Screen scraping approach)
export class LightBlueCRMProvider implements CRMProvider {
  public readonly id = 'lightblue';
  public readonly name = 'Light Blue';
  public readonly auth_type = 'basic_auth';
  public readonly rate_limits = {
    requests_per_minute: 30, // Lower due to scraping
    requests_per_hour: 500
  };

  async testConnection(authConfig: Record<string, any>): Promise<{ success: boolean; error?: string }> {
    try {
      // Use headless browser to test login
      const browser = await this.initBrowser();
      const page = await browser.newPage();
      
      await page.goto('https://app.lightblue.com/login');
      await page.fill('input[name="email"]', authConfig.username);
      await page.fill('input[name="password"]', authConfig.password);
      await page.click('button[type="submit"]');
      
      await page.waitForURL('**/dashboard', { timeout: 10000 });
      
      await browser.close();
      return { success: true };
      
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  async getAllClients(authConfig: Record<string, any>, syncConfig: any): Promise<any[]> {
    const browser = await this.initBrowser();
    const page = await browser.newPage();
    
    try {
      // Login
      await this.login(page, authConfig);
      
      // Navigate to clients page
      await page.goto('https://app.lightblue.com/clients');
      
      // Extract client data through DOM manipulation
      const clients = await page.evaluate(() => {
        const clientRows = document.querySelectorAll('.client-row');
        return Array.from(clientRows).map(row => ({
          id: row.getAttribute('data-client-id'),
          name: row.querySelector('.client-name')?.textContent,
          email: row.querySelector('.client-email')?.textContent,
          phone: row.querySelector('.client-phone')?.textContent,
          wedding_date: row.querySelector('.wedding-date')?.textContent,
          // Extract other fields based on Light Blue's HTML structure
        }));
      });
      
      return clients;
      
    } finally {
      await browser.close();
    }
  }

  private async initBrowser() {
    // Initialize Playwright browser for scraping
    const { chromium } = require('playwright');
    return await chromium.launch({ headless: true });
  }

  private async login(page: any, authConfig: Record<string, any>) {
    await page.goto('https://app.lightblue.com/login');
    await page.fill('input[name="email"]', authConfig.username);
    await page.fill('input[name="password"]', authConfig.password);
    await page.click('button[type="submit"]');
    await page.waitForURL('**/dashboard');
  }

  getDefaultFieldMappings(): CRMFieldMapping[] {
    return [
      {
        wedsync_field: 'first_name',
        crm_field: 'client_first_name',
        field_type: 'text',
        sync_direction: 'import_only', // Light Blue is read-only via scraping
        is_required: true,
        transform_rules: {}
      },
      // ... other mappings
    ];
  }
}
```

### ACCEPTANCE CRITERIA

**Core Functionality:**
- [ ] Support for 9+ major CRM systems (Tave, Light Blue, HoneyBook, Seventeen, ShootQ, Pixieset, Iris Works, Dubsado, Studio Ninja)
- [ ] OAuth2 authentication flow for supported providers
- [ ] API key authentication for providers without OAuth
- [ ] Screen scraping capability for providers without APIs (Light Blue)
- [ ] Bidirectional data synchronization
- [ ] Flexible field mapping system with custom transformations
- [ ] Real-time sync status monitoring with progress indicators
- [ ] Comprehensive error handling and recovery
- [ ] Rate limiting compliance for all CRM APIs
- [ ] Conflict resolution strategies (newest wins, manual review, etc.)

**Data Integration:**
- [ ] Import all historical client data (contacts, projects, invoices, events)
- [ ] Automatic duplicate detection and merging
- [ ] Preserve data relationships between clients, projects, and events
- [ ] Support for custom fields from CRM systems
- [ ] Data validation and sanitization before import
- [ ] Backup creation before major sync operations
- [ ] Rollback capability for failed syncs

**User Experience:**
- [ ] Intuitive integration setup wizard
- [ ] Visual field mapping interface with drag-and-drop
- [ ] Real-time sync progress with detailed logs
- [ ] Integration health monitoring dashboard
- [ ] One-click sync triggers and scheduling
- [ ] Comprehensive sync history and audit trails
- [ ] Mobile-responsive integration management

**Business Logic:**
- [ ] Tier-based integration limits (FREE: 0, STARTER: 1, PROFESSIONAL: 3, SCALE: 5, ENTERPRISE: unlimited)
- [ ] Integration usage analytics and reporting
- [ ] Cost tracking for API usage and rate limits
- [ ] Performance metrics and optimization recommendations
- [ ] Viral growth tracking (imported clients becoming users)

**Security & Compliance:**
- [ ] Secure credential storage with encryption
- [ ] OAuth token refresh handling
- [ ] GDPR compliance for data processing
- [ ] Audit logging for all sync operations
- [ ] Data retention policies for sync logs
- [ ] Permission-based access to integrations

**Testing & Quality:**
- [ ] Comprehensive test coverage >90%
- [ ] Integration testing with CRM provider sandboxes
- [ ] Load testing for high-volume imports (1000+ clients)
- [ ] Error scenario testing (network failures, API changes)
- [ ] Mobile responsiveness testing
- [ ] Performance testing (sync 500 clients <5 minutes)

### DEPENDENCIES & INTEGRATION

**Must Complete After:**
- WS-305: Authentication System (OAuth flows)
- WS-306: Client Management System (data structure)
- WS-342: Advanced Form Builder (form creation from imports)

**Must Complete Before:**
- WS-350: Email Marketing System (client import for campaigns)
- WS-355: Analytics Dashboard (integration metrics)
- Production launch (critical for onboarding)

**Shares Code With:**
- Authentication system (OAuth handling)
- Client management (data models and APIs)
- Form system (auto-generation from CRM data)
- Email system (imported client notifications)

### ESTIMATED EFFORT
- **Frontend Development:** 40 hours
  - Integration dashboard and setup wizards
  - Field mapping interface
  - Sync monitoring and logs UI
  - Mobile responsive design

- **Backend Development:** 50 hours
  - CRM provider API integrations
  - Sync job processing system
  - Field mapping engine
  - Error handling and recovery

- **Database & Infrastructure:** 20 hours
  - Schema design and migration
  - Sync job queuing system
  - Performance optimization
  - Data backup and recovery

- **Testing & QA:** 10 hours
  - Unit and integration tests
  - CRM provider sandbox testing
  - Performance and security testing
  - Mobile testing

**Total Estimated Effort:** 120 hours

### TECHNICAL NOTES

**CRM Provider Priorities:**
1. **Tave** - REST API v2, 25% of photographers, excellent documentation
2. **Light Blue** - No API, requires web scraping, 20% of photographers
3. **HoneyBook** - OAuth2 + REST API, 15% of photographers, complex auth
4. **Seventeen** - REST API, 10% of photographers
5. **Others** - Various APIs and capabilities

**Performance Considerations:**
- Implement background job processing for large imports
- Use database staging tables for import validation
- Implement exponential backoff for API rate limits
- Cache frequently accessed CRM provider metadata
- Optimize field mapping transformations

**Security Best Practices:**
- Encrypt all stored credentials using AES-256
- Implement OAuth PKCE flow for enhanced security
- Use secure HTTP-only cookies for session management
- Regular credential rotation for API keys
- Comprehensive audit logging for compliance

This CRM Integration Hub will be the cornerstone feature that removes the biggest barrier to WedSync adoption - data migration fears. By making it effortless for vendors to import their existing client base, we enable rapid onboarding and viral growth through the imported client networks.