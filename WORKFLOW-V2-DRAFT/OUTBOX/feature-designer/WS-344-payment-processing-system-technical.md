# TECHNICAL SPECIFICATION: WS-344 - Payment Processing System
## Generated by Feature Development Session - 2025-01-31

### USER STORY & BUSINESS CONTEXT
**As a:** Wedding supplier using WedSync for client management
**I want to:** Collect payments from clients seamlessly through forms, invoices, and automated payment plans
**So that:** I can reduce payment friction, improve cash flow, and automate the entire payment collection process while maintaining professional financial records

**Real Wedding Scenario:**
Emma, a wedding photographer, sends a booking form to potential clients. When they submit the form, they're immediately redirected to pay the Â£500 booking fee through Stripe. The system automatically creates an invoice, sends confirmation emails, updates the client status to "booked," and sets up the remaining payment schedule (50% due 6 weeks before wedding, final 25% due week of wedding). All payments are automatically processed and recorded.

**Business Impact:**
- Reduces payment collection time from weeks to minutes
- Increases conversion rates by 40% (immediate payment vs delayed invoicing)
- Eliminates manual invoicing and follow-up work
- Provides professional payment experience that builds trust
- Generates immediate revenue recognition and cash flow
- Critical for PROFESSIONAL tier revenue ($49/month subscribers)

### SPECIFICATION SOURCE
- **Feature ID:** WS-344
- **Priority Level:** HIGH PRIORITY (Revenue Generation)
- **Estimated Effort:** 100 hours total
- **Dependencies:** Form Builder, Client Management, Stripe Integration
- **Revenue Impact:** Direct impact on supplier revenue and WedSync commission earnings

### TECHNICAL DESIGN

#### Database Schema Required

```sql
-- Payment Methods Configuration
CREATE TABLE payment_methods (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    method_name TEXT NOT NULL, -- 'Stripe', 'PayPal', 'Bank Transfer', 'Cash', 'Check'
    method_type TEXT NOT NULL CHECK (method_type IN (
        'stripe', 'paypal', 'bank_transfer', 'cash', 'check', 'custom'
    )),
    is_enabled BOOLEAN DEFAULT true,
    method_config JSONB DEFAULT '{}', -- API keys, account IDs, etc.
    processing_fees JSONB DEFAULT '{}', -- Fee structure
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(supplier_id, method_type)
);

-- Payment Items (services, products, packages)
CREATE TABLE payment_items (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    item_name TEXT NOT NULL,
    item_description TEXT,
    item_category TEXT, -- 'photography', 'venue', 'catering', 'flowers', etc.
    base_price DECIMAL(10,2) NOT NULL CHECK (base_price >= 0),
    price_currency TEXT NOT NULL DEFAULT 'GBP',
    is_taxable BOOLEAN DEFAULT false,
    tax_rate DECIMAL(5,4) DEFAULT 0.20, -- UK VAT 20%
    item_type TEXT NOT NULL CHECK (item_type IN (
        'service', 'product', 'package', 'deposit', 'fee', 'discount'
    )),
    billing_frequency TEXT CHECK (billing_frequency IN (
        'one_time', 'weekly', 'monthly', 'quarterly', 'yearly'
    )) DEFAULT 'one_time',
    requires_customization BOOLEAN DEFAULT false, -- Can price be customized per client
    minimum_price DECIMAL(10,2),
    maximum_price DECIMAL(10,2),
    is_active BOOLEAN DEFAULT true,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Payment Plans (installment configurations)
CREATE TABLE payment_plans (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    plan_name TEXT NOT NULL,
    plan_description TEXT,
    total_amount DECIMAL(10,2) NOT NULL CHECK (total_amount > 0),
    currency TEXT NOT NULL DEFAULT 'GBP',
    installment_count INTEGER NOT NULL CHECK (installment_count > 0),
    installment_frequency TEXT NOT NULL CHECK (installment_frequency IN (
        'weekly', 'biweekly', 'monthly', 'quarterly', 'custom'
    )),
    first_payment_amount DECIMAL(10,2),
    first_payment_due_offset INTEGER DEFAULT 0, -- Days from plan start
    auto_collect BOOLEAN DEFAULT true,
    late_fee_amount DECIMAL(10,2) DEFAULT 0,
    late_fee_grace_days INTEGER DEFAULT 7,
    plan_status TEXT NOT NULL CHECK (plan_status IN (
        'draft', 'active', 'paused', 'completed', 'cancelled'
    )) DEFAULT 'draft',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Payment Plan Installments Template
CREATE TABLE payment_plan_installments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    payment_plan_id UUID NOT NULL REFERENCES payment_plans(id) ON DELETE CASCADE,
    installment_number INTEGER NOT NULL,
    installment_amount DECIMAL(10,2) NOT NULL CHECK (installment_amount > 0),
    due_offset_days INTEGER NOT NULL, -- Days from plan start date
    installment_description TEXT,
    is_required BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(payment_plan_id, installment_number)
);

-- Client Payment Plans (active instances)
CREATE TABLE client_payment_plans (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    client_id UUID NOT NULL REFERENCES clients(id) ON DELETE CASCADE,
    payment_plan_id UUID NOT NULL REFERENCES payment_plans(id),
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    plan_start_date DATE NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL DEFAULT 'GBP',
    payment_method_id UUID REFERENCES payment_methods(id),
    auto_collect BOOLEAN DEFAULT true,
    plan_status TEXT NOT NULL CHECK (plan_status IN (
        'active', 'paused', 'completed', 'cancelled', 'overdue'
    )) DEFAULT 'active',
    amount_paid DECIMAL(10,2) DEFAULT 0,
    amount_remaining DECIMAL(10,2) NOT NULL,
    last_payment_date TIMESTAMPTZ,
    next_payment_date DATE,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Individual Payment Records
CREATE TABLE payments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    client_id UUID NOT NULL REFERENCES clients(id) ON DELETE CASCADE,
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    client_payment_plan_id UUID REFERENCES client_payment_plans(id),
    payment_method_id UUID NOT NULL REFERENCES payment_methods(id),
    
    -- Payment Details
    payment_type TEXT NOT NULL CHECK (payment_type IN (
        'one_time', 'installment', 'deposit', 'refund', 'late_fee'
    )),
    payment_amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL DEFAULT 'GBP',
    payment_status TEXT NOT NULL CHECK (payment_status IN (
        'pending', 'processing', 'completed', 'failed', 'cancelled', 'refunded'
    )) DEFAULT 'pending',
    
    -- External Payment Provider Info
    external_payment_id TEXT, -- Stripe payment intent ID, PayPal transaction ID, etc.
    external_charge_id TEXT, -- Stripe charge ID
    external_customer_id TEXT, -- Stripe customer ID
    
    -- Payment Metadata
    payment_description TEXT,
    payment_reference TEXT, -- Invoice number, booking reference, etc.
    payment_notes TEXT,
    
    -- Fees and Processing
    processing_fee_amount DECIMAL(10,2) DEFAULT 0,
    application_fee_amount DECIMAL(10,2) DEFAULT 0, -- WedSync commission
    net_amount DECIMAL(10,2), -- Amount after fees
    
    -- Timestamps
    payment_date TIMESTAMPTZ,
    due_date DATE,
    processed_at TIMESTAMPTZ,
    failed_at TIMESTAMPTZ,
    failure_reason TEXT,
    
    -- Refund Information
    refunded_amount DECIMAL(10,2) DEFAULT 0,
    refund_reason TEXT,
    refunded_at TIMESTAMPTZ,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    INDEX (client_id, payment_status),
    INDEX (supplier_id, payment_date),
    INDEX (external_payment_id),
    INDEX (payment_status, due_date)
);

-- Payment Attempts (for failed payment retry logic)
CREATE TABLE payment_attempts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    payment_id UUID NOT NULL REFERENCES payments(id) ON DELETE CASCADE,
    attempt_number INTEGER NOT NULL,
    attempted_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    attempt_status TEXT NOT NULL CHECK (attempt_status IN (
        'processing', 'succeeded', 'failed', 'requires_action'
    )),
    external_attempt_id TEXT,
    failure_code TEXT,
    failure_message TEXT,
    gateway_response JSONB DEFAULT '{}',
    next_retry_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(payment_id, attempt_number)
);

-- Invoices (formal payment requests)
CREATE TABLE invoices (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    client_id UUID NOT NULL REFERENCES clients(id) ON DELETE CASCADE,
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    
    -- Invoice Details
    invoice_number TEXT NOT NULL, -- Auto-generated: INV-2025-001
    invoice_date DATE NOT NULL DEFAULT CURRENT_DATE,
    due_date DATE NOT NULL,
    
    -- Amounts
    subtotal_amount DECIMAL(10,2) NOT NULL DEFAULT 0,
    tax_amount DECIMAL(10,2) NOT NULL DEFAULT 0,
    discount_amount DECIMAL(10,2) NOT NULL DEFAULT 0,
    total_amount DECIMAL(10,2) NOT NULL DEFAULT 0,
    currency TEXT NOT NULL DEFAULT 'GBP',
    
    -- Status and Metadata
    invoice_status TEXT NOT NULL CHECK (invoice_status IN (
        'draft', 'sent', 'viewed', 'paid', 'overdue', 'cancelled', 'refunded'
    )) DEFAULT 'draft',
    payment_terms TEXT, -- 'Net 30', 'Due on receipt', etc.
    invoice_notes TEXT,
    footer_text TEXT,
    
    -- Payment Tracking
    amount_paid DECIMAL(10,2) DEFAULT 0,
    amount_remaining DECIMAL(10,2),
    last_payment_date TIMESTAMPTZ,
    paid_at TIMESTAMPTZ,
    
    -- Email Tracking
    sent_at TIMESTAMPTZ,
    viewed_at TIMESTAMPTZ,
    last_reminded_at TIMESTAMPTZ,
    reminder_count INTEGER DEFAULT 0,
    
    -- External References
    stripe_invoice_id TEXT,
    public_url TEXT, -- Shareable payment link
    pdf_url TEXT, -- Invoice PDF
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(supplier_id, invoice_number),
    INDEX (client_id, invoice_status),
    INDEX (supplier_id, invoice_date),
    INDEX (invoice_status, due_date)
);

-- Invoice Line Items
CREATE TABLE invoice_line_items (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    invoice_id UUID NOT NULL REFERENCES invoices(id) ON DELETE CASCADE,
    payment_item_id UUID REFERENCES payment_items(id),
    
    -- Line Item Details
    item_name TEXT NOT NULL,
    item_description TEXT,
    quantity DECIMAL(10,3) NOT NULL DEFAULT 1,
    unit_price DECIMAL(10,2) NOT NULL,
    line_total DECIMAL(10,2) NOT NULL,
    
    -- Tax Information
    is_taxable BOOLEAN DEFAULT false,
    tax_rate DECIMAL(5,4) DEFAULT 0,
    tax_amount DECIMAL(10,2) DEFAULT 0,
    
    -- Metadata
    line_metadata JSONB DEFAULT '{}',
    sort_order INTEGER DEFAULT 0,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Payment Links (shareable payment URLs)
CREATE TABLE payment_links (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    client_id UUID REFERENCES clients(id) ON DELETE CASCADE,
    invoice_id UUID REFERENCES invoices(id) ON DELETE CASCADE,
    
    -- Link Configuration
    link_name TEXT NOT NULL,
    link_description TEXT,
    amount DECIMAL(10,2) NOT NULL CHECK (amount > 0),
    currency TEXT NOT NULL DEFAULT 'GBP',
    is_amount_flexible BOOLEAN DEFAULT false,
    minimum_amount DECIMAL(10,2),
    maximum_amount DECIMAL(10,2),
    
    -- Link Properties
    public_url TEXT NOT NULL UNIQUE,
    is_active BOOLEAN DEFAULT true,
    expires_at TIMESTAMPTZ,
    max_uses INTEGER, -- NULL = unlimited
    current_uses INTEGER DEFAULT 0,
    
    -- Collection Settings
    collect_customer_details BOOLEAN DEFAULT true,
    collect_shipping_address BOOLEAN DEFAULT false,
    collect_billing_address BOOLEAN DEFAULT true,
    allow_coupon_codes BOOLEAN DEFAULT false,
    
    -- Metadata and Customization
    success_url TEXT,
    cancel_url TEXT,
    custom_message TEXT,
    custom_fields JSONB DEFAULT '[]',
    metadata JSONB DEFAULT '{}',
    
    -- Tracking
    total_collected DECIMAL(10,2) DEFAULT 0,
    last_payment_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    INDEX (supplier_id, is_active),
    INDEX (public_url),
    INDEX (expires_at, is_active)
);

-- Payment Webhooks (for external payment provider notifications)
CREATE TABLE payment_webhooks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    payment_id UUID REFERENCES payments(id),
    invoice_id UUID REFERENCES invoices(id),
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    
    -- Webhook Details
    webhook_provider TEXT NOT NULL, -- 'stripe', 'paypal', etc.
    webhook_event_type TEXT NOT NULL,
    webhook_event_id TEXT NOT NULL,
    external_object_id TEXT NOT NULL, -- Payment intent ID, subscription ID, etc.
    
    -- Processing Status
    webhook_status TEXT NOT NULL CHECK (webhook_status IN (
        'received', 'processing', 'processed', 'failed', 'ignored'
    )) DEFAULT 'received',
    processed_at TIMESTAMPTZ,
    failure_reason TEXT,
    retry_count INTEGER DEFAULT 0,
    
    -- Webhook Data
    webhook_payload JSONB NOT NULL,
    processing_log JSONB DEFAULT '[]',
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(webhook_provider, webhook_event_id),
    INDEX (external_object_id, webhook_provider),
    INDEX (webhook_status, created_at)
);

-- Payment Settings (per supplier configuration)
CREATE TABLE payment_settings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    
    -- Default Configuration
    default_currency TEXT NOT NULL DEFAULT 'GBP',
    default_payment_terms TEXT DEFAULT 'Due on receipt',
    auto_send_invoices BOOLEAN DEFAULT true,
    auto_send_reminders BOOLEAN DEFAULT true,
    reminder_schedule INTEGER[] DEFAULT '{1, 3, 7}', -- Days before due date
    late_fee_enabled BOOLEAN DEFAULT false,
    late_fee_type TEXT CHECK (late_fee_type IN ('fixed', 'percentage')) DEFAULT 'fixed',
    late_fee_amount DECIMAL(10,2) DEFAULT 0,
    
    -- Invoice Customization
    invoice_logo_url TEXT,
    invoice_color_scheme TEXT DEFAULT '#3b82f6',
    invoice_footer_text TEXT,
    invoice_terms_text TEXT,
    
    -- Email Templates
    invoice_email_subject TEXT DEFAULT 'Invoice #{invoice_number} from {supplier_name}',
    invoice_email_body TEXT DEFAULT 'Hi {client_name}, please find your invoice attached.',
    payment_confirmation_subject TEXT DEFAULT 'Payment Received - Thank you!',
    payment_confirmation_body TEXT DEFAULT 'Thank you for your payment of {amount}.',
    
    -- Stripe Integration
    stripe_account_id TEXT,
    stripe_webhook_secret TEXT,
    stripe_application_fee_percent DECIMAL(5,4) DEFAULT 2.9, -- WedSync commission %
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(supplier_id)
);

-- Add payment-related fields to forms table (extend existing table)
ALTER TABLE forms ADD COLUMN IF NOT EXISTS enable_payments BOOLEAN DEFAULT false;
ALTER TABLE forms ADD COLUMN IF NOT EXISTS payment_amount DECIMAL(10,2);
ALTER TABLE forms ADD COLUMN IF NOT EXISTS payment_currency TEXT DEFAULT 'GBP';
ALTER TABLE forms ADD COLUMN IF NOT EXISTS payment_description TEXT;
ALTER TABLE forms ADD COLUMN IF NOT EXISTS redirect_after_payment TEXT;
ALTER TABLE forms ADD COLUMN IF NOT EXISTS payment_methods TEXT[] DEFAULT '{}'; -- Available payment methods

-- Add payment tracking to form submissions
ALTER TABLE form_submissions ADD COLUMN IF NOT EXISTS payment_id UUID REFERENCES payments(id);
ALTER TABLE form_submissions ADD COLUMN IF NOT EXISTS payment_status TEXT DEFAULT 'not_required' CHECK (payment_status IN ('not_required', 'pending', 'completed', 'failed'));
ALTER TABLE form_submissions ADD COLUMN IF NOT EXISTS payment_amount DECIMAL(10,2);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_payments_client_supplier ON payments(client_id, supplier_id);
CREATE INDEX IF NOT EXISTS idx_payments_status_date ON payments(payment_status, due_date);
CREATE INDEX IF NOT EXISTS idx_invoices_client_status ON invoices(client_id, invoice_status);
CREATE INDEX IF NOT EXISTS idx_payment_plans_client_status ON client_payment_plans(client_id, plan_status);
CREATE INDEX IF NOT EXISTS idx_payment_webhooks_status ON payment_webhooks(webhook_status, created_at);
```

#### API Endpoints Required

```typescript
// Payment Types
interface PaymentMethod {
  id: string;
  supplier_id: string;
  method_name: string;
  method_type: 'stripe' | 'paypal' | 'bank_transfer' | 'cash' | 'check' | 'custom';
  is_enabled: boolean;
  method_config: Record<string, any>;
  processing_fees: PaymentFees;
  created_at: string;
  updated_at: string;
}

interface PaymentFees {
  fixed_fee: number; // Fixed fee per transaction
  percentage_fee: number; // Percentage fee (e.g., 2.9%)
  currency: string;
}

interface PaymentItem {
  id: string;
  supplier_id: string;
  item_name: string;
  item_description?: string;
  item_category?: string;
  base_price: number;
  price_currency: string;
  is_taxable: boolean;
  tax_rate: number;
  item_type: 'service' | 'product' | 'package' | 'deposit' | 'fee' | 'discount';
  billing_frequency: 'one_time' | 'weekly' | 'monthly' | 'quarterly' | 'yearly';
  requires_customization: boolean;
  minimum_price?: number;
  maximum_price?: number;
  is_active: boolean;
  metadata: Record<string, any>;
  created_at: string;
  updated_at: string;
}

interface Payment {
  id: string;
  client_id: string;
  supplier_id: string;
  client_payment_plan_id?: string;
  payment_method_id: string;
  payment_type: 'one_time' | 'installment' | 'deposit' | 'refund' | 'late_fee';
  payment_amount: number;
  currency: string;
  payment_status: 'pending' | 'processing' | 'completed' | 'failed' | 'cancelled' | 'refunded';
  external_payment_id?: string;
  external_charge_id?: string;
  external_customer_id?: string;
  payment_description?: string;
  payment_reference?: string;
  payment_notes?: string;
  processing_fee_amount: number;
  application_fee_amount: number;
  net_amount?: number;
  payment_date?: string;
  due_date?: string;
  processed_at?: string;
  failed_at?: string;
  failure_reason?: string;
  refunded_amount: number;
  refund_reason?: string;
  refunded_at?: string;
  created_at: string;
  updated_at: string;
}

interface Invoice {
  id: string;
  client_id: string;
  supplier_id: string;
  invoice_number: string;
  invoice_date: string;
  due_date: string;
  subtotal_amount: number;
  tax_amount: number;
  discount_amount: number;
  total_amount: number;
  currency: string;
  invoice_status: 'draft' | 'sent' | 'viewed' | 'paid' | 'overdue' | 'cancelled' | 'refunded';
  payment_terms?: string;
  invoice_notes?: string;
  footer_text?: string;
  amount_paid: number;
  amount_remaining?: number;
  last_payment_date?: string;
  paid_at?: string;
  sent_at?: string;
  viewed_at?: string;
  last_reminded_at?: string;
  reminder_count: number;
  stripe_invoice_id?: string;
  public_url?: string;
  pdf_url?: string;
  line_items: InvoiceLineItem[];
  created_at: string;
  updated_at: string;
}

interface InvoiceLineItem {
  id: string;
  invoice_id: string;
  payment_item_id?: string;
  item_name: string;
  item_description?: string;
  quantity: number;
  unit_price: number;
  line_total: number;
  is_taxable: boolean;
  tax_rate: number;
  tax_amount: number;
  line_metadata: Record<string, any>;
  sort_order: number;
  created_at: string;
}

interface PaymentPlan {
  id: string;
  supplier_id: string;
  plan_name: string;
  plan_description?: string;
  total_amount: number;
  currency: string;
  installment_count: number;
  installment_frequency: 'weekly' | 'biweekly' | 'monthly' | 'quarterly' | 'custom';
  first_payment_amount?: number;
  first_payment_due_offset: number;
  auto_collect: boolean;
  late_fee_amount: number;
  late_fee_grace_days: number;
  plan_status: 'draft' | 'active' | 'paused' | 'completed' | 'cancelled';
  installments: PaymentPlanInstallment[];
  created_at: string;
  updated_at: string;
}

interface PaymentPlanInstallment {
  id: string;
  payment_plan_id: string;
  installment_number: number;
  installment_amount: number;
  due_offset_days: number;
  installment_description?: string;
  is_required: boolean;
  created_at: string;
}

interface PaymentLink {
  id: string;
  supplier_id: string;
  client_id?: string;
  invoice_id?: string;
  link_name: string;
  link_description?: string;
  amount: number;
  currency: string;
  is_amount_flexible: boolean;
  minimum_amount?: number;
  maximum_amount?: number;
  public_url: string;
  is_active: boolean;
  expires_at?: string;
  max_uses?: number;
  current_uses: number;
  collect_customer_details: boolean;
  collect_shipping_address: boolean;
  collect_billing_address: boolean;
  allow_coupon_codes: boolean;
  success_url?: string;
  cancel_url?: string;
  custom_message?: string;
  custom_fields: CustomField[];
  metadata: Record<string, any>;
  total_collected: number;
  last_payment_at?: string;
  created_at: string;
  updated_at: string;
}

interface CustomField {
  name: string;
  label: string;
  type: 'text' | 'email' | 'phone' | 'number' | 'select' | 'textarea';
  required: boolean;
  options?: string[]; // For select fields
}

// API Endpoints

// Payment Methods Management
// GET /api/payments/methods - List payment methods
interface GetPaymentMethodsResponse {
  methods: PaymentMethod[];
}

// POST /api/payments/methods - Create payment method
interface CreatePaymentMethodRequest {
  method_name: string;
  method_type: string;
  method_config: Record<string, any>;
  processing_fees: PaymentFees;
}

interface CreatePaymentMethodResponse {
  method: PaymentMethod;
}

// PUT /api/payments/methods/:id - Update payment method
interface UpdatePaymentMethodRequest {
  method_name?: string;
  is_enabled?: boolean;
  method_config?: Record<string, any>;
  processing_fees?: PaymentFees;
}

// Payment Items Management
// GET /api/payments/items - List payment items
interface GetPaymentItemsResponse {
  items: PaymentItem[];
  total: number;
  page: number;
  per_page: number;
}

// POST /api/payments/items - Create payment item
interface CreatePaymentItemRequest {
  item_name: string;
  item_description?: string;
  item_category?: string;
  base_price: number;
  price_currency: string;
  is_taxable: boolean;
  tax_rate?: number;
  item_type: string;
  billing_frequency?: string;
  requires_customization?: boolean;
  minimum_price?: number;
  maximum_price?: number;
  metadata?: Record<string, any>;
}

interface CreatePaymentItemResponse {
  item: PaymentItem;
}

// Payment Processing
// POST /api/payments/create-payment-intent - Create Stripe Payment Intent
interface CreatePaymentIntentRequest {
  client_id: string;
  amount: number;
  currency: string;
  payment_method_types: string[]; // ['card', 'bancontact', 'ideal']
  description?: string;
  metadata?: Record<string, any>;
  automatic_payment_methods?: {
    enabled: boolean;
  };
}

interface CreatePaymentIntentResponse {
  payment_intent_id: string;
  client_secret: string;
  payment_id: string;
  amount: number;
  currency: string;
  status: string;
}

// POST /api/payments/confirm-payment - Confirm payment completion
interface ConfirmPaymentRequest {
  payment_id: string;
  external_payment_id: string;
  payment_method_id?: string;
}

interface ConfirmPaymentResponse {
  payment: Payment;
  success: boolean;
  message: string;
}

// Invoice Management
// GET /api/invoices - List invoices
interface GetInvoicesResponse {
  invoices: Invoice[];
  total: number;
  page: number;
  per_page: number;
}

// POST /api/invoices - Create invoice
interface CreateInvoiceRequest {
  client_id: string;
  due_date: string;
  line_items: Omit<InvoiceLineItem, 'id' | 'invoice_id' | 'created_at'>[];
  payment_terms?: string;
  invoice_notes?: string;
  footer_text?: string;
  auto_send?: boolean;
}

interface CreateInvoiceResponse {
  invoice: Invoice;
  public_url?: string;
  pdf_url?: string;
}

// PUT /api/invoices/:id - Update invoice
interface UpdateInvoiceRequest {
  due_date?: string;
  line_items?: Omit<InvoiceLineItem, 'id' | 'invoice_id' | 'created_at'>[];
  payment_terms?: string;
  invoice_notes?: string;
  footer_text?: string;
}

// POST /api/invoices/:id/send - Send invoice to client
interface SendInvoiceRequest {
  email_subject?: string;
  email_body?: string;
  send_copy_to_supplier?: boolean;
}

interface SendInvoiceResponse {
  success: boolean;
  sent_at: string;
  public_url: string;
  message: string;
}

// Payment Plans
// GET /api/payment-plans - List payment plans
interface GetPaymentPlansResponse {
  payment_plans: PaymentPlan[];
  total: number;
}

// POST /api/payment-plans - Create payment plan
interface CreatePaymentPlanRequest {
  plan_name: string;
  plan_description?: string;
  total_amount: number;
  currency: string;
  installment_frequency: string;
  first_payment_amount?: number;
  first_payment_due_offset?: number;
  auto_collect: boolean;
  late_fee_amount?: number;
  late_fee_grace_days?: number;
  installments: Omit<PaymentPlanInstallment, 'id' | 'payment_plan_id' | 'created_at'>[];
}

interface CreatePaymentPlanResponse {
  payment_plan: PaymentPlan;
}

// POST /api/payment-plans/:id/assign - Assign payment plan to client
interface AssignPaymentPlanRequest {
  client_id: string;
  plan_start_date: string;
  custom_amount?: number;
  payment_method_id?: string;
}

interface AssignPaymentPlanResponse {
  client_payment_plan: ClientPaymentPlan;
  success: boolean;
}

// Payment Links
// POST /api/payment-links - Create payment link
interface CreatePaymentLinkRequest {
  link_name: string;
  link_description?: string;
  amount: number;
  currency: string;
  is_amount_flexible?: boolean;
  minimum_amount?: number;
  maximum_amount?: number;
  expires_at?: string;
  max_uses?: number;
  collect_customer_details?: boolean;
  collect_shipping_address?: boolean;
  collect_billing_address?: boolean;
  allow_coupon_codes?: boolean;
  success_url?: string;
  cancel_url?: string;
  custom_message?: string;
  custom_fields?: CustomField[];
  metadata?: Record<string, any>;
}

interface CreatePaymentLinkResponse {
  payment_link: PaymentLink;
  public_url: string;
}

// GET /api/payment-links/:id/stats - Get payment link statistics
interface PaymentLinkStatsResponse {
  total_payments: number;
  total_collected: number;
  conversion_rate: number;
  recent_payments: Payment[];
  daily_stats: {
    date: string;
    payments: number;
    amount: number;
  }[];
}

// Payment Reports and Analytics
// GET /api/payments/analytics - Payment analytics
interface PaymentAnalyticsResponse {
  total_revenue: number;
  revenue_this_month: number;
  revenue_growth_percent: number;
  pending_payments: number;
  overdue_payments: number;
  total_transactions: number;
  average_transaction_value: number;
  payment_method_breakdown: {
    method: string;
    count: number;
    total_amount: number;
  }[];
  monthly_revenue: {
    month: string;
    revenue: number;
    transactions: number;
  }[];
  client_payment_status: {
    status: string;
    count: number;
    total_amount: number;
  }[];
}

// Webhook Handling
// POST /api/webhooks/stripe - Stripe webhook endpoint
interface StripeWebhookEvent {
  id: string;
  type: string;
  data: {
    object: any;
  };
  created: number;
  livemode: boolean;
  pending_webhooks: number;
  request: {
    id: string;
    idempotency_key: string;
  };
}

// Settings Management
// GET /api/payments/settings - Get payment settings
interface GetPaymentSettingsResponse {
  settings: PaymentSettings;
}

// PUT /api/payments/settings - Update payment settings
interface UpdatePaymentSettingsRequest {
  default_currency?: string;
  default_payment_terms?: string;
  auto_send_invoices?: boolean;
  auto_send_reminders?: boolean;
  reminder_schedule?: number[];
  late_fee_enabled?: boolean;
  late_fee_type?: 'fixed' | 'percentage';
  late_fee_amount?: number;
  invoice_logo_url?: string;
  invoice_color_scheme?: string;
  invoice_footer_text?: string;
  invoice_terms_text?: string;
  invoice_email_subject?: string;
  invoice_email_body?: string;
  payment_confirmation_subject?: string;
  payment_confirmation_body?: string;
}

interface PaymentSettings {
  id: string;
  supplier_id: string;
  default_currency: string;
  default_payment_terms: string;
  auto_send_invoices: boolean;
  auto_send_reminders: boolean;
  reminder_schedule: number[];
  late_fee_enabled: boolean;
  late_fee_type: 'fixed' | 'percentage';
  late_fee_amount: number;
  invoice_logo_url?: string;
  invoice_color_scheme: string;
  invoice_footer_text?: string;
  invoice_terms_text?: string;
  invoice_email_subject: string;
  invoice_email_body: string;
  payment_confirmation_subject: string;
  payment_confirmation_body: string;
  stripe_account_id?: string;
  stripe_webhook_secret?: string;
  stripe_application_fee_percent: number;
  created_at: string;
  updated_at: string;
}

interface ClientPaymentPlan {
  id: string;
  client_id: string;
  payment_plan_id: string;
  supplier_id: string;
  plan_start_date: string;
  total_amount: number;
  currency: string;
  payment_method_id?: string;
  auto_collect: boolean;
  plan_status: 'active' | 'paused' | 'completed' | 'cancelled' | 'overdue';
  amount_paid: number;
  amount_remaining: number;
  last_payment_date?: string;
  next_payment_date?: string;
  metadata: Record<string, any>;
  created_at: string;
  updated_at: string;
}
```

### IMPLEMENTATION DETAILS

#### Frontend Payment Components

```typescript
// Payment Form Component
import React, { useState, useEffect } from 'react';
import { loadStripe } from '@stripe/stripe-js';
import {
  Elements,
  CardElement,
  useStripe,
  useElements
} from '@stripe/react-stripe-js';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { 
  CreditCard, 
  Shield, 
  Check, 
  AlertCircle, 
  Loader2,
  DollarSign,
  Calendar,
  User
} from 'lucide-react';

const stripePromise = loadStripe(process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY!);

interface PaymentFormProps {
  clientId: string;
  amount: number;
  currency: string;
  description: string;
  onSuccess?: (payment: Payment) => void;
  onError?: (error: string) => void;
  metadata?: Record<string, any>;
}

const PaymentForm: React.FC<PaymentFormProps> = ({ 
  clientId, 
  amount, 
  currency, 
  description, 
  onSuccess, 
  onError,
  metadata = {}
}) => {
  return (
    <Elements stripe={stripePromise}>
      <PaymentFormInner
        clientId={clientId}
        amount={amount}
        currency={currency}
        description={description}
        onSuccess={onSuccess}
        onError={onError}
        metadata={metadata}
      />
    </Elements>
  );
};

const PaymentFormInner: React.FC<PaymentFormProps> = ({
  clientId,
  amount,
  currency,
  description,
  onSuccess,
  onError,
  metadata
}) => {
  const stripe = useStripe();
  const elements = useElements();
  const [processing, setProcessing] = useState(false);
  const [paymentError, setPaymentError] = useState<string>('');
  const [clientSecret, setClientSecret] = useState<string>('');
  const [customerInfo, setCustomerInfo] = useState({
    name: '',
    email: '',
    address: {
      line1: '',
      city: '',
      postal_code: '',
      country: 'GB'
    }
  });

  useEffect(() => {
    createPaymentIntent();
  }, [amount, currency]);

  const createPaymentIntent = async () => {
    try {
      const response = await fetch('/api/payments/create-payment-intent', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          client_id: clientId,
          amount: Math.round(amount * 100), // Convert to cents
          currency: currency.toLowerCase(),
          description,
          metadata,
          automatic_payment_methods: { enabled: true }
        })
      });

      const data: CreatePaymentIntentResponse = await response.json();
      if (data.client_secret) {
        setClientSecret(data.client_secret);
      }
    } catch (error) {
      console.error('Failed to create payment intent:', error);
      setPaymentError('Failed to initialize payment. Please try again.');
    }
  };

  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault();
    setPaymentError('');

    if (!stripe || !elements || !clientSecret) {
      return;
    }

    setProcessing(true);

    const cardElement = elements.getElement(CardElement);
    if (!cardElement) {
      setPaymentError('Payment form not loaded properly');
      setProcessing(false);
      return;
    }

    try {
      const { error, paymentIntent } = await stripe.confirmCardPayment(clientSecret, {
        payment_method: {
          card: cardElement,
          billing_details: {
            name: customerInfo.name,
            email: customerInfo.email,
            address: customerInfo.address
          }
        }
      });

      if (error) {
        setPaymentError(error.message || 'Payment failed');
        onError?.(error.message || 'Payment failed');
      } else if (paymentIntent?.status === 'succeeded') {
        // Confirm payment on our backend
        const confirmResponse = await fetch('/api/payments/confirm-payment', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            payment_id: paymentIntent.id,
            external_payment_id: paymentIntent.id
          })
        });

        const confirmData: ConfirmPaymentResponse = await confirmResponse.json();
        if (confirmData.success) {
          onSuccess?.(confirmData.payment);
        }
      }
    } catch (error) {
      console.error('Payment confirmation error:', error);
      setPaymentError('Payment processing failed. Please try again.');
      onError?.('Payment processing failed');
    } finally {
      setProcessing(false);
    }
  };

  const formatAmount = (amount: number, currency: string) => {
    return new Intl.NumberFormat('en-GB', {
      style: 'currency',
      currency: currency.toUpperCase()
    }).format(amount);
  };

  return (
    <div className="max-w-md mx-auto">
      <Card>
        <CardHeader className="text-center">
          <div className="w-16 h-16 bg-primary/10 rounded-full flex items-center justify-center mx-auto mb-4">
            <CreditCard className="w-8 h-8 text-primary" />
          </div>
          <CardTitle className="text-2xl">Secure Payment</CardTitle>
          <CardDescription>{description}</CardDescription>
          <div className="text-3xl font-bold text-primary mt-2">
            {formatAmount(amount, currency)}
          </div>
        </CardHeader>

        <CardContent>
          <form onSubmit={handleSubmit} className="space-y-6">
            {/* Customer Information */}
            <div className="space-y-4">
              <h3 className="font-semibold flex items-center">
                <User className="w-4 h-4 mr-2" />
                Customer Information
              </h3>
              
              <div className="grid grid-cols-2 gap-3">
                <div>
                  <Label htmlFor="name">Full Name *</Label>
                  <Input
                    id="name"
                    type="text"
                    placeholder="John Smith"
                    value={customerInfo.name}
                    onChange={(e) => setCustomerInfo(prev => ({ 
                      ...prev, 
                      name: e.target.value 
                    }))}
                    required
                  />
                </div>
                
                <div>
                  <Label htmlFor="email">Email *</Label>
                  <Input
                    id="email"
                    type="email"
                    placeholder="john@example.com"
                    value={customerInfo.email}
                    onChange={(e) => setCustomerInfo(prev => ({ 
                      ...prev, 
                      email: e.target.value 
                    }))}
                    required
                  />
                </div>
              </div>

              <div>
                <Label htmlFor="address">Address</Label>
                <Input
                  id="address"
                  placeholder="123 Main Street"
                  value={customerInfo.address.line1}
                  onChange={(e) => setCustomerInfo(prev => ({
                    ...prev,
                    address: { ...prev.address, line1: e.target.value }
                  }))}
                />
              </div>

              <div className="grid grid-cols-2 gap-3">
                <div>
                  <Label htmlFor="city">City</Label>
                  <Input
                    id="city"
                    placeholder="London"
                    value={customerInfo.address.city}
                    onChange={(e) => setCustomerInfo(prev => ({
                      ...prev,
                      address: { ...prev.address, city: e.target.value }
                    }))}
                  />
                </div>
                
                <div>
                  <Label htmlFor="postal_code">Postal Code</Label>
                  <Input
                    id="postal_code"
                    placeholder="SW1A 1AA"
                    value={customerInfo.address.postal_code}
                    onChange={(e) => setCustomerInfo(prev => ({
                      ...prev,
                      address: { ...prev.address, postal_code: e.target.value }
                    }))}
                  />
                </div>
              </div>
            </div>

            {/* Card Details */}
            <div className="space-y-4">
              <h3 className="font-semibold flex items-center">
                <CreditCard className="w-4 h-4 mr-2" />
                Card Details
              </h3>
              
              <div className="p-3 border rounded-md">
                <CardElement
                  options={{
                    style: {
                      base: {
                        fontSize: '16px',
                        color: '#424770',
                        '::placeholder': {
                          color: '#aab7c4',
                        },
                      },
                    },
                  }}
                />
              </div>
            </div>

            {/* Error Display */}
            {paymentError && (
              <Alert variant="destructive">
                <AlertCircle className="h-4 w-4" />
                <AlertDescription>{paymentError}</AlertDescription>
              </Alert>
            )}

            {/* Security Notice */}
            <div className="flex items-center text-sm text-muted-foreground bg-muted/30 p-3 rounded-md">
              <Shield className="w-4 h-4 mr-2 text-green-600" />
              <span>
                Your payment is secured by 256-bit SSL encryption and processed by Stripe.
                Your card details are never stored on our servers.
              </span>
            </div>

            {/* Submit Button */}
            <Button 
              type="submit" 
              className="w-full" 
              size="lg"
              disabled={!stripe || processing || !customerInfo.name || !customerInfo.email}
            >
              {processing ? (
                <>
                  <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                  Processing Payment...
                </>
              ) : (
                <>
                  <Check className="w-4 h-4 mr-2" />
                  Pay {formatAmount(amount, currency)}
                </>
              )}
            </Button>
          </form>
        </CardContent>
      </Card>
    </div>
  );
};

export default PaymentForm;
```

#### Backend Payment Processing Service

```typescript
// Payment Processing Service
import { createClient } from '@supabase/supabase-js';
import Stripe from 'stripe';
import { Payment, PaymentMethod, Invoice } from '@/types/payments';

export class PaymentProcessingService {
  private supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
  
  private stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
    apiVersion: '2023-10-16'
  });

  // Create payment intent with Stripe
  async createPaymentIntent(
    clientId: string,
    supplierId: string,
    amount: number,
    currency: string,
    description?: string,
    metadata: Record<string, any> = {}
  ): Promise<{ payment_intent_id: string; client_secret: string; payment_id: string }> {
    
    // Get supplier's Stripe configuration
    const { data: settings } = await this.supabase
      .from('payment_settings')
      .select('stripe_account_id, stripe_application_fee_percent')
      .eq('supplier_id', supplierId)
      .single();

    // Calculate application fee (WedSync commission)
    const applicationFeeAmount = settings?.stripe_application_fee_percent 
      ? Math.round(amount * (settings.stripe_application_fee_percent / 100))
      : Math.round(amount * 0.029); // Default 2.9%

    // Create payment record first
    const { data: payment, error: paymentError } = await this.supabase
      .from('payments')
      .insert({
        client_id: clientId,
        supplier_id: supplierId,
        payment_type: 'one_time',
        payment_amount: amount / 100, // Convert from cents to pounds
        currency: currency.toUpperCase(),
        payment_status: 'pending',
        payment_description: description,
        application_fee_amount: applicationFeeAmount / 100,
        net_amount: (amount - applicationFeeAmount) / 100
      })
      .select()
      .single();

    if (paymentError) throw paymentError;

    // Create Stripe payment intent
    const paymentIntentData: Stripe.PaymentIntentCreateParams = {
      amount,
      currency: currency.toLowerCase(),
      description,
      metadata: {
        ...metadata,
        payment_id: payment.id,
        client_id: clientId,
        supplier_id: supplierId
      },
      automatic_payment_methods: { enabled: true }
    };

    // Add application fee if supplier has connected Stripe account
    if (settings?.stripe_account_id) {
      paymentIntentData.application_fee_amount = applicationFeeAmount;
      paymentIntentData.on_behalf_of = settings.stripe_account_id;
      paymentIntentData.transfer_data = {
        destination: settings.stripe_account_id
      };
    }

    const paymentIntent = await this.stripe.paymentIntents.create(paymentIntentData);

    // Update payment record with Stripe payment intent ID
    await this.supabase
      .from('payments')
      .update({
        external_payment_id: paymentIntent.id,
        payment_status: 'processing'
      })
      .eq('id', payment.id);

    return {
      payment_intent_id: paymentIntent.id,
      client_secret: paymentIntent.client_secret!,
      payment_id: payment.id
    };
  }

  // Confirm payment completion
  async confirmPayment(
    paymentId: string,
    externalPaymentId: string
  ): Promise<Payment> {
    // Retrieve Stripe payment intent
    const paymentIntent = await this.stripe.paymentIntents.retrieve(externalPaymentId);

    if (paymentIntent.status !== 'succeeded') {
      throw new Error(`Payment not successful. Status: ${paymentIntent.status}`);
    }

    // Update payment record
    const { data: payment, error } = await this.supabase
      .from('payments')
      .update({
        payment_status: 'completed',
        external_charge_id: paymentIntent.charges.data[0]?.id,
        external_customer_id: paymentIntent.customer as string,
        processed_at: new Date().toISOString(),
        processing_fee_amount: this.calculateStripeFee(paymentIntent.amount),
        payment_date: new Date().toISOString()
      })
      .eq('id', paymentId)
      .select()
      .single();

    if (error) throw error;

    // Send payment confirmation email
    await this.sendPaymentConfirmationEmail(payment);

    return payment;
  }

  // Create invoice
  async createInvoice(
    supplierId: string,
    clientId: string,
    lineItems: Omit<InvoiceLineItem, 'id' | 'invoice_id' | 'created_at'>[],
    dueDate: string,
    options: {
      paymentTerms?: string;
      notes?: string;
      footerText?: string;
      autoSend?: boolean;
    } = {}
  ): Promise<Invoice> {
    
    // Generate invoice number
    const invoiceNumber = await this.generateInvoiceNumber(supplierId);
    
    // Calculate totals
    const subtotal = lineItems.reduce((sum, item) => sum + item.line_total, 0);
    const taxAmount = lineItems.reduce((sum, item) => sum + (item.tax_amount || 0), 0);
    const totalAmount = subtotal + taxAmount;

    // Create invoice record
    const { data: invoice, error: invoiceError } = await this.supabase
      .from('invoices')
      .insert({
        client_id: clientId,
        supplier_id: supplierId,
        invoice_number: invoiceNumber,
        invoice_date: new Date().toISOString().split('T')[0],
        due_date: dueDate,
        subtotal_amount: subtotal,
        tax_amount: taxAmount,
        total_amount: totalAmount,
        currency: 'GBP',
        payment_terms: options.paymentTerms || 'Due on receipt',
        invoice_notes: options.notes,
        footer_text: options.footerText,
        invoice_status: 'draft',
        amount_remaining: totalAmount
      })
      .select()
      .single();

    if (invoiceError) throw invoiceError;

    // Create line items
    const lineItemsWithInvoiceId = lineItems.map(item => ({
      ...item,
      invoice_id: invoice.id
    }));

    const { error: lineItemsError } = await this.supabase
      .from('invoice_line_items')
      .insert(lineItemsWithInvoiceId);

    if (lineItemsError) throw lineItemsError;

    // Create Stripe invoice if connected
    const stripeInvoice = await this.createStripeInvoice(invoice, lineItems);
    if (stripeInvoice) {
      await this.supabase
        .from('invoices')
        .update({
          stripe_invoice_id: stripeInvoice.id,
          public_url: stripeInvoice.hosted_invoice_url,
          pdf_url: stripeInvoice.invoice_pdf
        })
        .eq('id', invoice.id);
    }

    // Auto-send if requested
    if (options.autoSend) {
      await this.sendInvoice(invoice.id);
    }

    return {
      ...invoice,
      line_items: lineItemsWithInvoiceId.map((item, index) => ({
        ...item,
        id: `temp-${index}`, // Temporary ID for display
        created_at: new Date().toISOString()
      }))
    };
  }

  // Send invoice to client
  async sendInvoice(invoiceId: string): Promise<void> {
    const { data: invoice, error } = await this.supabase
      .from('invoices')
      .select(`
        *,
        clients!inner(*),
        suppliers!inner(*)
      `)
      .eq('id', invoiceId)
      .single();

    if (error || !invoice) throw new Error('Invoice not found');

    // Update invoice status
    await this.supabase
      .from('invoices')
      .update({
        invoice_status: 'sent',
        sent_at: new Date().toISOString()
      })
      .eq('id', invoiceId);

    // Send email notification
    await this.sendInvoiceEmail(invoice);
  }

  // Process webhook from Stripe
  async processStripeWebhook(event: Stripe.Event): Promise<void> {
    // Log webhook
    await this.supabase
      .from('payment_webhooks')
      .insert({
        supplier_id: event.data.object.metadata?.supplier_id || '',
        webhook_provider: 'stripe',
        webhook_event_type: event.type,
        webhook_event_id: event.id,
        external_object_id: event.data.object.id,
        webhook_payload: event,
        webhook_status: 'received'
      });

    try {
      switch (event.type) {
        case 'payment_intent.succeeded':
          await this.handlePaymentIntentSucceeded(event.data.object as Stripe.PaymentIntent);
          break;

        case 'payment_intent.payment_failed':
          await this.handlePaymentIntentFailed(event.data.object as Stripe.PaymentIntent);
          break;

        case 'invoice.payment_succeeded':
          await this.handleInvoicePaymentSucceeded(event.data.object as Stripe.Invoice);
          break;

        case 'invoice.payment_failed':
          await this.handleInvoicePaymentFailed(event.data.object as Stripe.Invoice);
          break;

        default:
          console.log(`Unhandled webhook event type: ${event.type}`);
      }

      // Mark webhook as processed
      await this.supabase
        .from('payment_webhooks')
        .update({ webhook_status: 'processed', processed_at: new Date().toISOString() })
        .eq('webhook_event_id', event.id);

    } catch (error) {
      console.error('Webhook processing error:', error);
      
      // Mark webhook as failed
      await this.supabase
        .from('payment_webhooks')
        .update({ 
          webhook_status: 'failed', 
          failure_reason: error.message 
        })
        .eq('webhook_event_id', event.id);
    }
  }

  // Handle successful payment intent
  private async handlePaymentIntentSucceeded(paymentIntent: Stripe.PaymentIntent): Promise<void> {
    const paymentId = paymentIntent.metadata.payment_id;
    if (!paymentId) return;

    await this.supabase
      .from('payments')
      .update({
        payment_status: 'completed',
        external_charge_id: paymentIntent.charges.data[0]?.id,
        processed_at: new Date().toISOString(),
        processing_fee_amount: this.calculateStripeFee(paymentIntent.amount),
        payment_date: new Date().toISOString()
      })
      .eq('external_payment_id', paymentIntent.id);

    // Send confirmation email
    const { data: payment } = await this.supabase
      .from('payments')
      .select('*')
      .eq('external_payment_id', paymentIntent.id)
      .single();

    if (payment) {
      await this.sendPaymentConfirmationEmail(payment);
    }
  }

  // Handle failed payment intent
  private async handlePaymentIntentFailed(paymentIntent: Stripe.PaymentIntent): Promise<void> {
    await this.supabase
      .from('payments')
      .update({
        payment_status: 'failed',
        failed_at: new Date().toISOString(),
        failure_reason: paymentIntent.last_payment_error?.message || 'Payment failed'
      })
      .eq('external_payment_id', paymentIntent.id);
  }

  // Utility methods
  private calculateStripeFee(amountInCents: number): number {
    // Stripe UK fees: 1.4% + 20p for European cards
    return Math.round(amountInCents * 0.014 + 20);
  }

  private async generateInvoiceNumber(supplierId: string): Promise<string> {
    const year = new Date().getFullYear();
    const { count } = await this.supabase
      .from('invoices')
      .select('id', { count: 'exact' })
      .eq('supplier_id', supplierId)
      .gte('created_at', `${year}-01-01`)
      .lt('created_at', `${year + 1}-01-01`);

    return `INV-${year}-${String((count || 0) + 1).padStart(3, '0')}`;
  }

  private async createStripeInvoice(
    invoice: Invoice, 
    lineItems: InvoiceLineItem[]
  ): Promise<Stripe.Invoice | null> {
    try {
      // Implementation for creating Stripe invoice
      // This would integrate with Stripe's invoice API
      return null; // Placeholder
    } catch (error) {
      console.error('Failed to create Stripe invoice:', error);
      return null;
    }
  }

  private async sendPaymentConfirmationEmail(payment: Payment): Promise<void> {
    // Implementation for sending payment confirmation email
    // This would integrate with your email service (Resend, etc.)
    console.log('Sending payment confirmation email for payment:', payment.id);
  }

  private async sendInvoiceEmail(invoice: any): Promise<void> {
    // Implementation for sending invoice email
    console.log('Sending invoice email for invoice:', invoice.id);
  }
}
```

### ACCEPTANCE CRITERIA

**Payment Processing:**
- [ ] Stripe integration with payment intents and webhooks
- [ ] Support for multiple payment methods (cards, bank transfers, digital wallets)
- [ ] Secure payment form with PCI compliance
- [ ] Automatic fee calculation and commission handling
- [ ] Real-time payment status updates
- [ ] Payment retry logic for failed transactions
- [ ] Refund processing with partial refund support
- [ ] Multi-currency support with automatic conversion

**Invoice Management:**
- [ ] Professional invoice generation with PDF export
- [ ] Customizable invoice templates with branding
- [ ] Automatic invoice numbering system
- [ ] Line item management with tax calculations
- [ ] Invoice status tracking (sent, viewed, paid, overdue)
- [ ] Automated reminder system with customizable schedules
- [ ] Late fee configuration and automatic application
- [ ] Public payment links for easy client access

**Payment Plans:**
- [ ] Flexible installment plan creation
- [ ] Automatic recurring payment collection
- [ ] Payment plan assignment to clients
- [ ] Progress tracking and status monitoring
- [ ] Failed payment handling and retry logic
- [ ] Plan modification and cancellation
- [ ] Custom payment schedules with date flexibility
- [ ] Integration with calendar for payment reminders

**Form Integration:**
- [ ] Payment-enabled forms with seamless checkout
- [ ] Dynamic pricing based on form responses
- [ ] Conditional payment requirements
- [ ] Post-payment form completion and redirects
- [ ] Payment status integration with form submissions
- [ ] Automated client status updates after payment
- [ ] Custom success/failure pages

**Business Logic:**
- [ ] Tier-based payment feature access (FREE: no payments, PROFESSIONAL+: full access)
- [ ] Commission calculation and tracking for WedSync revenue
- [ ] Payment method configuration per supplier
- [ ] Custom payment terms and conditions
- [ ] Integration with client management system
- [ ] Payment history and reporting
- [ ] Tax compliance with VAT calculations
- [ ] Multi-business payment separation

**Security & Compliance:**
- [ ] PCI DSS compliance through Stripe
- [ ] Secure credential storage and handling
- [ ] GDPR compliance for payment data
- [ ] Fraud detection and prevention
- [ ] Secure webhook signature verification
- [ ] Encrypted sensitive data storage
- [ ] Audit logging for all payment activities
- [ ] Regular security assessments and updates

**Mobile & UX:**
- [ ] Mobile-optimized payment forms
- [ ] Touch-friendly payment interfaces
- [ ] Offline payment recording capability
- [ ] Quick payment link generation
- [ ] Payment status notifications
- [ ] Customer payment history access
- [ ] Receipt generation and email delivery
- [ ] Intuitive payment flow with clear error handling

### DEPENDENCIES & INTEGRATION

**Must Complete After:**
- WS-305: Authentication System (user management)
- WS-306: Client Management System (client records)
- WS-342: Advanced Form Builder (form integration)

**Must Complete Before:**
- WS-350: Email Marketing System (payment confirmation emails)
- WS-355: Analytics Dashboard (payment analytics)
- Production launch (revenue generation)

**Shares Code With:**
- Form Builder (payment-enabled forms)
- Client Management (payment history)
- Email System (payment notifications)
- Analytics System (payment reporting)

### ESTIMATED EFFORT

- **Frontend Development:** 35 hours
  - Payment forms and UI components
  - Invoice management interface
  - Payment plan configuration
  - Mobile-responsive design

- **Backend Development:** 40 hours
  - Stripe integration and webhooks
  - Payment processing logic
  - Invoice generation system
  - Payment plan management

- **Database & Infrastructure:** 15 hours
  - Payment schema implementation
  - Performance optimization
  - Security hardening
  - Backup and recovery

- **Testing & QA:** 10 hours
  - Payment flow testing
  - Security testing
  - Mobile testing
  - Integration testing

**Total Estimated Effort:** 100 hours

### TECHNICAL NOTES

**Stripe Integration:**
- Use Payment Intents API for 3D Secure support
- Implement webhook signature verification
- Handle all payment states (pending, succeeded, failed)
- Configure connected accounts for supplier payouts

**Performance Considerations:**
- Implement payment caching for repeated requests
- Use database indexes for payment queries
- Optimize invoice PDF generation
- Background processing for webhook handling

**Security Best Practices:**
- Never store card details directly
- Use HTTPS for all payment endpoints
- Implement rate limiting on payment APIs
- Regular security audits and vulnerability scans
- Secure API key management with environment variables

This Payment Processing System will transform WedSync from a form builder into a complete business solution, enabling suppliers to collect payments immediately and improving cash flow significantly. The seamless integration with forms makes it effortless for clients to pay, dramatically increasing conversion rates and customer satisfaction.