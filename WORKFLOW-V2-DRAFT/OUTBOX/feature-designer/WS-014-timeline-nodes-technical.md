# TECHNICAL SPECIFICATION: WS-014 - Timeline Nodes
## Generated by Feature Development Session - 2025-08-21

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding venue coordinator scheduling critical touchpoints
**I want to:** Create timeline nodes that automatically calculate execution dates based on wedding timeline anchors
**So that:** I can ensure wedding coordination activities happen at exactly the right time instead of manual calendar tracking prone to errors

**Real Wedding Scenario:**
A venue coordinator must execute specific tasks: final headcount confirmation (7 days before), setup timeline review (3 days before), vendor arrival coordination (day of at 8 AM), ceremony start check (30 minutes before ceremony). Currently tracked manually in calendar with high error risk - missed the headcount deadline for Sarah's wedding, causing catering complications. With timeline nodes, they set "7 days before wedding_date" anchor, and the system auto-calculates June 8th for June 15th wedding, adjusts for weekend (moves to Monday June 10th), and triggers email reminder precisely when needed - eliminating manual calculation errors and ensuring 100% on-time execution.

### SPECIFICATION SOURCE
- **Feature ID:** WS-014
- **Original Spec:** /CORE-SPECIFICATIONS/02-WEDSYNC-SUPPLIER-PLATFORM/05-Customer-Journey/02-timeline-nodes md.md
- **Current Implementation:** 0% complete
- **Files to Modify:**
  - /src/components/journey/JourneyCanvas.tsx (add timeline node support)
- **New Files to Create:**
  - /src/components/timeline/TimelineNode.tsx
  - /src/components/timeline/TimelineNodeEditor.tsx
  - /src/components/timeline/DateCalculator.tsx
  - /src/components/timeline/BusinessRulesPanel.tsx
  - /src/lib/timeline/timelineCalculator.ts
  - /src/lib/stores/timelineStore.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Timeline node definitions and calculations
CREATE TABLE IF NOT EXISTS timeline_nodes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  journey_id UUID REFERENCES journeys(id) ON DELETE CASCADE,
  node_id TEXT NOT NULL, -- Canvas node ID
  anchor_type TEXT CHECK (anchor_type IN ('wedding_date', 'booking_date', 'fixed_date', 'event_date')) NOT NULL,
  offset_value INTEGER NOT NULL,
  offset_unit TEXT CHECK (offset_unit IN ('minutes', 'hours', 'days', 'weeks', 'months')) NOT NULL,
  offset_direction TEXT CHECK (offset_direction IN ('before', 'after')) NOT NULL,
  time_of_day TIME,
  timezone TEXT DEFAULT 'client_local',
  business_rules JSONB DEFAULT '{}', -- Skip weekends, holidays, business hours
  label TEXT,
  description TEXT,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  
  UNIQUE(journey_id, node_id)
);

-- Timeline execution instances for specific clients
CREATE TABLE IF NOT EXISTS timeline_executions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  timeline_node_id UUID REFERENCES timeline_nodes(id) ON DELETE CASCADE,
  journey_execution_id UUID REFERENCES journey_executions(id) ON DELETE CASCADE,
  client_id UUID REFERENCES client_profiles(id) ON DELETE CASCADE,
  anchor_date TIMESTAMP NOT NULL, -- The reference date (wedding, booking, etc.)
  calculated_date TIMESTAMP NOT NULL, -- Final calculated execution date
  original_calculated_date TIMESTAMP NOT NULL, -- Before business rule adjustments
  business_adjustments JSONB DEFAULT '{}', -- What adjustments were made
  execution_status TEXT CHECK (execution_status IN ('scheduled', 'executing', 'completed', 'failed', 'cancelled')) DEFAULT 'scheduled',
  executed_at TIMESTAMP,
  next_retry_at TIMESTAMP,
  error_message TEXT,
  
  INDEX(client_id, calculated_date),
  INDEX(execution_status, calculated_date),
  INDEX(journey_execution_id)
);

-- Business calendar rules (holidays, blackout dates)
CREATE TABLE IF NOT EXISTS business_calendar_rules (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  rule_type TEXT CHECK (rule_type IN ('holiday', 'blackout', 'business_hours', 'timezone_override')) NOT NULL,
  rule_name TEXT NOT NULL,
  start_date DATE,
  end_date DATE,
  recurring_pattern JSONB, -- For recurring holidays
  time_rules JSONB, -- Business hours, timezone info
  applies_to TEXT[] DEFAULT ARRAY['all'], -- Which timeline types this affects
  created_at TIMESTAMP DEFAULT NOW()
);

-- Timeline performance analytics
CREATE TABLE IF NOT EXISTS timeline_analytics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  timeline_node_id UUID REFERENCES timeline_nodes(id) ON DELETE CASCADE,
  metric_date DATE NOT NULL,
  total_executions INTEGER DEFAULT 0,
  successful_executions INTEGER DEFAULT 0,
  failed_executions INTEGER DEFAULT 0,
  average_delay_minutes INTEGER DEFAULT 0, -- How late executions ran
  business_adjustments_count INTEGER DEFAULT 0,
  created_at TIMESTAMP DEFAULT NOW(),
  
  UNIQUE(timeline_node_id, metric_date)
);
```

#### API Endpoints Required
```typescript
// POST /api/timeline/nodes
interface CreateTimelineNodeRequest {
  journeyId: string;
  nodeId: string;
  anchorType: 'wedding_date' | 'booking_date' | 'fixed_date' | 'event_date';
  offset: {
    value: number;
    unit: 'minutes' | 'hours' | 'days' | 'weeks' | 'months';
    direction: 'before' | 'after';
  };
  timeOfDay?: string; // HH:MM format
  timezone?: string;
  businessRules?: {
    skipWeekends?: boolean;
    skipHolidays?: boolean;
    businessHoursOnly?: boolean;
    blackoutDates?: string[];
    allowedDaysOfWeek?: number[]; // 0-6, Sunday-Saturday
  };
  label?: string;
  description?: string;
}

interface CreateTimelineNodeResponse {
  success: boolean;
  data: {
    timelineNode: TimelineNode;
    previewCalculations: Array<{
      clientId: string;
      clientName: string;
      anchorDate: string;
      calculatedDate: string;
      adjustments: string[];
    }>;
  };
}

// GET /api/timeline/calculate
interface CalculateTimelineRequest {
  anchorType: string;
  anchorDate: string;
  offset: TimelineOffset;
  timeOfDay?: string;
  timezone?: string;
  businessRules?: BusinessRules;
  clientId?: string; // For client-specific rules
}

interface CalculateTimelineResponse {
  success: boolean;
  data: {
    calculatedDate: string;
    originalDate: string; // Before business rule adjustments
    adjustments: Array<{
      type: 'weekend_skip' | 'holiday_skip' | 'business_hours' | 'blackout_date';
      message: string;
      dateChange: {
        from: string;
        to: string;
      };
    }>;
    warnings: string[];
    timezone: string;
    businessDay: boolean;
  };
}

// GET /api/timeline/executions/[clientId]
interface GetClientTimelineExecutionsResponse {
  success: boolean;
  data: {
    executions: Array<{
      id: string;
      timelineNodeId: string;
      label: string;
      anchorDate: string;
      calculatedDate: string;
      status: 'scheduled' | 'executing' | 'completed' | 'failed' | 'cancelled';
      businessAdjustments: Array<{
        type: string;
        message: string;
      }>;
      executedAt?: string;
      nextRetryAt?: string;
    }>;
    upcomingCount: number;
    overdueCount: number;
    nextExecution?: {
      date: string;
      label: string;
      daysAway: number;
    };
  };
}

// POST /api/timeline/test
interface TestTimelineCalculationRequest {
  timelineNodeConfig: TimelineNodeConfig;
  testScenarios: Array<{
    name: string;
    anchorDate: string;
    clientTimezone?: string;
    expectedDate?: string; // For validation
  }>;
}

interface TestTimelineCalculationResponse {
  success: boolean;
  data: {
    results: Array<{
      scenarioName: string;
      anchorDate: string;
      calculatedDate: string;
      adjustments: string[];
      passed: boolean; // If expectedDate was provided and matches
      warnings: string[];
    }>;
    summary: {
      totalTests: number;
      passed: number;
      failed: number;
      averageAdjustments: number;
    };
  };
}
```

#### Frontend Components Required
```typescript
// Component: TimelineNode
// Location: /src/components/timeline/TimelineNode.tsx

interface TimelineNodeProps extends NodeProps {
  data: {
    anchorType: 'wedding_date' | 'booking_date' | 'fixed_date' | 'event_date';
    offset: TimelineOffset;
    timeOfDay?: string;
    timezone: string;
    businessRules: BusinessRules;
    label: string;
    calculatedDate?: string;
    adjustments?: string[];
    status?: 'valid' | 'warning' | 'error';
  };
  selected: boolean;
  onEdit: () => void;
}

// Key functionality:
- Visual timeline marker with calculated date display
- Color coding based on offset direction (green=after, blue=before)
- Business rule indicators (weekend skip, holiday adjust)
- Warning/error states for invalid configurations
- Hover tooltip with calculation details
- Drag handles for canvas repositioning
- Connection points for module linking

// Component: TimelineNodeEditor
// Location: /src/components/timeline/TimelineNodeEditor.tsx

interface TimelineNodeEditorProps {
  timelineNode?: TimelineNode;
  onSave: (config: TimelineNodeConfig) => void;
  onCancel: () => void;
  availableAnchors: Array<{
    type: string;
    label: string;
    description: string;
  }>;
  clientPreview?: string; // Client ID for preview calculations
}

// Key functionality:
- Anchor type selection with descriptions
- Offset configuration (value, unit, direction)
- Time of day picker with timezone support
- Business rules configuration panel
- Real-time calculation preview
- Test scenarios with multiple dates
- Validation with clear error messages

// Component: DateCalculator
// Location: /src/components/timeline/DateCalculator.tsx

interface DateCalculatorProps {
  anchorDate: Date;
  offset: TimelineOffset;
  timeOfDay?: string;
  timezone: string;
  businessRules: BusinessRules;
  onCalculation: (result: CalculationResult) => void;
}

// Key functionality:
- Live calculation as inputs change
- Visual timeline with anchor and calculated positions
- Step-by-step calculation explanation
- Business rule impact visualization
- Multiple timezone display
- Calendar widget with highlighted dates

// Component: BusinessRulesPanel
// Location: /src/components/timeline/BusinessRulesPanel.tsx

interface BusinessRulesPanelProps {
  rules: BusinessRules;
  onChange: (rules: BusinessRules) => void;
  holidayCalendar: Holiday[];
  clientTimezone?: string;
}

// Key functionality:
- Weekend skip toggle with preview
- Holiday calendar integration
- Business hours time picker
- Blackout dates selection
- Custom rule builder
- Rule conflict detection
- Preview impact on sample dates
```

#### Integration Points
```typescript
// Timeline calculation engine
export class TimelineCalculator {
  private holidayCache: Map<string, Holiday[]> = new Map();
  private timezoneCache: Map<string, TimezoneInfo> = new Map();
  
  async calculateTimelineDate(config: TimelineCalculationConfig): Promise<TimelineCalculationResult> {
    // Step 1: Parse anchor date and validate
    const anchorDate = this.parseAnchorDate(config.anchorDate, config.clientTimezone);
    
    // Step 2: Apply offset calculation
    const baseCalculatedDate = this.applyOffset(anchorDate, config.offset);
    
    // Step 3: Apply time of day
    let calculatedDate = this.applyTimeOfDay(baseCalculatedDate, config.timeOfDay, config.timezone);
    
    // Step 4: Apply business rules
    const adjustments: TimelineAdjustment[] = [];
    
    if (config.businessRules.skipWeekends) {
      const weekendAdjustment = await this.adjustForWeekends(calculatedDate);
      if (weekendAdjustment) {
        calculatedDate = weekendAdjustment.adjustedDate;
        adjustments.push(weekendAdjustment);
      }
    }
    
    if (config.businessRules.skipHolidays) {
      const holidayAdjustment = await this.adjustForHolidays(calculatedDate, config.clientLocation);
      if (holidayAdjustment) {
        calculatedDate = holidayAdjustment.adjustedDate;
        adjustments.push(holidayAdjustment);
      }
    }
    
    if (config.businessRules.businessHoursOnly) {
      const businessHoursAdjustment = this.adjustForBusinessHours(calculatedDate, config.businessRules.businessHours);
      if (businessHoursAdjustment) {
        calculatedDate = businessHoursAdjustment.adjustedDate;
        adjustments.push(businessHoursAdjustment);
      }
    }
    
    // Step 5: Check blackout dates
    if (config.businessRules.blackoutDates?.length) {
      const blackoutAdjustment = this.adjustForBlackoutDates(calculatedDate, config.businessRules.blackoutDates);
      if (blackoutAdjustment) {
        calculatedDate = blackoutAdjustment.adjustedDate;
        adjustments.push(blackoutAdjustment);
      }
    }
    
    // Step 6: Validate final result
    const warnings = this.validateCalculation(config, calculatedDate, adjustments);
    
    return {
      anchorDate,
      originalCalculatedDate: baseCalculatedDate,
      finalCalculatedDate: calculatedDate,
      adjustments,
      warnings,
      timezone: config.timezone,
      isBusinessDay: this.isBusinessDay(calculatedDate),
      dayOfWeek: calculatedDate.getDay(),
      calculationTime: Date.now()
    };
  }
  
  private applyOffset(anchorDate: Date, offset: TimelineOffset): Date {
    const multiplier = offset.direction === 'before' ? -1 : 1;
    const offsetMs = this.convertToMilliseconds(offset.value, offset.unit) * multiplier;
    
    return new Date(anchorDate.getTime() + offsetMs);
  }
  
  private convertToMilliseconds(value: number, unit: TimelineUnit): number {
    const conversions = {
      minutes: 60 * 1000,
      hours: 60 * 60 * 1000,
      days: 24 * 60 * 60 * 1000,
      weeks: 7 * 24 * 60 * 60 * 1000,
      months: 30 * 24 * 60 * 60 * 1000 // Approximate
    };
    
    return value * conversions[unit];
  }
  
  private async adjustForWeekends(date: Date): Promise<TimelineAdjustment | null> {
    const dayOfWeek = date.getDay();
    
    if (dayOfWeek === 0) { // Sunday
      const adjustedDate = new Date(date.getTime() + 24 * 60 * 60 * 1000); // Move to Monday
      return {
        type: 'weekend_skip',
        message: 'Moved from Sunday to Monday',
        originalDate: date,
        adjustedDate,
        reason: 'Skip weekends rule applied'
      };
    }
    
    if (dayOfWeek === 6) { // Saturday
      const adjustedDate = new Date(date.getTime() + 2 * 24 * 60 * 60 * 1000); // Move to Monday
      return {
        type: 'weekend_skip',
        message: 'Moved from Saturday to Monday',
        originalDate: date,
        adjustedDate,
        reason: 'Skip weekends rule applied'
      };
    }
    
    return null;
  }
  
  private async adjustForHolidays(date: Date, location?: string): Promise<TimelineAdjustment | null> {
    const holidays = await this.getHolidays(date.getFullYear(), location);
    const dateStr = format(date, 'yyyy-MM-dd');
    
    const holiday = holidays.find(h => h.date === dateStr);
    if (holiday) {
      // Find next business day
      let nextDate = new Date(date.getTime() + 24 * 60 * 60 * 1000);
      
      while (this.isWeekend(nextDate) || await this.isHoliday(nextDate, location)) {
        nextDate = new Date(nextDate.getTime() + 24 * 60 * 60 * 1000);
      }
      
      return {
        type: 'holiday_skip',
        message: `Moved from ${holiday.name} to next business day`,
        originalDate: date,
        adjustedDate: nextDate,
        reason: `Holiday: ${holiday.name}`
      };
    }
    
    return null;
  }
  
  private async getHolidays(year: number, location?: string): Promise<Holiday[]> {
    const cacheKey = `${year}-${location || 'default'}`;
    
    if (this.holidayCache.has(cacheKey)) {
      return this.holidayCache.get(cacheKey)!;
    }
    
    // Fetch holidays from API or local data
    const holidays = await this.fetchHolidays(year, location);
    this.holidayCache.set(cacheKey, holidays);
    
    return holidays;
  }
}

// Store: timelineStore
interface TimelineStore {
  timelineNodes: Map<string, TimelineNode>;
  calculations: Map<string, TimelineCalculationResult>;
  businessRules: BusinessRules;
  
  createTimelineNode: (config: TimelineNodeConfig) => Promise<TimelineNode>;
  updateTimelineNode: (nodeId: string, updates: Partial<TimelineNodeConfig>) => Promise<void>;
  deleteTimelineNode: (nodeId: string) => Promise<void>;
  
  calculateTimeline: (nodeId: string, clientId?: string) => Promise<TimelineCalculationResult>;
  previewCalculation: (config: TimelineNodeConfig, anchorDate: Date) => Promise<TimelineCalculationResult>;
  
  getClientExecutions: (clientId: string) => Promise<TimelineExecution[]>;
  updateExecutionStatus: (executionId: string, status: string) => Promise<void>;
  
  testTimelineNode: (config: TimelineNodeConfig, testScenarios: TestScenario[]) => Promise<TestResult>;
}
```

### CODE EXAMPLES

#### Example 1: Advanced Business Rules Processing
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
export class AdvancedBusinessRulesProcessor {
  
  async processComplexBusinessRules(date: Date, rules: ComplexBusinessRules, context: TimelineContext): Promise<BusinessRuleResult> {
    let processedDate = new Date(date.getTime());
    const appliedAdjustments: BusinessAdjustment[] = [];
    const warnings: string[] = [];
    
    // Step 1: Apply day-of-week restrictions
    if (rules.allowedDaysOfWeek?.length) {
      const adjustment = await this.adjustForAllowedDays(processedDate, rules.allowedDaysOfWeek);
      if (adjustment) {
        processedDate = adjustment.adjustedDate;
        appliedAdjustments.push(adjustment);
      }
    }
    
    // Step 2: Apply seasonal restrictions
    if (rules.seasonalRestrictions) {
      const seasonalAdjustment = await this.applySeasonalRules(processedDate, rules.seasonalRestrictions, context);
      if (seasonalAdjustment) {
        processedDate = seasonalAdjustment.adjustedDate;
        appliedAdjustments.push(seasonalAdjustment);
      }
    }
    
    // Step 3: Apply client-specific rules
    if (context.clientId && rules.clientSpecificRules) {
      const clientRules = await this.getClientSpecificRules(context.clientId);
      const clientAdjustment = await this.applyClientRules(processedDate, clientRules);
      if (clientAdjustment) {
        processedDate = clientAdjustment.adjustedDate;
        appliedAdjustments.push(clientAdjustment);
      }
    }
    
    // Step 4: Apply workload balancing
    if (rules.workloadBalancing) {
      const workloadAdjustment = await this.balanceWorkload(processedDate, context.supplierId, rules.workloadBalancing);
      if (workloadAdjustment) {
        processedDate = workloadAdjustment.adjustedDate;
        appliedAdjustments.push(workloadAdjustment);
        
        if (workloadAdjustment.isWarning) {
          warnings.push(`Date adjusted due to high workload: ${workloadAdjustment.message}`);
        }
      }
    }
    
    // Step 5: Validate final date constraints
    const validationResult = await this.validateFinalDate(processedDate, date, rules, context);
    if (!validationResult.isValid) {
      if (validationResult.isCritical) {
        throw new Error(`Business rule validation failed: ${validationResult.error}`);
      } else {
        warnings.push(validationResult.error);
      }
    }
    
    // Step 6: Check for excessive adjustments
    const totalAdjustmentDays = Math.abs((processedDate.getTime() - date.getTime()) / (1000 * 60 * 60 * 24));
    if (totalAdjustmentDays > 7) {
      warnings.push(`Final date is ${Math.round(totalAdjustmentDays)} days from originally calculated date`);
    }
    
    return {
      finalDate: processedDate,
      originalDate: date,
      adjustments: appliedAdjustments,
      warnings,
      processingTime: Date.now(),
      confidence: this.calculateConfidenceScore(appliedAdjustments, warnings)
    };
  }
  
  private async adjustForAllowedDays(date: Date, allowedDays: number[]): Promise<BusinessAdjustment | null> {
    const currentDay = date.getDay();
    
    if (allowedDays.includes(currentDay)) {
      return null; // No adjustment needed
    }
    
    // Find the next allowed day
    let nextDate = new Date(date.getTime());
    let daysAdded = 0;
    
    while (!allowedDays.includes(nextDate.getDay()) && daysAdded < 7) {
      nextDate = new Date(nextDate.getTime() + 24 * 60 * 60 * 1000);
      daysAdded++;
    }
    
    if (daysAdded >= 7) {
      throw new Error('No allowed days found within a week');
    }
    
    const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    
    return {
      type: 'allowed_days',
      message: `Moved from ${dayNames[currentDay]} to ${dayNames[nextDate.getDay()]}`,
      originalDate: date,
      adjustedDate: nextDate,
      reason: `Only ${allowedDays.map(d => dayNames[d]).join(', ')} are allowed`,
      metadata: { daysAdded, allowedDays }
    };
  }
  
  private async balanceWorkload(date: Date, supplierId: string, balancingRules: WorkloadBalancingRules): Promise<BusinessAdjustment | null> {
    // Step 1: Get current workload for the target date
    const currentWorkload = await this.getWorkloadForDate(date, supplierId);
    
    if (currentWorkload.count < balancingRules.maxTasksPerDay) {
      return null; // No adjustment needed
    }
    
    // Step 2: Find alternative dates with lower workload
    const searchRange = balancingRules.searchRangeDays || 7;
    const alternatives: Array<{ date: Date; workload: number }> = [];
    
    for (let i = 1; i <= searchRange; i++) {
      // Check days before and after
      const beforeDate = new Date(date.getTime() - i * 24 * 60 * 60 * 1000);
      const afterDate = new Date(date.getTime() + i * 24 * 60 * 60 * 1000);
      
      const beforeWorkload = await this.getWorkloadForDate(beforeDate, supplierId);
      const afterWorkload = await this.getWorkloadForDate(afterDate, supplierId);
      
      if (beforeWorkload.count < balancingRules.maxTasksPerDay) {
        alternatives.push({ date: beforeDate, workload: beforeWorkload.count });
      }
      
      if (afterWorkload.count < balancingRules.maxTasksPerDay) {
        alternatives.push({ date: afterDate, workload: afterWorkload.count });
      }
    }
    
    if (alternatives.length === 0) {
      return {
        type: 'workload_warning',
        message: `High workload on ${format(date, 'MMM d')} (${currentWorkload.count} tasks)`,
        originalDate: date,
        adjustedDate: date, // No change, but flag as warning
        reason: `No alternative dates found within ${searchRange} days`,
        isWarning: true,
        metadata: { currentWorkload: currentWorkload.count, maxAllowed: balancingRules.maxTasksPerDay }
      };
    }
    
    // Step 3: Choose the best alternative (prefer closer dates with lower workload)
    const bestAlternative = alternatives
      .sort((a, b) => {
        const aDaysAway = Math.abs((a.date.getTime() - date.getTime()) / (1000 * 60 * 60 * 24));
        const bDaysAway = Math.abs((b.date.getTime() - date.getTime()) / (1000 * 60 * 60 * 24));
        
        // Prefer lower workload, then closer date
        if (a.workload !== b.workload) {
          return a.workload - b.workload;
        }
        return aDaysAway - bDaysAway;
      })[0];
    
    return {
      type: 'workload_balancing',
      message: `Moved to balance workload (${currentWorkload.count} → ${bestAlternative.workload} tasks)`,
      originalDate: date,
      adjustedDate: bestAlternative.date,
      reason: `Original date exceeded maximum ${balancingRules.maxTasksPerDay} tasks per day`,
      metadata: {
        originalWorkload: currentWorkload.count,
        newWorkload: bestAlternative.workload,
        daysShifted: Math.round((bestAlternative.date.getTime() - date.getTime()) / (1000 * 60 * 60 * 24))
      }
    };
  }
  
  private async getWorkloadForDate(date: Date, supplierId: string): Promise<WorkloadInfo> {
    const dateStr = format(date, 'yyyy-MM-dd');
    
    const { data: executions } = await supabase
      .from('timeline_executions')
      .select('id, timeline_node_id, client_id')
      .eq('supplier_id', supplierId)
      .gte('calculated_date', `${dateStr} 00:00:00`)
      .lt('calculated_date', `${dateStr} 23:59:59`)
      .eq('execution_status', 'scheduled');
    
    return {
      date,
      count: executions?.length || 0,
      executions: executions || [],
      capacity: await this.getSupplierCapacity(supplierId)
    };
  }
  
  private calculateConfidenceScore(adjustments: BusinessAdjustment[], warnings: string[]): number {
    let score = 1.0;
    
    // Reduce confidence for each adjustment
    score -= adjustments.length * 0.1;
    
    // Reduce confidence for warnings
    score -= warnings.length * 0.05;
    
    // Reduce confidence for large time shifts
    const totalShift = adjustments.reduce((total, adj) => {
      const shift = Math.abs((adj.adjustedDate.getTime() - adj.originalDate.getTime()) / (1000 * 60 * 60 * 24));
      return total + shift;
    }, 0);
    
    if (totalShift > 3) {
      score -= 0.2; // Significant date shift
    }
    
    return Math.max(0, Math.min(1, score));
  }
}
```

#### Example 2: Timeline Execution Monitoring and Recovery
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
export class TimelineExecutionMonitor {
  private monitoringInterval: NodeJS.Timeout | null = null;
  
  startMonitoring(): void {
    if (this.monitoringInterval) {
      clearInterval(this.monitoringInterval);
    }
    
    // Check for due timeline executions every minute
    this.monitoringInterval = setInterval(() => {
      this.processExecutionQueue();
    }, 60 * 1000);
    
    console.log('Timeline execution monitoring started');
  }
  
  private async processExecutionQueue(): Promise<void> {
    try {
      // Step 1: Find executions due for processing
      const dueExecutions = await this.getDueExecutions();
      
      if (dueExecutions.length === 0) {
        return;
      }
      
      console.log(`Processing ${dueExecutions.length} due timeline executions`);
      
      // Step 2: Process executions in batches
      const batchSize = 10;
      for (let i = 0; i < dueExecutions.length; i += batchSize) {
        const batch = dueExecutions.slice(i, i + batchSize);
        await Promise.allSettled(batch.map(execution => this.processExecution(execution)));
      }
      
      // Step 3: Handle failed executions
      await this.handleFailedExecutions();
      
      // Step 4: Update analytics
      await this.updateExecutionAnalytics();
      
    } catch (error) {
      console.error('Error in timeline execution monitoring:', error);
    }
  }
  
  private async getDueExecutions(): Promise<TimelineExecution[]> {
    const now = new Date();
    const grace_period = new Date(now.getTime() - 5 * 60 * 1000); // 5 minutes grace
    
    const { data: executions } = await supabase
      .from('timeline_executions')
      .select(`
        *,
        timeline_node:timeline_nodes(*),
        journey_execution:journey_executions(*),
        client:client_profiles(id, couple_names, wedding_date)
      `)
      .eq('execution_status', 'scheduled')
      .gte('calculated_date', grace_period.toISOString())
      .lte('calculated_date', now.toISOString())
      .order('calculated_date', { ascending: true });
    
    return executions || [];
  }
  
  private async processExecution(execution: TimelineExecution): Promise<void> {
    try {
      // Step 1: Mark as executing
      await this.updateExecutionStatus(execution.id, 'executing');
      
      // Step 2: Get the timeline node configuration
      const timelineNode = execution.timeline_node;
      if (!timelineNode) {
        throw new Error('Timeline node not found');
      }
      
      // Step 3: Execute based on node type
      const executionResult = await this.executeTimelineNode(execution, timelineNode);
      
      // Step 4: Update execution record
      await supabase
        .from('timeline_executions')
        .update({
          execution_status: 'completed',
          executed_at: new Date().toISOString(),
          result_data: executionResult
        })
        .eq('id', execution.id);
      
      // Step 5: Trigger next nodes in journey
      await this.triggerNextJourneyNodes(execution.journey_execution_id, timelineNode.node_id);
      
      console.log(`Timeline execution completed: ${execution.id}`);
      
    } catch (error) {
      // Step 6: Handle execution failure
      await this.handleExecutionFailure(execution.id, error);
    }
  }
  
  private async executeTimelineNode(execution: TimelineExecution, timelineNode: TimelineNode): Promise<ExecutionResult> {
    // The timeline node itself doesn't execute actions - it triggers connected modules
    // But we record the execution for tracking and analytics
    
    const executionResult: ExecutionResult = {
      nodeId: timelineNode.node_id,
      executionTime: new Date().toISOString(),
      status: 'completed',
      metadata: {
        originalCalculatedDate: execution.original_calculated_date,
        finalCalculatedDate: execution.calculated_date,
        businessAdjustments: execution.business_adjustments,
        anchorDate: execution.anchor_date,
        clientId: execution.client_id
      }
    };
    
    // Step 1: Log the timeline trigger
    await supabase
      .from('journey_execution_log')
      .insert({
        journey_execution_id: execution.journey_execution_id,
        node_id: timelineNode.node_id,
        event_type: 'timeline_triggered',
        event_data: executionResult.metadata,
        timestamp: new Date().toISOString()
      });
    
    // Step 2: Find connected modules and trigger them
    const connectedModules = await this.getConnectedModules(execution.journey_execution_id, timelineNode.node_id);
    
    for (const moduleNode of connectedModules) {
      try {
        await this.triggerConnectedModule(execution, moduleNode);
        executionResult.triggeredModules = (executionResult.triggeredModules || []).concat([moduleNode.id]);
      } catch (moduleError) {
        console.error(`Failed to trigger module ${moduleNode.id}:`, moduleError);
        executionResult.moduleErrors = (executionResult.moduleErrors || []).concat([{
          moduleId: moduleNode.id,
          error: moduleError.message
        }]);
      }
    }
    
    return executionResult;
  }
  
  private async handleExecutionFailure(executionId: string, error: Error): Promise<void> {
    const maxRetries = 3;
    const retryDelayMinutes = 15;
    
    // Step 1: Get current retry count
    const { data: execution } = await supabase
      .from('timeline_executions')
      .select('error_message, next_retry_at')
      .eq('id', executionId)
      .single();
    
    if (!execution) return;
    
    const currentRetries = execution.error_message ? (execution.error_message.match(/Retry \d+/g) || []).length : 0;
    
    if (currentRetries < maxRetries) {
      // Schedule retry
      const nextRetryAt = new Date(Date.now() + retryDelayMinutes * 60 * 1000);
      
      await supabase
        .from('timeline_executions')
        .update({
          execution_status: 'scheduled', // Reset to scheduled for retry
          error_message: `${error.message} (Retry ${currentRetries + 1}/${maxRetries})`,
          next_retry_at: nextRetryAt.toISOString()
        })
        .eq('id', executionId);
        
      console.log(`Timeline execution ${executionId} scheduled for retry ${currentRetries + 1}/${maxRetries} at ${nextRetryAt}`);
    } else {
      // Max retries exceeded, mark as failed
      await supabase
        .from('timeline_executions')
        .update({
          execution_status: 'failed',
          error_message: `Failed after ${maxRetries} retries: ${error.message}`
        })
        .eq('id', executionId);
        
      // Notify user of timeline failure
      await this.notifyTimelineFailure(executionId, error);
      
      console.error(`Timeline execution ${executionId} failed permanently:`, error);
    }
  }
  
  private async notifyTimelineFailure(executionId: string, error: Error): Promise<void> {
    // Get execution details for notification
    const { data: execution } = await supabase
      .from('timeline_executions')
      .select(`
        *,
        timeline_node:timeline_nodes(label, description),
        client:client_profiles(couple_names),
        journey_execution:journey_executions(
          journey:journeys(name)
        )
      `)
      .eq('id', executionId)
      .single();
    
    if (!execution) return;
    
    // Send notification to supplier
    await supabase
      .from('notifications')
      .insert({
        user_id: execution.journey_execution.journey.supplier_id,
        type: 'timeline_execution_failed',
        title: 'Timeline Execution Failed',
        message: `Timeline "${execution.timeline_node.label}" failed for ${execution.client.couple_names}`,
        data: {
          executionId,
          clientId: execution.client_id,
          journeyId: execution.journey_execution.journey_id,
          error: error.message
        },
        priority: 'high'
      });
  }
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for date/time libraries and business logic
- [ ] Playwright: Test timeline node creation and date calculations
- [x] Filesystem: Access timeline component directories

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/date-fns/date-fns", "date calculations", 3000);
await mcp__context7__get-library-docs("/moment/luxon", "timezone handling", 2000);
await mcp__context7__get-library-docs("/nodejs/node", "cron scheduling", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('Timeline Calculator', () => {
  it('should calculate correct dates with offsets', async () => {
    const calculator = new TimelineCalculator();
    const config = {
      anchorDate: new Date('2024-06-15'),
      offset: { value: 30, unit: 'days', direction: 'before' },
      timezone: 'America/New_York'
    };
    
    const result = await calculator.calculateTimelineDate(config);
    
    expect(result.finalCalculatedDate).toEqual(new Date('2024-05-16'));
  });
  
  it('should adjust for weekends correctly', async () => {
    const calculator = new TimelineCalculator();
    const config = {
      anchorDate: new Date('2024-06-16'), // Sunday
      offset: { value: 0, unit: 'days', direction: 'before' },
      businessRules: { skipWeekends: true }
    };
    
    const result = await calculator.calculateTimelineDate(config);
    
    expect(result.finalCalculatedDate.getDay()).toBe(1); // Monday
    expect(result.adjustments).toHaveLength(1);
    expect(result.adjustments[0].type).toBe('weekend_skip');
  });
  
  it('should handle complex business rules', async () => {
    const processor = new AdvancedBusinessRulesProcessor();
    const rules = {
      skipWeekends: true,
      skipHolidays: true,
      allowedDaysOfWeek: [1, 2, 3, 4, 5], // Monday-Friday
      businessHours: { start: '09:00', end: '17:00' }
    };
    
    const result = await processor.processComplexBusinessRules(
      new Date('2024-07-04 16:00'), // Independence Day, Thursday at 4 PM
      rules,
      { supplierId: 'user1' }
    );
    
    expect(result.adjustments.some(a => a.type === 'holiday_skip')).toBe(true);
  });
});

describe('Timeline Execution Monitor', () => {
  it('should process due executions correctly', async () => {
    const monitor = new TimelineExecutionMonitor();
    const mockExecution = {
      id: 'exec1',
      calculated_date: new Date().toISOString(),
      execution_status: 'scheduled'
    };
    
    jest.spyOn(monitor, 'getDueExecutions').mockResolvedValue([mockExecution]);
    jest.spyOn(monitor, 'processExecution').mockResolvedValue();
    
    await monitor.processExecutionQueue();
    
    expect(monitor.processExecution).toHaveBeenCalledWith(mockExecution);
  });
  
  it('should handle execution failures with retries', async () => {
    const monitor = new TimelineExecutionMonitor();
    const error = new Error('Module execution failed');
    
    await monitor.handleExecutionFailure('exec1', error);
    
    // Should schedule retry
    const { data: execution } = await supabase
      .from('timeline_executions')
      .select('execution_status, next_retry_at, error_message')
      .eq('id', 'exec1')
      .single();
      
    expect(execution.execution_status).toBe('scheduled');
    expect(execution.next_retry_at).toBeDefined();
    expect(execution.error_message).toContain('Retry 1/3');
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Timeline node creation and configuration', async () => {
  await mcp__playwright__browser_navigate({url: '/journeys/canvas/123'});
  
  // Add timeline node to canvas
  await mcp__playwright__browser_drag({
    startElement: 'Timeline module',
    startRef: '[data-testid="module-timeline"]',
    endElement: 'Canvas',
    endRef: '[data-testid="canvas-drop-zone"]'
  });
  
  // Configure timeline node
  await mcp__playwright__browser_click({
    element: 'Timeline node',
    ref: '[data-node-id="timeline-1"]'
  });
  
  // Set anchor type
  await mcp__playwright__browser_select_option({
    element: 'Anchor type',
    ref: '[data-testid="anchor-type"]',
    values: ['wedding_date']
  });
  
  // Set offset
  await mcp__playwright__browser_type({
    element: 'Offset value',
    ref: '[data-testid="offset-value"]',
    text: '7'
  });
  
  await mcp__playwright__browser_select_option({
    element: 'Offset unit',
    ref: '[data-testid="offset-unit"]',
    values: ['days']
  });
  
  await mcp__playwright__browser_select_option({
    element: 'Offset direction',
    ref: '[data-testid="offset-direction"]',
    values: ['before']
  });
  
  // Configure business rules
  await mcp__playwright__browser_click({
    element: 'Skip weekends',
    ref: '[data-testid="skip-weekends"]'
  });
  
  // Set time of day
  await mcp__playwright__browser_type({
    element: 'Time of day',
    ref: '[data-testid="time-of-day"]',
    text: '09:00'
  });
  
  // Preview calculation
  await mcp__playwright__browser_click({
    element: 'Preview calculation',
    ref: '[data-testid="preview-calculation"]'
  });
  
  // Verify calculated date appears
  await mcp__playwright__browser_wait_for({text: 'Calculated date:'});
  
  // Save configuration
  await mcp__playwright__browser_click({
    element: 'Save node',
    ref: '[data-testid="save-node"]'
  });
  
  await mcp__playwright__browser_wait_for({text: 'Timeline node saved'});
});

test('Timeline calculation with business rules', async () => {
  await mcp__playwright__browser_navigate({url: '/timeline/calculator'});
  
  // Set anchor date (Sunday)
  await mcp__playwright__browser_type({
    element: 'Anchor date',
    ref: '[data-testid="anchor-date"]',
    text: '2024-06-16'
  });
  
  // Configure for weekend skip
  await mcp__playwright__browser_click({
    element: 'Skip weekends',
    ref: '[data-testid="skip-weekends"]'
  });
  
  // Calculate
  await mcp__playwright__browser_click({
    element: 'Calculate',
    ref: '[data-testid="calculate"]'
  });
  
  // Verify adjustment message
  await mcp__playwright__browser_wait_for({text: 'Moved from Sunday to Monday'});
  
  // Verify final date is Monday
  const finalDate = await mcp__playwright__browser_evaluate({
    function: () => document.querySelector('[data-testid="final-date"]')?.textContent
  });
  
  expect(finalDate).toContain('Monday');
});

test('Timeline execution monitoring', async () => {
  await mcp__playwright__browser_navigate({url: '/journeys/executions'});
  
  // View timeline executions
  await mcp__playwright__browser_wait_for({text: 'Timeline Executions'});
  
  // Check for due executions
  await mcp__playwright__browser_click({
    element: 'Due today filter',
    ref: '[data-testid="filter-due-today"]'
  });
  
  // Process execution manually
  await mcp__playwright__browser_click({
    element: 'Process execution',
    ref: '[data-testid="process-execution-1"]'
  });
  
  // Verify status updates
  await mcp__playwright__browser_wait_for({text: 'Executing'});
  await mcp__playwright__browser_wait_for({text: 'Completed'});
  
  // Check execution details
  await mcp__playwright__browser_click({
    element: 'View details',
    ref: '[data-testid="view-execution-details"]'
  });
  
  await mcp__playwright__browser_wait_for({text: 'Execution Result'});
});
```

### ACCEPTANCE CRITERIA
- [ ] Timeline nodes calculate dates accurately with all offset types
- [ ] Business rules (weekends, holidays, hours) apply correctly
- [ ] Multiple timezone support with automatic conversions
- [ ] Real-time calculation preview updates as inputs change
- [ ] Complex business rules (workload balancing, allowed days) function
- [ ] Timeline execution monitoring processes scheduled tasks
- [ ] Failed executions retry automatically with exponential backoff
- [ ] Analytics track execution success rates and delays
- [ ] Client-specific rules and preferences apply correctly
- [ ] Holiday calendar integration works for multiple countries
- [ ] Performance handles 1000+ concurrent timeline calculations
- [ ] Date adjustments clearly explain reasons for changes

### DEPENDENCIES
- Must complete after: WS-013 (Journey Canvas integration)
- Must complete before: WS-015 (Conditional Branching - timeline triggers)
- Shares code with: WS-013 (canvas engine), WS-015 (execution engine)

### ESTIMATED EFFORT
- Team A Frontend: 28 hours
- Team B Backend: 24 hours
- Team C Integration: 8 hours
- Total: 60 hours