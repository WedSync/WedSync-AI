# TECHNICAL SPECIFICATION: WS-345 - Email Automation Engine
## Generated by Feature Development Session - 2025-01-31

### USER STORY & BUSINESS CONTEXT
**As a:** Wedding supplier managing multiple clients simultaneously
**I want to:** Automatically send personalized emails based on client actions, dates, and workflows without manual intervention
**So that:** I can maintain consistent communication, nurture leads, follow up on bookings, and provide exceptional client experience while saving hours of manual work

**Real Wedding Scenario:**
When Sarah, a bride, submits a booking inquiry form on a photographer's website at 2 AM, the Email Automation Engine immediately sends a personalized welcome email with pricing information and portfolio link. Three days later, if no response, it automatically sends a follow-up with client testimonials. Two weeks before the wedding date, it sends a timeline confirmation email. After the wedding, it sends a thank-you email requesting reviews and referrals. All completely automated, personalized, and professional.

**Business Impact:**
- Increases lead conversion by 300% through immediate automated responses
- Reduces manual email work from 10 hours/week to 30 minutes/week
- Provides 24/7 professional communication even when supplier is busy
- Ensures no client communication falls through the cracks
- Critical for PROFESSIONAL tier value proposition ($49/month)
- Enables suppliers to scale without hiring additional staff

### SPECIFICATION SOURCE
- **Feature ID:** WS-345
- **Priority Level:** HIGH PRIORITY (Client Communication & Conversion)
- **Estimated Effort:** 110 hours total
- **Dependencies:** Form Builder, Client Management, Email Service Integration
- **Revenue Impact:** Major conversion improvement and tier upgrade driver

### TECHNICAL DESIGN

#### Database Schema Required

```sql
-- Email Templates (reusable email designs)
CREATE TABLE email_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    template_name TEXT NOT NULL,
    template_description TEXT,
    template_category TEXT NOT NULL CHECK (template_category IN (
        'welcome', 'follow_up', 'booking_confirmation', 'payment_reminder', 
        'pre_event', 'post_event', 'birthday', 'anniversary', 'newsletter',
        'promotional', 'thank_you', 'review_request', 'referral_request', 'custom'
    )),
    
    -- Email Content
    email_subject TEXT NOT NULL,
    email_body_html TEXT NOT NULL,
    email_body_text TEXT, -- Plain text version
    
    -- Template Settings
    is_active BOOLEAN DEFAULT true,
    is_system_template BOOLEAN DEFAULT false, -- WedSync provided templates
    sender_name TEXT,
    sender_email TEXT,
    reply_to_email TEXT,
    
    -- Personalization
    merge_fields JSONB DEFAULT '[]', -- Available merge fields like {{client_name}}, {{wedding_date}}
    dynamic_content JSONB DEFAULT '{}', -- Conditional content blocks
    
    -- Scheduling and Delivery
    send_immediately BOOLEAN DEFAULT true,
    delay_minutes INTEGER DEFAULT 0, -- Delay before sending
    optimal_send_time TIME, -- Preferred time to send (e.g., 10:00 AM)
    
    -- Analytics and Performance
    open_rate_percent DECIMAL(5,2) DEFAULT 0,
    click_rate_percent DECIMAL(5,2) DEFAULT 0,
    unsubscribe_rate_percent DECIMAL(5,2) DEFAULT 0,
    total_sent INTEGER DEFAULT 0,
    
    -- A/B Testing
    is_ab_test BOOLEAN DEFAULT false,
    ab_test_group TEXT, -- 'A' or 'B'
    ab_test_percentage INTEGER DEFAULT 50, -- % of recipients for this variant
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(supplier_id, template_name)
);

-- Email Automation Workflows
CREATE TABLE email_workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    workflow_name TEXT NOT NULL,
    workflow_description TEXT,
    
    -- Workflow Status
    workflow_status TEXT NOT NULL CHECK (workflow_status IN (
        'draft', 'active', 'paused', 'completed', 'archived'
    )) DEFAULT 'draft',
    
    -- Trigger Configuration
    trigger_type TEXT NOT NULL CHECK (trigger_type IN (
        'form_submission', 'client_created', 'payment_received', 'date_based',
        'client_action', 'manual_trigger', 'webhook', 'api_call'
    )),
    trigger_config JSONB NOT NULL DEFAULT '{}', -- Specific trigger conditions
    
    -- Workflow Execution
    total_executions INTEGER DEFAULT 0,
    successful_executions INTEGER DEFAULT 0,
    failed_executions INTEGER DEFAULT 0,
    last_executed_at TIMESTAMPTZ,
    
    -- Timing and Scheduling
    is_recurring BOOLEAN DEFAULT false,
    recurrence_pattern TEXT, -- 'daily', 'weekly', 'monthly', 'yearly'
    recurrence_config JSONB, -- Detailed recurrence settings
    
    -- Performance Metrics
    conversion_rate_percent DECIMAL(5,2) DEFAULT 0,
    avg_open_rate_percent DECIMAL(5,2) DEFAULT 0,
    avg_click_rate_percent DECIMAL(5,2) DEFAULT 0,
    
    -- Workflow Settings
    max_executions_per_client INTEGER DEFAULT 1, -- Prevent spam
    cooldown_hours INTEGER DEFAULT 24, -- Minimum time between executions
    is_active BOOLEAN DEFAULT true,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    INDEX (supplier_id, workflow_status),
    INDEX (trigger_type, workflow_status)
);

-- Email Workflow Steps (sequence of actions in a workflow)
CREATE TABLE email_workflow_steps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES email_workflows(id) ON DELETE CASCADE,
    step_number INTEGER NOT NULL,
    step_name TEXT NOT NULL,
    step_type TEXT NOT NULL CHECK (step_type IN (
        'send_email', 'wait', 'condition', 'update_client', 'trigger_webhook', 'add_tag', 'remove_tag'
    )),
    
    -- Step Configuration
    step_config JSONB NOT NULL DEFAULT '{}',
    email_template_id UUID REFERENCES email_templates(id),
    
    -- Conditional Logic
    condition_type TEXT CHECK (condition_type IN (
        'always', 'if_opened', 'if_not_opened', 'if_clicked', 'if_not_clicked',
        'if_replied', 'if_not_replied', 'if_field_equals', 'if_date_passed'
    )) DEFAULT 'always',
    condition_config JSONB DEFAULT '{}',
    
    -- Timing
    delay_type TEXT CHECK (delay_type IN ('immediate', 'minutes', 'hours', 'days', 'weeks', 'months')) DEFAULT 'immediate',
    delay_amount INTEGER DEFAULT 0,
    delay_from_step INTEGER, -- Reference to previous step
    
    -- A/B Testing
    is_ab_test BOOLEAN DEFAULT false,
    ab_split_percentage INTEGER DEFAULT 50,
    
    -- Performance Tracking
    executions_count INTEGER DEFAULT 0,
    success_rate_percent DECIMAL(5,2) DEFAULT 0,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(workflow_id, step_number),
    FOREIGN KEY (workflow_id, delay_from_step) REFERENCES email_workflow_steps(workflow_id, step_number) DEFERRABLE
);

-- Client Email Workflow Instances (active workflows for specific clients)
CREATE TABLE client_email_workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    client_id UUID NOT NULL REFERENCES clients(id) ON DELETE CASCADE,
    workflow_id UUID NOT NULL REFERENCES email_workflows(id),
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    
    -- Execution Status
    execution_status TEXT NOT NULL CHECK (execution_status IN (
        'active', 'completed', 'paused', 'cancelled', 'failed'
    )) DEFAULT 'active',
    
    -- Progress Tracking
    current_step_number INTEGER DEFAULT 1,
    next_execution_at TIMESTAMPTZ,
    steps_completed INTEGER DEFAULT 0,
    total_steps INTEGER NOT NULL,
    
    -- Performance Metrics
    emails_sent INTEGER DEFAULT 0,
    emails_opened INTEGER DEFAULT 0,
    emails_clicked INTEGER DEFAULT 0,
    conversion_achieved BOOLEAN DEFAULT false,
    conversion_value DECIMAL(10,2),
    
    -- Timing
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    last_step_executed_at TIMESTAMPTZ,
    
    -- Context Data
    context_data JSONB DEFAULT '{}', -- Client-specific data for personalization
    trigger_data JSONB DEFAULT '{}', -- Data that triggered this workflow
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(client_id, workflow_id), -- One workflow per client at a time
    INDEX (execution_status, next_execution_at),
    INDEX (client_id, execution_status),
    INDEX (workflow_id, execution_status)
);

-- Email Send Queue (scheduled and immediate emails)
CREATE TABLE email_send_queue (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    client_id UUID NOT NULL REFERENCES clients(id) ON DELETE CASCADE,
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    client_workflow_id UUID REFERENCES client_email_workflows(id) ON DELETE CASCADE,
    workflow_step_id UUID REFERENCES email_workflow_steps(id),
    email_template_id UUID NOT NULL REFERENCES email_templates(id),
    
    -- Email Details
    recipient_email TEXT NOT NULL,
    recipient_name TEXT,
    sender_email TEXT NOT NULL,
    sender_name TEXT,
    reply_to_email TEXT,
    email_subject TEXT NOT NULL,
    email_body_html TEXT NOT NULL,
    email_body_text TEXT,
    
    -- Scheduling
    scheduled_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    priority INTEGER DEFAULT 5 CHECK (priority >= 1 AND priority <= 10), -- 1 = highest priority
    
    -- Send Status
    send_status TEXT NOT NULL CHECK (send_status IN (
        'queued', 'sending', 'sent', 'failed', 'cancelled'
    )) DEFAULT 'queued',
    
    -- Delivery Tracking
    sent_at TIMESTAMPTZ,
    external_message_id TEXT, -- Resend/SendGrid message ID
    delivery_status TEXT CHECK (delivery_status IN (
        'pending', 'delivered', 'bounced', 'deferred', 'spam', 'blocked'
    )),
    delivered_at TIMESTAMPTZ,
    
    -- Engagement Tracking
    opened_at TIMESTAMPTZ,
    first_opened_at TIMESTAMPTZ,
    open_count INTEGER DEFAULT 0,
    last_clicked_at TIMESTAMPTZ,
    click_count INTEGER DEFAULT 0,
    unsubscribed_at TIMESTAMPTZ,
    
    -- Error Handling
    retry_count INTEGER DEFAULT 0,
    max_retries INTEGER DEFAULT 3,
    last_error_message TEXT,
    failed_at TIMESTAMPTZ,
    
    -- Personalization Data
    merge_data JSONB DEFAULT '{}', -- Data used for personalization
    tracking_data JSONB DEFAULT '{}', -- UTM parameters, custom tracking
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    INDEX (send_status, priority, scheduled_at),
    INDEX (client_id, send_status),
    INDEX (supplier_id, scheduled_at),
    INDEX (external_message_id)
);

-- Email Engagement Tracking
CREATE TABLE email_engagements (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email_queue_id UUID NOT NULL REFERENCES email_send_queue(id) ON DELETE CASCADE,
    client_id UUID NOT NULL REFERENCES clients(id) ON DELETE CASCADE,
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    
    -- Engagement Details
    engagement_type TEXT NOT NULL CHECK (engagement_type IN (
        'open', 'click', 'reply', 'forward', 'unsubscribe', 'spam_report'
    )),
    engagement_data JSONB DEFAULT '{}', -- Link clicked, device info, etc.
    
    -- Context Information
    ip_address INET,
    user_agent TEXT,
    device_type TEXT, -- 'desktop', 'mobile', 'tablet'
    email_client TEXT, -- 'gmail', 'outlook', 'apple_mail', etc.
    location_data JSONB, -- City, country from IP
    
    -- Timing
    engaged_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    INDEX (email_queue_id, engagement_type),
    INDEX (client_id, engagement_type, engaged_at),
    INDEX (supplier_id, engaged_at)
);

-- Email Unsubscribes (manage opt-outs)
CREATE TABLE email_unsubscribes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    client_id UUID NOT NULL REFERENCES clients(id) ON DELETE CASCADE,
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    email_address TEXT NOT NULL,
    
    -- Unsubscribe Details
    unsubscribe_type TEXT NOT NULL CHECK (unsubscribe_type IN (
        'all_emails', 'marketing_emails', 'workflow_emails', 'specific_template'
    )),
    unsubscribe_reason TEXT,
    template_id UUID REFERENCES email_templates(id), -- For specific template unsubscribes
    
    -- Source Information
    unsubscribed_from_email_id UUID REFERENCES email_send_queue(id),
    unsubscribe_method TEXT CHECK (unsubscribe_method IN (
        'email_link', 'reply', 'spam_report', 'manual', 'gdpr_request'
    )),
    
    -- Timing
    unsubscribed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    can_resubscribe BOOLEAN DEFAULT true,
    resubscribed_at TIMESTAMPTZ,
    
    UNIQUE(client_id, supplier_id, unsubscribe_type),
    INDEX (email_address, supplier_id),
    INDEX (supplier_id, unsubscribe_type)
);

-- Email Campaign Analytics (aggregated metrics)
CREATE TABLE email_campaign_analytics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    workflow_id UUID REFERENCES email_workflows(id) ON DELETE CASCADE,
    template_id UUID REFERENCES email_templates(id) ON DELETE CASCADE,
    
    -- Time Period
    analytics_date DATE NOT NULL,
    analytics_period TEXT NOT NULL CHECK (analytics_period IN (
        'daily', 'weekly', 'monthly', 'quarterly', 'yearly'
    )),
    
    -- Email Metrics
    emails_sent INTEGER DEFAULT 0,
    emails_delivered INTEGER DEFAULT 0,
    emails_bounced INTEGER DEFAULT 0,
    emails_opened INTEGER DEFAULT 0,
    unique_opens INTEGER DEFAULT 0,
    emails_clicked INTEGER DEFAULT 0,
    unique_clicks INTEGER DEFAULT 0,
    emails_replied INTEGER DEFAULT 0,
    emails_forwarded INTEGER DEFAULT 0,
    emails_unsubscribed INTEGER DEFAULT 0,
    spam_reports INTEGER DEFAULT 0,
    
    -- Calculated Rates
    delivery_rate_percent DECIMAL(5,2) DEFAULT 0,
    open_rate_percent DECIMAL(5,2) DEFAULT 0,
    click_rate_percent DECIMAL(5,2) DEFAULT 0,
    click_to_open_rate_percent DECIMAL(5,2) DEFAULT 0,
    unsubscribe_rate_percent DECIMAL(5,2) DEFAULT 0,
    
    -- Business Metrics
    leads_generated INTEGER DEFAULT 0,
    bookings_generated INTEGER DEFAULT 0,
    revenue_generated DECIMAL(10,2) DEFAULT 0,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(supplier_id, analytics_date, analytics_period, workflow_id, template_id),
    INDEX (supplier_id, analytics_date, analytics_period)
);

-- Email Settings (per supplier configuration)
CREATE TABLE email_settings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    
    -- Sender Information
    default_sender_name TEXT NOT NULL,
    default_sender_email TEXT NOT NULL,
    default_reply_to_email TEXT,
    
    -- Email Service Provider
    email_provider TEXT NOT NULL CHECK (email_provider IN (
        'resend', 'sendgrid', 'mailgun', 'ses', 'postmark'
    )) DEFAULT 'resend',
    provider_api_key TEXT, -- Encrypted
    provider_config JSONB DEFAULT '{}',
    
    -- Sending Limits and Throttling
    daily_send_limit INTEGER DEFAULT 1000,
    hourly_send_limit INTEGER DEFAULT 100,
    sends_per_minute INTEGER DEFAULT 10,
    
    -- Email Preferences
    track_opens BOOLEAN DEFAULT true,
    track_clicks BOOLEAN DEFAULT true,
    include_unsubscribe_link BOOLEAN DEFAULT true,
    auto_add_utm_parameters BOOLEAN DEFAULT true,
    
    -- Branding and Design
    email_signature TEXT,
    company_logo_url TEXT,
    brand_color_primary TEXT DEFAULT '#3b82f6',
    brand_color_secondary TEXT DEFAULT '#1e40af',
    
    -- Compliance
    gdpr_compliant BOOLEAN DEFAULT true,
    can_spam_compliant BOOLEAN DEFAULT true,
    include_physical_address BOOLEAN DEFAULT true,
    physical_address TEXT,
    
    -- Automation Settings
    max_emails_per_client_per_day INTEGER DEFAULT 3,
    quiet_hours_start TIME DEFAULT '22:00',
    quiet_hours_end TIME DEFAULT '08:00',
    timezone TEXT DEFAULT 'Europe/London',
    
    -- A/B Testing
    ab_testing_enabled BOOLEAN DEFAULT false,
    default_ab_test_duration_days INTEGER DEFAULT 7,
    ab_test_sample_size_percent INTEGER DEFAULT 20,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(supplier_id)
);

-- Add email automation fields to forms table
ALTER TABLE forms ADD COLUMN IF NOT EXISTS email_automation_enabled BOOLEAN DEFAULT false;
ALTER TABLE forms ADD COLUMN IF NOT EXISTS welcome_email_template_id UUID REFERENCES email_templates(id);
ALTER TABLE forms ADD COLUMN IF NOT EXISTS follow_up_workflow_id UUID REFERENCES email_workflows(id);
ALTER TABLE forms ADD COLUMN IF NOT EXISTS auto_trigger_workflows UUID[] DEFAULT '{}'; -- Array of workflow IDs to trigger

-- Add automation tracking to clients table  
ALTER TABLE clients ADD COLUMN IF NOT EXISTS email_marketing_consent BOOLEAN DEFAULT false;
ALTER TABLE clients ADD COLUMN IF NOT EXISTS email_marketing_consented_at TIMESTAMPTZ;
ALTER TABLE clients ADD COLUMN IF NOT EXISTS total_emails_received INTEGER DEFAULT 0;
ALTER TABLE clients ADD COLUMN IF NOT EXISTS last_email_opened_at TIMESTAMPTZ;
ALTER TABLE clients ADD COLUMN IF NOT EXISTS email_engagement_score INTEGER DEFAULT 0 CHECK (email_engagement_score >= 0 AND email_engagement_score <= 100);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_email_queue_status_scheduled ON email_send_queue(send_status, scheduled_at);
CREATE INDEX IF NOT EXISTS idx_email_queue_supplier_date ON email_send_queue(supplier_id, created_at);
CREATE INDEX IF NOT EXISTS idx_workflow_instances_next_execution ON client_email_workflows(execution_status, next_execution_at);
CREATE INDEX IF NOT EXISTS idx_email_engagements_client_type ON email_engagements(client_id, engagement_type);
CREATE INDEX IF NOT EXISTS idx_templates_supplier_category ON email_templates(supplier_id, template_category, is_active);
```

#### API Endpoints Required

```typescript
// Email Automation Types
interface EmailTemplate {
  id: string;
  supplier_id: string;
  template_name: string;
  template_description?: string;
  template_category: 'welcome' | 'follow_up' | 'booking_confirmation' | 'payment_reminder' | 
                     'pre_event' | 'post_event' | 'birthday' | 'anniversary' | 'newsletter' |
                     'promotional' | 'thank_you' | 'review_request' | 'referral_request' | 'custom';
  email_subject: string;
  email_body_html: string;
  email_body_text?: string;
  is_active: boolean;
  is_system_template: boolean;
  sender_name?: string;
  sender_email?: string;
  reply_to_email?: string;
  merge_fields: MergeField[];
  dynamic_content: Record<string, any>;
  send_immediately: boolean;
  delay_minutes: number;
  optimal_send_time?: string;
  open_rate_percent: number;
  click_rate_percent: number;
  unsubscribe_rate_percent: number;
  total_sent: number;
  is_ab_test: boolean;
  ab_test_group?: string;
  ab_test_percentage: number;
  created_at: string;
  updated_at: string;
}

interface MergeField {
  name: string;
  label: string;
  type: 'text' | 'date' | 'number' | 'currency' | 'url' | 'image';
  default_value?: string;
  required: boolean;
  description: string;
}

interface EmailWorkflow {
  id: string;
  supplier_id: string;
  workflow_name: string;
  workflow_description?: string;
  workflow_status: 'draft' | 'active' | 'paused' | 'completed' | 'archived';
  trigger_type: 'form_submission' | 'client_created' | 'payment_received' | 'date_based' | 
                'client_action' | 'manual_trigger' | 'webhook' | 'api_call';
  trigger_config: Record<string, any>;
  total_executions: number;
  successful_executions: number;
  failed_executions: number;
  last_executed_at?: string;
  is_recurring: boolean;
  recurrence_pattern?: string;
  recurrence_config?: Record<string, any>;
  conversion_rate_percent: number;
  avg_open_rate_percent: number;
  avg_click_rate_percent: number;
  max_executions_per_client: number;
  cooldown_hours: number;
  is_active: boolean;
  steps: EmailWorkflowStep[];
  created_at: string;
  updated_at: string;
}

interface EmailWorkflowStep {
  id: string;
  workflow_id: string;
  step_number: number;
  step_name: string;
  step_type: 'send_email' | 'wait' | 'condition' | 'update_client' | 'trigger_webhook' | 'add_tag' | 'remove_tag';
  step_config: Record<string, any>;
  email_template_id?: string;
  condition_type: 'always' | 'if_opened' | 'if_not_opened' | 'if_clicked' | 'if_not_clicked' |
                  'if_replied' | 'if_not_replied' | 'if_field_equals' | 'if_date_passed';
  condition_config: Record<string, any>;
  delay_type: 'immediate' | 'minutes' | 'hours' | 'days' | 'weeks' | 'months';
  delay_amount: number;
  delay_from_step?: number;
  is_ab_test: boolean;
  ab_split_percentage: number;
  executions_count: number;
  success_rate_percent: number;
  created_at: string;
}

interface ClientEmailWorkflow {
  id: string;
  client_id: string;
  workflow_id: string;
  supplier_id: string;
  execution_status: 'active' | 'completed' | 'paused' | 'cancelled' | 'failed';
  current_step_number: number;
  next_execution_at?: string;
  steps_completed: number;
  total_steps: number;
  emails_sent: number;
  emails_opened: number;
  emails_clicked: number;
  conversion_achieved: boolean;
  conversion_value?: number;
  started_at: string;
  completed_at?: string;
  last_step_executed_at?: string;
  context_data: Record<string, any>;
  trigger_data: Record<string, any>;
  created_at: string;
  updated_at: string;
}

interface EmailSendQueue {
  id: string;
  client_id: string;
  supplier_id: string;
  client_workflow_id?: string;
  workflow_step_id?: string;
  email_template_id: string;
  recipient_email: string;
  recipient_name?: string;
  sender_email: string;
  sender_name?: string;
  reply_to_email?: string;
  email_subject: string;
  email_body_html: string;
  email_body_text?: string;
  scheduled_at: string;
  priority: number;
  send_status: 'queued' | 'sending' | 'sent' | 'failed' | 'cancelled';
  sent_at?: string;
  external_message_id?: string;
  delivery_status?: 'pending' | 'delivered' | 'bounced' | 'deferred' | 'spam' | 'blocked';
  delivered_at?: string;
  opened_at?: string;
  first_opened_at?: string;
  open_count: number;
  last_clicked_at?: string;
  click_count: number;
  unsubscribed_at?: string;
  retry_count: number;
  max_retries: number;
  last_error_message?: string;
  failed_at?: string;
  merge_data: Record<string, any>;
  tracking_data: Record<string, any>;
  created_at: string;
  updated_at: string;
}

interface EmailEngagement {
  id: string;
  email_queue_id: string;
  client_id: string;
  supplier_id: string;
  engagement_type: 'open' | 'click' | 'reply' | 'forward' | 'unsubscribe' | 'spam_report';
  engagement_data: Record<string, any>;
  ip_address?: string;
  user_agent?: string;
  device_type?: string;
  email_client?: string;
  location_data?: Record<string, any>;
  engaged_at: string;
}

interface EmailAnalytics {
  supplier_id: string;
  workflow_id?: string;
  template_id?: string;
  analytics_date: string;
  analytics_period: 'daily' | 'weekly' | 'monthly' | 'quarterly' | 'yearly';
  emails_sent: number;
  emails_delivered: number;
  emails_bounced: number;
  emails_opened: number;
  unique_opens: number;
  emails_clicked: number;
  unique_clicks: number;
  emails_replied: number;
  emails_forwarded: number;
  emails_unsubscribed: number;
  spam_reports: number;
  delivery_rate_percent: number;
  open_rate_percent: number;
  click_rate_percent: number;
  click_to_open_rate_percent: number;
  unsubscribe_rate_percent: number;
  leads_generated: number;
  bookings_generated: number;
  revenue_generated: number;
  created_at: string;
}

// API Endpoints

// Email Templates
// GET /api/email/templates - List email templates
interface GetEmailTemplatesResponse {
  templates: EmailTemplate[];
  system_templates: EmailTemplate[]; // WedSync provided templates
  total: number;
  page: number;
  per_page: number;
}

// POST /api/email/templates - Create email template
interface CreateEmailTemplateRequest {
  template_name: string;
  template_description?: string;
  template_category: string;
  email_subject: string;
  email_body_html: string;
  email_body_text?: string;
  sender_name?: string;
  sender_email?: string;
  reply_to_email?: string;
  merge_fields?: MergeField[];
  dynamic_content?: Record<string, any>;
  send_immediately?: boolean;
  delay_minutes?: number;
  optimal_send_time?: string;
}

interface CreateEmailTemplateResponse {
  template: EmailTemplate;
  merge_fields_detected: MergeField[]; // Auto-detected from content
}

// PUT /api/email/templates/:id - Update email template
interface UpdateEmailTemplateRequest {
  template_name?: string;
  template_description?: string;
  email_subject?: string;
  email_body_html?: string;
  email_body_text?: string;
  is_active?: boolean;
  merge_fields?: MergeField[];
}

// POST /api/email/templates/:id/duplicate - Duplicate template
interface DuplicateEmailTemplateResponse {
  template: EmailTemplate;
}

// POST /api/email/templates/:id/test - Send test email
interface SendTestEmailRequest {
  test_email: string;
  test_data: Record<string, any>; // Data for merge fields
}

interface SendTestEmailResponse {
  success: boolean;
  message_id?: string;
  preview_html: string;
  preview_text: string;
}

// Email Workflows
// GET /api/email/workflows - List email workflows
interface GetEmailWorkflowsResponse {
  workflows: EmailWorkflow[];
  total: number;
  page: number;
  per_page: number;
}

// POST /api/email/workflows - Create email workflow
interface CreateEmailWorkflowRequest {
  workflow_name: string;
  workflow_description?: string;
  trigger_type: string;
  trigger_config: Record<string, any>;
  is_recurring?: boolean;
  recurrence_pattern?: string;
  recurrence_config?: Record<string, any>;
  max_executions_per_client?: number;
  cooldown_hours?: number;
  steps: Omit<EmailWorkflowStep, 'id' | 'workflow_id' | 'created_at'>[];
}

interface CreateEmailWorkflowResponse {
  workflow: EmailWorkflow;
  validation_errors?: WorkflowValidationError[];
}

interface WorkflowValidationError {
  step_number: number;
  field: string;
  error: string;
  suggestion?: string;
}

// PUT /api/email/workflows/:id - Update workflow
interface UpdateEmailWorkflowRequest {
  workflow_name?: string;
  workflow_description?: string;
  workflow_status?: string;
  trigger_config?: Record<string, any>;
  steps?: Omit<EmailWorkflowStep, 'id' | 'workflow_id' | 'created_at'>[];
}

// POST /api/email/workflows/:id/activate - Activate workflow
interface ActivateWorkflowResponse {
  workflow: EmailWorkflow;
  affected_clients: number; // Clients who will enter this workflow
}

// POST /api/email/workflows/:id/test - Test workflow with sample data
interface TestWorkflowRequest {
  test_client_data: Record<string, any>;
  test_trigger_data?: Record<string, any>;
}

interface TestWorkflowResponse {
  success: boolean;
  steps_executed: number;
  emails_would_send: number;
  execution_log: WorkflowExecutionLogEntry[];
}

interface WorkflowExecutionLogEntry {
  step_number: number;
  step_name: string;
  step_type: string;
  executed: boolean;
  delay_applied: string;
  email_preview?: string;
  error_message?: string;
}

// POST /api/email/workflows/:id/trigger - Manually trigger workflow for client
interface TriggerWorkflowRequest {
  client_id: string;
  trigger_data?: Record<string, any>;
  context_data?: Record<string, any>;
}

interface TriggerWorkflowResponse {
  client_workflow: ClientEmailWorkflow;
  next_execution_at?: string;
}

// Email Sending
// POST /api/email/send - Send individual email
interface SendEmailRequest {
  client_id: string;
  template_id: string;
  merge_data?: Record<string, any>;
  scheduled_at?: string;
  priority?: number;
  tracking_data?: Record<string, any>;
}

interface SendEmailResponse {
  email_queue_id: string;
  scheduled_at: string;
  estimated_delivery: string;
}

// POST /api/email/send-bulk - Send bulk emails
interface SendBulkEmailRequest {
  template_id: string;
  recipients: BulkEmailRecipient[];
  scheduled_at?: string;
  priority?: number;
  batch_size?: number; // For throttling
}

interface BulkEmailRecipient {
  client_id: string;
  email: string;
  name?: string;
  merge_data?: Record<string, any>;
}

interface SendBulkEmailResponse {
  batch_id: string;
  total_emails: number;
  emails_queued: number;
  emails_failed: number;
  estimated_completion: string;
}

// Email Analytics
// GET /api/email/analytics - Get email analytics
interface GetEmailAnalyticsRequest {
  start_date: string;
  end_date: string;
  workflow_id?: string;
  template_id?: string;
  period?: 'daily' | 'weekly' | 'monthly';
}

interface GetEmailAnalyticsResponse {
  analytics: EmailAnalytics[];
  summary: {
    total_sent: number;
    total_delivered: number;
    total_opened: number;
    total_clicked: number;
    avg_open_rate: number;
    avg_click_rate: number;
    avg_conversion_rate: number;
    total_revenue: number;
  };
  top_performing: {
    templates: EmailTemplate[];
    workflows: EmailWorkflow[];
  };
  trends: {
    date: string;
    sent: number;
    opened: number;
    clicked: number;
    converted: number;
  }[];
}

// GET /api/email/analytics/performance - Template/workflow performance comparison
interface GetPerformanceAnalyticsResponse {
  templates: {
    template: EmailTemplate;
    metrics: {
      sent: number;
      open_rate: number;
      click_rate: number;
      conversion_rate: number;
      revenue: number;
    };
  }[];
  workflows: {
    workflow: EmailWorkflow;
    metrics: {
      active_clients: number;
      completion_rate: number;
      avg_open_rate: number;
      avg_click_rate: number;
      conversion_rate: number;
      revenue: number;
    };
  }[];
}

// Client Workflow Management
// GET /api/email/client-workflows - List client workflows
interface GetClientWorkflowsResponse {
  client_workflows: ClientEmailWorkflow[];
  total: number;
  page: number;
  per_page: number;
}

// PUT /api/email/client-workflows/:id - Update client workflow
interface UpdateClientWorkflowRequest {
  execution_status?: string;
  context_data?: Record<string, any>;
  skip_to_step?: number;
}

// POST /api/email/client-workflows/:id/pause - Pause workflow
interface PauseClientWorkflowResponse {
  client_workflow: ClientEmailWorkflow;
  next_scheduled_email_cancelled: boolean;
}

// POST /api/email/client-workflows/:id/resume - Resume workflow
interface ResumeClientWorkflowResponse {
  client_workflow: ClientEmailWorkflow;
  next_execution_at: string;
}

// Unsubscribe Management
// POST /api/email/unsubscribe - Process unsubscribe
interface UnsubscribeRequest {
  email_queue_id?: string;
  client_id?: string;
  email_address: string;
  unsubscribe_type: 'all_emails' | 'marketing_emails' | 'workflow_emails' | 'specific_template';
  template_id?: string;
  reason?: string;
}

interface UnsubscribeResponse {
  success: boolean;
  message: string;
  unsubscribe_id: string;
}

// GET /api/email/unsubscribes - List unsubscribes
interface GetUnsubscribesResponse {
  unsubscribes: EmailUnsubscribe[];
  total: number;
  page: number;
  per_page: number;
}

interface EmailUnsubscribe {
  id: string;
  client_id: string;
  supplier_id: string;
  email_address: string;
  unsubscribe_type: string;
  unsubscribe_reason?: string;
  template_id?: string;
  unsubscribed_from_email_id?: string;
  unsubscribe_method: string;
  unsubscribed_at: string;
  can_resubscribe: boolean;
  resubscribed_at?: string;
}

// Email Settings
// GET /api/email/settings - Get email settings
interface GetEmailSettingsResponse {
  settings: EmailSettings;
  provider_status: {
    connected: boolean;
    daily_quota_used: number;
    daily_quota_limit: number;
    last_error?: string;
  };
}

interface EmailSettings {
  id: string;
  supplier_id: string;
  default_sender_name: string;
  default_sender_email: string;
  default_reply_to_email?: string;
  email_provider: 'resend' | 'sendgrid' | 'mailgun' | 'ses' | 'postmark';
  provider_config: Record<string, any>;
  daily_send_limit: number;
  hourly_send_limit: number;
  sends_per_minute: number;
  track_opens: boolean;
  track_clicks: boolean;
  include_unsubscribe_link: boolean;
  auto_add_utm_parameters: boolean;
  email_signature?: string;
  company_logo_url?: string;
  brand_color_primary: string;
  brand_color_secondary: string;
  gdpr_compliant: boolean;
  can_spam_compliant: boolean;
  include_physical_address: boolean;
  physical_address?: string;
  max_emails_per_client_per_day: number;
  quiet_hours_start: string;
  quiet_hours_end: string;
  timezone: string;
  ab_testing_enabled: boolean;
  default_ab_test_duration_days: number;
  ab_test_sample_size_percent: number;
  created_at: string;
  updated_at: string;
}

// PUT /api/email/settings - Update email settings
interface UpdateEmailSettingsRequest {
  default_sender_name?: string;
  default_sender_email?: string;
  default_reply_to_email?: string;
  email_provider?: string;
  provider_api_key?: string;
  daily_send_limit?: number;
  hourly_send_limit?: number;
  track_opens?: boolean;
  track_clicks?: boolean;
  email_signature?: string;
  company_logo_url?: string;
  brand_color_primary?: string;
  brand_color_secondary?: string;
  physical_address?: string;
  max_emails_per_client_per_day?: number;
  quiet_hours_start?: string;
  quiet_hours_end?: string;
  timezone?: string;
}

// POST /api/email/settings/test-connection - Test email provider connection
interface TestEmailConnectionResponse {
  success: boolean;
  provider: string;
  quota_remaining: number;
  send_rate_limit: number;
  error_message?: string;
}
```

### IMPLEMENTATION DETAILS

#### Frontend Email Automation Components

```typescript
// Email Template Editor Component
import React, { useState, useEffect, useRef } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { Badge } from '@/components/ui/badge';
import { 
  Mail, 
  Eye, 
  Send, 
  Save, 
  Copy, 
  Trash2, 
  Settings, 
  BarChart3,
  Wand2,
  Code,
  Smartphone,
  Monitor,
  Play
} from 'lucide-react';

interface EmailTemplateEditorProps {
  templateId?: string;
  onSave?: (template: EmailTemplate) => void;
  onCancel?: () => void;
}

const EmailTemplateEditor: React.FC<EmailTemplateEditorProps> = ({ 
  templateId, 
  onSave, 
  onCancel 
}) => {
  const [template, setTemplate] = useState<Partial<EmailTemplate>>({
    template_name: '',
    template_category: 'welcome',
    email_subject: '',
    email_body_html: '',
    email_body_text: '',
    merge_fields: [],
    is_active: true
  });
  
  const [previewMode, setPreviewMode] = useState<'desktop' | 'mobile'>('desktop');
  const [showCode, setShowCode] = useState(false);
  const [mergeData, setMergeData] = useState<Record<string, any>>({});
  const [saving, setSaving] = useState(false);
  const htmlEditorRef = useRef<HTMLTextAreaElement>(null);

  useEffect(() => {
    if (templateId) {
      loadTemplate(templateId);
    }
  }, [templateId]);

  const loadTemplate = async (id: string) => {
    try {
      const response = await fetch(`/api/email/templates/${id}`);
      const data = await response.json();
      setTemplate(data.template);
      
      // Initialize merge data with sample values
      const sampleData: Record<string, any> = {};
      data.template.merge_fields.forEach((field: MergeField) => {
        sampleData[field.name] = getSampleValue(field);
      });
      setMergeData(sampleData);
    } catch (error) {
      console.error('Failed to load template:', error);
    }
  };

  const getSampleValue = (field: MergeField): string => {
    switch (field.type) {
      case 'text':
        return field.name === 'client_name' ? 'Sarah Johnson' : 
               field.name === 'partner_name' ? 'Mike Johnson' :
               field.name === 'venue_name' ? 'The Grand Hotel' : 'Sample Value';
      case 'date':
        return field.name === 'wedding_date' ? '2025-06-15' : new Date().toISOString().split('T')[0];
      case 'currency':
        return '£1,500.00';
      case 'number':
        return '150';
      case 'url':
        return 'https://example.com';
      default:
        return field.default_value || 'Sample';
    }
  };

  const handleSave = async () => {
    setSaving(true);
    try {
      const endpoint = templateId ? `/api/email/templates/${templateId}` : '/api/email/templates';
      const method = templateId ? 'PUT' : 'POST';
      
      const response = await fetch(endpoint, {
        method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(template)
      });
      
      const data = await response.json();
      if (data.template) {
        onSave?.(data.template);
      }
    } catch (error) {
      console.error('Failed to save template:', error);
    } finally {
      setSaving(false);
    }
  };

  const handleSendTest = async () => {
    try {
      await fetch(`/api/email/templates/${templateId}/test`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          test_email: 'test@example.com', // Would come from settings
          test_data: mergeData
        })
      });
      
      // Show success notification
    } catch (error) {
      console.error('Failed to send test email:', error);
    }
  };

  const insertMergeField = (fieldName: string) => {
    const textarea = htmlEditorRef.current;
    if (!textarea) return;

    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const currentValue = template.email_body_html || '';
    const mergeTag = `{{${fieldName}}}`;
    
    const newValue = currentValue.slice(0, start) + mergeTag + currentValue.slice(end);
    
    setTemplate(prev => ({
      ...prev,
      email_body_html: newValue
    }));

    // Reset cursor position
    setTimeout(() => {
      textarea.focus();
      textarea.setSelectionRange(start + mergeTag.length, start + mergeTag.length);
    }, 0);
  };

  const renderPreview = () => {
    let htmlContent = template.email_body_html || '';
    
    // Replace merge fields with sample data
    Object.entries(mergeData).forEach(([key, value]) => {
      const regex = new RegExp(`{{\\s*${key}\\s*}}`, 'g');
      htmlContent = htmlContent.replace(regex, String(value));
    });

    return htmlContent;
  };

  return (
    <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 h-full">
      {/* Editor Panel */}
      <div className="space-y-6">
        <Card>
          <CardHeader>
            <div className="flex items-center justify-between">
              <div>
                <CardTitle>Email Template Editor</CardTitle>
                <CardDescription>
                  Create and customize your email template
                </CardDescription>
              </div>
              <div className="flex space-x-2">
                <Button variant="outline" size="sm" onClick={handleSendTest}>
                  <Send className="w-4 h-4 mr-2" />
                  Test
                </Button>
                <Button onClick={handleSave} disabled={saving}>
                  <Save className="w-4 h-4 mr-2" />
                  {saving ? 'Saving...' : 'Save'}
                </Button>
              </div>
            </div>
          </CardHeader>
          
          <CardContent className="space-y-4">
            {/* Template Basic Info */}
            <div className="grid grid-cols-2 gap-4">
              <div>
                <Label htmlFor="template_name">Template Name</Label>
                <Input
                  id="template_name"
                  value={template.template_name}
                  onChange={(e) => setTemplate(prev => ({ 
                    ...prev, 
                    template_name: e.target.value 
                  }))}
                  placeholder="Welcome Email"
                />
              </div>
              
              <div>
                <Label htmlFor="category">Category</Label>
                <select
                  id="category"
                  className="w-full p-2 border rounded-md"
                  value={template.template_category}
                  onChange={(e) => setTemplate(prev => ({ 
                    ...prev, 
                    template_category: e.target.value as any
                  }))}
                >
                  <option value="welcome">Welcome</option>
                  <option value="follow_up">Follow Up</option>
                  <option value="booking_confirmation">Booking Confirmation</option>
                  <option value="payment_reminder">Payment Reminder</option>
                  <option value="pre_event">Pre-Event</option>
                  <option value="post_event">Post-Event</option>
                  <option value="thank_you">Thank You</option>
                  <option value="review_request">Review Request</option>
                  <option value="custom">Custom</option>
                </select>
              </div>
            </div>

            {/* Subject Line */}
            <div>
              <Label htmlFor="subject">Subject Line</Label>
              <Input
                id="subject"
                value={template.email_subject}
                onChange={(e) => setTemplate(prev => ({ 
                  ...prev, 
                  email_subject: e.target.value 
                }))}
                placeholder="Welcome to {{supplier_name}}!"
              />
            </div>

            {/* Merge Fields */}
            <div>
              <Label>Available Merge Fields</Label>
              <div className="flex flex-wrap gap-2 mt-2">
                {[
                  'client_name', 'partner_name', 'wedding_date', 'venue_name',
                  'supplier_name', 'package_name', 'total_amount', 'booking_date'
                ].map((field) => (
                  <Badge
                    key={field}
                    variant="secondary"
                    className="cursor-pointer hover:bg-primary hover:text-primary-foreground"
                    onClick={() => insertMergeField(field)}
                  >
                    <Wand2 className="w-3 h-3 mr-1" />
                    {field}
                  </Badge>
                ))}
              </div>
            </div>

            {/* Email Content */}
            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <Label htmlFor="email_body">Email Content</Label>
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => setShowCode(!showCode)}
                >
                  <Code className="w-4 h-4 mr-2" />
                  {showCode ? 'Visual' : 'Code'}
                </Button>
              </div>
              
              {showCode ? (
                <Textarea
                  ref={htmlEditorRef}
                  id="email_body"
                  className="font-mono text-sm min-h-96"
                  value={template.email_body_html}
                  onChange={(e) => setTemplate(prev => ({ 
                    ...prev, 
                    email_body_html: e.target.value 
                  }))}
                  placeholder="Enter HTML content..."
                />
              ) : (
                <div className="border rounded-md p-3 min-h-96 bg-gray-50">
                  <RichTextEditor
                    content={template.email_body_html || ''}
                    onChange={(content) => setTemplate(prev => ({ 
                      ...prev, 
                      email_body_html: content 
                    }))}
                    onInsertMergeField={insertMergeField}
                  />
                </div>
              )}
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Preview Panel */}
      <div className="space-y-4">
        <Card>
          <CardHeader>
            <div className="flex items-center justify-between">
              <div>
                <CardTitle className="flex items-center">
                  <Eye className="w-5 h-5 mr-2" />
                  Email Preview
                </CardTitle>
                <CardDescription>
                  See how your email will look to recipients
                </CardDescription>
              </div>
              
              <div className="flex space-x-2">
                <Button
                  variant={previewMode === 'desktop' ? 'default' : 'outline'}
                  size="sm"
                  onClick={() => setPreviewMode('desktop')}
                >
                  <Monitor className="w-4 h-4" />
                </Button>
                <Button
                  variant={previewMode === 'mobile' ? 'default' : 'outline'}
                  size="sm"
                  onClick={() => setPreviewMode('mobile')}
                >
                  <Smartphone className="w-4 h-4" />
                </Button>
              </div>
            </div>
          </CardHeader>
          
          <CardContent>
            {/* Email Header */}
            <div className="bg-gray-100 p-3 rounded-t-md border-b">
              <div className="text-sm text-gray-600 mb-1">Subject:</div>
              <div className="font-semibold">
                {template.email_subject?.replace(/{{(\w+)}}/g, (match, key) => 
                  mergeData[key] || match
                )}
              </div>
            </div>
            
            {/* Email Body Preview */}
            <div 
              className={`bg-white border rounded-b-md overflow-auto ${
                previewMode === 'mobile' ? 'max-w-sm mx-auto' : 'w-full'
              }`}
              style={{ height: '500px' }}
            >
              <div
                dangerouslySetInnerHTML={{ 
                  __html: renderPreview() 
                }}
                className="p-4 email-preview"
              />
            </div>
          </CardContent>
        </Card>

        {/* Sample Data Editor */}
        <Card>
          <CardHeader>
            <CardTitle>Sample Data</CardTitle>
            <CardDescription>
              Edit sample data to see how merge fields render
            </CardDescription>
          </CardHeader>
          
          <CardContent>
            <div className="grid grid-cols-2 gap-3 text-sm">
              {Object.entries(mergeData).map(([key, value]) => (
                <div key={key}>
                  <Label htmlFor={key} className="text-xs">{key}</Label>
                  <Input
                    id={key}
                    size="sm"
                    value={String(value)}
                    onChange={(e) => setMergeData(prev => ({
                      ...prev,
                      [key]: e.target.value
                    }))}
                  />
                </div>
              ))}
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
};
```

#### Email Automation Service

```typescript
// Email Automation Service
import { createClient } from '@supabase/supabase-js';
import { Resend } from 'resend';
import { EmailTemplate, EmailWorkflow, ClientEmailWorkflow, EmailSendQueue } from '@/types/email';

export class EmailAutomationService {
  private supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
  
  private resend = new Resend(process.env.RESEND_API_KEY);

  // Trigger workflow execution
  async triggerWorkflow(
    clientId: string,
    workflowId: string,
    triggerData: Record<string, any> = {},
    contextData: Record<string, any> = {}
  ): Promise<ClientEmailWorkflow> {
    
    // Check if client already has this workflow active
    const { data: existingWorkflow } = await this.supabase
      .from('client_email_workflows')
      .select('*')
      .eq('client_id', clientId)
      .eq('workflow_id', workflowId)
      .eq('execution_status', 'active')
      .single();

    if (existingWorkflow) {
      console.log('Workflow already active for client:', clientId);
      return existingWorkflow;
    }

    // Get workflow details
    const { data: workflow, error: workflowError } = await this.supabase
      .from('email_workflows')
      .select(`
        *,
        email_workflow_steps(*)
      `)
      .eq('id', workflowId)
      .eq('workflow_status', 'active')
      .single();

    if (workflowError || !workflow) {
      throw new Error('Workflow not found or not active');
    }

    // Create client workflow instance
    const { data: clientWorkflow, error: clientWorkflowError } = await this.supabase
      .from('client_email_workflows')
      .insert({
        client_id: clientId,
        workflow_id: workflowId,
        supplier_id: workflow.supplier_id,
        execution_status: 'active',
        current_step_number: 1,
        total_steps: workflow.email_workflow_steps.length,
        context_data: contextData,
        trigger_data: triggerData,
        next_execution_at: this.calculateNextExecution(workflow.email_workflow_steps[0])
      })
      .select()
      .single();

    if (clientWorkflowError) throw clientWorkflowError;

    // Schedule first step execution
    await this.scheduleWorkflowStep(clientWorkflow, workflow.email_workflow_steps[0]);

    // Update workflow execution count
    await this.supabase
      .from('email_workflows')
      .update({
        total_executions: workflow.total_executions + 1,
        last_executed_at: new Date().toISOString()
      })
      .eq('id', workflowId);

    return clientWorkflow;
  }

  // Execute workflow step
  async executeWorkflowStep(clientWorkflowId: string): Promise<void> {
    const { data: clientWorkflow, error } = await this.supabase
      .from('client_email_workflows')
      .select(`
        *,
        email_workflows!inner(*),
        email_workflow_steps!inner(*),
        clients!inner(*)
      `)
      .eq('id', clientWorkflowId)
      .eq('execution_status', 'active')
      .single();

    if (error || !clientWorkflow) {
      console.error('Client workflow not found:', clientWorkflowId);
      return;
    }

    const currentStep = clientWorkflow.email_workflow_steps.find(
      (step: any) => step.step_number === clientWorkflow.current_step_number
    );

    if (!currentStep) {
      console.error('Current step not found for workflow:', clientWorkflowId);
      return;
    }

    try {
      let stepSuccess = false;

      switch (currentStep.step_type) {
        case 'send_email':
          stepSuccess = await this.executeSendEmailStep(clientWorkflow, currentStep);
          break;
          
        case 'wait':
          stepSuccess = await this.executeWaitStep(clientWorkflow, currentStep);
          break;
          
        case 'condition':
          stepSuccess = await this.executeConditionStep(clientWorkflow, currentStep);
          break;
          
        case 'update_client':
          stepSuccess = await this.executeUpdateClientStep(clientWorkflow, currentStep);
          break;
          
        case 'add_tag':
          stepSuccess = await this.executeAddTagStep(clientWorkflow, currentStep);
          break;
          
        default:
          console.error('Unknown step type:', currentStep.step_type);
          stepSuccess = false;
      }

      if (stepSuccess) {
        await this.moveToNextStep(clientWorkflow);
      } else {
        await this.markWorkflowFailed(clientWorkflow.id, 'Step execution failed');
      }

    } catch (error) {
      console.error('Workflow step execution error:', error);
      await this.markWorkflowFailed(clientWorkflow.id, error.message);
    }
  }

  // Execute send email step
  private async executeSendEmailStep(
    clientWorkflow: any,
    step: any
  ): Promise<boolean> {
    try {
      // Get email template
      const { data: template, error: templateError } = await this.supabase
        .from('email_templates')
        .select('*')
        .eq('id', step.email_template_id)
        .single();

      if (templateError || !template) {
        console.error('Email template not found:', step.email_template_id);
        return false;
      }

      // Prepare merge data
      const mergeData = {
        ...clientWorkflow.context_data,
        ...clientWorkflow.trigger_data,
        client_name: clientWorkflow.clients.first_name || 'Valued Client',
        supplier_name: 'Your Wedding Vendor',
        workflow_name: clientWorkflow.email_workflows.workflow_name
      };

      // Queue email for sending
      await this.queueEmail({
        client_id: clientWorkflow.client_id,
        supplier_id: clientWorkflow.supplier_id,
        client_workflow_id: clientWorkflow.id,
        workflow_step_id: step.id,
        email_template_id: template.id,
        recipient_email: clientWorkflow.clients.email,
        recipient_name: `${clientWorkflow.clients.first_name} ${clientWorkflow.clients.last_name}`,
        sender_email: template.sender_email || 'noreply@wedsync.com',
        sender_name: template.sender_name || 'WedSync',
        reply_to_email: template.reply_to_email,
        email_subject: this.processTemplate(template.email_subject, mergeData),
        email_body_html: this.processTemplate(template.email_body_html, mergeData),
        email_body_text: template.email_body_text ? 
          this.processTemplate(template.email_body_text, mergeData) : undefined,
        scheduled_at: new Date().toISOString(),
        priority: 5,
        merge_data: mergeData
      });

      // Update client workflow statistics
      await this.supabase
        .from('client_email_workflows')
        .update({
          emails_sent: clientWorkflow.emails_sent + 1
        })
        .eq('id', clientWorkflow.id);

      return true;
    } catch (error) {
      console.error('Send email step error:', error);
      return false;
    }
  }

  // Process email templates with merge fields
  private processTemplate(template: string, mergeData: Record<string, any>): string {
    let processed = template;
    
    // Replace merge fields like {{field_name}}
    Object.entries(mergeData).forEach(([key, value]) => {
      const regex = new RegExp(`{{\\s*${key}\\s*}}`, 'g');
      processed = processed.replace(regex, String(value || ''));
    });

    // Handle conditional blocks like {{#if field_name}}...{{/if}}
    processed = this.processConditionals(processed, mergeData);

    return processed;
  }

  // Process conditional blocks in templates
  private processConditionals(template: string, data: Record<string, any>): string {
    let processed = template;

    // Handle {{#if field}}...{{/if}} blocks
    const ifRegex = /{{#if\s+(\w+)}}([\s\S]*?){{\/if}}/g;
    processed = processed.replace(ifRegex, (match, field, content) => {
      return data[field] ? content : '';
    });

    // Handle {{#unless field}}...{{/unless}} blocks  
    const unlessRegex = /{{#unless\s+(\w+)}}([\s\S]*?){{\/unless}}/g;
    processed = processed.replace(unlessRegex, (match, field, content) => {
      return !data[field] ? content : '';
    });

    return processed;
  }

  // Queue email for sending
  private async queueEmail(emailData: Partial<EmailSendQueue>): Promise<string> {
    const { data: queuedEmail, error } = await this.supabase
      .from('email_send_queue')
      .insert(emailData)
      .select()
      .single();

    if (error) throw error;

    // Trigger immediate sending if scheduled for now
    if (new Date(emailData.scheduled_at!).getTime() <= Date.now()) {
      setTimeout(() => this.processEmailQueue(), 1000);
    }

    return queuedEmail.id;
  }

  // Process email sending queue
  async processEmailQueue(): Promise<void> {
    const { data: queuedEmails, error } = await this.supabase
      .from('email_send_queue')
      .select('*')
      .eq('send_status', 'queued')
      .lte('scheduled_at', new Date().toISOString())
      .order('priority', { ascending: true })
      .order('scheduled_at', { ascending: true })
      .limit(10);

    if (error || !queuedEmails?.length) return;

    for (const email of queuedEmails) {
      try {
        await this.sendQueuedEmail(email);
      } catch (error) {
        console.error('Failed to send queued email:', email.id, error);
        
        await this.supabase
          .from('email_send_queue')
          .update({
            send_status: 'failed',
            failed_at: new Date().toISOString(),
            last_error_message: error.message,
            retry_count: email.retry_count + 1
          })
          .eq('id', email.id);
      }
    }
  }

  // Send individual queued email
  private async sendQueuedEmail(email: EmailSendQueue): Promise<void> {
    // Update status to sending
    await this.supabase
      .from('email_send_queue')
      .update({ send_status: 'sending' })
      .eq('id', email.id);

    // Send via Resend
    const result = await this.resend.emails.send({
      from: `${email.sender_name} <${email.sender_email}>`,
      to: [email.recipient_email],
      replyTo: email.reply_to_email,
      subject: email.email_subject,
      html: email.email_body_html,
      text: email.email_body_text,
      headers: {
        'X-WedSync-Email-ID': email.id,
        'X-WedSync-Client-ID': email.client_id,
        'List-Unsubscribe': `<${process.env.NEXT_PUBLIC_APP_URL}/unsubscribe/${email.id}>`
      }
    });

    if (result.error) {
      throw new Error(result.error.message);
    }

    // Update status to sent
    await this.supabase
      .from('email_send_queue')
      .update({
        send_status: 'sent',
        sent_at: new Date().toISOString(),
        external_message_id: result.data?.id
      })
      .eq('id', email.id);
  }

  // Move workflow to next step
  private async moveToNextStep(clientWorkflow: any): Promise<void> {
    const nextStepNumber = clientWorkflow.current_step_number + 1;
    const totalSteps = clientWorkflow.total_steps;

    if (nextStepNumber > totalSteps) {
      // Workflow completed
      await this.supabase
        .from('client_email_workflows')
        .update({
          execution_status: 'completed',
          completed_at: new Date().toISOString(),
          steps_completed: totalSteps
        })
        .eq('id', clientWorkflow.id);
    } else {
      // Move to next step
      const nextStep = clientWorkflow.email_workflow_steps.find(
        (step: any) => step.step_number === nextStepNumber
      );

      const nextExecutionAt = this.calculateNextExecution(nextStep);

      await this.supabase
        .from('client_email_workflows')
        .update({
          current_step_number: nextStepNumber,
          next_execution_at: nextExecutionAt,
          steps_completed: nextStepNumber - 1,
          last_step_executed_at: new Date().toISOString()
        })
        .eq('id', clientWorkflow.id);

      // Schedule next step
      await this.scheduleWorkflowStep(clientWorkflow, nextStep);
    }
  }

  // Calculate when next step should execute based on delay
  private calculateNextExecution(step: any): string | null {
    if (step.delay_type === 'immediate') {
      return new Date().toISOString();
    }

    const now = new Date();
    let delayMs = 0;

    switch (step.delay_type) {
      case 'minutes':
        delayMs = step.delay_amount * 60 * 1000;
        break;
      case 'hours':
        delayMs = step.delay_amount * 60 * 60 * 1000;
        break;
      case 'days':
        delayMs = step.delay_amount * 24 * 60 * 60 * 1000;
        break;
      case 'weeks':
        delayMs = step.delay_amount * 7 * 24 * 60 * 60 * 1000;
        break;
      case 'months':
        delayMs = step.delay_amount * 30 * 24 * 60 * 60 * 1000; // Approximate
        break;
    }

    return new Date(now.getTime() + delayMs).toISOString();
  }

  // Schedule workflow step execution
  private async scheduleWorkflowStep(clientWorkflow: any, step: any): Promise<void> {
    const executionTime = this.calculateNextExecution(step);
    if (!executionTime) return;

    // This would integrate with your job scheduler (e.g., node-cron, Bull Queue)
    // For now, we'll use a simple setTimeout approach
    const delay = new Date(executionTime).getTime() - Date.now();
    
    if (delay <= 60000) { // If less than 1 minute, execute immediately
      setTimeout(() => this.executeWorkflowStep(clientWorkflow.id), Math.max(0, delay));
    }
    // For longer delays, you'd want to use a persistent job queue
  }

  // Mark workflow as failed
  private async markWorkflowFailed(clientWorkflowId: string, reason: string): Promise<void> {
    await this.supabase
      .from('client_email_workflows')
      .update({
        execution_status: 'failed',
        // You might want to add a failure_reason field to the schema
      })
      .eq('id', clientWorkflowId);
  }

  // Process webhook for email engagement tracking
  async processEmailWebhook(webhookData: any): Promise<void> {
    const { event, data } = webhookData;
    const emailId = data.headers?.['X-WedSync-Email-ID'];
    
    if (!emailId) return;

    const { data: email } = await this.supabase
      .from('email_send_queue')
      .select('*')
      .eq('id', emailId)
      .single();

    if (!email) return;

    switch (event) {
      case 'email.delivered':
        await this.handleEmailDelivered(email, data);
        break;
        
      case 'email.opened':
        await this.handleEmailOpened(email, data);
        break;
        
      case 'email.clicked':
        await this.handleEmailClicked(email, data);
        break;
        
      case 'email.bounced':
        await this.handleEmailBounced(email, data);
        break;
    }
  }

  private async handleEmailOpened(email: EmailSendQueue, data: any): Promise<void> {
    // Update email record
    const isFirstOpen = !email.first_opened_at;
    
    await this.supabase
      .from('email_send_queue')
      .update({
        opened_at: new Date().toISOString(),
        first_opened_at: email.first_opened_at || new Date().toISOString(),
        open_count: email.open_count + 1
      })
      .eq('id', email.id);

    // Record engagement
    await this.supabase
      .from('email_engagements')
      .insert({
        email_queue_id: email.id,
        client_id: email.client_id,
        supplier_id: email.supplier_id,
        engagement_type: 'open',
        engagement_data: data,
        ip_address: data.ip,
        user_agent: data.user_agent,
        device_type: data.device_type,
        email_client: data.email_client
      });

    // Update client workflow if this was first open
    if (isFirstOpen && email.client_workflow_id) {
      await this.supabase
        .from('client_email_workflows')
        .update({
          emails_opened: email.emails_opened + 1
        })
        .eq('id', email.client_workflow_id);
    }
  }

  private async handleEmailClicked(email: EmailSendQueue, data: any): Promise<void> {
    // Update email record
    await this.supabase
      .from('email_send_queue')
      .update({
        last_clicked_at: new Date().toISOString(),
        click_count: email.click_count + 1
      })
      .eq('id', email.id);

    // Record engagement
    await this.supabase
      .from('email_engagements')
      .insert({
        email_queue_id: email.id,
        client_id: email.client_id,
        supplier_id: email.supplier_id,
        engagement_type: 'click',
        engagement_data: { ...data, link_url: data.url },
        ip_address: data.ip,
        user_agent: data.user_agent
      });

    // Update client workflow
    if (email.client_workflow_id) {
      await this.supabase
        .from('client_email_workflows')
        .update({
          emails_clicked: email.emails_clicked + 1
        })
        .eq('id', email.client_workflow_id);
    }
  }
}
```

### ACCEPTANCE CRITERIA

**Email Template Management:**
- [ ] Visual drag-and-drop email template builder
- [ ] Pre-designed templates for common wedding scenarios
- [ ] Dynamic merge fields with client/wedding data
- [ ] Conditional content blocks based on data
- [ ] Mobile-responsive email templates
- [ ] A/B testing for subject lines and content
- [ ] Template performance analytics (open/click rates)
- [ ] Easy duplication and version management

**Workflow Automation:**
- [ ] Visual workflow builder with step-by-step design
- [ ] Multiple trigger types (form submission, date-based, manual)
- [ ] Conditional logic between steps (if opened, if clicked)
- [ ] Flexible delay options (minutes, hours, days, weeks)
- [ ] Branch paths based on client actions or data
- [ ] Real-time workflow execution monitoring
- [ ] Pause, resume, and cancel workflow capabilities
- [ ] Performance metrics per workflow step

**Email Delivery:**
- [ ] Integration with multiple email providers (Resend, SendGrid, etc.)
- [ ] Priority-based email queuing system
- [ ] Rate limiting to respect provider limits
- [ ] Automatic retry logic for failed sends
- [ ] Delivery status tracking and reporting
- [ ] Bounce and spam complaint handling
- [ ] Quiet hours configuration (no emails 10 PM - 8 AM)
- [ ] Timezone-aware scheduling

**Engagement Tracking:**
- [ ] Email open tracking with device/client detection
- [ ] Link click tracking with UTM parameters
- [ ] Reply detection and threading
- [ ] Forward and share tracking
- [ ] Unsubscribe link management
- [ ] Engagement scoring per client
- [ ] Heat map analytics for email content
- [ ] Conversion tracking from email to booking

**Compliance & Deliverability:**
- [ ] GDPR-compliant unsubscribe handling
- [ ] CAN-SPAM compliance with physical address
- [ ] Double opt-in for marketing emails
- [ ] Automatic suppression list management
- [ ] SPF/DKIM/DMARC configuration guidance
- [ ] Deliverability score monitoring
- [ ] Spam complaint tracking and response
- [ ] Regular compliance audits and reporting

**Business Logic:**
- [ ] Tier-based email limits (FREE: 0, STARTER: 100/month, PROFESSIONAL: unlimited)
- [ ] Client-specific email preferences and opt-outs
- [ ] Wedding date-based automation triggers
- [ ] Form integration for automatic workflow triggers
- [ ] Payment status integration for follow-up sequences
- [ ] Client journey tracking across touchpoints
- [ ] Revenue attribution from email campaigns
- [ ] Integration with CRM systems for data sync

### DEPENDENCIES & INTEGRATION

**Must Complete After:**
- WS-342: Advanced Form Builder (form submission triggers)
- WS-306: Client Management System (client data access)
- WS-344: Payment Processing System (payment-based triggers)

**Must Complete Before:**
- WS-355: Analytics Dashboard (email performance metrics)
- Production launch (critical for client communication)

**Shares Code With:**
- Form Builder (automatic workflow triggers)
- Client Management (merge field data)
- Payment System (payment confirmation emails)
- Analytics System (engagement reporting)

### ESTIMATED EFFORT

- **Frontend Development:** 45 hours
  - Template editor with visual builder
  - Workflow designer interface
  - Analytics dashboard for email performance
  - Mobile-responsive email preview

- **Backend Development:** 40 hours
  - Email automation engine
  - Template processing and merge logic
  - Workflow execution system
  - Email provider integrations

- **Database & Infrastructure:** 15 hours
  - Email schema implementation
  - Queue processing system
  - Performance optimization
  - Webhook handling

- **Testing & QA:** 10 hours
  - Email template testing across clients
  - Workflow automation testing
  - Deliverability testing
  - Mobile email testing

**Total Estimated Effort:** 110 hours

### TECHNICAL NOTES

**Email Provider Integration:**
- Primary: Resend (developer-friendly, great deliverability)
- Backup: SendGrid (enterprise features)
- Support multiple providers per supplier for redundancy
- Automatic failover if provider has issues

**Performance Considerations:**
- Background job processing for workflow execution
- Intelligent email queuing with priority system
- Database indexing for quick workflow lookups
- Caching for frequently used templates
- Rate limiting to prevent spam issues

**Deliverability Best Practices:**
- Warm up new sender domains gradually
- Monitor reputation scores and adjust sending
- Implement feedback loops with ISPs
- Regular list cleaning to remove inactive subscribers
- Use dedicated IP addresses for high-volume senders

This Email Automation Engine will transform how wedding suppliers communicate with clients, turning manual, time-consuming email tasks into sophisticated, automated nurture sequences that increase bookings and client satisfaction while saving hours of work per week.