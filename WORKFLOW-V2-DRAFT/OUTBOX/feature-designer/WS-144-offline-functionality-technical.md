# TECHNICAL SPECIFICATION: WS-144 - Offline Functionality System
## Generated by Feature Development Session - 2025-01-24

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding photographer working at remote venues
**I want to:** Access all my wedding day information even with poor or no internet connection
**So that:** I can check timelines, contact details, and shot lists without worrying about venue WiFi issues

**Real Wedding Scenario:**
Mark, a wedding photographer, arrives at a countryside venue with terrible cell coverage. His WedSync app automatically downloaded all today's wedding data overnight. He can access the timeline, shot list, vendor contacts, and even fill out post-wedding forms. When he gets back to his car with signal, everything syncs seamlessly to the cloud. The bride never knows there were connectivity issues.

### SPECIFICATION SOURCE
- **Feature ID:** WS-144
- **Original Spec:** /CORE-SPECIFICATIONS/09-MOBILE-OPTIMIZATION/03-offline-functionality md.md
- **Current Implementation:** 15% complete (basic PWA setup)
- **Files to Modify:** 
  - /wedsync/next.config.js (PWA configuration)
  - /wedsync/public/sw.js (service worker enhancements)
- **New Files to Create:** 
  - /src/lib/offline/offline-database.ts
  - /src/lib/offline/sync-manager.ts
  - /src/lib/offline/conflict-resolver.ts
  - /src/components/offline/OfflineIndicator.tsx
  - /src/components/offline/OfflineForm.tsx
  - /src/hooks/useOfflineData.ts
  - /src/pages/offline.tsx

### TECHNICAL DESIGN

#### Database Schema Required (IndexedDB)
```typescript
// IndexedDB schema using Dexie
import Dexie, { Table } from 'dexie';

export interface CachedWedding {
  id: string;
  date: string;
  coupleId: string;
  coupleName: string;
  venue: string;
  status: 'upcoming' | 'active' | 'completed';
  lastSync: string;
  syncStatus: 'synced' | 'pending' | 'conflict';
}

export interface CachedClient {
  id: string;
  name: string;
  email: string;
  phone?: string;
  weddingDate: string;
  status: 'active' | 'archived';
  lastActivity: string;
  lastSync: string;
}

export interface CachedForm {
  id: string;
  name: string;
  type: 'questionnaire' | 'timeline' | 'shot_list';
  clientId: string;
  lastModified: string;
  fields: any[];
  responses?: any[];
}

export interface CachedFormDraft {
  id: string;
  formId: string;
  clientId: string;
  data: Record<string, any>;
  autoSaveTime: string;
  syncStatus: 'pending' | 'synced' | 'failed';
}

export interface SyncQueueItem {
  id?: number;
  type: 'form_submission' | 'form_draft' | 'client_update' | 'note_create';
  action: 'create' | 'update' | 'delete';
  data: any;
  attempts: number;
  timestamp: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  nextRetry?: string;
}

export class WedSyncOfflineDB extends Dexie {
  weddings!: Table<CachedWedding>;
  clients!: Table<CachedClient>;
  forms!: Table<CachedForm>;
  formDrafts!: Table<CachedFormDraft>;
  syncQueue!: Table<SyncQueueItem>;

  constructor() {
    super('WedSyncOffline');

    this.version(1).stores({
      weddings: 'id, date, coupleId, status, [date+status]',
      clients: 'id, weddingDate, status, lastSync',
      forms: 'id, clientId, type, lastModified',
      formDrafts: 'id, formId, clientId, autoSaveTime, syncStatus',
      syncQueue: '++id, type, status, timestamp, nextRetry'
    });

    // Add hooks for automatic sync status tracking
    this.weddings.hook('creating', this.addSyncMetadata);
    this.weddings.hook('updating', this.updateSyncMetadata);
    this.clients.hook('creating', this.addSyncMetadata);
    this.clients.hook('updating', this.updateSyncMetadata);
  }

  private addSyncMetadata = (primKey: any, obj: any) => {
    obj.lastSync = new Date().toISOString();
    obj.syncStatus = 'pending';
  };

  private updateSyncMetadata = (modifications: any) => {
    modifications.lastSync = new Date().toISOString();
    if (!modifications.syncStatus) {
      modifications.syncStatus = 'pending';
    }
  };
}

export const offlineDB = new WedSyncOfflineDB();
```

#### API Endpoints Required
```typescript
// POST /api/offline/prefetch
interface PrefetchRequest {
  weddingIds?: string[];
  date?: string; // Prefetch all weddings for specific date
  priority: 'high' | 'normal' | 'low';
}

interface PrefetchResponse {
  success: boolean;
  cached: {
    weddings: number;
    clients: number;
    forms: number;
    totalSizeMB: number;
  };
  errors?: string[];
}

// POST /api/offline/sync
interface SyncRequest {
  queueItems: Array<{
    type: string;
    action: string;
    data: any;
    clientTimestamp: string;
  }>;
}

interface SyncResponse {
  success: boolean;
  results: Array<{
    id: string;
    status: 'success' | 'conflict' | 'error';
    serverData?: any;
    error?: string;
  }>;
  conflicts: Array<{
    id: string;
    clientData: any;
    serverData: any;
    field: string;
  }>;
}

// GET /api/offline/status
interface OfflineStatusResponse {
  cacheHealth: {
    size: number; // bytes
    quota: number; // bytes
    usage: number; // 0-1
    oldestEntry: string;
  };
  syncStatus: {
    queueSize: number;
    lastSync: string;
    failedSyncs: number;
  };
}
```

#### Frontend Components Required
```typescript
// Component: OfflineIndicator
// Location: /src/components/offline/OfflineIndicator.tsx

interface OfflineIndicatorProps {
  showDetails?: boolean;
}

// Key functionality:
- Show connection status (online/offline/syncing)
- Display sync queue count
- Show data freshness indicators
- Provide manual sync trigger
- Display cache usage stats

// Component: OfflineForm  
// Location: /src/components/offline/OfflineForm.tsx

interface OfflineFormProps {
  formId: string;
  clientId: string;
  onSubmit: (data: any) => Promise<void>;
  autoSave?: boolean;
}

// Key functionality:
- Auto-save drafts every 30 seconds
- Handle offline form submissions
- Show sync status for each field
- Conflict resolution UI
- Offline validation and error handling
```

#### Core Offline Services
```typescript
// Service: OfflineDataService
export class OfflineDataService {
  private isOnline = navigator.onLine;
  private syncInProgress = false;

  async cacheWeddingDayData(date: Date): Promise<void> {
    const weddings = await this.getWeddingsForDate(date);

    for (const wedding of weddings) {
      await Promise.all([
        this.cacheWedding(wedding),
        this.cacheTimeline(wedding.id),
        this.cacheContacts(wedding.clientId),
        this.cacheForms(wedding.clientId),
        this.cacheVenueDetails(wedding.venueId)
      ]);
    }

    console.log(`Cached ${weddings.length} weddings for ${date.toDateString()}`);
  }

  async prefetchUpcomingWeddings(days: number = 7): Promise<void> {
    const upcoming = await this.getUpcomingWeddings(days);

    for (const wedding of upcoming) {
      const cacheAge = await this.getCacheAge(wedding.id);
      
      // Refresh if data is older than 6 hours
      if (!cacheAge || cacheAge > 6 * 60 * 60 * 1000) {
        await this.cacheWeddingDayData(wedding.date);
      }
    }
  }

  async intelligentPrefetch(): Promise<void> {
    // Prefetch based on user patterns
    const userPattern = await this.analyzeUserPattern();
    
    if (userPattern.typicalCheckTime) {
      // Pre-cache data 2 hours before user typically checks
      const prefetchTime = new Date(userPattern.typicalCheckTime.getTime() - 2 * 60 * 60 * 1000);
      
      if (new Date() >= prefetchTime) {
        await this.prefetchUpcomingWeddings();
      }
    }
  }
}

// Service: SyncManager
export class SyncManager {
  private syncQueue: SyncQueueItem[] = [];
  private retryDelays = [1000, 5000, 15000, 60000, 300000]; // Exponential backoff

  async addToQueue(item: Omit<SyncQueueItem, 'id' | 'attempts' | 'timestamp' | 'status'>): Promise<void> {
    const queueItem: SyncQueueItem = {
      ...item,
      attempts: 0,
      timestamp: new Date().toISOString(),
      status: 'pending'
    };

    await offlineDB.syncQueue.add(queueItem);

    // Try immediate sync if online
    if (this.isOnline && !this.syncInProgress) {
      this.processSyncQueue();
    }
  }

  async processSyncQueue(): Promise<void> {
    if (this.syncInProgress || !navigator.onLine) return;

    this.syncInProgress = true;
    
    try {
      const pendingItems = await offlineDB.syncQueue
        .where('status')
        .equals('pending')
        .or('status')
        .equals('failed')
        .toArray();

      for (const item of pendingItems) {
        await this.processSingleItem(item);
      }
    } finally {
      this.syncInProgress = false;
    }
  }

  private async processSingleItem(item: SyncQueueItem): Promise<void> {
    try {
      // Update status to processing
      await offlineDB.syncQueue.update(item.id!, { status: 'processing' });

      let result;
      switch (item.type) {
        case 'form_submission':
          result = await this.syncFormSubmission(item.data);
          break;
        case 'form_draft':
          result = await this.syncFormDraft(item.data);
          break;
        case 'client_update':
          result = await this.syncClientUpdate(item.data);
          break;
        case 'note_create':
          result = await this.syncNoteCreation(item.data);
          break;
        default:
          throw new Error(`Unknown sync type: ${item.type}`);
      }

      // Success - remove from queue
      await offlineDB.syncQueue.delete(item.id!);
      
    } catch (error) {
      await this.handleSyncError(item, error as Error);
    }
  }

  private async handleSyncError(item: SyncQueueItem, error: Error): Promise<void> {
    const attempts = item.attempts + 1;
    const maxAttempts = 5;

    if (attempts >= maxAttempts) {
      // Max attempts reached - mark as permanently failed
      await offlineDB.syncQueue.update(item.id!, {
        status: 'failed',
        attempts
      });
      
      // Notify user of persistent sync failure
      await this.notifyPersistentFailure(item, error);
    } else {
      // Schedule retry with exponential backoff
      const delay = this.retryDelays[Math.min(attempts - 1, this.retryDelays.length - 1)];
      const nextRetry = new Date(Date.now() + delay).toISOString();

      await offlineDB.syncQueue.update(item.id!, {
        status: 'pending',
        attempts,
        nextRetry
      });

      // Schedule retry
      setTimeout(() => this.processSingleItem(item), delay);
    }
  }
}
```

### CODE EXAMPLES

#### Example 1: Smart Data Caching with Storage Management
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
export class SmartCacheManager {
  private readonly MAX_CACHE_SIZE = 50 * 1024 * 1024; // 50MB
  private readonly CACHE_PRIORITIES = {
    critical: 1, // Today's weddings
    important: 2, // Next 7 days
    normal: 3, // Historical data
    low: 4 // Analytics, preferences
  };

  async optimizeStorage(): Promise<void> {
    const usage = await this.getCacheUsage();
    
    if (usage.size > this.MAX_CACHE_SIZE * 0.8) {
      console.log('Cache approaching limit, optimizing...');
      await this.pruneOldData();
    }
  }

  async cacheWithPriority(data: any, priority: keyof typeof this.CACHE_PRIORITIES): Promise<void> {
    // Check if we need to free space
    await this.optimizeStorage();

    // Add priority metadata
    const cacheEntry = {
      ...data,
      cachedAt: new Date().toISOString(),
      priority: this.CACHE_PRIORITIES[priority],
      accessCount: 0,
      lastAccessed: new Date().toISOString()
    };

    // Store in appropriate table based on data type
    await this.storeByType(cacheEntry);
  }

  async pruneOldData(): Promise<void> {
    const cutoffDate = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000); // 30 days ago

    // Remove low priority data older than cutoff
    await offlineDB.transaction('rw', [offlineDB.weddings, offlineDB.clients, offlineDB.forms], async () => {
      // Remove old completed weddings (keep upcoming ones)
      await offlineDB.weddings
        .where('status')
        .equals('completed')
        .and(wedding => new Date(wedding.date) < cutoffDate)
        .delete();

      // Remove old client data that hasn't been accessed
      await offlineDB.clients
        .where('lastActivity')
        .below(cutoffDate.toISOString())
        .and(client => client.accessCount < 5)
        .delete();

      // Keep forms only for active clients
      const activeClients = await offlineDB.clients
        .where('status')
        .equals('active')
        .primaryKeys();
        
      await offlineDB.forms
        .where('clientId')
        .noneOf(activeClients as string[])
        .delete();
    });

    console.log('Cache optimization completed');
  }

  async preloadCriticalData(): Promise<void> {
    // Get today's weddings
    const today = new Date().toISOString().split('T')[0];
    const todayWeddings = await this.fetchWeddingsForDate(today);
    
    // Cache with highest priority
    for (const wedding of todayWeddings) {
      await this.cacheWithPriority(wedding, 'critical');
      
      // Cache related data
      await Promise.all([
        this.cacheClientData(wedding.clientId, 'critical'),
        this.cacheWeddingForms(wedding.id, 'critical'),
        this.cacheVenueInfo(wedding.venueId, 'critical')
      ]);
    }

    // Preload tomorrow's weddings with high priority
    const tomorrow = new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString().split('T')[0];
    const tomorrowWeddings = await this.fetchWeddingsForDate(tomorrow);
    
    for (const wedding of tomorrowWeddings) {
      await this.cacheWithPriority(wedding, 'important');
    }
  }

  async getCacheUsage(): Promise<{ size: number; quota: number; usage: number }> {
    if ('storage' in navigator && 'estimate' in navigator.storage) {
      const estimate = await navigator.storage.estimate();
      return {
        size: estimate.usage || 0,
        quota: estimate.quota || 0,
        usage: (estimate.usage || 0) / (estimate.quota || 1)
      };
    }

    // Fallback for browsers without storage API
    const tableStats = await Promise.all([
      offlineDB.weddings.count(),
      offlineDB.clients.count(),
      offlineDB.forms.count(),
      offlineDB.formDrafts.count()
    ]);

    const estimatedSize = tableStats.reduce((total, count, index) => {
      const avgSizes = [2048, 1024, 4096, 512]; // Estimated bytes per record
      return total + (count * avgSizes[index]);
    }, 0);

    return {
      size: estimatedSize,
      quota: this.MAX_CACHE_SIZE,
      usage: estimatedSize / this.MAX_CACHE_SIZE
    };
  }
}
```

#### Example 2: Conflict Resolution System
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
interface DataConflict {
  field: string;
  clientValue: any;
  serverValue: any;
  clientTimestamp: string;
  serverTimestamp: string;
  conflictType: 'value_mismatch' | 'concurrent_edit' | 'deleted_on_server';
}

export class ConflictResolver {
  async resolveConflicts(conflicts: DataConflict[], resourceType: string): Promise<any> {
    const resolution = { ...conflicts[0].clientValue };

    for (const conflict of conflicts) {
      const strategy = this.getResolutionStrategy(conflict, resourceType);
      resolution[conflict.field] = await this.applyStrategy(conflict, strategy);
    }

    return resolution;
  }

  private getResolutionStrategy(conflict: DataConflict, resourceType: string): 'client-wins' | 'server-wins' | 'merge' | 'user-choice' {
    // Form drafts: Client always wins (user's work is precious)
    if (resourceType === 'form_draft') return 'client-wins';

    // Timeline data: Server wins (authoritative source)
    if (resourceType === 'timeline') return 'server-wins';

    // Client notes: Try to merge
    if (conflict.field === 'notes') return 'merge';

    // User preferences: Client wins
    if (resourceType === 'preferences') return 'client-wins';

    // Default: Last write wins (compare timestamps)
    const clientTime = new Date(conflict.clientTimestamp);
    const serverTime = new Date(conflict.serverTimestamp);
    
    return clientTime > serverTime ? 'client-wins' : 'server-wins';
  }

  private async applyStrategy(conflict: DataConflict, strategy: string): Promise<any> {
    switch (strategy) {
      case 'client-wins':
        return conflict.clientValue;
        
      case 'server-wins':
        return conflict.serverValue;
        
      case 'merge':
        return this.mergeValues(conflict);
        
      case 'user-choice':
        return this.promptUserChoice(conflict);
        
      default:
        throw new Error(`Unknown resolution strategy: ${strategy}`);
    }
  }

  private mergeValues(conflict: DataConflict): any {
    if (Array.isArray(conflict.clientValue) && Array.isArray(conflict.serverValue)) {
      // Merge arrays, removing duplicates
      return [...new Set([...conflict.clientValue, ...conflict.serverValue])];
    }

    if (typeof conflict.clientValue === 'object' && typeof conflict.serverValue === 'object') {
      // Merge objects, client values take precedence
      return { ...conflict.serverValue, ...conflict.clientValue };
    }

    if (typeof conflict.clientValue === 'string' && typeof conflict.serverValue === 'string') {
      // Merge text fields (for notes, comments)
      return this.mergeText(conflict.clientValue, conflict.serverValue);
    }

    // Can't merge, fall back to timestamp comparison
    const clientTime = new Date(conflict.clientTimestamp);
    const serverTime = new Date(conflict.serverTimestamp);
    
    return clientTime > serverTime ? conflict.clientValue : conflict.serverValue;
  }

  private mergeText(clientText: string, serverText: string): string {
    // Simple text merge - append client changes if different
    if (clientText === serverText) return clientText;
    
    // If client text contains server text, use client
    if (clientText.includes(serverText)) return clientText;
    
    // If server text contains client text, use server
    if (serverText.includes(clientText)) return serverText;
    
    // Neither contains the other, append with separator
    return `${serverText}\n\n[Added offline]: ${clientText}`;
  }

  private async promptUserChoice(conflict: DataConflict): Promise<any> {
    return new Promise((resolve) => {
      const modal = document.createElement('div');
      modal.innerHTML = `
        <div class="conflict-resolution-modal">
          <h3>Data Conflict Detected</h3>
          <p>The ${conflict.field} was changed both online and offline:</p>
          <div class="conflict-options">
            <div class="option">
              <strong>Your offline changes:</strong>
              <pre>${JSON.stringify(conflict.clientValue, null, 2)}</pre>
              <button onclick="resolveConflict('client')">Use My Changes</button>
            </div>
            <div class="option">
              <strong>Server changes:</strong>
              <pre>${JSON.stringify(conflict.serverValue, null, 2)}</pre>
              <button onclick="resolveConflict('server')">Use Server Changes</button>
            </div>
          </div>
        </div>
      `;
      
      (window as any).resolveConflict = (choice: 'client' | 'server') => {
        modal.remove();
        resolve(choice === 'client' ? conflict.clientValue : conflict.serverValue);
      };
      
      document.body.appendChild(modal);
    });
  }
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [ ] Context7: Load docs for IndexedDB, PWA best practices, offline patterns
- [ ] PostgreSQL: Test offline sync scenarios with database
- [ ] Supabase: Configure real-time sync when connection restored

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/dexie/dexie", "indexeddb patterns", 3000);
await mcp__context7__get-library-docs("/vercel/next.js", "pwa configuration", 2000);
await mcp__context7__get-library-docs("/workbox/workbox", "service worker", 2500);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('OfflineDataService', () => {
  beforeEach(() => {
    // Mock navigator.onLine
    Object.defineProperty(navigator, 'onLine', {
      writable: true,
      value: true
    });
  });

  it('should cache wedding day data correctly', async () => {
    const testDate = new Date('2024-06-15');
    await OfflineDataService.cacheWeddingDayData(testDate);
    
    const cached = await offlineDB.weddings
      .where('date')
      .equals('2024-06-15')
      .toArray();
      
    expect(cached.length).toBeGreaterThan(0);
  });

  it('should handle offline form submissions', async () => {
    // Simulate offline
    Object.defineProperty(navigator, 'onLine', {
      value: false
    });

    const formData = { name: 'Test', email: 'test@example.com' };
    await SyncManager.addToQueue({
      type: 'form_submission',
      action: 'create',
      data: formData
    });

    const queueSize = await offlineDB.syncQueue.count();
    expect(queueSize).toBe(1);
  });
});

describe('ConflictResolver', () => {
  it('should resolve client-wins conflicts correctly', async () => {
    const conflict: DataConflict = {
      field: 'notes',
      clientValue: 'Client note',
      serverValue: 'Server note',
      clientTimestamp: '2024-01-20T10:00:00Z',
      serverTimestamp: '2024-01-20T09:00:00Z',
      conflictType: 'value_mismatch'
    };

    const resolver = new ConflictResolver();
    const result = await resolver.resolveConflicts([conflict], 'form_draft');
    
    expect(result.notes).toBe('Client note');
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Offline form handling', async () => {
  // Start online
  await mcp__playwright__browser_navigate({url: '/forms/wedding-timeline'});
  
  // Fill form
  await mcp__playwright__browser_fill_form({
    fields: [
      { name: 'Ceremony Time', type: 'textbox', ref: '[data-testid="ceremony-time"]', value: '2:00 PM' }
    ]
  });

  // Simulate going offline
  await mcp__playwright__browser_evaluate({
    function: '() => { Object.defineProperty(navigator, "onLine", { value: false }); window.dispatchEvent(new Event("offline")); }'
  });

  // Should show offline indicator
  await mcp__playwright__browser_wait_for({
    text: 'Offline Mode'
  });

  // Submit form while offline
  await mcp__playwright__browser_click({
    element: 'Submit button',
    ref: '[data-testid="submit-btn"]'
  });

  // Should show offline save confirmation
  await mcp__playwright__browser_wait_for({
    text: 'Saved offline - will sync when connected'
  });
});

test('Data sync after reconnection', async () => {
  // Simulate coming back online
  await mcp__playwright__browser_evaluate({
    function: '() => { Object.defineProperty(navigator, "onLine", { value: true }); window.dispatchEvent(new Event("online")); }'
  });

  // Should show syncing indicator
  await mcp__playwright__browser_wait_for({
    text: 'Syncing...'
  });

  // Wait for sync completion
  await mcp__playwright__browser_wait_for({
    text: 'All changes synced'
  });
});
```

### ACCEPTANCE CRITERIA
- [ ] Wedding day data caches automatically 24 hours before event
- [ ] All forms work offline with auto-save every 30 seconds
- [ ] Sync queue processes automatically when connection restored
- [ ] Offline indicator shows connection status and sync progress
- [ ] Conflict resolution handles concurrent edits gracefully
- [ ] Cache size stays under 50MB with automatic cleanup
- [ ] Offline mode works for minimum 7 days without connection
- [ ] Data integrity maintained - no data loss during offline operations
- [ ] Performance impact minimal - <100ms for cache operations
- [ ] Works across all supported browsers (Chrome, Safari, Firefox, Edge)
- [ ] Graceful degradation - non-critical features disabled when offline
- [ ] User education - clear feedback about offline capabilities and limitations

### DEPENDENCIES
- Must complete after: WS-036 (Photo Management) - Needs image caching strategy
- Must complete before: WS-146 (App Store Preparation) - PWA requirements for stores
- Shares code with: WS-145 (Performance Targets), All form-related features

### ESTIMATED EFFORT
- Team A Frontend: 28 hours (offline UI components, sync indicators, conflict resolution)
- Team B Backend: 20 hours (sync endpoints, conflict detection, data validation)
- Team C Integration: 20 hours (IndexedDB setup, service worker, cache management)
- Total: 68 hours