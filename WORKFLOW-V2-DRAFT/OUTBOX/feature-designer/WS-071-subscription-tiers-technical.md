# TECHNICAL SPECIFICATION: WS-071 - Subscription Tiers
## Generated by Feature Development Session - August 22, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding photographer growing from 5 to 50 clients per year
**I want to:** Access advanced features like unlimited client storage and AI-powered workflows as my business scales
**So that:** I can efficiently manage larger client volumes without manual workarounds or hitting arbitrary limits

**Real Wedding Scenario:**
A photographer starts with the free tier (10 clients, basic dashboard). As they book more weddings, they hit the client limit and need the Starter tier ($19/month, 50 clients, email automation). When they reach 50+ clients annually, they upgrade to Professional ($49/month, unlimited clients, AI chatbot, advanced analytics) to handle the volume efficiently.

### SPECIFICATION SOURCE
- **Feature ID:** WS-071
- **Original Spec:** /CORE-SPECIFICATIONS/02-WEDSYNC-SUPPLIER-PLATFORM/11-Billing-Settings/01-subscription-tiers md.md
- **Current Implementation:** 0% complete
- **Files to Modify:**
  - /wedsync/src/app/(dashboard)/settings/page.tsx (add billing tab)
  - /wedsync/src/middleware.ts (add feature gating middleware)
- **New Files to Create:**
  - /wedsync/src/app/(dashboard)/billing/page.tsx
  - /wedsync/src/app/(dashboard)/billing/upgrade/page.tsx
  - /wedsync/src/app/api/billing/subscription/route.ts
  - /wedsync/src/app/api/billing/usage/route.ts
  - /wedsync/src/app/api/billing/upgrade/route.ts
  - /wedsync/src/components/billing/SubscriptionManager.tsx
  - /wedsync/src/components/billing/UsageDisplay.tsx
  - /wedsync/src/components/billing/UpgradeDialog.tsx
  - /wedsync/src/lib/services/subscriptionService.ts
  - /wedsync/src/lib/services/usageTracker.ts
  - /wedsync/src/lib/billing/featureGating.ts
  - /wedsync/src/lib/billing/stripeClient.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Subscription tiers configuration
CREATE TABLE IF NOT EXISTS subscription_tiers (
  id VARCHAR(50) PRIMARY KEY, -- 'free', 'starter', 'professional'
  name VARCHAR(100) NOT NULL,
  price_cents INTEGER NOT NULL, -- 0 for free, 1900 for starter, 4900 for professional
  billing_interval VARCHAR(20) DEFAULT 'monthly',
  client_limit INTEGER DEFAULT -1, -- -1 for unlimited
  form_limit INTEGER DEFAULT -1,
  storage_mb INTEGER DEFAULT 100,
  features JSONB NOT NULL DEFAULT '[]',
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Supplier subscriptions
CREATE TABLE IF NOT EXISTS supplier_subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID NOT NULL REFERENCES suppliers(id),
  tier_id VARCHAR(50) NOT NULL REFERENCES subscription_tiers(id),
  stripe_subscription_id VARCHAR(255),
  stripe_customer_id VARCHAR(255),
  status VARCHAR(50) DEFAULT 'active', -- 'active', 'canceled', 'past_due', 'trial'
  current_period_start TIMESTAMP WITH TIME ZONE,
  current_period_end TIMESTAMP WITH TIME ZONE,
  trial_end TIMESTAMP WITH TIME ZONE,
  cancel_at_period_end BOOLEAN DEFAULT false,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  
  UNIQUE(supplier_id)
);

-- Usage tracking
CREATE TABLE IF NOT EXISTS usage_tracking (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID NOT NULL REFERENCES suppliers(id),
  resource_type VARCHAR(50) NOT NULL, -- 'clients', 'forms', 'storage'
  current_usage INTEGER NOT NULL DEFAULT 0,
  usage_date DATE NOT NULL DEFAULT CURRENT_DATE,
  
  UNIQUE(supplier_id, resource_type, usage_date)
);

-- Feature usage logs
CREATE TABLE IF NOT EXISTS feature_usage_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID NOT NULL REFERENCES suppliers(id),
  feature_key VARCHAR(100) NOT NULL,
  attempted_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  allowed BOOLEAN NOT NULL,
  tier_id VARCHAR(50) NOT NULL
);

-- Insert default tiers
INSERT INTO subscription_tiers (id, name, price_cents, client_limit, form_limit, storage_mb, features) VALUES
('free', 'Free', 0, 10, 1, 100, '["basic_dashboard"]'),
('starter', 'Starter', 1900, 50, 5, 5000, '["basic_dashboard", "email_automation", "custom_domain"]'),
('professional', 'Professional', 4900, -1, -1, 50000, '["basic_dashboard", "email_automation", "custom_domain", "ai_chatbot", "journey_builder", "analytics"]');
```

#### API Endpoints Required
```typescript
// GET /api/billing/subscription - Get current subscription
interface GetSubscriptionResponse {
  tier: {
    id: string;
    name: string;
    price: number;
    features: string[];
  };
  usage: {
    clients: { current: number; limit: number };
    forms: { current: number; limit: number };
    storage: { current: number; limit: number; unit: 'MB' };
  };
  billing: {
    status: string;
    currentPeriodEnd: string;
    cancelAtPeriodEnd: boolean;
  };
}

// POST /api/billing/upgrade - Upgrade subscription
interface UpgradeRequest {
  newTierId: 'starter' | 'professional';
  paymentMethodId?: string;
}

interface UpgradeResponse {
  success: boolean;
  clientSecret?: string; // For 3D Secure payments
  subscriptionId: string;
}

// GET /api/billing/usage - Get detailed usage statistics
interface UsageResponse {
  current: {
    clients: number;
    forms: number;
    storageMB: number;
  };
  trends: {
    date: string;
    clients: number;
    forms: number;
    storageMB: number;
  }[];
  projectedUsage: {
    clients: number; // Based on growth trend
    estimatedOverage: number;
  };
}
```

#### Frontend Components Required
```typescript
// Component: SubscriptionManager
// Location: /src/components/billing/SubscriptionManager.tsx

interface SubscriptionManagerProps {
  supplierId: string;
  currentSubscription: Subscription;
}

// Key functionality:
- Display current tier and features
- Show usage meters with visual progress bars
- Upgrade/downgrade flow with Stripe integration
- Billing history and invoice downloads
- Cancel subscription with confirmation

// Component: UsageDisplay  
// Location: /src/components/billing/UsageDisplay.tsx

interface UsageDisplayProps {
  usage: UsageData;
  limits: TierLimits;
  showProjections?: boolean;
}

// Key functionality:
- Visual usage meters for each resource type
- Color-coded alerts when approaching limits
- Usage trends over time (charts)
- Projected overage warnings
- Upgrade prompts when limits exceeded

// Component: UpgradeDialog
// Location: /src/components/billing/UpgradeDialog.tsx

interface UpgradeDialogProps {
  currentTier: string;
  targetTier: string;
  onUpgrade: (paymentMethod: string) => Promise<void>;
}

// Key functionality:
- Feature comparison between tiers
- Stripe payment form integration
- Proration calculation display
- 3D Secure payment handling
- Success/error state management
```

#### Integration Points
```typescript
// Service: SubscriptionService
// Dependencies: Stripe, Supabase, Redis cache

class SubscriptionService {
  async getCurrentSubscription(supplierId: string) {
    // Check cache first (5 minute TTL)
    const cached = await redis.get(`subscription:${supplierId}`);
    if (cached) return JSON.parse(cached);
    
    // Fetch from database with tier details
    const subscription = await supabase
      .from('supplier_subscriptions')
      .select('*, subscription_tiers(*)')
      .eq('supplier_id', supplierId)
      .single();
    
    // Cache result
    await redis.setex(`subscription:${supplierId}`, 300, JSON.stringify(subscription));
    return subscription;
  }
  
  async checkFeatureAccess(supplierId: string, featureKey: string) {
    const subscription = await this.getCurrentSubscription(supplierId);
    const hasAccess = subscription.tier.features.includes(featureKey) || 
                      subscription.tier.features.includes('*');
    
    // Log access attempt for analytics
    await this.logFeatureUsage(supplierId, featureKey, hasAccess);
    
    return hasAccess;
  }
  
  async upgradeSubscription(supplierId: string, newTierId: string, paymentMethodId?: string) {
    // Create or update Stripe subscription
    const stripeResult = await stripe.subscriptions.create({
      customer: subscription.stripe_customer_id,
      items: [{ price: getPriceIdForTier(newTierId) }],
      default_payment_method: paymentMethodId,
      proration_behavior: 'create_prorations'
    });
    
    // Update local subscription record
    await supabase
      .from('supplier_subscriptions')
      .update({
        tier_id: newTierId,
        stripe_subscription_id: stripeResult.id,
        status: stripeResult.status,
        updated_at: new Date().toISOString()
      })
      .eq('supplier_id', supplierId);
    
    // Clear cache
    await redis.del(`subscription:${supplierId}`);
    
    return stripeResult;
  }
}
```

### CODE EXAMPLES

#### Example 1: Feature Gating Middleware
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';

export async function featureGatingMiddleware(request: NextRequest) {
  const supabase = createClient();
  
  // Step 1: Extract supplier ID from session
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) return NextResponse.redirect(new URL('/login', request.url));
  
  const supplierId = session.user.id;
  
  // Step 2: Check if route requires feature gating
  const protectedRoutes = {
    '/ai-chatbot': 'ai_chatbot',
    '/journey-builder': 'journey_builder', 
    '/analytics': 'analytics',
    '/email-automation': 'email_automation'
  };
  
  const requiredFeature = protectedRoutes[request.nextUrl.pathname];
  if (!requiredFeature) return NextResponse.next();
  
  // Step 3: Check subscription and feature access
  const { data: subscription } = await supabase
    .from('supplier_subscriptions')
    .select('tier_id, subscription_tiers(features)')
    .eq('supplier_id', supplierId)
    .eq('status', 'active')
    .single();
  
  const hasAccess = subscription?.subscription_tiers.features.includes(requiredFeature);
  
  // Step 4: Redirect to upgrade if no access
  if (!hasAccess) {
    const upgradeUrl = new URL('/billing/upgrade', request.url);
    upgradeUrl.searchParams.set('feature', requiredFeature);
    return NextResponse.redirect(upgradeUrl);
  }
  
  return NextResponse.next();
}

// Usage tracking function
export async function trackUsage(supplierId: string, resourceType: string, delta: number = 1) {
  const today = new Date().toISOString().split('T')[0];
  
  await supabase
    .from('usage_tracking')
    .upsert({
      supplier_id: supplierId,
      resource_type: resourceType,
      current_usage: delta,
      usage_date: today
    }, {
      onConflict: 'supplier_id, resource_type, usage_date',
      // Increment existing usage
      ignoreDuplicates: false
    });
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [ ] Context7: Load docs for Stripe integration, Next.js middleware
- [ ] Playwright: Test subscription upgrade flow and payment processing
- [ ] Filesystem: Access billing templates and legal documents

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/stripe/stripe-node", "subscriptions", 3000);
await mcp__context7__get-library-docs("/vercel/next.js", "middleware", 2000);
await mcp__context7__get-library-docs("/recharts/recharts", "charts", 1500);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('Subscription Service', () => {
  it('should check feature access correctly for each tier', async () => {
    const freeTierAccess = await subscriptionService.checkFeatureAccess('supplier-free', 'ai_chatbot');
    expect(freeTierAccess).toBe(false);
    
    const proTierAccess = await subscriptionService.checkFeatureAccess('supplier-pro', 'ai_chatbot');
    expect(proTierAccess).toBe(true);
  });
  
  it('should track usage and enforce limits', async () => {
    await usageTracker.trackUsage('supplier-123', 'clients', 1);
    const usage = await usageTracker.getCurrentUsage('supplier-123', 'clients');
    expect(usage).toBe(1);
    
    // Should throw when limit exceeded
    await expect(
      usageTracker.enforceLimit('supplier-free', 'clients', 11)
    ).rejects.toThrow('Client limit exceeded');
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Subscription upgrade flow', async () => {
  await mcp__playwright__browser_navigate({url: '/billing'});
  await mcp__playwright__browser_snapshot();
  
  // Test upgrade button
  await mcp__playwright__browser_click({
    element: "Upgrade to Professional button",
    ref: "button[data-testid='upgrade-professional']"
  });
  
  // Test Stripe payment form
  await mcp__playwright__browser_type({
    element: "Card number input",
    ref: "input[data-testid='card-number']",
    text: "4242424242424242"
  });
  
  // Test usage meter display
  const usageMeter = await mcp__playwright__browser_evaluate({
    function: "() => document.querySelector('[data-testid=\"usage-meter\"]').getAttribute('data-percentage')"
  });
  expect(parseInt(usageMeter)).toBeGreaterThan(0);
});
```

### ACCEPTANCE CRITERIA
- [ ] Three subscription tiers (Free, Starter, Professional) with correct pricing and limits
- [ ] Feature gating prevents access to premium features without proper subscription
- [ ] Usage tracking accurately monitors clients, forms, and storage consumption
- [ ] Stripe integration handles subscription creation, upgrades, and downgrades
- [ ] Proration calculations are correct for mid-cycle changes
- [ ] Performance: Feature access checks complete within 50ms (cached)
- [ ] Security: Payment data handled only by Stripe, never stored locally
- [ ] Accessibility: Billing interface complies with WCAG 2.1 AA

### DEPENDENCIES
- Must complete after: None (foundational billing system)
- Must complete before: WS-072 (API Key Management) - needs subscription validation
- Shares code with: All premium features requiring gating

### ESTIMATED EFFORT
- Team B Backend: 20 hours (Stripe integration, usage tracking, feature gating)
- Team E Full-stack: 24 hours (Billing UI, subscription management, payment flows)
- Team C Integration: 8 hours (Middleware integration, feature flag deployment)
- Total: 52 hours