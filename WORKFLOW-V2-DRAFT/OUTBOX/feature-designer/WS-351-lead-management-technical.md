# TECHNICAL SPECIFICATION: WS-351 - Comprehensive Lead Management System
## Generated by Feature Development Session - 2025-01-20

### USER STORY & BUSINESS CONTEXT
**As a:** Wedding supplier managing multiple prospects and client inquiries
**I want to:** A comprehensive lead management system that captures, tracks, nurtures, and converts wedding inquiries into bookings
**So that:** I can maximize conversion rates, never lose a potential client, and systematically grow my wedding business through data-driven lead management

**Real Wedding Scenario:**
Sarah, a wedding photographer, receives 15-20 inquiries per week during peak season (January-March). Currently using spreadsheets, she loses track of follow-ups, can't measure conversion rates, and struggles to identify which marketing channels generate quality leads. With WedSync's Lead Management System, she can automatically capture leads from her website, track all interactions, set up automated follow-up sequences, measure conversion rates by source, and increase her booking rate from 20% to 35%.

**Business Impact:**
- 73% of wedding suppliers struggle with lead follow-up consistency
- Average wedding inquiry is worth £2,400 in potential revenue
- Proper lead nurturing increases conversion rates by 40-60%
- Lost leads cost wedding businesses an average of £28,000 annually
- Systematic lead scoring improves sales efficiency by 45%

### SPECIFICATION SOURCE
- **Feature ID:** WS-351
- **Original Spec:** /CORE-SPECIFICATIONS/lead-management-system/
- **Current Implementation:** 0% complete (new comprehensive system)
- **Files to Modify:** 
  - `/src/app/leads/page.tsx` - Lead dashboard interface
  - `/src/components/leads/` - All lead management components
  - `/src/lib/leads/` - Lead processing services
- **New Files to Create:**
  - Lead capture forms and widgets
  - Lead scoring engine
  - Automated nurture sequences
  - Conversion tracking analytics
  - Lead source attribution system

### TECHNICAL DESIGN

#### Database Schema Required

```sql
-- Core leads table with comprehensive tracking
CREATE TABLE leads (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    lead_source VARCHAR(100) NOT NULL, -- 'website', 'social_media', 'referral', 'wedding_show', 'google_ads', 'facebook_ads', 'instagram', 'directory_listing', 'word_of_mouth', 'email_marketing', 'seo_organic'
    source_details JSONB DEFAULT '{}', -- Additional source metadata
    
    -- Contact Information
    couple_name_bride VARCHAR(255),
    couple_name_groom VARCHAR(255),
    primary_email VARCHAR(255) NOT NULL,
    secondary_email VARCHAR(255),
    primary_phone VARCHAR(20),
    secondary_phone VARCHAR(20),
    preferred_contact_method VARCHAR(50) CHECK (preferred_contact_method IN ('email', 'phone', 'whatsapp', 'text')) DEFAULT 'email',
    
    -- Wedding Details
    wedding_date DATE,
    wedding_venue TEXT,
    wedding_location VARCHAR(255),
    estimated_guest_count INTEGER,
    estimated_budget DECIMAL(12,2),
    budget_range VARCHAR(50), -- 'under_1000', '1000_2500', '2500_5000', '5000_10000', '10000_plus'
    
    -- Service Requirements
    services_needed TEXT[], -- Array of service types needed
    specific_requirements TEXT,
    additional_notes TEXT,
    
    -- Lead Status & Scoring
    lead_status VARCHAR(50) CHECK (lead_status IN ('new', 'contacted', 'qualified', 'proposal_sent', 'follow_up', 'negotiation', 'won', 'lost', 'spam', 'duplicate')) DEFAULT 'new',
    lead_score INTEGER DEFAULT 0, -- 0-100 scoring system
    priority_level VARCHAR(20) CHECK (priority_level IN ('low', 'medium', 'high', 'urgent')) DEFAULT 'medium',
    quality_rating DECIMAL(2,1) CHECK (quality_rating >= 1.0 AND quality_rating <= 5.0),
    
    -- Engagement Tracking
    first_contact_at TIMESTAMPTZ,
    last_contact_at TIMESTAMPTZ,
    next_follow_up_at TIMESTAMPTZ,
    total_interactions INTEGER DEFAULT 0,
    email_opens INTEGER DEFAULT 0,
    email_clicks INTEGER DEFAULT 0,
    website_visits INTEGER DEFAULT 0,
    
    -- Conversion Tracking
    converted_at TIMESTAMPTZ,
    conversion_value DECIMAL(12,2),
    lost_reason VARCHAR(100),
    lost_details TEXT,
    
    -- Assignment & Ownership
    assigned_to_user_id UUID REFERENCES users(id),
    team_id UUID REFERENCES teams(id),
    
    -- Automation
    nurture_sequence_id UUID REFERENCES nurture_sequences(id),
    automation_paused BOOLEAN DEFAULT FALSE,
    
    -- Privacy & Compliance
    consent_marketing BOOLEAN DEFAULT FALSE,
    consent_data_processing BOOLEAN DEFAULT FALSE,
    gdpr_consent_date TIMESTAMPTZ,
    opt_out_date TIMESTAMPTZ,
    
    -- Metadata
    tags TEXT[] DEFAULT '{}',
    custom_fields JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    -- Indexes
    INDEX idx_leads_supplier_id (supplier_id),
    INDEX idx_leads_status (lead_status),
    INDEX idx_leads_source (lead_source),
    INDEX idx_leads_score (lead_score DESC),
    INDEX idx_leads_wedding_date (wedding_date),
    INDEX idx_leads_follow_up (next_follow_up_at),
    INDEX idx_leads_created (created_at DESC),
    UNIQUE INDEX idx_leads_supplier_email (supplier_id, primary_email)
);

-- Lead interactions and activity log
CREATE TABLE lead_interactions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lead_id UUID NOT NULL REFERENCES leads(id) ON DELETE CASCADE,
    user_id UUID REFERENCES users(id), -- Who performed the interaction
    
    interaction_type VARCHAR(50) CHECK (interaction_type IN (
        'email_sent', 'email_opened', 'email_clicked', 'phone_call', 'meeting_scheduled', 
        'meeting_completed', 'proposal_sent', 'proposal_viewed', 'contract_sent', 
        'payment_received', 'note_added', 'status_changed', 'score_updated',
        'website_visit', 'social_media_engagement', 'referral_received'
    )) NOT NULL,
    
    interaction_subject VARCHAR(255),
    interaction_content TEXT,
    interaction_metadata JSONB DEFAULT '{}', -- Email templates, call duration, etc.
    
    -- Results & Outcomes
    interaction_outcome VARCHAR(100),
    follow_up_required BOOLEAN DEFAULT FALSE,
    follow_up_date TIMESTAMPTZ,
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    
    INDEX idx_lead_interactions_lead_id (lead_id),
    INDEX idx_lead_interactions_type (interaction_type),
    INDEX idx_lead_interactions_date (created_at DESC)
);

-- Lead scoring rules and configuration
CREATE TABLE lead_scoring_rules (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    rule_name VARCHAR(255) NOT NULL,
    rule_description TEXT,
    
    -- Scoring Criteria
    criteria_type VARCHAR(50) CHECK (criteria_type IN (
        'demographic', 'behavioral', 'engagement', 'wedding_details', 'budget', 'timeline'
    )) NOT NULL,
    
    criteria_field VARCHAR(100) NOT NULL,
    criteria_operator VARCHAR(20) CHECK (criteria_operator IN ('equals', 'contains', 'greater_than', 'less_than', 'between', 'in_list')) NOT NULL,
    criteria_value TEXT NOT NULL,
    
    score_adjustment INTEGER NOT NULL, -- Can be positive or negative
    rule_weight DECIMAL(3,2) DEFAULT 1.0,
    
    is_active BOOLEAN DEFAULT TRUE,
    rule_order INTEGER DEFAULT 0,
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    
    INDEX idx_scoring_rules_supplier (supplier_id),
    INDEX idx_scoring_rules_criteria (criteria_type),
    INDEX idx_scoring_rules_active (is_active)
);

-- Lead sources and attribution tracking
CREATE TABLE lead_sources (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    source_name VARCHAR(100) NOT NULL,
    source_category VARCHAR(50) CHECK (source_category IN (
        'paid_advertising', 'organic_search', 'social_media', 'referral', 
        'directory', 'email_marketing', 'direct', 'partnership'
    )) NOT NULL,
    
    -- Tracking Configuration
    tracking_url TEXT,
    utm_parameters JSONB DEFAULT '{}',
    conversion_tracking_code TEXT,
    
    -- Performance Metrics
    total_leads INTEGER DEFAULT 0,
    qualified_leads INTEGER DEFAULT 0,
    converted_leads INTEGER DEFAULT 0,
    total_revenue DECIMAL(12,2) DEFAULT 0.00,
    cost_per_lead DECIMAL(8,2) DEFAULT 0.00,
    
    -- Configuration
    is_active BOOLEAN DEFAULT TRUE,
    auto_assign_to_user_id UUID REFERENCES users(id),
    default_priority VARCHAR(20) DEFAULT 'medium',
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    INDEX idx_lead_sources_supplier (supplier_id),
    INDEX idx_lead_sources_category (source_category),
    UNIQUE INDEX idx_lead_sources_name (supplier_id, source_name)
);

-- Automated nurture sequences
CREATE TABLE nurture_sequences (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    sequence_name VARCHAR(255) NOT NULL,
    sequence_description TEXT,
    
    -- Triggering Conditions
    trigger_conditions JSONB DEFAULT '{}', -- When to start this sequence
    target_lead_status VARCHAR(50)[],
    target_lead_sources VARCHAR(100)[],
    target_score_range INTEGER[], -- [min, max]
    
    -- Sequence Settings
    is_active BOOLEAN DEFAULT TRUE,
    sequence_type VARCHAR(50) CHECK (sequence_type IN ('welcome', 'nurture', 're_engagement', 'post_inquiry', 'pre_wedding', 'post_wedding')) NOT NULL,
    priority_level INTEGER DEFAULT 1,
    
    -- Performance Tracking
    total_enrollments INTEGER DEFAULT 0,
    completion_rate DECIMAL(5,2) DEFAULT 0.00,
    conversion_rate DECIMAL(5,2) DEFAULT 0.00,
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    INDEX idx_nurture_sequences_supplier (supplier_id),
    INDEX idx_nurture_sequences_active (is_active),
    UNIQUE INDEX idx_nurture_sequences_name (supplier_id, sequence_name)
);

-- Individual steps within nurture sequences
CREATE TABLE nurture_sequence_steps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    sequence_id UUID NOT NULL REFERENCES nurture_sequences(id) ON DELETE CASCADE,
    step_order INTEGER NOT NULL,
    step_name VARCHAR(255) NOT NULL,
    
    -- Step Configuration
    step_type VARCHAR(50) CHECK (step_type IN (
        'email', 'sms', 'phone_call', 'task_creation', 'score_adjustment', 'status_change', 'tag_assignment'
    )) NOT NULL,
    
    -- Timing
    delay_amount INTEGER NOT NULL, -- Number of delay units
    delay_unit VARCHAR(20) CHECK (delay_unit IN ('minutes', 'hours', 'days', 'weeks')) NOT NULL,
    send_time TIME DEFAULT '09:00:00',
    send_days INTEGER[] DEFAULT '{1,2,3,4,5}', -- Days of week (1=Monday)
    
    -- Content
    email_template_id UUID REFERENCES email_templates(id),
    sms_template_id UUID REFERENCES sms_templates(id),
    task_template_id UUID REFERENCES task_templates(id),
    step_content TEXT,
    
    -- Conditions & Branching
    execution_conditions JSONB DEFAULT '{}',
    branch_conditions JSONB DEFAULT '{}',
    
    is_active BOOLEAN DEFAULT TRUE,
    
    INDEX idx_sequence_steps_sequence (sequence_id),
    INDEX idx_sequence_steps_order (step_order)
);

-- Track lead enrollment in nurture sequences
CREATE TABLE lead_nurture_enrollments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lead_id UUID NOT NULL REFERENCES leads(id) ON DELETE CASCADE,
    sequence_id UUID NOT NULL REFERENCES nurture_sequences(id) ON DELETE CASCADE,
    
    enrollment_date TIMESTAMPTZ DEFAULT NOW(),
    current_step_id UUID REFERENCES nurture_sequence_steps(id),
    next_execution_at TIMESTAMPTZ,
    
    -- Status
    status VARCHAR(50) CHECK (status IN ('active', 'paused', 'completed', 'cancelled', 'failed')) DEFAULT 'active',
    completion_rate DECIMAL(5,2) DEFAULT 0.00,
    
    -- Performance
    steps_completed INTEGER DEFAULT 0,
    emails_opened INTEGER DEFAULT 0,
    emails_clicked INTEGER DEFAULT 0,
    converted BOOLEAN DEFAULT FALSE,
    conversion_step_id UUID REFERENCES nurture_sequence_steps(id),
    
    ended_at TIMESTAMPTZ,
    end_reason VARCHAR(100),
    
    INDEX idx_enrollments_lead (lead_id),
    INDEX idx_enrollments_sequence (sequence_id),
    INDEX idx_enrollments_status (status),
    INDEX idx_enrollments_next_execution (next_execution_at),
    UNIQUE INDEX idx_enrollments_lead_sequence (lead_id, sequence_id)
);

-- Lead conversion tracking and attribution
CREATE TABLE lead_conversions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lead_id UUID NOT NULL REFERENCES leads(id) ON DELETE CASCADE,
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    
    -- Conversion Details
    conversion_type VARCHAR(50) CHECK (conversion_type IN (
        'booking_confirmed', 'contract_signed', 'deposit_paid', 'full_payment', 'service_completed'
    )) NOT NULL,
    conversion_value DECIMAL(12,2) NOT NULL,
    conversion_date TIMESTAMPTZ DEFAULT NOW(),
    
    -- Attribution
    first_touch_source VARCHAR(100),
    last_touch_source VARCHAR(100),
    touch_points_count INTEGER DEFAULT 0,
    attribution_model VARCHAR(50) DEFAULT 'last_touch', -- 'first_touch', 'last_touch', 'linear', 'time_decay'
    
    -- Lead Journey Metrics
    days_to_conversion INTEGER,
    total_interactions INTEGER,
    nurture_sequences_completed INTEGER DEFAULT 0,
    
    -- Revenue Attribution
    attributed_revenue DECIMAL(12,2),
    commission_amount DECIMAL(8,2),
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    
    INDEX idx_conversions_lead (lead_id),
    INDEX idx_conversions_supplier (supplier_id),
    INDEX idx_conversions_date (conversion_date DESC),
    INDEX idx_conversions_value (conversion_value DESC)
);

-- Lead analytics and reporting aggregations
CREATE TABLE lead_analytics_daily (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    date_recorded DATE NOT NULL,
    
    -- Volume Metrics
    leads_created INTEGER DEFAULT 0,
    leads_qualified INTEGER DEFAULT 0,
    leads_converted INTEGER DEFAULT 0,
    leads_lost INTEGER DEFAULT 0,
    
    -- Source Breakdown
    source_breakdown JSONB DEFAULT '{}',
    
    -- Conversion Metrics
    total_conversion_value DECIMAL(12,2) DEFAULT 0.00,
    average_lead_score DECIMAL(5,2),
    average_days_to_conversion DECIMAL(5,2),
    
    -- Activity Metrics
    total_interactions INTEGER DEFAULT 0,
    emails_sent INTEGER DEFAULT 0,
    calls_made INTEGER DEFAULT 0,
    meetings_scheduled INTEGER DEFAULT 0,
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    
    INDEX idx_analytics_supplier (supplier_id),
    INDEX idx_analytics_date (date_recorded DESC),
    UNIQUE INDEX idx_analytics_supplier_date (supplier_id, date_recorded)
);
```

#### API Endpoints Required

```typescript
// Lead Management API Types
interface Lead {
    id: string;
    supplier_id: string;
    lead_source: string;
    source_details: Record<string, any>;
    
    // Contact Information
    couple_name_bride?: string;
    couple_name_groom?: string;
    primary_email: string;
    secondary_email?: string;
    primary_phone?: string;
    secondary_phone?: string;
    preferred_contact_method: 'email' | 'phone' | 'whatsapp' | 'text';
    
    // Wedding Details
    wedding_date?: string;
    wedding_venue?: string;
    wedding_location?: string;
    estimated_guest_count?: number;
    estimated_budget?: number;
    budget_range?: string;
    
    // Service Requirements
    services_needed: string[];
    specific_requirements?: string;
    additional_notes?: string;
    
    // Lead Status & Scoring
    lead_status: 'new' | 'contacted' | 'qualified' | 'proposal_sent' | 'follow_up' | 'negotiation' | 'won' | 'lost' | 'spam' | 'duplicate';
    lead_score: number;
    priority_level: 'low' | 'medium' | 'high' | 'urgent';
    quality_rating?: number;
    
    // Engagement Tracking
    first_contact_at?: string;
    last_contact_at?: string;
    next_follow_up_at?: string;
    total_interactions: number;
    email_opens: number;
    email_clicks: number;
    website_visits: number;
    
    // Conversion Tracking
    converted_at?: string;
    conversion_value?: number;
    lost_reason?: string;
    lost_details?: string;
    
    // Assignment & Ownership
    assigned_to_user_id?: string;
    team_id?: string;
    
    // Automation
    nurture_sequence_id?: string;
    automation_paused: boolean;
    
    // Privacy & Compliance
    consent_marketing: boolean;
    consent_data_processing: boolean;
    gdpr_consent_date?: string;
    opt_out_date?: string;
    
    // Metadata
    tags: string[];
    custom_fields: Record<string, any>;
    created_at: string;
    updated_at: string;
}

interface LeadCreateRequest {
    lead_source: string;
    source_details?: Record<string, any>;
    couple_name_bride?: string;
    couple_name_groom?: string;
    primary_email: string;
    secondary_email?: string;
    primary_phone?: string;
    secondary_phone?: string;
    preferred_contact_method?: 'email' | 'phone' | 'whatsapp' | 'text';
    wedding_date?: string;
    wedding_venue?: string;
    wedding_location?: string;
    estimated_guest_count?: number;
    estimated_budget?: number;
    budget_range?: string;
    services_needed: string[];
    specific_requirements?: string;
    additional_notes?: string;
    consent_marketing: boolean;
    consent_data_processing: boolean;
    tags?: string[];
    custom_fields?: Record<string, any>;
}

interface LeadUpdateRequest {
    couple_name_bride?: string;
    couple_name_groom?: string;
    secondary_email?: string;
    secondary_phone?: string;
    preferred_contact_method?: 'email' | 'phone' | 'whatsapp' | 'text';
    wedding_date?: string;
    wedding_venue?: string;
    wedding_location?: string;
    estimated_guest_count?: number;
    estimated_budget?: number;
    budget_range?: string;
    services_needed?: string[];
    specific_requirements?: string;
    additional_notes?: string;
    lead_status?: 'new' | 'contacted' | 'qualified' | 'proposal_sent' | 'follow_up' | 'negotiation' | 'won' | 'lost' | 'spam' | 'duplicate';
    priority_level?: 'low' | 'medium' | 'high' | 'urgent';
    quality_rating?: number;
    next_follow_up_at?: string;
    assigned_to_user_id?: string;
    team_id?: string;
    nurture_sequence_id?: string;
    automation_paused?: boolean;
    tags?: string[];
    custom_fields?: Record<string, any>;
    lost_reason?: string;
    lost_details?: string;
}

interface LeadInteraction {
    id: string;
    lead_id: string;
    user_id?: string;
    interaction_type: string;
    interaction_subject?: string;
    interaction_content?: string;
    interaction_metadata: Record<string, any>;
    interaction_outcome?: string;
    follow_up_required: boolean;
    follow_up_date?: string;
    created_at: string;
}

interface LeadScoringRule {
    id: string;
    supplier_id: string;
    rule_name: string;
    rule_description?: string;
    criteria_type: 'demographic' | 'behavioral' | 'engagement' | 'wedding_details' | 'budget' | 'timeline';
    criteria_field: string;
    criteria_operator: 'equals' | 'contains' | 'greater_than' | 'less_than' | 'between' | 'in_list';
    criteria_value: string;
    score_adjustment: number;
    rule_weight: number;
    is_active: boolean;
    rule_order: number;
    created_at: string;
}

interface LeadSource {
    id: string;
    supplier_id: string;
    source_name: string;
    source_category: 'paid_advertising' | 'organic_search' | 'social_media' | 'referral' | 'directory' | 'email_marketing' | 'direct' | 'partnership';
    tracking_url?: string;
    utm_parameters: Record<string, any>;
    conversion_tracking_code?: string;
    total_leads: number;
    qualified_leads: number;
    converted_leads: number;
    total_revenue: number;
    cost_per_lead: number;
    is_active: boolean;
    auto_assign_to_user_id?: string;
    default_priority: string;
    created_at: string;
    updated_at: string;
}

interface NurtureSequence {
    id: string;
    supplier_id: string;
    sequence_name: string;
    sequence_description?: string;
    trigger_conditions: Record<string, any>;
    target_lead_status: string[];
    target_lead_sources: string[];
    target_score_range: number[];
    is_active: boolean;
    sequence_type: 'welcome' | 'nurture' | 're_engagement' | 'post_inquiry' | 'pre_wedding' | 'post_wedding';
    priority_level: number;
    total_enrollments: number;
    completion_rate: number;
    conversion_rate: number;
    created_at: string;
    updated_at: string;
}

interface LeadsListResponse {
    leads: Lead[];
    pagination: {
        total: number;
        page: number;
        limit: number;
        totalPages: number;
    };
    filters_applied: Record<string, any>;
    summary: {
        total_leads: number;
        new_leads: number;
        qualified_leads: number;
        converted_leads: number;
        average_score: number;
        conversion_rate: number;
    };
}

interface LeadAnalyticsResponse {
    date_range: {
        start_date: string;
        end_date: string;
    };
    metrics: {
        leads_created: number;
        leads_qualified: number;
        leads_converted: number;
        leads_lost: number;
        conversion_rate: number;
        average_lead_score: number;
        average_days_to_conversion: number;
        total_conversion_value: number;
    };
    source_performance: Array<{
        source_name: string;
        leads_count: number;
        conversion_rate: number;
        cost_per_lead: number;
        revenue_generated: number;
        roi: number;
    }>;
    trends: Array<{
        date: string;
        leads_created: number;
        leads_converted: number;
        conversion_value: number;
    }>;
    funnel_analysis: Array<{
        stage: string;
        count: number;
        percentage: number;
        drop_off_rate: number;
    }>;
}

// API Endpoints

// GET /api/leads - List and filter leads
interface LeadsListRequest {
    page?: number;
    limit?: number;
    status?: string[];
    source?: string[];
    assigned_to?: string;
    priority?: string[];
    score_min?: number;
    score_max?: number;
    wedding_date_from?: string;
    wedding_date_to?: string;
    created_from?: string;
    created_to?: string;
    tags?: string[];
    search?: string; // Search across name, email, venue, location
    sort_by?: 'created_at' | 'updated_at' | 'lead_score' | 'wedding_date' | 'next_follow_up';
    sort_order?: 'asc' | 'desc';
}

// POST /api/leads - Create new lead
interface LeadCreateResponse {
    success: boolean;
    lead: Lead;
    lead_score_calculated: number;
    nurture_sequences_enrolled: string[];
    message?: string;
}

// PUT /api/leads/:id - Update lead
interface LeadUpdateResponse {
    success: boolean;
    lead: Lead;
    score_changes: {
        old_score: number;
        new_score: number;
        score_adjustments: Array<{
            rule_name: string;
            adjustment: number;
        }>;
    };
    automation_changes: {
        sequences_enrolled: string[];
        sequences_removed: string[];
    };
    message?: string;
}

// POST /api/leads/:id/interactions - Add interaction
interface AddInteractionRequest {
    interaction_type: string;
    interaction_subject?: string;
    interaction_content?: string;
    interaction_metadata?: Record<string, any>;
    interaction_outcome?: string;
    follow_up_required?: boolean;
    follow_up_date?: string;
}

interface AddInteractionResponse {
    success: boolean;
    interaction: LeadInteraction;
    lead_score_updated: boolean;
    new_lead_score?: number;
    next_recommended_action?: string;
    message?: string;
}

// GET /api/leads/analytics - Lead analytics and reporting
interface LeadAnalyticsRequest {
    start_date: string;
    end_date: string;
    group_by?: 'day' | 'week' | 'month';
    sources?: string[];
    team_members?: string[];
    lead_statuses?: string[];
}

// GET/POST /api/lead-scoring/rules - Lead scoring rules management
interface ScoringRulesResponse {
    rules: LeadScoringRule[];
    total_rules: number;
    active_rules: number;
}

// GET/POST /api/lead-sources - Lead sources management
interface LeadSourcesResponse {
    sources: LeadSource[];
    performance_summary: {
        total_sources: number;
        best_performing_source: string;
        highest_conversion_rate: number;
        lowest_cost_per_lead: number;
    };
}

// GET/POST /api/nurture-sequences - Nurture sequences management
interface NurtureSequencesResponse {
    sequences: NurtureSequence[];
    active_enrollments: number;
    total_sequences: number;
    average_completion_rate: number;
}

// POST /api/leads/:id/convert - Mark lead as converted
interface ConvertLeadRequest {
    conversion_type: 'booking_confirmed' | 'contract_signed' | 'deposit_paid' | 'full_payment' | 'service_completed';
    conversion_value: number;
    conversion_date?: string;
    attributed_sources?: string[];
    notes?: string;
}

interface ConvertLeadResponse {
    success: boolean;
    conversion: LeadConversion;
    lead_updated: Lead;
    revenue_attributed: number;
    source_attributions: Array<{
        source: string;
        attribution_percentage: number;
        attributed_revenue: number;
    }>;
    message?: string;
}

// Webhook endpoints for external lead capture
interface WebhookLeadCapture {
    webhook_id: string;
    source_identifier: string;
    lead_data: LeadCreateRequest;
    verification_token?: string;
    timestamp: string;
}
```

### CODE EXAMPLES

#### Example 1: Lead Management Dashboard Component

```typescript
// /src/components/leads/LeadManagementDashboard.tsx
'use client';

import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Input } from '@/components/ui/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { DataTable } from '@/components/ui/data-table';
import { Progress } from '@/components/ui/progress';
import { Calendar, Phone, Mail, Star, TrendingUp, Users, DollarSign, Target } from 'lucide-react';
import { Lead, LeadsListResponse, LeadAnalyticsResponse } from '@/types/leads';
import { leadService } from '@/lib/leads/lead-service';
import { formatCurrency, formatDate, getStatusColor } from '@/lib/utils';

interface LeadManagementDashboardProps {
  initialData?: LeadsListResponse;
  analytics?: LeadAnalyticsResponse;
}

export function LeadManagementDashboard({ initialData, analytics }: LeadManagementDashboardProps) {
  const router = useRouter();
  const [leads, setLeads] = useState<Lead[]>(initialData?.leads || []);
  const [loading, setLoading] = useState(false);
  const [filters, setFilters] = useState({
    status: '',
    source: '',
    priority: '',
    assigned_to: '',
    search: ''
  });
  const [selectedLeads, setSelectedLeads] = useState<string[]>([]);
  const [viewMode, setViewMode] = useState<'list' | 'cards' | 'pipeline'>('list');

  // Lead status statistics
  const statusStats = {
    new: leads.filter(l => l.lead_status === 'new').length,
    contacted: leads.filter(l => l.lead_status === 'contacted').length,
    qualified: leads.filter(l => l.lead_status === 'qualified').length,
    proposal_sent: leads.filter(l => l.lead_status === 'proposal_sent').length,
    won: leads.filter(l => l.lead_status === 'won').length,
    lost: leads.filter(l => l.lead_status === 'lost').length
  };

  const conversionRate = leads.length > 0 ? (statusStats.won / leads.length * 100) : 0;
  const averageScore = leads.reduce((sum, lead) => sum + lead.lead_score, 0) / leads.length || 0;

  const handleFilterChange = async (key: string, value: string) => {
    const newFilters = { ...filters, [key]: value };
    setFilters(newFilters);
    await loadLeads(newFilters);
  };

  const loadLeads = async (filterParams = filters) => {
    setLoading(true);
    try {
      const response = await leadService.getLeads({
        ...filterParams,
        page: 1,
        limit: 50
      });
      setLeads(response.leads);
    } catch (error) {
      console.error('Failed to load leads:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleLeadClick = (leadId: string) => {
    router.push(`/leads/${leadId}`);
  };

  const handleBulkAction = async (action: string) => {
    if (selectedLeads.length === 0) return;
    
    try {
      setLoading(true);
      await leadService.bulkUpdateLeads(selectedLeads, { action });
      await loadLeads();
      setSelectedLeads([]);
    } catch (error) {
      console.error('Bulk action failed:', error);
    } finally {
      setLoading(false);
    }
  };

  const columns = [
    {
      accessorKey: 'select',
      header: ({ table }) => (
        <input
          type="checkbox"
          checked={table.getIsAllPageRowsSelected()}
          onChange={(e) => {
            if (e.target.checked) {
              setSelectedLeads(leads.map(l => l.id));
            } else {
              setSelectedLeads([]);
            }
          }}
        />
      ),
      cell: ({ row }) => {
        const lead = row.original as Lead;
        return (
          <input
            type="checkbox"
            checked={selectedLeads.includes(lead.id)}
            onChange={(e) => {
              if (e.target.checked) {
                setSelectedLeads(prev => [...prev, lead.id]);
              } else {
                setSelectedLeads(prev => prev.filter(id => id !== lead.id));
              }
            }}
          />
        );
      }
    },
    {
      accessorKey: 'couple_names',
      header: 'Couple',
      cell: ({ row }) => {
        const lead = row.original as Lead;
        const coupleName = [lead.couple_name_bride, lead.couple_name_groom]
          .filter(Boolean)
          .join(' & ');
        return (
          <div className="space-y-1">
            <div className="font-medium">{coupleName || 'Unknown Couple'}</div>
            <div className="text-sm text-muted-foreground">{lead.primary_email}</div>
          </div>
        );
      }
    },
    {
      accessorKey: 'wedding_date',
      header: 'Wedding Date',
      cell: ({ row }) => {
        const lead = row.original as Lead;
        return (
          <div className="space-y-1">
            <div className="flex items-center gap-1">
              <Calendar className="w-4 h-4" />
              {lead.wedding_date ? formatDate(lead.wedding_date) : 'TBD'}
            </div>
            {lead.wedding_location && (
              <div className="text-sm text-muted-foreground">{lead.wedding_location}</div>
            )}
          </div>
        );
      }
    },
    {
      accessorKey: 'lead_status',
      header: 'Status',
      cell: ({ row }) => {
        const lead = row.original as Lead;
        return (
          <Badge 
            variant={getStatusColor(lead.lead_status)}
            className="capitalize"
          >
            {lead.lead_status.replace('_', ' ')}
          </Badge>
        );
      }
    },
    {
      accessorKey: 'lead_score',
      header: 'Score',
      cell: ({ row }) => {
        const lead = row.original as Lead;
        return (
          <div className="flex items-center gap-2">
            <Progress value={lead.lead_score} className="w-16" />
            <span className="text-sm font-medium">{lead.lead_score}</span>
          </div>
        );
      }
    },
    {
      accessorKey: 'lead_source',
      header: 'Source',
      cell: ({ row }) => {
        const lead = row.original as Lead;
        return (
          <Badge variant="outline" className="capitalize">
            {lead.lead_source.replace('_', ' ')}
          </Badge>
        );
      }
    },
    {
      accessorKey: 'estimated_budget',
      header: 'Budget',
      cell: ({ row }) => {
        const lead = row.original as Lead;
        return lead.estimated_budget ? formatCurrency(lead.estimated_budget) : 'Not specified';
      }
    },
    {
      accessorKey: 'next_follow_up_at',
      header: 'Follow-up',
      cell: ({ row }) => {
        const lead = row.original as Lead;
        if (!lead.next_follow_up_at) return '-';
        
        const followUpDate = new Date(lead.next_follow_up_at);
        const isOverdue = followUpDate < new Date();
        
        return (
          <div className={`text-sm ${isOverdue ? 'text-red-600 font-medium' : 'text-muted-foreground'}`}>
            {formatDate(lead.next_follow_up_at)}
            {isOverdue && ' (Overdue)'}
          </div>
        );
      }
    },
    {
      id: 'actions',
      cell: ({ row }) => {
        const lead = row.original as Lead;
        return (
          <div className="flex gap-1">
            <Button variant="ghost" size="sm" onClick={() => handleLeadClick(lead.id)}>
              View
            </Button>
            <Button 
              variant="ghost" 
              size="sm" 
              onClick={() => window.open(`mailto:${lead.primary_email}`)}
            >
              <Mail className="w-4 h-4" />
            </Button>
            {lead.primary_phone && (
              <Button 
                variant="ghost" 
                size="sm" 
                onClick={() => window.open(`tel:${lead.primary_phone}`)}
              >
                <Phone className="w-4 h-4" />
              </Button>
            )}
          </div>
        );
      }
    }
  ];

  return (
    <div className="space-y-6">
      {/* Header with key metrics */}
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-3xl font-bold">Lead Management</h1>
          <p className="text-muted-foreground">Manage and track your wedding inquiries</p>
        </div>
        <Button onClick={() => router.push('/leads/capture')}>
          Add New Lead
        </Button>
      </div>

      {/* Key Metrics Cards */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Total Leads</CardTitle>
            <Users className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{leads.length}</div>
            <p className="text-xs text-muted-foreground">
              {statusStats.new} new this week
            </p>
          </CardContent>
        </Card>
        
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Conversion Rate</CardTitle>
            <Target className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{conversionRate.toFixed(1)}%</div>
            <p className="text-xs text-muted-foreground">
              {statusStats.won} conversions
            </p>
          </CardContent>
        </Card>
        
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Average Score</CardTitle>
            <Star className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{averageScore.toFixed(0)}</div>
            <Progress value={averageScore} className="mt-2" />
          </CardContent>
        </Card>
        
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Revenue Pipeline</CardTitle>
            <DollarSign className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              {formatCurrency(leads.reduce((sum, lead) => sum + (lead.estimated_budget || 0), 0))}
            </div>
            <p className="text-xs text-muted-foreground">
              Potential revenue
            </p>
          </CardContent>
        </Card>
      </div>

      {/* Filters and Actions */}
      <Card>
        <CardContent className="pt-6">
          <div className="flex flex-wrap gap-4 mb-4">
            <Input
              placeholder="Search leads..."
              value={filters.search}
              onChange={(e) => handleFilterChange('search', e.target.value)}
              className="max-w-sm"
            />
            
            <Select value={filters.status} onValueChange={(value) => handleFilterChange('status', value)}>
              <SelectTrigger className="w-[180px]">
                <SelectValue placeholder="Status" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="">All Statuses</SelectItem>
                <SelectItem value="new">New</SelectItem>
                <SelectItem value="contacted">Contacted</SelectItem>
                <SelectItem value="qualified">Qualified</SelectItem>
                <SelectItem value="proposal_sent">Proposal Sent</SelectItem>
                <SelectItem value="won">Won</SelectItem>
                <SelectItem value="lost">Lost</SelectItem>
              </SelectContent>
            </Select>
            
            <Select value={filters.source} onValueChange={(value) => handleFilterChange('source', value)}>
              <SelectTrigger className="w-[180px]">
                <SelectValue placeholder="Source" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="">All Sources</SelectItem>
                <SelectItem value="website">Website</SelectItem>
                <SelectItem value="social_media">Social Media</SelectItem>
                <SelectItem value="referral">Referral</SelectItem>
                <SelectItem value="google_ads">Google Ads</SelectItem>
                <SelectItem value="wedding_show">Wedding Show</SelectItem>
              </SelectContent>
            </Select>
            
            <Select value={filters.priority} onValueChange={(value) => handleFilterChange('priority', value)}>
              <SelectTrigger className="w-[180px]">
                <SelectValue placeholder="Priority" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="">All Priorities</SelectItem>
                <SelectItem value="urgent">Urgent</SelectItem>
                <SelectItem value="high">High</SelectItem>
                <SelectItem value="medium">Medium</SelectItem>
                <SelectItem value="low">Low</SelectItem>
              </SelectContent>
            </Select>
          </div>
          
          {selectedLeads.length > 0 && (
            <div className="flex gap-2 mb-4">
              <Button 
                variant="outline" 
                size="sm"
                onClick={() => handleBulkAction('assign')}
              >
                Assign ({selectedLeads.length})
              </Button>
              <Button 
                variant="outline" 
                size="sm"
                onClick={() => handleBulkAction('change_status')}
              >
                Change Status
              </Button>
              <Button 
                variant="outline" 
                size="sm"
                onClick={() => handleBulkAction('add_tag')}
              >
                Add Tag
              </Button>
            </div>
          )}
        </CardContent>
      </Card>

      {/* Leads Data Table */}
      <Card>
        <CardContent className="pt-6">
          <DataTable
            columns={columns}
            data={leads}
            loading={loading}
            onRowClick={(lead) => handleLeadClick(lead.id)}
          />
        </CardContent>
      </Card>
    </div>
  );
}
```

#### Example 2: Lead Scoring Service

```typescript
// /src/lib/leads/lead-scoring-service.ts
import { supabase } from '@/lib/supabase';
import { Lead, LeadScoringRule } from '@/types/leads';

export class LeadScoringService {
  private scoreCache = new Map<string, number>();

  /**
   * Calculate lead score based on all active scoring rules
   */
  async calculateLeadScore(lead: Lead, supplierId: string): Promise<number> {
    const cacheKey = `${lead.id}_${supplierId}`;
    
    // Check cache first
    if (this.scoreCache.has(cacheKey)) {
      return this.scoreCache.get(cacheKey)!;
    }

    try {
      // Get all active scoring rules for the supplier
      const { data: rules, error } = await supabase
        .from('lead_scoring_rules')
        .select('*')
        .eq('supplier_id', supplierId)
        .eq('is_active', true)
        .order('rule_order', { ascending: true });

      if (error) throw error;

      let totalScore = 0;
      const scoreAdjustments: Array<{ rule_name: string; adjustment: number }> = [];

      // Apply each scoring rule
      for (const rule of rules || []) {
        const adjustment = this.applyRule(lead, rule);
        if (adjustment !== 0) {
          totalScore += adjustment * rule.rule_weight;
          scoreAdjustments.push({
            rule_name: rule.rule_name,
            adjustment: adjustment * rule.rule_weight
          });
        }
      }

      // Ensure score is within bounds (0-100)
      const finalScore = Math.max(0, Math.min(100, totalScore));

      // Cache the result
      this.scoreCache.set(cacheKey, finalScore);

      // Log scoring calculation for audit trail
      await this.logScoringCalculation(lead.id, finalScore, scoreAdjustments);

      return finalScore;
    } catch (error) {
      console.error('Error calculating lead score:', error);
      return 0; // Default score on error
    }
  }

  /**
   * Apply a single scoring rule to a lead
   */
  private applyRule(lead: Lead, rule: LeadScoringRule): number {
    const fieldValue = this.getFieldValue(lead, rule.criteria_field);
    
    if (fieldValue === null || fieldValue === undefined) {
      return 0;
    }

    switch (rule.criteria_operator) {
      case 'equals':
        return fieldValue === rule.criteria_value ? rule.score_adjustment : 0;
      
      case 'contains':
        if (typeof fieldValue === 'string') {
          return fieldValue.toLowerCase().includes(rule.criteria_value.toLowerCase()) 
            ? rule.score_adjustment : 0;
        }
        return 0;
      
      case 'greater_than':
        if (typeof fieldValue === 'number') {
          return fieldValue > parseFloat(rule.criteria_value) ? rule.score_adjustment : 0;
        }
        return 0;
      
      case 'less_than':
        if (typeof fieldValue === 'number') {
          return fieldValue < parseFloat(rule.criteria_value) ? rule.score_adjustment : 0;
        }
        return 0;
      
      case 'between':
        if (typeof fieldValue === 'number') {
          const [min, max] = rule.criteria_value.split(',').map(v => parseFloat(v.trim()));
          return fieldValue >= min && fieldValue <= max ? rule.score_adjustment : 0;
        }
        return 0;
      
      case 'in_list':
        const listValues = rule.criteria_value.split(',').map(v => v.trim().toLowerCase());
        const checkValue = typeof fieldValue === 'string' 
          ? fieldValue.toLowerCase() 
          : String(fieldValue).toLowerCase();
        return listValues.includes(checkValue) ? rule.score_adjustment : 0;
      
      default:
        return 0;
    }
  }

  /**
   * Get field value from lead object using dot notation
   */
  private getFieldValue(lead: Lead, fieldPath: string): any {
    const keys = fieldPath.split('.');
    let value: any = lead;
    
    for (const key of keys) {
      if (value && typeof value === 'object' && key in value) {
        value = value[key];
      } else {
        return null;
      }
    }
    
    return value;
  }

  /**
   * Batch calculate scores for multiple leads
   */
  async batchCalculateScores(leads: Lead[], supplierId: string): Promise<Map<string, number>> {
    const scores = new Map<string, number>();
    
    // Process in batches to avoid overwhelming the system
    const batchSize = 10;
    for (let i = 0; i < leads.length; i += batchSize) {
      const batch = leads.slice(i, i + batchSize);
      const batchPromises = batch.map(lead => 
        this.calculateLeadScore(lead, supplierId).then(score => ({ leadId: lead.id, score }))
      );
      
      const batchResults = await Promise.all(batchPromises);
      batchResults.forEach(({ leadId, score }) => {
        scores.set(leadId, score);
      });
    }
    
    return scores;
  }

  /**
   * Update lead score in database
   */
  async updateLeadScore(leadId: string, newScore: number): Promise<void> {
    const { error } = await supabase
      .from('leads')
      .update({ lead_score: newScore, updated_at: new Date().toISOString() })
      .eq('id', leadId);

    if (error) {
      throw new Error(`Failed to update lead score: ${error.message}`);
    }
  }

  /**
   * Get scoring rules for a supplier
   */
  async getScoringRules(supplierId: string): Promise<LeadScoringRule[]> {
    const { data, error } = await supabase
      .from('lead_scoring_rules')
      .select('*')
      .eq('supplier_id', supplierId)
      .order('rule_order', { ascending: true });

    if (error) {
      throw new Error(`Failed to get scoring rules: ${error.message}`);
    }

    return data || [];
  }

  /**
   * Create or update scoring rule
   */
  async upsertScoringRule(rule: Partial<LeadScoringRule>): Promise<LeadScoringRule> {
    const { data, error } = await supabase
      .from('lead_scoring_rules')
      .upsert(rule)
      .select()
      .single();

    if (error) {
      throw new Error(`Failed to upsert scoring rule: ${error.message}`);
    }

    // Clear cache when rules change
    this.scoreCache.clear();

    return data;
  }

  /**
   * Log scoring calculation for audit purposes
   */
  private async logScoringCalculation(
    leadId: string, 
    finalScore: number, 
    adjustments: Array<{ rule_name: string; adjustment: number }>
  ): Promise<void> {
    try {
      await supabase
        .from('lead_interactions')
        .insert({
          lead_id: leadId,
          interaction_type: 'score_updated',
          interaction_subject: 'Automatic Score Calculation',
          interaction_metadata: {
            final_score: finalScore,
            score_adjustments: adjustments,
            calculated_at: new Date().toISOString()
          }
        });
    } catch (error) {
      // Log error but don't fail the main process
      console.error('Failed to log scoring calculation:', error);
    }
  }

  /**
   * Get score distribution for analytics
   */
  async getScoreDistribution(supplierId: string): Promise<{
    ranges: Array<{ range: string; count: number; percentage: number }>;
    average: number;
    median: number;
  }> {
    const { data: leads, error } = await supabase
      .from('leads')
      .select('lead_score')
      .eq('supplier_id', supplierId);

    if (error || !leads?.length) {
      return { ranges: [], average: 0, median: 0 };
    }

    const scores = leads.map(l => l.lead_score).sort((a, b) => a - b);
    const total = scores.length;
    const average = scores.reduce((sum, score) => sum + score, 0) / total;
    const median = scores[Math.floor(total / 2)];

    const ranges = [
      { range: '0-20', count: 0 },
      { range: '21-40', count: 0 },
      { range: '41-60', count: 0 },
      { range: '61-80', count: 0 },
      { range: '81-100', count: 0 }
    ];

    scores.forEach(score => {
      if (score <= 20) ranges[0].count++;
      else if (score <= 40) ranges[1].count++;
      else if (score <= 60) ranges[2].count++;
      else if (score <= 80) ranges[3].count++;
      else ranges[4].count++;
    });

    return {
      ranges: ranges.map(r => ({ ...r, percentage: (r.count / total) * 100 })),
      average,
      median
    };
  }
}

export const leadScoringService = new LeadScoringService();
```

#### Example 3: Automated Lead Nurturing Service

```typescript
// /src/lib/leads/nurture-automation-service.ts
import { supabase } from '@/lib/supabase';
import { Lead, NurtureSequence, NurtureSequenceStep, LeadNurtureEnrollment } from '@/types/leads';
import { emailService } from '@/lib/email/email-service';
import { smsService } from '@/lib/sms/sms-service';
import { taskService } from '@/lib/tasks/task-service';

export class NurtureAutomationService {
  /**
   * Process all pending nurture sequence executions
   */
  async processPendingExecutions(): Promise<void> {
    try {
      // Get all enrollments that are ready for next execution
      const { data: enrollments, error } = await supabase
        .from('lead_nurture_enrollments')
        .select(`
          *,
          lead:leads(*),
          sequence:nurture_sequences(*),
          current_step:nurture_sequence_steps(*)
        `)
        .eq('status', 'active')
        .lte('next_execution_at', new Date().toISOString())
        .order('next_execution_at', { ascending: true });

      if (error) throw error;

      // Process each enrollment
      for (const enrollment of enrollments || []) {
        await this.processEnrollmentExecution(enrollment);
      }
    } catch (error) {
      console.error('Failed to process pending nurture executions:', error);
    }
  }

  /**
   * Enroll a lead in a nurture sequence
   */
  async enrollLead(leadId: string, sequenceId: string): Promise<LeadNurtureEnrollment> {
    try {
      // Check if lead is already enrolled in this sequence
      const { data: existingEnrollment } = await supabase
        .from('lead_nurture_enrollments')
        .select('*')
        .eq('lead_id', leadId)
        .eq('sequence_id', sequenceId)
        .eq('status', 'active')
        .single();

      if (existingEnrollment) {
        throw new Error('Lead is already enrolled in this sequence');
      }

      // Get the first step of the sequence
      const { data: firstStep, error: stepError } = await supabase
        .from('nurture_sequence_steps')
        .select('*')
        .eq('sequence_id', sequenceId)
        .eq('is_active', true)
        .order('step_order', { ascending: true })
        .limit(1)
        .single();

      if (stepError || !firstStep) {
        throw new Error('Sequence has no active steps');
      }

      // Calculate next execution time
      const nextExecutionAt = this.calculateNextExecution(firstStep);

      // Create enrollment record
      const { data: enrollment, error } = await supabase
        .from('lead_nurture_enrollments')
        .insert({
          lead_id: leadId,
          sequence_id: sequenceId,
          current_step_id: firstStep.id,
          next_execution_at: nextExecutionAt,
          status: 'active'
        })
        .select()
        .single();

      if (error) throw error;

      // Update sequence enrollment count
      await supabase
        .from('nurture_sequences')
        .update({ 
          total_enrollments: supabase.sql`total_enrollments + 1`,
          updated_at: new Date().toISOString()
        })
        .eq('id', sequenceId);

      return enrollment;
    } catch (error) {
      console.error('Failed to enroll lead in nurture sequence:', error);
      throw error;
    }
  }

  /**
   * Process a single enrollment execution
   */
  private async processEnrollmentExecution(enrollment: any): Promise<void> {
    try {
      const { lead, sequence, current_step } = enrollment;
      
      // Check if execution should proceed (conditions check)
      const shouldExecute = await this.checkExecutionConditions(lead, current_step);
      if (!shouldExecute) {
        await this.moveToNextStep(enrollment);
        return;
      }

      // Execute the current step
      const executionResult = await this.executeStep(lead, current_step, sequence);

      // Log the interaction
      await this.logNurtureInteraction(lead.id, current_step, executionResult);

      // Move to next step or complete sequence
      await this.moveToNextStep(enrollment);
      
    } catch (error) {
      console.error(`Failed to process enrollment ${enrollment.id}:`, error);
      
      // Mark enrollment as failed
      await supabase
        .from('lead_nurture_enrollments')
        .update({ 
          status: 'failed',
          ended_at: new Date().toISOString(),
          end_reason: `Execution failed: ${error.message}`
        })
        .eq('id', enrollment.id);
    }
  }

  /**
   * Execute a specific nurture step
   */
  private async executeStep(
    lead: Lead, 
    step: NurtureSequenceStep, 
    sequence: NurtureSequence
  ): Promise<{ success: boolean; details: any }> {
    switch (step.step_type) {
      case 'email':
        return await this.executeEmailStep(lead, step);
      
      case 'sms':
        return await this.executeSmsStep(lead, step);
      
      case 'phone_call':
        return await this.executePhoneCallStep(lead, step);
      
      case 'task_creation':
        return await this.executeTaskCreationStep(lead, step, sequence);
      
      case 'score_adjustment':
        return await this.executeScoreAdjustmentStep(lead, step);
      
      case 'status_change':
        return await this.executeStatusChangeStep(lead, step);
      
      case 'tag_assignment':
        return await this.executeTagAssignmentStep(lead, step);
      
      default:
        throw new Error(`Unknown step type: ${step.step_type}`);
    }
  }

  /**
   * Execute email step
   */
  private async executeEmailStep(lead: Lead, step: NurtureSequenceStep): Promise<{ success: boolean; details: any }> {
    try {
      if (!step.email_template_id) {
        throw new Error('Email step missing template ID');
      }

      // Get email template
      const { data: template, error } = await supabase
        .from('email_templates')
        .select('*')
        .eq('id', step.email_template_id)
        .single();

      if (error || !template) {
        throw new Error('Email template not found');
      }

      // Personalize email content
      const personalizedContent = this.personalizeContent(template.content, lead);
      const personalizedSubject = this.personalizeContent(template.subject, lead);

      // Send email
      const result = await emailService.sendEmail({
        to: lead.primary_email,
        subject: personalizedSubject,
        html: personalizedContent,
        leadId: lead.id,
        templateId: template.id
      });

      return {
        success: true,
        details: {
          email_id: result.email_id,
          template_used: template.name,
          sent_at: new Date().toISOString()
        }
      };
    } catch (error) {
      return {
        success: false,
        details: {
          error: error.message,
          attempted_at: new Date().toISOString()
        }
      };
    }
  }

  /**
   * Execute SMS step
   */
  private async executeSmsStep(lead: Lead, step: NurtureSequenceStep): Promise<{ success: boolean; details: any }> {
    try {
      if (!lead.primary_phone) {
        return {
          success: false,
          details: { error: 'Lead has no phone number', skipped: true }
        };
      }

      if (!step.sms_template_id) {
        throw new Error('SMS step missing template ID');
      }

      // Get SMS template
      const { data: template, error } = await supabase
        .from('sms_templates')
        .select('*')
        .eq('id', step.sms_template_id)
        .single();

      if (error || !template) {
        throw new Error('SMS template not found');
      }

      // Personalize SMS content
      const personalizedContent = this.personalizeContent(template.content, lead);

      // Send SMS
      const result = await smsService.sendSms({
        to: lead.primary_phone,
        message: personalizedContent,
        leadId: lead.id,
        templateId: template.id
      });

      return {
        success: true,
        details: {
          sms_id: result.sms_id,
          template_used: template.name,
          sent_at: new Date().toISOString()
        }
      };
    } catch (error) {
      return {
        success: false,
        details: {
          error: error.message,
          attempted_at: new Date().toISOString()
        }
      };
    }
  }

  /**
   * Execute task creation step
   */
  private async executeTaskCreationStep(
    lead: Lead, 
    step: NurtureSequenceStep, 
    sequence: NurtureSequence
  ): Promise<{ success: boolean; details: any }> {
    try {
      const taskData = JSON.parse(step.step_content || '{}');
      
      const task = await taskService.createTask({
        supplier_id: lead.supplier_id,
        lead_id: lead.id,
        title: this.personalizeContent(taskData.title || step.step_name, lead),
        description: this.personalizeContent(taskData.description || '', lead),
        due_date: this.calculateTaskDueDate(taskData.due_in_days || 1),
        priority: taskData.priority || 'medium',
        assigned_to: taskData.assigned_to || lead.assigned_to_user_id,
        task_type: 'nurture_follow_up',
        metadata: {
          nurture_sequence_id: sequence.id,
          nurture_step_id: step.id,
          lead_data: {
            couple_names: [lead.couple_name_bride, lead.couple_name_groom].filter(Boolean),
            wedding_date: lead.wedding_date,
            contact_info: {
              email: lead.primary_email,
              phone: lead.primary_phone
            }
          }
        }
      });

      return {
        success: true,
        details: {
          task_id: task.id,
          task_title: task.title,
          created_at: new Date().toISOString()
        }
      };
    } catch (error) {
      return {
        success: false,
        details: {
          error: error.message,
          attempted_at: new Date().toISOString()
        }
      };
    }
  }

  /**
   * Check if step execution conditions are met
   */
  private async checkExecutionConditions(lead: Lead, step: NurtureSequenceStep): Promise<boolean> {
    try {
      const conditions = step.execution_conditions || {};
      
      // Check lead status conditions
      if (conditions.required_status && !conditions.required_status.includes(lead.lead_status)) {
        return false;
      }
      
      // Check lead score conditions
      if (conditions.min_score && lead.lead_score < conditions.min_score) {
        return false;
      }
      
      if (conditions.max_score && lead.lead_score > conditions.max_score) {
        return false;
      }
      
      // Check tag conditions
      if (conditions.required_tags) {
        const requiredTags = Array.isArray(conditions.required_tags) ? conditions.required_tags : [conditions.required_tags];
        const hasRequiredTags = requiredTags.every(tag => lead.tags.includes(tag));
        if (!hasRequiredTags) {
          return false;
        }
      }
      
      // Check exclusion conditions
      if (conditions.excluded_tags) {
        const excludedTags = Array.isArray(conditions.excluded_tags) ? conditions.excluded_tags : [conditions.excluded_tags];
        const hasExcludedTags = excludedTags.some(tag => lead.tags.includes(tag));
        if (hasExcludedTags) {
          return false;
        }
      }
      
      return true;
    } catch (error) {
      console.error('Error checking execution conditions:', error);
      return false; // Fail safe - don't execute if conditions can't be evaluated
    }
  }

  /**
   * Personalize content with lead data
   */
  private personalizeContent(content: string, lead: Lead): string {
    return content
      .replace(/{{bride_name}}/g, lead.couple_name_bride || 'there')
      .replace(/{{groom_name}}/g, lead.couple_name_groom || 'there')
      .replace(/{{couple_names}}/g, 
        [lead.couple_name_bride, lead.couple_name_groom].filter(Boolean).join(' & ') || 'there'
      )
      .replace(/{{wedding_date}}/g, lead.wedding_date ? new Date(lead.wedding_date).toLocaleDateString() : 'your special day')
      .replace(/{{wedding_venue}}/g, lead.wedding_venue || 'your venue')
      .replace(/{{wedding_location}}/g, lead.wedding_location || 'your location')
      .replace(/{{estimated_budget}}/g, lead.estimated_budget ? `£${lead.estimated_budget.toLocaleString()}` : 'your budget')
      .replace(/{{lead_score}}/g, lead.lead_score.toString())
      .replace(/{{days_since_inquiry}}/g, 
        Math.floor((new Date().getTime() - new Date(lead.created_at).getTime()) / (1000 * 3600 * 24)).toString()
      );
  }

  /**
   * Calculate next execution time based on step timing
   */
  private calculateNextExecution(step: NurtureSequenceStep): string {
    const now = new Date();
    let executionTime = new Date(now);

    // Add delay
    switch (step.delay_unit) {
      case 'minutes':
        executionTime.setMinutes(now.getMinutes() + step.delay_amount);
        break;
      case 'hours':
        executionTime.setHours(now.getHours() + step.delay_amount);
        break;
      case 'days':
        executionTime.setDate(now.getDate() + step.delay_amount);
        break;
      case 'weeks':
        executionTime.setDate(now.getDate() + (step.delay_amount * 7));
        break;
    }

    // Adjust to preferred send time if it's a future date
    if (step.send_time && step.delay_amount > 0) {
      const [hours, minutes] = step.send_time.split(':').map(Number);
      executionTime.setHours(hours, minutes, 0, 0);
    }

    // Ensure it's on a valid send day
    if (step.send_days && step.send_days.length > 0) {
      while (!step.send_days.includes(executionTime.getDay() || 7)) {
        executionTime.setDate(executionTime.getDate() + 1);
      }
    }

    return executionTime.toISOString();
  }

  /**
   * Move enrollment to next step or complete sequence
   */
  private async moveToNextStep(enrollment: LeadNurtureEnrollment): Promise<void> {
    try {
      // Get next step in sequence
      const { data: nextStep, error } = await supabase
        .from('nurture_sequence_steps')
        .select('*')
        .eq('sequence_id', enrollment.sequence_id)
        .gt('step_order', enrollment.current_step?.step_order || 0)
        .eq('is_active', true)
        .order('step_order', { ascending: true })
        .limit(1)
        .single();

      if (error || !nextStep) {
        // No more steps - complete the sequence
        await supabase
          .from('lead_nurture_enrollments')
          .update({
            status: 'completed',
            completion_rate: 100,
            ended_at: new Date().toISOString(),
            end_reason: 'All steps completed'
          })
          .eq('id', enrollment.id);
        return;
      }

      // Calculate next execution time
      const nextExecutionAt = this.calculateNextExecution(nextStep);

      // Update enrollment to next step
      await supabase
        .from('lead_nurture_enrollments')
        .update({
          current_step_id: nextStep.id,
          next_execution_at: nextExecutionAt,
          steps_completed: (enrollment.steps_completed || 0) + 1
        })
        .eq('id', enrollment.id);
        
    } catch (error) {
      console.error('Failed to move to next step:', error);
      throw error;
    }
  }

  /**
   * Log nurture interaction
   */
  private async logNurtureInteraction(
    leadId: string, 
    step: NurtureSequenceStep, 
    result: { success: boolean; details: any }
  ): Promise<void> {
    try {
      await supabase
        .from('lead_interactions')
        .insert({
          lead_id: leadId,
          interaction_type: `nurture_${step.step_type}`,
          interaction_subject: step.step_name,
          interaction_content: step.step_content,
          interaction_metadata: {
            nurture_step_id: step.id,
            execution_result: result,
            executed_at: new Date().toISOString()
          },
          interaction_outcome: result.success ? 'completed' : 'failed'
        });
    } catch (error) {
      console.error('Failed to log nurture interaction:', error);
    }
  }
}

export const nurtureAutomationService = new NurtureAutomationService();
```
