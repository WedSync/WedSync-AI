# TECHNICAL SPECIFICATION: WS-203 - WebSocket Channels
## Generated by Feature Development Session - 2025-08-25

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding supplier working with multiple couples simultaneously
**I want to:** Have organized real-time communication channels for each wedding I'm managing
**So that:** Updates from different weddings don't get mixed up and I can collaborate efficiently, preventing 5+ hours of confusion per month

**Real Wedding Scenario:**
A photographer manages 8 weddings this month. Sarah's wedding updates her timeline, while simultaneously, Mike's wedding changes the venue. With proper channel separation, the photographer sees Sarah's timeline update in her dedicated channel and Mike's venue change in his channel. Without this, all updates would flood a single feed, causing critical information to be missed and requiring constant clarification calls.

### SPECIFICATION SOURCE
- **Feature ID:** WS-203
- **Original Spec:** /CORE-SPECIFICATIONS/01-TECHNICAL-ARCHITECTURE/04-Real-time-Systems/02-websocket-channels md.md
- **Current Implementation:** 0% complete
- **Files to Modify:**
  - /wedsync/src/lib/realtime/subscription-manager.ts
  - /wedsync/src/hooks/useChannelSubscription.ts
  - /wedsync/src/components/providers/RealtimeProvider.tsx
- **New Files to Create:**
  - /wedsync/src/lib/websocket/channel-manager.ts
  - /wedsync/src/lib/websocket/message-queue.ts
  - /wedsync/src/lib/websocket/presence-manager.ts
  - /wedsync/src/types/websocket.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Channel registry for tracking active channels
CREATE TABLE IF NOT EXISTS websocket_channels (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  channel_name TEXT NOT NULL UNIQUE,
  channel_type TEXT CHECK (channel_type IN ('private', 'shared', 'broadcast')),
  scope TEXT NOT NULL,
  entity TEXT NOT NULL,
  entity_id UUID,
  created_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  last_activity TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  metadata JSONB DEFAULT '{}'::jsonb
);

-- Channel subscriptions tracking
CREATE TABLE IF NOT EXISTS channel_subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  channel_id UUID REFERENCES websocket_channels(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  subscribed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  last_seen_message_id UUID,
  subscription_status TEXT DEFAULT 'active',
  UNIQUE(channel_id, user_id)
);

-- Message queue for offline delivery
CREATE TABLE IF NOT EXISTS channel_message_queue (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  channel_id UUID REFERENCES websocket_channels(id) ON DELETE CASCADE,
  message_type TEXT NOT NULL,
  payload JSONB NOT NULL,
  sender_id UUID REFERENCES auth.users(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  expires_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() + INTERVAL '5 minutes',
  delivered_to UUID[] DEFAULT ARRAY[]::UUID[]
);

-- Indexes for performance
CREATE INDEX idx_channels_entity ON websocket_channels(entity, entity_id);
CREATE INDEX idx_channel_subs_user ON channel_subscriptions(user_id);
CREATE INDEX idx_message_queue_channel ON channel_message_queue(channel_id);
CREATE INDEX idx_message_queue_expires ON channel_message_queue(expires_at);
```

#### API Endpoints Required
```typescript
// POST /api/websocket/channels/create
interface CreateChannelRequest {
  scope: 'supplier' | 'couple' | 'form' | 'journey' | 'collaboration';
  entity: string;
  entityId: string;
  type: 'private' | 'shared' | 'broadcast';
  metadata?: Record<string, any>;
}

interface CreateChannelResponse {
  success: boolean;
  channel: {
    id: string;
    name: string;
    type: string;
    subscriptionUrl: string;
  };
}

// POST /api/websocket/channels/subscribe
interface SubscribeChannelRequest {
  channelName: string;
  lastMessageId?: string;
}

interface SubscribeChannelResponse {
  success: boolean;
  subscription: {
    channelId: string;
    status: 'active' | 'pending';
    queuedMessages: Message[];
  };
}

// POST /api/websocket/channels/broadcast
interface BroadcastRequest {
  channelName: string;
  eventType: string;
  payload: any;
}

interface BroadcastResponse {
  success: boolean;
  messageId: string;
  recipientCount: number;
}

// GET /api/websocket/channels/list
interface ListChannelsResponse {
  channels: {
    name: string;
    type: string;
    activeUsers: number;
    lastActivity: string;
    unreadCount: number;
  }[];
}
```

#### Frontend Components Required
```typescript
// Component: ChannelManager
// Location: /src/components/websocket/ChannelManager.tsx

interface ChannelManagerProps {
  userId: string;
  userType: 'supplier' | 'couple';
  maxChannels?: number;
}

// Key functionality:
- Manage multiple channel subscriptions
- Handle channel switching
- Display channel list with unread indicators
- Auto-join relevant channels on load
- Clean up inactive channels

// Component: ChannelIndicator
// Location: /src/components/websocket/ChannelIndicator.tsx

interface ChannelIndicatorProps {
  channelName: string;
  isActive: boolean;
  unreadCount: number;
  lastMessage?: Date;
}

// Key functionality:
- Show channel connection status
- Display unread message count
- Indicate typing/activity
- Color-coded by channel type

// Component: MessageQueue
// Location: /src/components/websocket/MessageQueue.tsx

interface MessageQueueProps {
  channelId: string;
  messages: QueuedMessage[];
  onMessageDelivered: (messageId: string) => void;
}

// Key functionality:
- Display queued messages during offline
- Retry failed message delivery
- Show delivery status
- Auto-dismiss delivered messages
```

#### Integration Points
```typescript
// Service: WebSocketChannelManager
// Dependencies: Supabase client, authentication, message queue

class WebSocketChannelManager {
  private channels: Map<string, Channel>;
  private messageQueue: MessageQueue;
  private reconnectTimer: NodeJS.Timeout | null;
  
  async createChannel(scope: string, entity: string, id: string): Promise<Channel> {
    // Create channel with naming convention
    const channelName = `${scope}:${entity}:${id}`;
    // Register in database
    // Return channel instance
  }
  
  async subscribeToChannel(channelName: string): Promise<Subscription> {
    // Check permissions
    // Subscribe to channel
    // Fetch queued messages
    // Return subscription
  }
  
  async broadcastToChannel(channelName: string, event: string, data: any): Promise<void> {
    // Validate permissions
    // Broadcast message
    // Queue for offline users
  }
  
  async handleReconnection(): Promise<void> {
    // Re-establish all subscriptions
    // Fetch missed messages
    // Update UI state
  }
}
```

### CODE EXAMPLES

#### Example 1: Channel Creation and Subscription
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { supabase } from '@/lib/supabase';
import { Channel } from '@/types/websocket';

export class ChannelFactory {
  static async createSupplierDashboardChannel(supplierId: string): Promise<Channel> {
    // Step 1: Create channel name following convention
    const channelName = `supplier:dashboard:${supplierId}`;
    
    // Step 2: Register channel in database
    const { data: channel, error } = await supabase
      .from('websocket_channels')
      .upsert({
        channel_name: channelName,
        channel_type: 'private',
        scope: 'supplier',
        entity: 'dashboard',
        entity_id: supplierId,
        created_by: supplierId
      })
      .select()
      .single();
      
    if (error) throw error;
    
    // Step 3: Create Supabase channel subscription
    const realtimeChannel = supabase.channel(channelName)
      .on('broadcast', { event: '*' }, (payload) => {
        console.log('Channel event:', payload);
      })
      .subscribe();
      
    return {
      id: channel.id,
      name: channelName,
      supabaseChannel: realtimeChannel
    };
  }
  
  static async createCollaborationChannel(
    supplierId: string, 
    coupleId: string
  ): Promise<Channel> {
    // Shared channel for supplier-couple collaboration
    const channelName = `collaboration:${supplierId}:${coupleId}`;
    
    // Similar implementation with 'shared' type
    // Both parties can subscribe and broadcast
  }
}
```

#### Example 2: Message Queue and Offline Handling
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { useEffect, useState } from 'react';
import { supabase } from '@/lib/supabase';

export function useMessageQueue(channelId: string) {
  const [queuedMessages, setQueuedMessages] = useState<Message[]>([]);
  const [isOnline, setIsOnline] = useState(navigator.onLine);
  
  useEffect(() => {
    // Step 1: Handle online/offline events
    const handleOnline = async () => {
      setIsOnline(true);
      
      // Step 2: Fetch queued messages when coming online
      const { data: messages } = await supabase
        .from('channel_message_queue')
        .select('*')
        .eq('channel_id', channelId)
        .gt('expires_at', new Date().toISOString())
        .not('delivered_to', 'cs', `{${userId}}`);
        
      if (messages) {
        setQueuedMessages(messages);
        
        // Step 3: Process queued messages
        for (const msg of messages) {
          // Deliver message to UI
          processMessage(msg);
          
          // Mark as delivered
          await supabase
            .from('channel_message_queue')
            .update({
              delivered_to: [...msg.delivered_to, userId]
            })
            .eq('id', msg.id);
        }
      }
    };
    
    const handleOffline = () => {
      setIsOnline(false);
    };
    
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    
    // Initial check
    if (isOnline) {
      handleOnline();
    }
    
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, [channelId]);
  
  return { queuedMessages, isOnline };
}
```

#### Example 3: Channel Event Handling
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
export function useChannelEvents(channelName: string) {
  const [events, setEvents] = useState<ChannelEvent[]>([]);
  
  useEffect(() => {
    const channel = supabase.channel(channelName);
    
    // Handle form events
    channel.on('broadcast', { event: 'form:response:new' }, (payload) => {
      setEvents(prev => [...prev, {
        type: 'form_response',
        data: payload.payload,
        timestamp: new Date()
      }]);
      
      // Show notification
      showNotification({
        title: 'New Form Response',
        message: `${payload.payload.formName} completed`,
        icon: 'form'
      });
    });
    
    // Handle journey events
    channel.on('broadcast', { event: 'journey:step:completed' }, (payload) => {
      setEvents(prev => [...prev, {
        type: 'journey_progress',
        data: payload.payload,
        timestamp: new Date()
      }]);
    });
    
    // Handle collaboration events
    channel.on('broadcast', { event: 'user:typing' }, (payload) => {
      // Show typing indicator
      setTypingUsers(prev => [...prev, payload.payload.userId]);
      
      // Clear after 3 seconds
      setTimeout(() => {
        setTypingUsers(prev => prev.filter(id => id !== payload.payload.userId));
      }, 3000);
    });
    
    channel.subscribe();
    
    return () => {
      channel.unsubscribe();
    };
  }, [channelName]);
  
  return events;
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for Supabase channels, WebSocket patterns
- [x] Playwright: Test multi-channel scenarios, offline handling
- [x] Filesystem: Access channel and queue implementation files
- [x] Supabase: Configure broadcast channels

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/supabase/supabase", "broadcast channels", 3000);
await mcp__context7__get-library-docs("/supabase/supabase", "presence", 2000);
await mcp__context7__get-library-docs("/vercel/next.js", "websocket app router", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('WebSocketChannelManager', () => {
  it('should create channels with correct naming convention', () => {
    const channel = createChannel('supplier', 'dashboard', '123');
    expect(channel.name).toBe('supplier:dashboard:123');
  });
  
  it('should enforce channel subscription limits', async () => {
    // Free tier: max 3 channels
    const manager = new ChannelManager({ tier: 'free' });
    // Subscribe to 3 channels - should succeed
    // Subscribe to 4th channel - should fail
  });
  
  it('should queue messages for offline users', async () => {
    // Send message while user offline
    // Verify message queued
    // User comes online
    // Verify message delivered
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Multi-channel collaboration', async () => {
  // Open supplier dashboard
  await mcp__playwright__browser_navigate({url: '/supplier/dashboard'});
  
  // Verify multiple channel indicators
  await mcp__playwright__browser_snapshot();
  
  // Switch between channels
  await mcp__playwright__browser_click({
    element: 'Sarah wedding channel',
    ref: 'channel-sarah-wedding'
  });
  
  // Verify correct messages displayed
  // Test channel isolation
});

test('Offline message queuing', async () => {
  // Simulate offline
  await mcp__playwright__browser_evaluate({
    function: '() => { window.dispatchEvent(new Event("offline")); }'
  });
  
  // Send messages
  // Go back online
  await mcp__playwright__browser_evaluate({
    function: '() => { window.dispatchEvent(new Event("online")); }'
  });
  
  // Verify queued messages delivered
});
```

### ACCEPTANCE CRITERIA
- [ ] Channels follow naming convention {scope}:{entity}:{id}
- [ ] Free tier limited to 3 concurrent channels
- [ ] Paid tiers support 10 concurrent channels
- [ ] Messages queued during offline (max 100 per channel)
- [ ] Auto-reconnect with exponential backoff
- [ ] Heartbeat maintains connection every 30 seconds
- [ ] Rate limit: 100 messages/minute per channel enforced
- [ ] Performance: Channel switch < 200ms
- [ ] Security: RLS enforced on all channel operations
- [ ] Accessibility: Screen readers announce channel switches

### DEPENDENCIES
- Must complete after: WS-202 (Supabase Realtime Integration)
- Must complete before: WS-204 (Presence Tracking), WS-205 (Broadcast Events)
- Shares code with: WS-202 (Realtime base), WS-204 (Presence)

### ESTIMATED EFFORT
- Team A Frontend: 20 hours
- Team B Backend: 12 hours
- Team C Integration: 8 hours
- Team D Platform: 16 hours
- Team E General: 0 hours
- Team F Workflows: 4 hours
- Team G Performance: 8 hours
- Total: 68 hours