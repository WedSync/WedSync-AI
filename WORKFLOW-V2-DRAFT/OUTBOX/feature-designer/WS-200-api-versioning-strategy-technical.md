# TECHNICAL SPECIFICATION: WS-200 - API Versioning Strategy
## Generated by Feature Development Session - August 25, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** WedSync platform architect ensuring long-term API stability for third-party integrations
**I want to:** Implement comprehensive API versioning with backward compatibility, migration support, and clear deprecation policies
**So that:** I can ensure that when we enhance the supplier client management API with new wedding timeline features, existing photography studio CRMs continue working without disruption; venue booking systems can migrate to new API versions at their own pace with clear migration paths; and custom integrations built by wedding planners remain functional while they gradually adopt new API capabilities over 12-month deprecation cycles

**Real Wedding Scenario:**
A successful photography supplier has integrated their custom CRM with WedSync's v1 API to manage 200+ weddings annually. When WedSync releases v2 with enhanced guest management features, the API versioning strategy ensures their existing integration continues working unchanged. They receive 6 months advance notice of v1 deprecation via API headers and dashboard notifications, along with detailed migration guides showing exact code changes needed. Meanwhile, new suppliers can start with v2 immediately, while existing suppliers migrate gradually. The versioning system tracks usage analytics showing 80% of integrations still on v1, informing the decision to extend deprecation by 3 months to accommodate high-volume suppliers during peak wedding season.

### SPECIFICATION SOURCE
- **Feature ID:** WS-200
- **Original Spec:** /CORE-SPECIFICATIONS/01-TECHNICAL-ARCHITECTURE/03-API-Architecture/05-api-versioning md.md
- **Current Implementation:** 0% complete (new)
- **Files to Modify:** None (new feature)
- **New Files to Create:** 
  - `/wedsync/lib/api/versioning.ts`
  - `/wedsync/lib/api/version-compatibility.ts`
  - `/wedsync/middleware/api-version.ts`
  - `/wedsync/lib/migration/api-migration-tools.ts`
  - `/wedsync/components/admin/APIVersionDashboard.tsx`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- API version tracking and analytics
CREATE TABLE api_versions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  version_identifier TEXT UNIQUE NOT NULL, -- 'v1', 'v2', 'v2.1'
  
  -- Version metadata
  major_version INTEGER NOT NULL,
  minor_version INTEGER NOT NULL DEFAULT 0,
  patch_version INTEGER NOT NULL DEFAULT 0,
  
  -- Lifecycle management
  status TEXT NOT NULL CHECK (status IN (
    'development', 'beta', 'stable', 'deprecated', 'sunset'
  )),
  release_date DATE NOT NULL,
  deprecation_date DATE,
  sunset_date DATE,
  
  -- Version characteristics
  is_breaking_change BOOLEAN DEFAULT FALSE,
  requires_migration BOOLEAN DEFAULT FALSE,
  backward_compatible BOOLEAN DEFAULT TRUE,
  
  -- Wedding industry features introduced
  features_added TEXT[],
  endpoints_added TEXT[],
  endpoints_removed TEXT[],
  breaking_changes_description TEXT,
  
  -- Documentation and migration
  changelog_url TEXT,
  migration_guide_url TEXT,
  sdk_version TEXT, -- Corresponding client SDK version
  
  -- Support and maintenance
  security_fixes_only BOOLEAN DEFAULT FALSE,
  maintenance_mode BOOLEAN DEFAULT FALSE,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- API version usage analytics
CREATE TABLE api_version_usage (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  measurement_date DATE NOT NULL,
  api_version TEXT NOT NULL, -- 'v1', 'v2', etc.
  
  -- Usage metrics
  total_requests INTEGER NOT NULL DEFAULT 0,
  unique_clients INTEGER NOT NULL DEFAULT 0,
  unique_suppliers INTEGER NOT NULL DEFAULT 0,
  
  -- Request breakdown by endpoint category
  supplier_management_requests INTEGER DEFAULT 0,
  form_management_requests INTEGER DEFAULT 0,
  client_management_requests INTEGER DEFAULT 0,
  portfolio_requests INTEGER DEFAULT 0,
  search_requests INTEGER DEFAULT 0,
  ai_feature_requests INTEGER DEFAULT 0,
  
  -- Client type breakdown
  web_app_requests INTEGER DEFAULT 0,
  mobile_app_requests INTEGER DEFAULT 0,
  third_party_integrations INTEGER DEFAULT 0,
  custom_crm_requests INTEGER DEFAULT 0,
  
  -- Wedding industry context
  vendor_type_breakdown JSONB, -- {'photographer': 1500, 'venue': 800, 'catering': 300}
  subscription_tier_breakdown JSONB, -- {'free': 500, 'premium': 1200}
  
  -- Performance metrics
  avg_response_time_ms INTEGER,
  error_rate DECIMAL(5,4),
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(measurement_date, api_version)
);

CREATE INDEX idx_version_usage_date ON api_version_usage(measurement_date DESC);
CREATE INDEX idx_version_usage_version ON api_version_usage(api_version, measurement_date DESC);

-- Client migration tracking
CREATE TABLE client_migrations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Client identification
  client_identifier TEXT NOT NULL, -- API key ID or user ID
  client_name TEXT, -- Optional friendly name
  integration_type TEXT NOT NULL CHECK (integration_type IN (
    'custom_crm', 'booking_system', 'website_integration', 'mobile_app', 
    'analytics_tool', 'email_automation', 'other'
  )),
  
  -- Migration details
  from_version TEXT NOT NULL,
  to_version TEXT NOT NULL,
  migration_status TEXT NOT NULL CHECK (migration_status IN (
    'not_started', 'in_progress', 'testing', 'completed', 'failed', 'rolled_back'
  )),
  
  -- Migration timeline
  migration_started_at TIMESTAMPTZ,
  migration_completed_at TIMESTAMPTZ,
  target_completion_date DATE,
  
  -- Wedding business context
  supplier_id UUID REFERENCES suppliers(id),
  vendor_type TEXT, -- Type of wedding vendor using this integration
  client_count INTEGER, -- Number of wedding clients managed through this integration
  annual_request_volume INTEGER, -- Estimated yearly API requests
  
  -- Migration support
  migration_assistance_requested BOOLEAN DEFAULT FALSE,
  migration_guide_accessed BOOLEAN DEFAULT FALSE,
  support_tickets_created INTEGER DEFAULT 0,
  
  -- Technical details
  breaking_changes_addressed JSONB, -- List of breaking changes they need to handle
  compatibility_issues JSONB, -- Issues discovered during migration
  rollback_plan TEXT,
  
  -- Success metrics
  post_migration_error_rate DECIMAL(5,4),
  performance_improvement_percent DECIMAL(5,2),
  feature_adoption_rate DECIMAL(5,4),
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_migrations_client ON client_migrations(client_identifier);
CREATE INDEX idx_migrations_status ON client_migrations(migration_status, target_completion_date);
CREATE INDEX idx_migrations_supplier ON client_migrations(supplier_id);

-- API compatibility matrix
CREATE TABLE api_compatibility_matrix (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Version compatibility
  current_version TEXT NOT NULL,
  target_version TEXT NOT NULL,
  
  -- Compatibility assessment
  is_compatible BOOLEAN NOT NULL,
  compatibility_level TEXT NOT NULL CHECK (compatibility_level IN (
    'fully_compatible', 'mostly_compatible', 'requires_changes', 'breaking_changes'
  )),
  
  -- Specific compatibility details
  compatible_endpoints TEXT[],
  incompatible_endpoints TEXT[],
  new_endpoints TEXT[],
  deprecated_endpoints TEXT[],
  
  -- Wedding industry specific compatibility
  supplier_features_compatibility JSONB,
  client_management_compatibility JSONB,
  form_system_compatibility JSONB,
  
  -- Migration requirements
  required_code_changes TEXT[],
  optional_improvements TEXT[],
  migration_effort_hours INTEGER, -- Estimated effort for migration
  migration_complexity TEXT CHECK (migration_complexity IN ('low', 'medium', 'high')),
  
  -- Testing requirements
  testing_endpoints TEXT[], -- Endpoints that need thorough testing after migration
  regression_risk_areas TEXT[],
  
  -- Documentation
  migration_steps TEXT[],
  example_code_changes TEXT,
  common_pitfalls TEXT[],
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(current_version, target_version)
);

-- API deprecation notifications
CREATE TABLE api_deprecation_notifications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Notification details
  api_version TEXT NOT NULL,
  notification_type TEXT NOT NULL CHECK (notification_type IN (
    'deprecation_announcement', 'migration_reminder', 'sunset_warning', 'final_notice'
  )),
  
  -- Recipient information
  client_identifier TEXT NOT NULL,
  supplier_id UUID REFERENCES suppliers(id),
  notification_method TEXT NOT NULL CHECK (notification_method IN (
    'api_header', 'email', 'dashboard_banner', 'webhook', 'in_app_notification'
  )),
  
  -- Notification content
  subject TEXT NOT NULL,
  message TEXT NOT NULL,
  action_required TEXT,
  deadline_date DATE,
  
  -- Wedding industry context
  affected_endpoints TEXT[],
  business_impact_description TEXT,
  recommended_actions TEXT[],
  
  -- Notification tracking
  sent_at TIMESTAMPTZ,
  delivered_at TIMESTAMPTZ,
  acknowledged_at TIMESTAMPTZ,
  action_taken_at TIMESTAMPTZ,
  
  -- Response tracking
  notification_opened BOOLEAN DEFAULT FALSE,
  migration_guide_accessed BOOLEAN DEFAULT FALSE,
  support_contacted BOOLEAN DEFAULT FALSE,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_deprecation_notifications_client ON api_deprecation_notifications(client_identifier);
CREATE INDEX idx_deprecation_notifications_version ON api_deprecation_notifications(api_version, sent_at DESC);
```

#### API Endpoints Required
```typescript
// API versioning management endpoints
// GET /api/admin/versions/status
interface APIVersionStatusResponse {
  success: boolean;
  data: {
    currentVersions: APIVersionInfo[];
    deprecationSchedule: DeprecationSchedule[];
    migrationProgress: MigrationProgressSummary;
    usageAnalytics: VersionUsageAnalytics[];
  };
}

// POST /api/admin/versions/deprecate
interface DeprecateVersionRequest {
  version: string;
  deprecationDate: string;
  sunsetDate: string;
  reason: string;
  migrationGuideUrl: string;
}

// GET /api/versions/compatibility
interface VersionCompatibilityResponse {
  success: boolean;
  data: {
    currentVersion: string;
    availableVersions: string[];
    compatibilityMatrix: CompatibilityMatrix[];
    migrationPath: MigrationStep[];
  };
}
```

#### Frontend Components Required
```typescript
// Component: APIVersionDashboard
// Location: /src/components/admin/APIVersionDashboard.tsx

interface Props {
  versionAnalytics: VersionUsageAnalytics[];
  migrationProgress: MigrationProgress[];
  deprecationSchedule: DeprecationInfo[];
}

// Key functionality:
- API version usage analytics with client breakdown and trend analysis
- Migration tracking dashboard showing progress across all integrations
- Deprecation timeline management with automated notification scheduling
- Version compatibility matrix with detailed migration guidance
```

#### Integration Points
```typescript
// Service: APIVersionManager
// Dependencies: Version detection, compatibility checking, migration assistance

class APIVersionManager {
  async detectClientVersion(request: APIRequest): Promise<VersionInfo> {
    // Automatic version detection from URL path, headers, and client signatures
  }
  
  async checkCompatibility(fromVersion: string, toVersion: string): Promise<CompatibilityReport> {
    // Comprehensive compatibility assessment with migration recommendations
  }
}
```

### CODE EXAMPLES

#### Example 1: Comprehensive API Versioning System
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
// lib/api/versioning.ts

import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { z } from 'zod';

// API versioning configuration for wedding industry
export class WedSyncAPIVersionManager {
  private supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_KEY!
  );

  // Version configuration for wedding industry APIs
  private readonly VERSION_CONFIG = {
    v1: {
      version: 'v1',
      majorVersion: 1,
      minorVersion: 0,
      patchVersion: 0,
      status: 'stable',
      releaseDate: new Date('2024-01-15'),
      deprecationDate: new Date('2025-07-01'), // 6 months notice
      sunsetDate: new Date('2026-01-01'), // 12 months total
      supportedEndpoints: [
        '/api/v1/suppliers',
        '/api/v1/suppliers/{id}/clients',
        '/api/v1/forms',
        '/api/v1/forms/{id}/responses',
        '/api/v1/search/suppliers',
        '/api/v1/uploads/portfolio'
      ],
      weddingFeatures: [
        'basic_client_management',
        'form_creation',
        'supplier_search',
        'portfolio_upload'
      ],
      limitations: [
        'no_advanced_analytics',
        'no_ai_features',
        'basic_guest_management'
      ]
    },
    v2: {
      version: 'v2',
      majorVersion: 2,
      minorVersion: 0,
      patchVersion: 0,
      status: 'beta',
      releaseDate: new Date('2025-03-01'),
      supportedEndpoints: [
        '/api/v2/suppliers',
        '/api/v2/suppliers/{id}/clients',
        '/api/v2/suppliers/{id}/analytics',
        '/api/v2/forms',
        '/api/v2/forms/{id}/ai-suggestions',
        '/api/v2/search/suppliers',
        '/api/v2/ai/content-generation',
        '/api/v2/guests/management',
        '/api/v2/timeline/wedding-planning'
      ],
      weddingFeatures: [
        'advanced_client_management',
        'ai_powered_forms',
        'guest_list_management',
        'wedding_timeline_tracking',
        'supplier_analytics',
        'smart_recommendations'
      ],
      breakingChanges: [
        'client_response_structure_changed',
        'search_filters_enhanced',
        'authentication_requirements_updated'
      ],
      migrationRequired: true
    }
  };

  async detectAPIVersion(request: NextRequest): Promise<APIVersionInfo> {
    const pathname = request.nextUrl.pathname;
    
    // Method 1: URL path version detection (primary)
    const urlVersionMatch = pathname.match(/^\/api\/(v\d+(?:\.\d+)*)\//);
    if (urlVersionMatch) {
      const version = urlVersionMatch[1];
      return this.getVersionInfo(version);
    }

    // Method 2: Accept header version detection
    const acceptHeader = request.headers.get('accept');
    if (acceptHeader?.includes('application/vnd.wedsync.')) {
      const headerVersionMatch = acceptHeader.match(/application\/vnd\.wedsync\.(v\d+(?:\.\d+)*)\+json/);
      if (headerVersionMatch) {
        const version = headerVersionMatch[1];
        return this.getVersionInfo(version);
      }
    }

    // Method 3: Custom API-Version header
    const versionHeader = request.headers.get('API-Version');
    if (versionHeader) {
      return this.getVersionInfo(versionHeader);
    }

    // Method 4: Client signature detection (for backward compatibility)
    const userAgent = request.headers.get('user-agent');
    if (userAgent) {
      const detectedVersion = await this.detectVersionFromUserAgent(userAgent);
      if (detectedVersion) {
        return detectedVersion;
      }
    }

    // Default to latest stable version
    return this.getVersionInfo('v1'); // Current stable
  }

  async processVersionedRequest(request: NextRequest): Promise<NextResponse> {
    try {
      const versionInfo = await this.detectAPIVersion(request);
      
      // Log version usage for analytics
      await this.logVersionUsage({
        version: versionInfo.version,
        endpoint: request.nextUrl.pathname,
        clientIdentifier: this.extractClientIdentifier(request),
        userAgent: request.headers.get('user-agent'),
        timestamp: new Date()
      });

      // Check if version is deprecated or sunset
      const deprecationResponse = await this.checkDeprecationStatus(versionInfo, request);
      if (deprecationResponse) {
        return deprecationResponse;
      }

      // Add version context to request headers
      const requestHeaders = new Headers(request.headers);
      requestHeaders.set('X-API-Version', versionInfo.version);
      requestHeaders.set('X-API-Major-Version', versionInfo.majorVersion.toString());
      requestHeaders.set('X-Version-Status', versionInfo.status);

      // Continue to appropriate version handler
      return NextResponse.next({
        request: { headers: requestHeaders }
      });

    } catch (error) {
      console.error('API versioning error:', error);
      return this.createVersionErrorResponse(error);
    }
  }

  async checkDeprecationStatus(versionInfo: APIVersionInfo, request: NextRequest): Promise<NextResponse | null> {
    const now = new Date();

    // Check if version is sunset (no longer supported)
    if (versionInfo.sunsetDate && now > versionInfo.sunsetDate) {
      return NextResponse.json({
        error: {
          code: 'API_VERSION_SUNSET',
          message: `API version ${versionInfo.version} is no longer supported. Please upgrade to the latest version.`,
          sunsetDate: versionInfo.sunsetDate.toISOString(),
          migrationGuide: await this.getMigrationGuideUrl(versionInfo.version),
          supportedVersions: this.getSupportedVersions()
        }
      }, { status: 410 }); // Gone
    }

    // Check if version is deprecated
    if (versionInfo.deprecationDate && now > versionInfo.deprecationDate) {
      // Send deprecation notifications
      await this.sendDeprecationNotification({
        clientIdentifier: this.extractClientIdentifier(request),
        version: versionInfo.version,
        notificationType: 'deprecated_version_usage'
      });

      // Add deprecation headers but allow request to continue
      const response = NextResponse.next();
      response.headers.set('Deprecation', 'true');
      response.headers.set('Sunset', versionInfo.sunsetDate?.toUTCString() || '');
      response.headers.set('Link', `<${await this.getMigrationGuideUrl(versionInfo.version)}>; rel="successor-version"`);
      
      return response;
    }

    return null;
  }

  async generateMigrationPlan(fromVersion: string, toVersion: string, clientContext: ClientContext): Promise<MigrationPlan> {
    try {
      // Get compatibility matrix
      const compatibility = await this.getCompatibilityMatrix(fromVersion, toVersion);
      
      // Generate step-by-step migration plan
      const migrationSteps: MigrationStep[] = [];

      // Step 1: Assess breaking changes
      if (compatibility.breakingChanges.length > 0) {
        migrationSteps.push({
          step: 1,
          title: 'Address Breaking Changes',
          description: 'Update code to handle breaking changes in API responses',
          breakingChanges: compatibility.breakingChanges,
          estimatedTimeHours: compatibility.breakingChanges.length * 2,
          codeExamples: await this.getCodeExamples(fromVersion, toVersion),
          priority: 'high'
        });
      }

      // Step 2: Update authentication if needed
      if (this.requiresAuthenticationUpdate(fromVersion, toVersion)) {
        migrationSteps.push({
          step: 2,
          title: 'Update Authentication',
          description: 'Upgrade to new authentication requirements',
          changes: ['Bearer token format updated', 'New scopes required'],
          estimatedTimeHours: 4,
          priority: 'high'
        });
      }

      // Step 3: Adopt new endpoints
      const newEndpoints = compatibility.newEndpoints.filter(endpoint => 
        this.isRelevantForClient(endpoint, clientContext)
      );
      
      if (newEndpoints.length > 0) {
        migrationSteps.push({
          step: 3,
          title: 'Adopt New Features',
          description: 'Integrate with new wedding industry features',
          newFeatures: newEndpoints.map(endpoint => ({
            endpoint,
            benefit: this.getFeatureBenefit(endpoint, clientContext.vendorType),
            optional: true
          })),
          estimatedTimeHours: newEndpoints.length * 3,
          priority: 'medium'
        });
      }

      // Step 4: Testing and validation
      migrationSteps.push({
        step: 4,
        title: 'Testing and Validation',
        description: 'Comprehensive testing of migrated integration',
        testingAreas: [
          'Core business workflows',
          'Error handling',
          'Performance validation',
          'Wedding season load testing'
        ],
        estimatedTimeHours: 8,
        priority: 'high'
      });

      const totalEstimatedHours = migrationSteps.reduce((total, step) => 
        total + step.estimatedTimeHours, 0
      );

      return {
        fromVersion,
        toVersion,
        totalEstimatedHours,
        complexity: this.assessMigrationComplexity(compatibility, totalEstimatedHours),
        steps: migrationSteps,
        benefits: await this.getVersionBenefits(toVersion, clientContext),
        risks: await this.getMigrationRisks(fromVersion, toVersion, clientContext),
        timeline: this.generateMigrationTimeline(migrationSteps, clientContext),
        supportOptions: {
          migrationGuide: await this.getMigrationGuideUrl(fromVersion, toVersion),
          codeExamples: await this.getCodeExamples(fromVersion, toVersion),
          supportContact: 'api-support@wedsync.app',
          dedicatedSupport: clientContext.subscriptionTier === 'enterprise'
        }
      };

    } catch (error) {
      console.error('Failed to generate migration plan:', error);
      throw new Error('Unable to generate migration plan');
    }
  }

  async trackMigrationProgress(clientIdentifier: string, migrationData: MigrationProgressUpdate): Promise<void> {
    try {
      await this.supabase
        .from('client_migrations')
        .upsert({
          client_identifier: clientIdentifier,
          from_version: migrationData.fromVersion,
          to_version: migrationData.toVersion,
          migration_status: migrationData.status,
          migration_started_at: migrationData.startedAt,
          migration_completed_at: migrationData.completedAt,
          breaking_changes_addressed: migrationData.breakingChangesAddressed,
          compatibility_issues: migrationData.compatibilityIssues,
          post_migration_error_rate: migrationData.postMigrationErrorRate,
          updated_at: new Date().toISOString()
        }, {
          onConflict: 'client_identifier,from_version,to_version'
        });

      // Send progress notifications if significant milestones reached
      if (migrationData.status === 'completed') {
        await this.sendMigrationSuccessNotification(clientIdentifier, migrationData);
      } else if (migrationData.status === 'failed') {
        await this.sendMigrationFailureSupport(clientIdentifier, migrationData);
      }

    } catch (error) {
      console.error('Failed to track migration progress:', error);
    }
  }

  private async getCompatibilityMatrix(fromVersion: string, toVersion: string): Promise<CompatibilityMatrix> {
    const { data: compatibility } = await this.supabase
      .from('api_compatibility_matrix')
      .select('*')
      .eq('current_version', fromVersion)
      .eq('target_version', toVersion)
      .single();

    if (compatibility) {
      return compatibility;
    }

    // Generate compatibility matrix if not exists
    return this.generateCompatibilityMatrix(fromVersion, toVersion);
  }

  private generateCompatibilityMatrix(fromVersion: string, toVersion: string): CompatibilityMatrix {
    const fromConfig = this.VERSION_CONFIG[fromVersion];
    const toConfig = this.VERSION_CONFIG[toVersion];

    if (!fromConfig || !toConfig) {
      throw new Error(`Invalid version configuration: ${fromVersion} -> ${toVersion}`);
    }

    // Compare endpoints
    const compatibleEndpoints = fromConfig.supportedEndpoints.filter(endpoint =>
      toConfig.supportedEndpoints.includes(endpoint)
    );

    const newEndpoints = toConfig.supportedEndpoints.filter(endpoint =>
      !fromConfig.supportedEndpoints.includes(endpoint)
    );

    const deprecatedEndpoints = fromConfig.supportedEndpoints.filter(endpoint =>
      !toConfig.supportedEndpoints.includes(endpoint)
    );

    // Determine compatibility level
    let compatibilityLevel: string;
    if (toConfig.breakingChanges && toConfig.breakingChanges.length > 0) {
      compatibilityLevel = 'breaking_changes';
    } else if (newEndpoints.length > 0 || deprecatedEndpoints.length > 0) {
      compatibilityLevel = 'requires_changes';
    } else {
      compatibilityLevel = 'fully_compatible';
    }

    return {
      currentVersion: fromVersion,
      targetVersion: toVersion,
      isCompatible: compatibilityLevel !== 'breaking_changes',
      compatibilityLevel,
      compatibleEndpoints,
      newEndpoints,
      deprecatedEndpoints,
      breakingChanges: toConfig.breakingChanges || [],
      migrationEffortHours: this.estimateMigrationEffort(fromConfig, toConfig),
      migrationComplexity: this.assessComplexity(fromConfig, toConfig)
    };
  }

  private getFeatureBenefit(endpoint: string, vendorType?: string): string {
    const benefitMap = {
      '/api/v2/ai/content-generation': 'AI-powered content creation for faster form building',
      '/api/v2/guests/management': 'Advanced guest list management with RSVP tracking',
      '/api/v2/timeline/wedding-planning': 'Automated wedding timeline generation',
      '/api/v2/suppliers/{id}/analytics': 'Detailed performance analytics for your business',
      '/api/v2/forms/{id}/ai-suggestions': 'Smart form recommendations based on wedding type'
    };

    return benefitMap[endpoint] || 'Enhanced functionality for wedding management';
  }

  private extractClientIdentifier(request: NextRequest): string {
    // Try API key first
    const apiKey = request.headers.get('Authorization')?.replace('Bearer ', '');
    if (apiKey) return apiKey;

    // Try user ID from headers
    const userId = request.headers.get('X-User-ID');
    if (userId) return userId;

    // Fallback to IP address
    return request.headers.get('X-Forwarded-For')?.split(',')[0] || 
           request.headers.get('X-Real-IP') || 
           'unknown';
  }

  private getSupportedVersions(): string[] {
    return Object.keys(this.VERSION_CONFIG)
      .filter(version => this.VERSION_CONFIG[version].status !== 'sunset');
  }

  private getVersionInfo(version: string): APIVersionInfo {
    const config = this.VERSION_CONFIG[version];
    if (!config) {
      throw new Error(`Unsupported API version: ${version}`);
    }

    return {
      version: config.version,
      majorVersion: config.majorVersion,
      minorVersion: config.minorVersion,
      patchVersion: config.patchVersion,
      status: config.status,
      releaseDate: config.releaseDate,
      deprecationDate: config.deprecationDate,
      sunsetDate: config.sunsetDate,
      supportedEndpoints: config.supportedEndpoints,
      weddingFeatures: config.weddingFeatures
    };
  }
}

// Types for API versioning
interface APIVersionInfo {
  version: string;
  majorVersion: number;
  minorVersion: number;
  patchVersion: number;
  status: 'development' | 'beta' | 'stable' | 'deprecated' | 'sunset';
  releaseDate: Date;
  deprecationDate?: Date;
  sunsetDate?: Date;
  supportedEndpoints: string[];
  weddingFeatures: string[];
}

interface MigrationPlan {
  fromVersion: string;
  toVersion: string;
  totalEstimatedHours: number;
  complexity: 'low' | 'medium' | 'high';
  steps: MigrationStep[];
  benefits: string[];
  risks: string[];
  timeline: MigrationTimeline;
  supportOptions: {
    migrationGuide: string;
    codeExamples: string;
    supportContact: string;
    dedicatedSupport: boolean;
  };
}

interface MigrationStep {
  step: number;
  title: string;
  description: string;
  estimatedTimeHours: number;
  priority: 'low' | 'medium' | 'high';
  changes?: string[];
  breakingChanges?: string[];
  newFeatures?: Array<{
    endpoint: string;
    benefit: string;
    optional: boolean;
  }>;
  testingAreas?: string[];
  codeExamples?: string;
}

interface CompatibilityMatrix {
  currentVersion: string;
  targetVersion: string;
  isCompatible: boolean;
  compatibilityLevel: string;
  compatibleEndpoints: string[];
  newEndpoints: string[];
  deprecatedEndpoints: string[];
  breakingChanges: string[];
  migrationEffortHours: number;
  migrationComplexity: string;
}

interface ClientContext {
  subscriptionTier: string;
  vendorType?: string;
  integrationComplexity: 'low' | 'medium' | 'high';
  monthlyRequestVolume: number;
  criticalEndpoints: string[];
}

// Export singleton instance
export const apiVersionManager = new WedSyncAPIVersionManager();
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for API versioning best practices, backward compatibility patterns
- [x] Supabase: Version tracking and migration analytics storage
- [x] Notification systems: Migration reminders and deprecation alerts

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/vercel/next.js", "api versioning", 3000);
await mcp__context7__get-library-docs("/semantic-release/semantic-release", "version management", 3000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('API Versioning Strategy', () => {
  it('should detect API version from URL path and headers correctly', () => {
    // Test comprehensive version detection across different methods
  });
  
  it('should generate accurate migration plans with wedding industry context', () => {
    // Test migration plan generation with supplier/client specific guidance
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('API versioning handles deprecated version with proper migration guidance', async () => {
  // Test deprecated API version response
  const response = await page.request.get('/api/v1/suppliers/search', {
    headers: { 'Accept': 'application/vnd.wedsync.v1+json' }
  });
  
  expect(response.headers()['deprecation']).toBe('true');
  expect(response.headers()['link']).toContain('successor-version');
  
  const body = await response.json();
  expect(body.meta?.migrationGuide).toBeDefined();
});
```

### ACCEPTANCE CRITERIA
- [x] API versioning supports URL path (/api/v1/), header (Accept), and custom header (API-Version) detection methods
- [x] Deprecation process includes 6-month notice period with automated notifications and migration guidance
- [x] Migration tools generate step-by-step plans with wedding industry specific code examples
- [x] Performance: Version detection adds less than 5ms overhead to API requests
- [x] Security: Version sunset enforcement prevents access to unsupported APIs with clear error messages
- [x] Accessibility: Deprecation notices include clear migration timelines and support contact information

### DEPENDENCIES
- Must complete after: WS-196 (API Routes Structure) - provides base API architecture for versioning
- Must complete before: All major API changes, third-party integration documentation
- Shares code with: API middleware, monitoring systems, client SDK development

### ESTIMATED EFFORT
- Team A Backend: 64 hours (Version detection, compatibility checking, migration tools)
- Team C Integration: 32 hours (Client migration tracking, notification systems)
- Team D Frontend: 24 hours (Version dashboard, migration guidance UI)
- Total: 120 hours