# TECHNICAL SPECIFICATION: WS-128 - Music Database AI
## Generated by Feature Development Session - 2025-01-23

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding DJ managing music for 80+ weddings per year across diverse musical tastes and cultural backgrounds
**I want to:** Access an intelligent music database that suggests appropriate songs, handles fuzzy requests, and filters inappropriate content
**So that:** I reduce 4 hours per wedding spent on song research and eliminate awkward moments from inappropriate music choices

**Real Wedding Scenario:**
A couple requests "that song from The Office" for their first dance. Instead of spending 20 minutes googling and asking follow-ups, the DJ enters the fuzzy request and the AI identifies "Forever" by Chris Brown, checks appropriateness scores, suggests similar but more suitable alternatives like "All of Me" by John Legend, and provides Spotify/Apple Music integration for immediate preview and playlist creation.

### SPECIFICATION SOURCE
- **Feature ID:** WS-128
- **Original Spec:** /CORE-SPECIFICATIONS/04-AI-INTEGRATION/05-Vendor-Specific/02-music-database md.md
- **Current Implementation:** 0% complete
- **Files to Modify:** None (new feature)
- **New Files to Create:**
  - /src/lib/music/music-database.ts
  - /src/lib/music/spotify-provider.ts
  - /src/lib/music/apple-music-provider.ts
  - /src/app/api/music/search/route.ts
  - /src/app/api/music/analyze/route.ts
  - /src/components/music/MusicSearchInterface.tsx
  - /src/components/music/WeddingPlaylistBuilder.tsx

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Cached music tracks from multiple providers
CREATE TABLE IF NOT EXISTS music_tracks_cache (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  external_id TEXT NOT NULL,
  provider TEXT NOT NULL CHECK (provider IN ('spotify', 'apple', 'youtube')),
  title TEXT NOT NULL,
  artist TEXT NOT NULL,
  album TEXT,
  duration_ms INTEGER,
  explicit BOOLEAN DEFAULT false,
  popularity INTEGER,
  preview_url TEXT,
  external_url TEXT,
  wedding_categories JSONB DEFAULT '{}',
  appropriateness_score DECIMAL(3,2) DEFAULT 0.5,
  cached_at TIMESTAMP DEFAULT NOW(),
  last_accessed TIMESTAMP DEFAULT NOW(),
  UNIQUE(provider, external_id)
);

-- Wedding-specific song categorization
CREATE TABLE IF NOT EXISTS wedding_song_categories (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  track_id UUID REFERENCES music_tracks_cache(id),
  category TEXT NOT NULL CHECK (category IN ('processional', 'recessional', 'first_dance', 'reception', 'cocktail')),
  suitability_score DECIMAL(3,2) NOT NULL,
  reasoning TEXT,
  ai_analyzed BOOLEAN DEFAULT false,
  human_verified BOOLEAN DEFAULT false,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Song request processing
CREATE TABLE IF NOT EXISTS song_requests (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES user_profiles(id),
  wedding_id UUID,
  original_request TEXT NOT NULL,
  matched_track_id UUID REFERENCES music_tracks_cache(id),
  confidence_score DECIMAL(3,2),
  approved BOOLEAN DEFAULT false,
  alternative_suggestions JSONB DEFAULT '[]',
  processing_time_ms INTEGER,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Inappropriate content analysis
CREATE TABLE IF NOT EXISTS inappropriate_content_analysis (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  track_id UUID REFERENCES music_tracks_cache(id),
  flagged_reasons TEXT[],
  confidence_score DECIMAL(3,2) NOT NULL,
  lyrics_analyzed BOOLEAN DEFAULT false,
  human_reviewed BOOLEAN DEFAULT false,
  created_at TIMESTAMP DEFAULT NOW()
);
```

#### API Endpoints Required
```typescript
// GET /api/music/search
interface MusicSearchRequest {
  query: string;
  providers?: ('spotify' | 'apple' | 'youtube')[];
  weddingCategory?: string;
  filterInappropriate?: boolean;
  limit?: number;
}

interface MusicSearchResponse {
  success: boolean;
  data: {
    tracks: Track[];
    totalResults: number;
    searchTime: number;
    suggestedCategories: string[];
  };
}

// POST /api/music/analyze
interface AnalyzeMusicRequest {
  tracks: Track[];
  analysisTypes: ('appropriateness' | 'wedding_category' | 'similar_songs')[];
}

interface AnalyzeMusicResponse {
  success: boolean;
  data: {
    trackAnalysis: TrackAnalysis[];
    recommendations: Track[];
  };
}

// POST /api/music/resolve-request
interface ResolveFuzzyRequestRequest {
  request: string;
  context?: {
    weddingStyle?: string;
    guestAge?: string;
    culturalBackground?: string;
  };
}
```

#### Frontend Components Required
```typescript
// Component: MusicSearchInterface
// Location: /src/components/music/MusicSearchInterface.tsx

interface MusicSearchProps {
  onTrackSelected: (track: Track) => void;
  weddingContext: WeddingContext;
  allowInappropriate?: boolean;
}

interface Track {
  id: string;
  title: string;
  artist: string;
  album: string;
  duration_ms: number;
  explicit: boolean;
  preview_url?: string;
  external_url: string;
  provider: string;
  appropriateness_score: number;
  wedding_categories: WeddingCategory[];
}

interface WeddingCategory {
  category: string;
  suitability_score: number;
  reasoning: string;
}

// Key functionality:
- Multi-provider search (Spotify, Apple Music)
- Fuzzy song request resolution
- Wedding appropriateness filtering
- Real-time preview playback
- Playlist builder integration
- Inappropriate content warnings
```

#### Integration Points
```typescript
// Service: MusicDatabaseService
// Dependencies: Spotify API, Apple Music API, OpenAI, Content analysis

class MusicDatabaseService {
  async searchTracks(query: string, options: SearchOptions): Promise<Track[]> {
    // Multi-provider search aggregation
    // Wedding category analysis
    // Appropriateness filtering
    // Caching and performance optimization
  }
  
  async analyzeSongApproppriateness(track: Track): Promise<AppropriatenessAnalysis> {
    // Explicit content detection
    // Lyrical analysis for wedding suitability
    // Cultural sensitivity assessment
  }
}
```

### CODE EXAMPLES

#### Example 1: Multi-Provider Music Search with AI Analysis
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { SpotifyWebApi } from 'spotify-web-api-node';
import { OpenAI } from 'openai';
import { supabase } from '@/lib/supabase';

export class MusicDatabase {
  private spotify: SpotifyWebApi;
  private openai: OpenAI;
  private rateLimiter: Map<string, number> = new Map();

  constructor() {
    this.spotify = new SpotifyWebApi({
      clientId: process.env.SPOTIFY_CLIENT_ID,
      clientSecret: process.env.SPOTIFY_CLIENT_SECRET
    });
    
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });
  }

  async searchMultiProvider(
    query: string,
    options: SearchOptions = {}
  ): Promise<Track[]> {
    // Step 1: Check cache first
    const cached = await this.getCachedResults(query);
    if (cached.length > 0 && this.isCacheFresh(cached[0])) {
      return cached;
    }

    // Step 2: Search multiple providers in parallel
    const searchPromises: Promise<Track[]>[] = [];
    
    if (this.canMakeRequest('spotify')) {
      searchPromises.push(this.searchSpotify(query));
    }
    
    if (this.canMakeRequest('apple')) {
      searchPromises.push(this.searchAppleMusic(query));
    }

    const results = await Promise.allSettled(searchPromises);
    const tracks = results
      .filter(r => r.status === 'fulfilled')
      .flatMap(r => r.value)
      .slice(0, options.limit || 50);

    // Step 3: Analyze for wedding appropriateness
    if (options.analyzeForWedding) {
      for (const track of tracks) {
        await this.analyzeWeddingApproppriateness(track);
      }
    }

    // Step 4: Cache results
    await this.cacheResults(query, tracks);

    return this.rankResults(tracks, options);
  }

  private async searchSpotify(query: string): Promise<Track[]> {
    try {
      // Refresh token if needed
      await this.refreshSpotifyToken();
      
      const results = await this.spotify.searchTracks(query, { limit: 25 });
      
      return results.body.tracks.items.map(track => ({
        id: track.id,
        title: track.name,
        artist: track.artists[0].name,
        album: track.album.name,
        duration_ms: track.duration_ms,
        explicit: track.explicit,
        popularity: track.popularity,
        preview_url: track.preview_url,
        external_url: track.external_urls.spotify,
        provider: 'spotify',
        release_date: track.album.release_date
      }));
    } catch (error) {
      console.error('Spotify search failed:', error);
      return [];
    }
  }

  async resolveRequestWithAI(request: string): Promise<Track[]> {
    // Step 1: Use AI to interpret fuzzy requests
    const interpretation = await this.openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [{
        role: 'system',
        content: `You are a music expert helping identify songs from partial or incorrect descriptions.
        Common wedding song requests include partial lyrics, TV show references, or artist name variations.
        Return specific artist and song title suggestions with confidence scores.`
      }, {
        role: 'user',
        content: `Song request: "${request}"
        
        What song(s) could this be referring to? Consider:
        - Popular wedding songs
        - TV/movie soundtrack references
        - Common misspellings of artist names
        - Partial lyrics
        
        Return as JSON with multiple possibilities ranked by confidence.`
      }],
      response_format: { type: 'json_object' },
      temperature: 0.3
    });

    const suggestions = JSON.parse(interpretation.choices[0].message.content);
    const searchPromises: Promise<Track[]>[] = [];

    // Step 2: Search for each AI suggestion
    for (const suggestion of suggestions.songs || []) {
      const searchQuery = `${suggestion.artist} ${suggestion.title}`;
      searchPromises.push(
        this.searchMultiProvider(searchQuery, { limit: 3 })
          .then(results => results.map(track => ({
            ...track,
            ai_confidence: suggestion.confidence,
            original_request: request
          })))
      );
    }

    const allResults = await Promise.all(searchPromises);
    const flatResults = allResults.flat();

    // Step 3: Rank by AI confidence and track popularity
    return flatResults
      .sort((a, b) => (b.ai_confidence * 0.7 + (b.popularity || 0) * 0.3) - 
                      (a.ai_confidence * 0.7 + (a.popularity || 0) * 0.3))
      .slice(0, 10);
  }

  async analyzeWeddingApproppriateness(track: Track): Promise<AppropriatenessAnalysis> {
    // Step 1: Check if already analyzed
    const existing = await supabase
      .from('inappropriate_content_analysis')
      .select('*')
      .eq('track_id', track.id)
      .single();

    if (existing.data && !existing.error) {
      return existing.data;
    }

    // Step 2: Analyze with AI
    const analysis = await this.openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [{
        role: 'system',
        content: `Analyze songs for wedding appropriateness. Consider lyrics, themes, and cultural sensitivity.
        Rate on 0-1 scale where 1.0 = perfect for weddings, 0.0 = completely inappropriate.`
      }, {
        role: 'user',
        content: `Song: "${track.title}" by ${track.artist}
        
        Analyze for wedding appropriateness:
        - Lyrical content (love/relationship themes vs breakup/explicit)
        - Cultural sensitivity
        - General audience suitability
        - Energy/mood for different wedding moments
        
        Return JSON with appropriateness score and category suggestions.`
      }],
      response_format: { type: 'json_object' },
      temperature: 0.2
    });

    const result = JSON.parse(analysis.choices[0].message.content);
    
    // Step 3: Store analysis
    await supabase
      .from('inappropriate_content_analysis')
      .insert({
        track_id: track.id,
        flagged_reasons: result.concerns || [],
        confidence_score: result.appropriateness_score,
        ai_analyzed: true
      });

    return result;
  }

  private canMakeRequest(provider: string): boolean {
    const now = Date.now();
    const lastRequest = this.rateLimiter.get(provider) || 0;
    
    // Rate limiting: max 100 requests per hour for Spotify
    const hourInMs = 60 * 60 * 1000;
    if (now - lastRequest < hourInMs / 100) {
      return false;
    }
    
    this.rateLimiter.set(provider, now);
    return true;
  }
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [ ] Context7: Load docs for Spotify and Apple Music APIs
- [ ] Playwright: Test music search interface and playlist builders
- [ ] Filesystem: Access music cache and configuration files

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/spotify/web-api-sdk", "search tracks", 3000);
await mcp__context7__get-library-docs("/openai/openai-node", "content moderation", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('MusicDatabase', () => {
  it('should resolve fuzzy song requests with AI', async () => {
    const request = 'that song from The Office wedding episode';
    const results = await musicDatabase.resolveRequestWithAI(request);
    
    expect(results).toHaveLength.greaterThan(0);
    expect(results[0].ai_confidence).toBeGreaterThan(0.7);
    expect(results[0].title.toLowerCase()).toContain('forever');
  });

  it('should filter inappropriate content for wedding', async () => {
    const track = { title: 'Explicit Song', artist: 'Test Artist', explicit: true };
    const analysis = await musicDatabase.analyzeWeddingApproppriateness(track);
    
    expect(analysis.appropriateness_score).toBeLessThan(0.5);
    expect(analysis.flagged_reasons).toContain('explicit content');
  });

  it('should search multiple providers and merge results', async () => {
    const results = await musicDatabase.searchMultiProvider('wedding songs');
    
    expect(results).toHaveLength.greaterThan(0);
    expect(results.some(r => r.provider === 'spotify')).toBe(true);
    expect(results.every(r => r.appropriateness_score >= 0.5)).toBe(true);
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Music search and playlist creation workflow', async () => {
  await mcp__playwright__browser_navigate({url: '/music/search'});
  
  await mcp__playwright__browser_type({
    element: 'Song Search Input',
    ref: 'input[name="musicQuery"]',
    text: 'perfect first dance song'
  });
  
  await mcp__playwright__browser_click({element: 'Search Button', ref: 'button[type="submit"]'});
  await mcp__playwright__browser_wait_for({text: 'Search Results'});
  
  // Test fuzzy search
  await mcp__playwright__browser_type({
    element: 'Fuzzy Request Input',
    ref: 'input[name="fuzzyRequest"]',
    text: 'that Bruno Mars wedding song'
  });
  
  await mcp__playwright__browser_click({element: 'Resolve Request', ref: 'button.resolve-fuzzy'});
  await mcp__playwright__browser_wait_for({text: 'Marry You'});
  
  await mcp__playwright__browser_snapshot();
});
```

### ACCEPTANCE CRITERIA
- [ ] Search across Spotify and Apple Music with 95%+ accuracy
- [ ] Resolve fuzzy song requests with 90%+ relevance
- [ ] Process song analysis within 2 seconds per track
- [ ] Filter inappropriate content with 95%+ accuracy
- [ ] Support wedding-specific categorization (5 categories)
- [ ] Cache search results for 24 hours to improve performance
- [ ] Handle rate limiting gracefully across all music providers
- [ ] Provide real-time song previews when available

### DEPENDENCIES
- Must complete after: None - Can start immediately
- Must complete before: Playlist generation and wedding timeline features
- Shares code with: AI content analysis infrastructure, external API management

### ESTIMATED EFFORT
- Team A Frontend: 24 hours (Search interface, playlist builder, preview player)
- Team B Backend: 28 hours (Multi-provider integration, AI analysis, caching)
- Team C Integration: 16 hours (API rate limiting, content moderation, data synchronization)
- Total: 68 hours