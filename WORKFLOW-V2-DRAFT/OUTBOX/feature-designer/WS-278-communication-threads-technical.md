# TECHNICAL SPECIFICATION: WS-278 - Communication Threads
## Generated by Feature Development Session - 2025-01-20

### USER STORY & BUSINESS CONTEXT (FACTUAL)
**As a:** Bride or groom coordinating with multiple wedding vendors
**I want to:** Have organized conversation threads for each wedding task or vendor topic
**So that:** All related messages stay together and vendors can follow the conversation history without scattered emails

**Real Wedding Scenario:**
Currently, couples discuss catering menu changes via 15+ separate emails with the caterer, venue, and planner. Important details get lost in email chains. With communication threads, all catering discussions stay in one organized thread where the couple, caterer, venue coordinator, and planner can all participate and see the complete conversation history.

### SPECIFICATION SOURCE
- **Feature ID:** WS-278
- **Original Spec:** Wedding vendor communication and task delegation requirements
- **Current Implementation:** 0% complete
- **Files to Modify:** 
  - `/src/components/messaging/MessageThread.tsx`
  - `/src/app/api/messages/route.ts`
- **New Files to Create:**
  - `/src/components/messaging/ThreadManager.tsx`
  - `/src/components/messaging/ThreadSidebar.tsx`
  - `/src/app/api/threads/route.ts`
  - `/src/app/api/threads/[id]/messages/route.ts`
  - `/src/lib/realtime/thread-subscriptions.ts`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Communication threads for organizing wedding conversations
CREATE TABLE IF NOT EXISTS communication_threads (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  wedding_id UUID REFERENCES weddings(id) ON DELETE CASCADE,
  title VARCHAR(200) NOT NULL,
  description TEXT,
  thread_type VARCHAR(50) NOT NULL CHECK (thread_type IN ('vendor_coordination', 'task_discussion', 'general_planning', 'emergency')),
  created_by UUID REFERENCES auth.users(id),
  status VARCHAR(20) DEFAULT 'active' CHECK (status IN ('active', 'archived', 'closed')),
  priority VARCHAR(20) DEFAULT 'normal' CHECK (priority IN ('low', 'normal', 'high', 'urgent')),
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Thread participants (couples, vendors, planners)
CREATE TABLE IF NOT EXISTS thread_participants (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  thread_id UUID REFERENCES communication_threads(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id),
  role VARCHAR(50) NOT NULL CHECK (role IN ('couple', 'vendor', 'planner', 'venue', 'coordinator')),
  can_add_participants BOOLEAN DEFAULT FALSE,
  can_archive_thread BOOLEAN DEFAULT FALSE,
  notification_settings JSONB DEFAULT '{"email": true, "push": true, "sms": false}',
  joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  last_read_at TIMESTAMP WITH TIME ZONE,
  UNIQUE(thread_id, user_id)
);

-- Messages within threads
CREATE TABLE IF NOT EXISTS thread_messages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  thread_id UUID REFERENCES communication_threads(id) ON DELETE CASCADE,
  sender_id UUID REFERENCES auth.users(id),
  message_type VARCHAR(20) DEFAULT 'text' CHECK (message_type IN ('text', 'image', 'file', 'system', 'task_update')),
  content TEXT NOT NULL,
  attachments JSONB DEFAULT '[]',
  reply_to UUID REFERENCES thread_messages(id),
  metadata JSONB DEFAULT '{}',
  edited_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_threads_wedding_status ON communication_threads(wedding_id, status);
CREATE INDEX idx_thread_participants_user ON thread_participants(user_id, thread_id);
CREATE INDEX idx_thread_messages_thread_created ON thread_messages(thread_id, created_at DESC);
CREATE INDEX idx_thread_messages_reply_to ON thread_messages(reply_to) WHERE reply_to IS NOT NULL;
```

#### API Endpoints Required
```typescript
// POST /api/threads - Create new thread
interface CreateThreadRequest {
  weddingId: string;
  title: string;
  description?: string;
  threadType: 'vendor_coordination' | 'task_discussion' | 'general_planning' | 'emergency';
  participants: {
    userId: string;
    role: 'couple' | 'vendor' | 'planner' | 'venue' | 'coordinator';
  }[];
  initialMessage?: string;
}

interface CreateThreadResponse {
  success: boolean;
  data: {
    threadId: string;
    title: string;
    participants: ThreadParticipant[];
  };
}

// GET /api/threads?weddingId=x - List threads for wedding
interface ThreadsListResponse {
  threads: {
    id: string;
    title: string;
    threadType: string;
    priority: string;
    participantCount: number;
    lastMessage: {
      content: string;
      senderName: string;
      createdAt: string;
    };
    unreadCount: number;
  }[];
}

// POST /api/threads/[id]/messages - Send message
interface SendMessageRequest {
  content: string;
  messageType: 'text' | 'image' | 'file';
  attachments?: FileAttachment[];
  replyTo?: string;
}

// GET /api/threads/[id]/messages - Get thread messages
interface ThreadMessagesResponse {
  messages: {
    id: string;
    senderId: string;
    senderName: string;
    senderRole: string;
    content: string;
    messageType: string;
    attachments: FileAttachment[];
    replyTo: string | null;
    createdAt: string;
    editedAt: string | null;
  }[];
  participants: ThreadParticipant[];
}
```

#### Frontend Components Required
```typescript
// Component: ThreadManager
// Location: /src/components/messaging/ThreadManager.tsx

interface ThreadManagerProps {
  weddingId: string;
  currentUserId: string;
  userRole: 'couple' | 'vendor' | 'planner' | 'venue' | 'coordinator';
}

// Key functionality:
- Thread list with search and filtering
- Thread creation modal
- Real-time thread updates
- Participant management
- Archive/unarchive threads

// Component: ThreadSidebar
// Location: /src/components/messaging/ThreadSidebar.tsx
interface ThreadSidebarProps {
  threads: Thread[];
  activeThreadId: string | null;
  onThreadSelect: (threadId: string) => void;
  onCreateThread: () => void;
  unreadCounts: Record<string, number>;
}

// Key functionality:
- Thread list with unread indicators
- Priority-based sorting
- Thread type filtering
- Search functionality
- Create new thread button

// Component: MessageComposer
// Location: /src/components/messaging/MessageComposer.tsx
interface MessageComposerProps {
  threadId: string;
  onSendMessage: (message: SendMessageRequest) => void;
  replyingTo?: Message | null;
  participants: ThreadParticipant[];
}

// Key functionality:
- Rich text message composition
- File attachment handling
- Reply-to message threading
- @mention participant tagging
- Message formatting tools
```

#### Integration Points
```typescript
// Service: ThreadRealtimeService
// Dependencies: Supabase Realtime, notification service

class ThreadRealtimeService {
  async subscribeToThread(threadId: string, callback: (message: Message) => void) {
    // Subscribe to real-time messages for specific thread
    // Handle new messages, edits, participant changes
    // Update unread counts in real-time
  }
  
  async subscribeToUserThreads(userId: string, callback: (update: ThreadUpdate) => void) {
    // Subscribe to all threads where user is participant
    // Handle new threads, status changes, participant updates
  }
  
  async sendMessage(threadId: string, message: SendMessageRequest) {
    // Send message and trigger real-time updates
    // Send notifications to thread participants
    // Update thread last activity timestamp
  }
}

// Service: ThreadNotificationService
// Dependencies: Email service, SMS service, push notifications

class ThreadNotificationService {
  async notifyParticipants(threadId: string, message: Message, excludeUserId: string) {
    // Get participant notification preferences
    // Send notifications via preferred channels
    // Track notification delivery status
  }
}
```

### CODE EXAMPLES

#### Example 1: Thread Creation and Management
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { useState, useEffect } from 'react';
import { createClient } from '@supabase/supabase-js';
import { useRealtime } from '@/hooks/useRealtime';

interface Thread {
  id: string;
  title: string;
  threadType: string;
  priority: string;
  participantCount: number;
  lastMessage: {
    content: string;
    senderName: string;
    createdAt: string;
  };
  unreadCount: number;
}

export function ThreadManager({ weddingId, currentUserId, userRole }: ThreadManagerProps) {
  const [threads, setThreads] = useState<Thread[]>([]);
  const [activeThread, setActiveThread] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const supabase = createClient(process.env.NEXT_PUBLIC_SUPABASE_URL!, process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!);

  // Load user's threads
  useEffect(() => {
    loadThreads();
  }, [weddingId]);

  const loadThreads = async () => {
    try {
      const { data, error } = await supabase
        .from('communication_threads')
        .select(`
          *,
          thread_participants!inner(user_id, last_read_at),
          thread_messages(
            content,
            created_at,
            sender:auth.users(full_name)
          )
        `)
        .eq('wedding_id', weddingId)
        .eq('thread_participants.user_id', currentUserId)
        .eq('status', 'active')
        .order('updated_at', { ascending: false });

      if (error) throw error;

      // Transform data to include unread counts and last message info
      const threadsWithMetadata = data?.map(thread => ({
        id: thread.id,
        title: thread.title,
        threadType: thread.thread_type,
        priority: thread.priority,
        participantCount: thread.thread_participants.length,
        lastMessage: thread.thread_messages[0] ? {
          content: thread.thread_messages[0].content.slice(0, 100),
          senderName: thread.thread_messages[0].sender?.full_name || 'Unknown',
          createdAt: thread.thread_messages[0].created_at
        } : null,
        unreadCount: calculateUnreadCount(thread.thread_messages, thread.thread_participants[0]?.last_read_at)
      })) || [];

      setThreads(threadsWithMetadata);
    } catch (error) {
      console.error('Error loading threads:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const createThread = async (threadData: CreateThreadRequest) => {
    try {
      // Create thread
      const { data: thread, error: threadError } = await supabase
        .from('communication_threads')
        .insert({
          wedding_id: threadData.weddingId,
          title: threadData.title,
          description: threadData.description,
          thread_type: threadData.threadType,
          created_by: currentUserId
        })
        .select()
        .single();

      if (threadError) throw threadError;

      // Add participants
      const participants = threadData.participants.map(p => ({
        thread_id: thread.id,
        user_id: p.userId,
        role: p.role,
        can_add_participants: p.role === 'couple' || p.role === 'planner'
      }));

      const { error: participantsError } = await supabase
        .from('thread_participants')
        .insert(participants);

      if (participantsError) throw participantsError;

      // Send initial message if provided
      if (threadData.initialMessage) {
        await sendMessage(thread.id, {
          content: threadData.initialMessage,
          messageType: 'text'
        });
      }

      // Reload threads to show new one
      await loadThreads();

      return { success: true, threadId: thread.id };
    } catch (error) {
      console.error('Error creating thread:', error);
      return { success: false, error: error.message };
    }
  };

  const sendMessage = async (threadId: string, messageData: SendMessageRequest) => {
    try {
      const { data, error } = await supabase
        .from('thread_messages')
        .insert({
          thread_id: threadId,
          sender_id: currentUserId,
          content: messageData.content,
          message_type: messageData.messageType,
          attachments: messageData.attachments || [],
          reply_to: messageData.replyTo
        })
        .select(`
          *,
          sender:auth.users(full_name, avatar_url)
        `)
        .single();

      if (error) throw error;

      // Update thread timestamp
      await supabase
        .from('communication_threads')
        .update({ updated_at: new Date().toISOString() })
        .eq('id', threadId);

      return data;
    } catch (error) {
      console.error('Error sending message:', error);
      throw error;
    }
  };

  return (
    <div className="flex h-full bg-white">
      {/* Thread Sidebar */}
      <div className="w-80 border-r border-gray-200 flex flex-col">
        <div className="p-4 border-b border-gray-200">
          <h2 className="text-lg font-semibold">Conversations</h2>
          <button
            onClick={() => setShowCreateModal(true)}
            className="mt-2 w-full bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700"
          >
            New Conversation
          </button>
        </div>
        
        <div className="flex-1 overflow-y-auto">
          {threads.map(thread => (
            <div
              key={thread.id}
              onClick={() => setActiveThread(thread.id)}
              className={`p-4 border-b border-gray-100 cursor-pointer hover:bg-gray-50 ${
                activeThread === thread.id ? 'bg-blue-50 border-l-4 border-l-blue-600' : ''
              }`}
            >
              <div className="flex justify-between items-start">
                <h3 className="font-medium text-gray-900 truncate">{thread.title}</h3>
                {thread.unreadCount > 0 && (
                  <span className="bg-blue-600 text-white text-xs px-2 py-1 rounded-full">
                    {thread.unreadCount}
                  </span>
                )}
              </div>
              
              <div className="flex justify-between items-center mt-2">
                <span className={`text-xs px-2 py-1 rounded ${getPriorityColor(thread.priority)}`}>
                  {thread.priority.toUpperCase()}
                </span>
                <span className="text-xs text-gray-500">
                  {thread.participantCount} participants
                </span>
              </div>
              
              {thread.lastMessage && (
                <div className="mt-2">
                  <p className="text-sm text-gray-600 truncate">
                    <span className="font-medium">{thread.lastMessage.senderName}:</span> {thread.lastMessage.content}
                  </p>
                  <p className="text-xs text-gray-400 mt-1">
                    {formatTimeAgo(thread.lastMessage.createdAt)}
                  </p>
                </div>
              )}
            </div>
          ))}
        </div>
      </div>

      {/* Thread Messages Area */}
      <div className="flex-1 flex flex-col">
        {activeThread ? (
          <ThreadMessagesView threadId={activeThread} currentUserId={currentUserId} />
        ) : (
          <div className="flex-1 flex items-center justify-center text-gray-500">
            <div className="text-center">
              <h3 className="text-lg font-medium">Select a conversation</h3>
              <p>Choose a conversation from the sidebar to start messaging</p>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

function calculateUnreadCount(messages: any[], lastReadAt: string | null): number {
  if (!lastReadAt) return messages.length;
  return messages.filter(msg => new Date(msg.created_at) > new Date(lastReadAt)).length;
}

function getPriorityColor(priority: string): string {
  switch (priority) {
    case 'urgent': return 'bg-red-100 text-red-800';
    case 'high': return 'bg-orange-100 text-orange-800';
    case 'normal': return 'bg-green-100 text-green-800';
    case 'low': return 'bg-gray-100 text-gray-800';
    default: return 'bg-gray-100 text-gray-800';
  }
}

function formatTimeAgo(dateString: string): string {
  const date = new Date(dateString);
  const now = new Date();
  const diffMinutes = Math.floor((now.getTime() - date.getTime()) / (1000 * 60));
  
  if (diffMinutes < 60) return `${diffMinutes}m ago`;
  if (diffMinutes < 1440) return `${Math.floor(diffMinutes / 60)}h ago`;
  return date.toLocaleDateString();
}
```

#### Example 2: Real-time Message Updates
```typescript
'use client';
import { useEffect, useState, useRef } from 'react';
import { createClient } from '@supabase/supabase-js';

interface Message {
  id: string;
  senderId: string;
  senderName: string;
  content: string;
  messageType: string;
  createdAt: string;
  replyTo: string | null;
}

export function ThreadMessagesView({ threadId, currentUserId }: { threadId: string; currentUserId: string }) {
  const [messages, setMessages] = useState<Message[]>([]);
  const [participants, setParticipants] = useState<ThreadParticipant[]>([]);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const supabase = createClient(process.env.NEXT_PUBLIC_SUPABASE_URL!, process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!);

  useEffect(() => {
    if (!threadId) return;

    // Load existing messages
    loadMessages();
    loadParticipants();

    // Subscribe to real-time updates
    const subscription = supabase
      .channel(`thread-${threadId}`)
      .on('postgres_changes', {
        event: 'INSERT',
        schema: 'public',
        table: 'thread_messages',
        filter: `thread_id=eq.${threadId}`
      }, (payload) => {
        // Add new message to state
        const newMessage = payload.new as any;
        setMessages(prev => [...prev, {
          id: newMessage.id,
          senderId: newMessage.sender_id,
          senderName: 'Loading...', // Will be populated by separate query
          content: newMessage.content,
          messageType: newMessage.message_type,
          createdAt: newMessage.created_at,
          replyTo: newMessage.reply_to
        }]);
      })
      .subscribe();

    // Mark thread as read when viewing
    markAsRead();

    return () => {
      subscription.unsubscribe();
    };
  }, [threadId]);

  // Auto-scroll to bottom when new messages arrive
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  const loadMessages = async () => {
    try {
      const { data, error } = await supabase
        .from('thread_messages')
        .select(`
          *,
          sender:auth.users(full_name, avatar_url),
          reply_to_message:thread_messages!reply_to(content, sender:auth.users(full_name))
        `)
        .eq('thread_id', threadId)
        .order('created_at', { ascending: true });

      if (error) throw error;

      const formattedMessages = data?.map(msg => ({
        id: msg.id,
        senderId: msg.sender_id,
        senderName: msg.sender?.full_name || 'Unknown User',
        senderAvatar: msg.sender?.avatar_url,
        content: msg.content,
        messageType: msg.message_type,
        createdAt: msg.created_at,
        replyTo: msg.reply_to,
        replyToMessage: msg.reply_to_message
      })) || [];

      setMessages(formattedMessages);
    } catch (error) {
      console.error('Error loading messages:', error);
    }
  };

  const markAsRead = async () => {
    try {
      await supabase
        .from('thread_participants')
        .update({ last_read_at: new Date().toISOString() })
        .eq('thread_id', threadId)
        .eq('user_id', currentUserId);
    } catch (error) {
      console.error('Error marking as read:', error);
    }
  };

  return (
    <div className="flex flex-col h-full">
      {/* Messages Area */}
      <div className="flex-1 overflow-y-auto p-4 space-y-4">
        {messages.map((message) => (
          <div
            key={message.id}
            className={`flex ${message.senderId === currentUserId ? 'justify-end' : 'justify-start'}`}
          >
            <div
              className={`max-w-xs lg:max-w-md px-4 py-2 rounded-lg ${
                message.senderId === currentUserId
                  ? 'bg-blue-600 text-white'
                  : 'bg-gray-100 text-gray-900'
              }`}
            >
              {/* Reply context */}
              {message.replyToMessage && (
                <div className={`text-xs mb-2 p-2 rounded ${
                  message.senderId === currentUserId ? 'bg-blue-700' : 'bg-gray-200'
                }`}>
                  <div className="font-medium">
                    {message.replyToMessage.sender?.full_name}
                  </div>
                  <div className="truncate">
                    {message.replyToMessage.content}
                  </div>
                </div>
              )}

              {/* Message content */}
              <div>
                {message.senderId !== currentUserId && (
                  <div className="text-xs font-medium mb-1">
                    {message.senderName}
                  </div>
                )}
                <div className="text-sm">{message.content}</div>
                <div className={`text-xs mt-1 ${
                  message.senderId === currentUserId ? 'text-blue-100' : 'text-gray-500'
                }`}>
                  {formatMessageTime(message.createdAt)}
                </div>
              </div>
            </div>
          </div>
        ))}
        <div ref={messagesEndRef} />
      </div>

      {/* Message Input */}
      <MessageComposer 
        threadId={threadId}
        participants={participants}
        onSendMessage={handleSendMessage}
      />
    </div>
  );
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Ref MCP: Search docs for Supabase Realtime, React messaging patterns
- [x] Supabase MCP: Real-time subscriptions and database operations
- [x] Browser MCP: Interactive testing of messaging interface
- [x] Filesystem: Access message templates and styling

#### Ref MCP Searches Needed
```bash
# Use Ref MCP to search for:
# - "Supabase Realtime React hooks"
# - "React messaging UI patterns"
# - "Real-time chat implementation"
# - "Message threading best practices"
```

#### Browser MCP Interactive Testing
```bash
# Use Browser MCP for:
# - Testing real-time message delivery
# - Verifying thread creation and participant management
# - Screenshot capture of conversation interface
# - Testing mobile responsive messaging layout
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('ThreadManager', () => {
  it('should load threads for wedding', async () => {
    // Test thread loading functionality
  });
  
  it('should create new thread with participants', async () => {
    // Test thread creation with proper participants
  });
  
  it('should calculate unread count correctly', () => {
    // Test unread message counting logic
  });
  
  it('should handle real-time message updates', async () => {
    // Test real-time subscription and message updates
  });
});
```

#### E2E Tests Required
```typescript
test('Create and participate in wedding discussion thread', async () => {
  await mcp__playwright__browser_navigate({url: '/wedding/test-wedding/communication'});
  
  // Create new thread
  await mcp__playwright__browser_click({element: 'New Conversation button', ref: '[data-testid="create-thread"]'});
  await mcp__playwright__browser_type({element: 'Thread title', ref: '[data-testid="thread-title"]', text: 'Catering Menu Discussion'});
  await mcp__playwright__browser_select_option({element: 'Thread type', ref: '[data-testid="thread-type"]', values: ['vendor_coordination']});
  
  // Add participants
  await mcp__playwright__browser_click({element: 'Add participant', ref: '[data-testid="add-participant"]'});
  await mcp__playwright__browser_select_option({element: 'Participant role', ref: '[data-testid="participant-role"]', values: ['vendor']});
  
  // Create thread
  await mcp__playwright__browser_click({element: 'Create button', ref: '[data-testid="confirm-create"]'});
  
  // Send initial message
  await mcp__playwright__browser_type({element: 'Message input', ref: '[data-testid="message-input"]', text: 'Let\'s discuss the updated menu options'});
  await mcp__playwright__browser_click({element: 'Send button', ref: '[data-testid="send-message"]'});
  
  // Verify thread appears in sidebar
  const threadItem = await page.waitForSelector('[data-testid="thread-item"]');
  expect(threadItem).toBeTruthy();
  
  // Verify message appears
  const messageContent = await page.waitForSelector('[data-testid="message-content"]');
  expect(await messageContent.textContent()).toContain('Let\'s discuss the updated menu');
});
```

### ACCEPTANCE CRITERIA
- [x] Users can create organized conversation threads for wedding topics
- [x] Threads support multiple participants (couples, vendors, planners)
- [x] Real-time message delivery with read receipts
- [x] Message threading with reply-to functionality
- [x] File attachments and image sharing in threads
- [x] Thread prioritization (normal, high, urgent, emergency)
- [x] Thread archiving and search functionality
- [x] Mobile-responsive messaging interface
- [x] Push notifications for new messages
- [x] **Navigation Integration: Communication threads accessible from wedding dashboard**
  - [x] Messages/Communication tab in main wedding navigation
  - [x] Unread message indicators in navigation
  - [x] Quick access to urgent/priority threads
  - [x] Mobile navigation support for messaging
  - [x] Keyboard shortcuts for navigation between threads

### DEPENDENCIES
- Must complete after: User authentication and wedding management system
- Must complete before: Delivery Methods Integration (WS-279)
- Shares code with: Real-time notification system and user management

### ESTIMATED EFFORT
- Team A Frontend: 32 hours (Thread UI, message interface, real-time updates)
- Team B Backend: 28 hours (Thread APIs, real-time subscriptions, notifications)
- Team C Integration: 12 hours (Supabase Realtime setup, file attachments)
- Team D Platform: 8 hours (Thread management, archiving, search)
- Team E General: 16 hours (Testing, mobile responsive, accessibility)
- Team F Workflows: 8 hours (User flow optimization, notification preferences)
- Team G Performance: 8 hours (Real-time optimization, message pagination)
- Total: 112 hours