# TECHNICAL SPECIFICATION: WS-175 - Advanced Data Encryption
## Generated by Feature Development Session - 2025-01-24

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding supplier storing guest personal information
**I want to:** All sensitive data encrypted both in transit and at rest
**So that:** Client privacy is protected and GDPR compliance is maintained

### SPECIFICATION SOURCE
- **Feature ID:** WS-175
- **Original Spec:** /CORE-SPECIFICATIONS/10-SECURITY-COMPLIANCE/02-data-encryption md.md
- **Current Implementation:** 0% complete
- **Files to Create:**
  - /src/lib/encryption/field-encryption.ts
  - /src/lib/encryption/key-management.ts
  - /src/lib/encryption/secure-storage.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Encryption keys table
CREATE TABLE IF NOT EXISTS encryption_keys (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  key_id TEXT UNIQUE NOT NULL,
  encrypted_key TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  expires_at TIMESTAMPTZ,
  active BOOLEAN DEFAULT true
);

-- Update sensitive fields to be encrypted
ALTER TABLE guest_lists ADD COLUMN email_encrypted TEXT;
ALTER TABLE guest_lists ADD COLUMN phone_encrypted TEXT;
```

### CODE EXAMPLES

#### Example 1: Field-Level Encryption
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import crypto from 'crypto';

export class FieldEncryption {
  private algorithm = 'aes-256-gcm';
  
  async encryptField(plaintext: string, keyId: string): Promise<{
    encrypted: string;
    keyId: string;
    iv: string;
    tag: string;
  }> {
    const key = await this.getEncryptionKey(keyId);
    const iv = crypto.randomBytes(16);
    
    const cipher = crypto.createCipher(this.algorithm, key);
    cipher.setAAD(Buffer.from(keyId));
    
    let encrypted = cipher.update(plaintext, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    const tag = cipher.getAuthTag();
    
    return {
      encrypted,
      keyId,
      iv: iv.toString('hex'),
      tag: tag.toString('hex')
    };
  }
  
  async decryptField(encryptedData: {
    encrypted: string;
    keyId: string;
    iv: string;
    tag: string;
  }): Promise<string> {
    const key = await this.getEncryptionKey(encryptedData.keyId);
    
    const decipher = crypto.createDecipher(this.algorithm, key);
    decipher.setAAD(Buffer.from(encryptedData.keyId));
    decipher.setAuthTag(Buffer.from(encryptedData.tag, 'hex'));
    
    let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  }
}
```

### MCP SERVER USAGE
- [ ] Context7: Load docs for encryption libraries
- [ ] PostgreSQL: Create encryption tables
- [ ] Supabase: Configure RLS with encryption

### ACCEPTANCE CRITERIA
- [ ] PII fields encrypted at rest
- [ ] TLS 1.3 enforced in transit
- [ ] Encryption keys rotated regularly
- [ ] Key management system secure
- [ ] Performance impact < 10ms
- [ ] Backup data encrypted
- [ ] Key derivation functions strong

### DEPENDENCIES
- Must complete after: WS-174 (Authentication Security)
- Must complete before: WS-176 (GDPR Compliance)
- Shares code with: WS-177 (Audit Logging)

### ESTIMATED EFFORT
- Team B Backend: 24 hours
- Team D Security: 20 hours
- Total: 44 hours