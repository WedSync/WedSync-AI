# TECHNICAL SPECIFICATION: WS-160 - Master Timeline
## Generated by Feature Development Session - August 23, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding couple coordinating their wedding day schedule
**I want to:** Create a comprehensive timeline from getting ready to send-off with automatic time calculations and conflict detection
**So that:** All suppliers and helpers know exactly when and where to be, preventing delays and ensuring smooth transitions between events

**Real Wedding Scenario:**
A couple currently emails separate timeline documents to their photographer, DJ, caterer, and officiant, leading to conflicting schedules. With this feature, they create one master timeline where "Cocktail Hour 5:00pm-6:00pm" automatically calculates that "Reception Setup" must complete by 4:45pm with buffer time. All suppliers see the same synchronized schedule, eliminating the "I thought ceremony started at 4:30pm" confusion that causes wedding delays.

### SPECIFICATION SOURCE
- **Feature ID:** WS-160
- **Original Spec:** /CORE-SPECIFICATIONS/03-WEDME-COUPLE-PLATFORM/07-Timeline-Builder/01-master-timeline md.md
- **Current Implementation:** 0% complete (new)
- **Files to Modify:** None (new feature)
- **New Files to Create:** 
  - `/src/app/(dashboard)/timeline/page.tsx`
  - `/src/components/timeline/TimelineBuilder.tsx`
  - `/src/components/timeline/TimelineEvent.tsx` 
  - `/src/components/timeline/TimelineTemplateLibrary.tsx`
  - `/src/components/timeline/ConflictDetector.tsx`
  - `/src/lib/services/timelineService.ts`
  - `/src/types/timeline.ts`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Master timeline tables
CREATE TABLE IF NOT EXISTS master_timelines (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  couple_id UUID REFERENCES couples(id),
  wedding_date DATE NOT NULL,
  timezone VARCHAR(50) DEFAULT 'America/New_York',
  sunset_time TIME, -- For photo planning
  buffer_time INTEGER DEFAULT 15, -- Minutes between events
  notes TEXT,
  is_finalized BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS timeline_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  timeline_id UUID REFERENCES master_timelines(id) ON DELETE CASCADE,
  title VARCHAR(255) NOT NULL,
  category VARCHAR(50) CHECK (category IN ('prep', 'ceremony', 'cocktail', 'reception', 'party', 'sendoff')),
  start_time TIME NOT NULL,
  duration INTEGER NOT NULL, -- minutes
  end_time TIME GENERATED ALWAYS AS (start_time + (duration || ' minutes')::INTERVAL) STORED,
  location VARCHAR(255),
  notes TEXT,
  guest_visibility BOOLEAN DEFAULT true,
  supplier_assignments UUID[], -- Array of supplier IDs
  helper_assignments UUID[], -- Array of helper IDs
  sort_order INTEGER,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Timeline templates for common wedding formats
CREATE TABLE IF NOT EXISTS timeline_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255) NOT NULL,
  description TEXT,
  wedding_type VARCHAR(100), -- 'traditional', 'outdoor', 'destination', 'elopement'
  ceremony_duration INTEGER, -- Default ceremony length in minutes
  template_events JSONB NOT NULL, -- Array of event objects with relative timings
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_master_timelines_couple_id ON master_timelines(couple_id);
CREATE INDEX idx_timeline_events_timeline_id ON timeline_events(timeline_id);
CREATE INDEX idx_timeline_events_start_time ON timeline_events(start_time);
CREATE INDEX idx_timeline_events_category ON timeline_events(category);
```

#### API Endpoints Required
```typescript
// POST /api/timeline
interface CreateTimelineRequestBody {
  wedding_date: string;
  timezone: string;
  ceremony_time: string;
  reception_start_time: string;
  template_id?: string;
}

interface CreateTimelineResponseBody {
  success: boolean;
  data: MasterTimeline & {
    events: TimelineEvent[];
    conflicts: TimelineConflict[];
  };
}

// GET /api/timeline/:couple_id
interface TimelineResponse {
  success: boolean;
  data: {
    timeline: MasterTimeline;
    events: TimelineEvent[];
    supplier_schedules: SupplierSchedule[];
    helper_schedules: HelperSchedule[];
  };
}

// POST /api/timeline/events
interface CreateEventRequest {
  timeline_id: string;
  title: string;
  category: string;
  start_time: string;
  duration: number;
  location: string;
  supplier_assignments?: string[];
  helper_assignments?: string[];
}

// POST /api/timeline/validate
interface ValidateTimelineRequest {
  events: TimelineEvent[];
  buffer_time: number;
}

interface ValidateTimelineResponse {
  success: boolean;
  conflicts: Array<{
    event1: TimelineEvent;
    event2: TimelineEvent;
    type: 'overlap' | 'insufficient_buffer' | 'supplier_conflict';
    suggestion?: string;
  }>;
}
```

#### Frontend Components Required
```typescript
// Component: TimelineBuilder
// Location: /src/components/timeline/TimelineBuilder.tsx

interface TimelineBuilderProps {
  coupleId: string;
  initialTimeline?: MasterTimeline;
  onTimelineUpdate: (timeline: MasterTimeline) => void;
}

// Key functionality:
- Visual timeline with hour markers (8am - 12am)
- Drag-and-drop event blocks with auto-snap to time increments
- Real-time conflict detection and highlighting
- Auto-calculate end times based on duration
- Color-coded event categories
- Zoom controls for detailed editing
- Print-friendly view generation

// Component: TimelineEvent
// Location: /src/components/timeline/TimelineEvent.tsx

interface TimelineEventProps {
  event: TimelineEvent;
  onEventUpdate: (event: TimelineEvent) => void;
  onEventDelete: (eventId: string) => void;
  isConflicted?: boolean;
  conflictDetails?: string;
}

// Key functionality:
- Inline editing of event details
- Duration adjustment with drag handles
- Supplier/helper assignment dropdowns
- Guest visibility toggle
- Notes and location editing
- Category color coding

// Component: ConflictDetector
// Location: /src/components/timeline/ConflictDetector.tsx

// Key functionality:
- Real-time validation as events are moved
- Visual conflict indicators
- Suggested resolution times
- Buffer time validation
- Supplier availability checking
```

#### Integration Points
```typescript
// Service: TimelineService
// Dependencies: Supplier service, weather service, venue service

class TimelineService {
  async createTimelineFromTemplate(templateId: string, weddingDetails: WeddingDetails): Promise<MasterTimeline> {
    const template = await this.getTemplate(templateId);
    
    // Calculate event times based on ceremony time
    const ceremonyTime = weddingDetails.ceremony_time;
    const events = template.events.map(eventTemplate => {
      const startTime = this.calculateEventTime(eventTemplate.relative_time, ceremonyTime);
      
      return {
        title: eventTemplate.title,
        category: eventTemplate.category,
        start_time: startTime,
        duration: eventTemplate.duration,
        location: eventTemplate.location || weddingDetails.venue_name,
        supplier_assignments: this.matchSuppliersToEvent(eventTemplate, weddingDetails.suppliers),
        guest_visibility: eventTemplate.guest_visibility
      };
    });
    
    // Validate for conflicts
    const conflicts = await this.validateEvents(events);
    
    if (conflicts.length > 0) {
      // Auto-resolve minor conflicts by adjusting buffer times
      events = this.autoResolveConflicts(events, conflicts);
    }
    
    return await this.createTimeline(weddingDetails.couple_id, events);
  }
  
  async validateTimelineEvents(events: TimelineEvent[], bufferTime: number): Promise<TimelineConflict[]> {
    const conflicts: TimelineConflict[] = [];
    
    // Sort events by start time
    const sortedEvents = [...events].sort((a, b) => a.start_time.localeCompare(b.start_time));
    
    for (let i = 0; i < sortedEvents.length - 1; i++) {
      const currentEvent = sortedEvents[i];
      const nextEvent = sortedEvents[i + 1];
      
      const currentEndTime = this.addMinutes(currentEvent.start_time, currentEvent.duration);
      const requiredStartTime = this.addMinutes(currentEndTime, bufferTime);
      
      if (requiredStartTime > nextEvent.start_time) {
        conflicts.push({
          type: 'insufficient_buffer',
          event1: currentEvent,
          event2: nextEvent,
          overlap_minutes: this.diffMinutes(requiredStartTime, nextEvent.start_time),
          suggestion: `Move "${nextEvent.title}" to ${requiredStartTime} or reduce "${currentEvent.title}" duration`
        });
      }
      
      // Check for supplier conflicts
      const supplierOverlap = this.findSupplierConflicts(currentEvent, nextEvent);
      if (supplierOverlap.length > 0) {
        conflicts.push({
          type: 'supplier_conflict',
          event1: currentEvent,
          event2: nextEvent,
          conflicted_suppliers: supplierOverlap,
          suggestion: 'Reassign conflicted suppliers or adjust timing'
        });
      }
    }
    
    return conflicts;
  }
  
  async integrateSunsetTime(weddingDate: Date, location: string): Promise<string> {
    // Use weather API to get accurate sunset time for photo planning
    const response = await fetch(`/api/weather/sunset?date=${weddingDate.toISOString()}&location=${location}`);
    const data = await response.json();
    return data.sunset_time;
  }
}
```

### CODE EXAMPLES

#### Example 1: Timeline Builder Component
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
'use client';

import { useState, useEffect, useCallback } from 'react';
import { supabase } from '@/lib/supabase';
import { MasterTimeline, TimelineEvent, TimelineConflict } from '@/types/timeline';
import { DragDropContext, Droppable, Draggable } from '@hello-pangea/dnd';
import { format, addMinutes, parseISO } from 'date-fns';

export function TimelineBuilder({ 
  coupleId, 
  initialTimeline, 
  onTimelineUpdate 
}: {
  coupleId: string;
  initialTimeline?: MasterTimeline;
  onTimelineUpdate: (timeline: MasterTimeline) => void;
}) {
  const [timeline, setTimeline] = useState<MasterTimeline | null>(initialTimeline || null);
  const [events, setEvents] = useState<TimelineEvent[]>([]);
  const [conflicts, setConflicts] = useState<TimelineConflict[]>([]);
  const [isValidating, setIsValidating] = useState(false);
  const [zoomLevel, setZoomLevel] = useState(1); // 1 = normal, 2 = detailed

  useEffect(() => {
    if (timeline) {
      fetchTimelineEvents();
    }
  }, [timeline]);

  const fetchTimelineEvents = async () => {
    if (!timeline) return;
    
    const { data, error } = await supabase
      .from('timeline_events')
      .select('*')
      .eq('timeline_id', timeline.id)
      .order('start_time');
    
    if (error) throw error;
    
    setEvents(data || []);
    await validateTimeline(data || []);
  };

  const validateTimeline = useCallback(async (events: TimelineEvent[]) => {
    setIsValidating(true);
    
    const { data, error } = await supabase
      .rpc('validate_timeline_events', {
        timeline_events: events,
        buffer_time: timeline?.buffer_time || 15
      });

    if (data?.conflicts) {
      setConflicts(data.conflicts);
    } else {
      setConflicts([]);
    }
    
    setIsValidating(false);
  }, [timeline?.buffer_time]);

  const handleEventDrag = async (result: any) => {
    const { destination, source, draggableId } = result;
    
    if (!destination) return;
    
    // Calculate new start time based on drop position
    const timeSlots = generateTimeSlots();
    const newStartTime = timeSlots[destination.index];
    
    const eventId = draggableId;
    const event = events.find(e => e.id === eventId);
    
    if (!event) return;
    
    // Update event start time
    const updatedEvent = {
      ...event,
      start_time: newStartTime
    };
    
    const { error } = await supabase
      .from('timeline_events')
      .update({ start_time: newStartTime })
      .eq('id', eventId);
      
    if (!error) {
      const updatedEvents = events.map(e => e.id === eventId ? updatedEvent : e);
      setEvents(updatedEvents);
      await validateTimeline(updatedEvents);
    }
  };

  const generateTimeSlots = () => {
    // Generate 15-minute time slots from 8am to 12am
    const slots = [];
    let currentTime = new Date();
    currentTime.setHours(8, 0, 0, 0);
    
    const endTime = new Date();
    endTime.setHours(24, 0, 0, 0);
    
    while (currentTime < endTime) {
      slots.push(format(currentTime, 'HH:mm'));
      currentTime = addMinutes(currentTime, 15);
    }
    
    return slots;
  };

  const addNewEvent = async (timeSlot: string) => {
    const newEvent = {
      timeline_id: timeline!.id,
      title: 'New Event',
      category: 'reception',
      start_time: timeSlot,
      duration: 60,
      location: '',
      guest_visibility: true,
      supplier_assignments: [],
      helper_assignments: []
    };
    
    const { data, error } = await supabase
      .from('timeline_events')
      .insert(newEvent)
      .select()
      .single();
      
    if (!error) {
      setEvents([...events, data]);
      await validateTimeline([...events, data]);
    }
  };

  const getEventConflicts = (eventId: string) => {
    return conflicts.filter(c => 
      c.event1.id === eventId || c.event2.id === eventId
    );
  };

  if (!timeline) {
    return <div>No timeline found. Create one first.</div>;
  }

  const timeSlots = generateTimeSlots();
  const hoursToShow = zoomLevel === 1 ? 16 : 8; // Show fewer hours in detailed view
  const visibleSlots = timeSlots.slice(0, hoursToShow * 4); // 4 slots per hour

  return (
    <div className="timeline-builder">
      {/* Timeline Header */}
      <div className="timeline-header flex justify-between items-center mb-6">
        <h2 className="text-2xl font-bold">
          Wedding Timeline - {format(parseISO(timeline.wedding_date), 'MMMM d, yyyy')}
        </h2>
        
        <div className="timeline-controls flex gap-4">
          <button
            onClick={() => setZoomLevel(zoomLevel === 1 ? 2 : 1)}
            className="px-4 py-2 bg-blue-500 text-white rounded"
          >
            {zoomLevel === 1 ? 'Detailed View' : 'Overview'}
          </button>
          
          <div className="conflict-indicator">
            {conflicts.length > 0 && (
              <div className="bg-yellow-100 border border-yellow-400 text-yellow-700 px-3 py-1 rounded">
                {conflicts.length} conflict{conflicts.length > 1 ? 's' : ''} detected
              </div>
            )}
          </div>
        </div>
      </div>

      {/* Timeline Grid */}
      <DragDropContext onDragEnd={handleEventDrag}>
        <div className="timeline-grid relative bg-gray-50 rounded-lg p-4">
          {/* Time Column */}
          <div className="time-column absolute left-0 top-0 w-20">
            {visibleSlots.filter((_, index) => index % 4 === 0).map((time, index) => (
              <div 
                key={time} 
                className="time-marker h-16 flex items-center text-sm font-medium text-gray-600"
              >
                {format(parseISO(`2000-01-01T${time}`), 'h:mm a')}
              </div>
            ))}
          </div>

          {/* Events Column */}
          <Droppable droppableId="timeline">
            {(provided) => (
              <div 
                ref={provided.innerRef}
                {...provided.droppableProps}
                className="events-column ml-24 relative"
              >
                {/* Time Slot Guides */}
                {visibleSlots.map((time, index) => (
                  <div 
                    key={`slot-${time}`}
                    className="time-slot h-4 border-b border-gray-200 hover:bg-blue-50 cursor-pointer"
                    onClick={() => addNewEvent(time)}
                  />
                ))}

                {/* Events */}
                {events.map((event, index) => {
                  const eventConflicts = getEventConflicts(event.id);
                  const slotIndex = visibleSlots.indexOf(event.start_time);
                  const eventHeight = (event.duration / 15) * 16; // 16px per 15-minute slot
                  
                  if (slotIndex === -1) return null; // Event outside visible range
                  
                  return (
                    <Draggable key={event.id} draggableId={event.id} index={index}>
                      {(provided, snapshot) => (
                        <div
                          ref={provided.innerRef}
                          {...provided.draggableProps}
                          {...provided.dragHandleProps}
                          className={`
                            timeline-event absolute left-0 right-0 rounded border p-2 cursor-move
                            ${eventConflicts.length > 0 ? 'bg-red-100 border-red-300' : 'bg-white border-gray-300'}
                            ${snapshot.isDragging ? 'shadow-lg' : 'shadow-sm'}
                          `}
                          style={{
                            ...provided.draggableProps.style,
                            top: `${slotIndex * 16}px`,
                            height: `${eventHeight}px`,
                            minHeight: '32px'
                          }}
                        >
                          <div className="event-title font-medium text-sm">{event.title}</div>
                          <div className="event-time text-xs text-gray-600">
                            {event.start_time} - {format(addMinutes(parseISO(`2000-01-01T${event.start_time}`), event.duration), 'HH:mm')}
                          </div>
                          {event.location && (
                            <div className="event-location text-xs text-gray-500">
                              üìç {event.location}
                            </div>
                          )}
                          
                          {eventConflicts.length > 0 && (
                            <div className="conflict-warning text-xs text-red-600 mt-1">
                              ‚ö†Ô∏è {eventConflicts[0].type.replace('_', ' ')}
                            </div>
                          )}
                        </div>
                      )}
                    </Draggable>
                  );
                })}
                
                {provided.placeholder}
              </div>
            )}
          </Droppable>
        </div>
      </DragDropContext>

      {/* Conflict Details */}
      {conflicts.length > 0 && (
        <div className="conflicts-panel mt-6 bg-yellow-50 border border-yellow-200 rounded-lg p-4">
          <h3 className="font-semibold text-yellow-800 mb-3">Timeline Conflicts</h3>
          <div className="space-y-2">
            {conflicts.map((conflict, index) => (
              <div key={index} className="text-sm text-yellow-700">
                <strong>
                  {conflict.event1.title} ‚Üí {conflict.event2.title}
                </strong>
                <div>{conflict.suggestion}</div>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for date-fns, React DnD
- [x] Playwright: Test timeline builder workflows
- [x] Filesystem: Access timeline components

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/date-fns/date-fns", "date calculations", 2500);
await mcp__context7__get-library-docs("/hello-pangea/dnd", "drag drop timeline", 2000);
await mcp__context7__get-library-docs("/supabase/supabase-js", "generated columns", 1500);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('TimelineService', () => {
  it('should detect timeline conflicts correctly', async () => {
    const events = [
      { start_time: '14:00', duration: 90 },
      { start_time: '15:00', duration: 60 }
    ];
    
    const conflicts = await service.validateTimelineEvents(events, 15);
    expect(conflicts).toHaveLength(1);
    expect(conflicts[0].type).toBe('insufficient_buffer');
  });

  it('should create timeline from template with correct timings', async () => {
    const template = { events: [{ relative_time: 'ceremony-60min', duration: 30 }] };
    const weddingDetails = { ceremony_time: '16:00' };
    
    const timeline = await service.createTimelineFromTemplate(template.id, weddingDetails);
    expect(timeline.events[0].start_time).toBe('15:00');
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Timeline builder workflow', async () => {
  await mcp__playwright__browser_navigate({url: '/timeline'});
  await mcp__playwright__browser_snapshot();
  
  // Test drag and drop event reordering
  await mcp__playwright__browser_drag({
    startElement: 'Ceremony event block',
    startRef: '[data-testid="event-ceremony"]',
    endElement: '3:00 PM time slot',
    endRef: '[data-testid="timeslot-15:00"]'
  });
  
  // Verify conflict detection
  await mcp__playwright__browser_wait_for({
    text: 'Timeline Conflicts'
  });
  
  // Test adding new event
  await mcp__playwright__browser_click({
    element: '4:00 PM time slot',
    ref: '[data-testid="timeslot-16:00"]'
  });
  
  await mcp__playwright__browser_snapshot();
});
```

### ACCEPTANCE CRITERIA
- [x] Users can create comprehensive wedding day timeline from getting ready to send-off
- [x] Drag-and-drop interface allows easy event reordering with visual feedback
- [x] Real-time conflict detection prevents overlapping events and insufficient buffer times
- [x] Auto-calculation of end times based on event duration
- [x] Timeline templates for different wedding types (church, outdoor, destination)
- [x] Integration with sunset API for optimal photo timing
- [x] Print-friendly timeline view for distribution to suppliers
- [x] Supplier and helper assignment to specific events
- [x] Performance: Timeline renders 50+ events in <2s, drag operations <100ms
- [x] Security: All timeline data scoped to couple_id with RLS policies
- [x] Accessibility: Keyboard navigation for timeline events

### DEPENDENCIES
- Must complete after: None (foundational feature)
- Must complete before: WS-161 (Supplier Schedules), WS-162 (Helper Schedules)
- Shares code with: Task delegation and journey workflow systems

### ESTIMATED EFFORT
- Team A Frontend: 28 hours
- Team B Backend: 20 hours
- Team C Integration: 12 hours
- Total: 60 hours