# TECHNICAL SPECIFICATION: WS-219 - Google Places Integration
## Generated by Feature Development Session - 2025-01-25

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding planner helping couples find venues and vendors
**I want to:** Search for and auto-populate venue details, addresses, and contact information from Google Places
**So that:** I can quickly add verified venue information without manual data entry, ensure accurate addresses for vendor coordination, and provide couples with rich venue details including photos, reviews, and contact info, saving 15-20 minutes per venue research

**Real Wedding Scenario:**
A couple wants their ceremony at "Castello di Casole" in Tuscany but only knows the name. The wedding planner uses Google Places integration to search and instantly pulls in the complete address (Localit√† Casole d'Elsa, Casole d'Elsa, SI, Italy), phone number (+39 0577 961501), website, photos, and exact GPS coordinates. When creating vendor lists, they search "florists near Napa Valley" and get a list of verified flower shops with ratings, contact details, and driving directions. For timeline planning, Google Places provides accurate travel times between the ceremony and reception venues, accounting for traffic patterns. This eliminates the need to manually Google each venue, copy-paste addresses, and verify business information.

### SPECIFICATION SOURCE
- **Feature ID:** WS-219
- **Original Spec:** /CORE-SPECIFICATIONS/08-INTEGRATIONS/05-External-Services/01-google-places md.md
- **Current Implementation:** 0% complete (standalone integration)
- **Files to Modify:** 
  - /src/components/venues/VenueSearch.tsx (add Places search)
  - /src/components/vendors/VendorDirectory.tsx (add location-based search)
- **New Files to Create:** 
  - /src/lib/integrations/google-places-client.ts
  - /src/lib/services/places-search-service.ts
  - /src/components/places/GooglePlacesAutocomplete.tsx
  - /src/components/places/PlaceDetails.tsx
  - /src/components/places/LocationPicker.tsx
  - /src/components/places/NearbyPlacesSearch.tsx
  - /src/hooks/useGooglePlaces.ts
  - /src/hooks/useGeolocation.ts
  - /src/app/api/places/search/route.ts
  - /src/app/api/places/details/route.ts
  - /src/app/api/places/nearby/route.ts
  - /src/app/api/places/photos/route.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Google Places API configuration and usage tracking
CREATE TABLE IF NOT EXISTS google_places_config (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  api_key_encrypted TEXT NOT NULL, -- Encrypted Google Places API key
  daily_quota_limit INTEGER DEFAULT 1000, -- Daily API request limit
  current_usage INTEGER DEFAULT 0, -- Current daily usage
  usage_reset_date DATE DEFAULT CURRENT_DATE,
  rate_limit_per_minute INTEGER DEFAULT 60, -- Requests per minute limit
  autocomplete_enabled BOOLEAN DEFAULT true,
  place_details_enabled BOOLEAN DEFAULT true,
  nearby_search_enabled BOOLEAN DEFAULT true,
  place_photos_enabled BOOLEAN DEFAULT true,
  allowed_countries TEXT[] DEFAULT ARRAY['US', 'CA', 'UK', 'IT', 'FR', 'MX'], -- Supported countries
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Cache for Google Places data to reduce API calls
CREATE TABLE IF NOT EXISTS google_places_cache (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  place_id VARCHAR(255) NOT NULL UNIQUE, -- Google Place ID
  place_data JSONB NOT NULL, -- Complete place information
  place_type TEXT NOT NULL CHECK (place_type IN ('venue', 'vendor', 'accommodation', 'restaurant', 'other')),
  name TEXT NOT NULL,
  address TEXT,
  phone_number TEXT,
  website TEXT,
  rating DECIMAL(2,1),
  price_level INTEGER,
  coordinates POINT, -- Lat/Long coordinates
  photo_references TEXT[], -- Array of Google Photos API references
  business_hours JSONB, -- Opening hours data
  last_refreshed_at TIMESTAMP DEFAULT NOW(),
  cache_expires_at TIMESTAMP DEFAULT (NOW() + INTERVAL '7 days'),
  api_request_count INTEGER DEFAULT 1, -- How many API calls were made to build this cache
  created_at TIMESTAMP DEFAULT NOW()
);

-- Track places associated with wedding events
CREATE TABLE IF NOT EXISTS wedding_places (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  couple_id UUID REFERENCES couples(id) ON DELETE CASCADE,
  supplier_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- Optional: who added this place
  place_id VARCHAR(255) REFERENCES google_places_cache(place_id),
  wedding_role TEXT NOT NULL CHECK (wedding_role IN (
    'ceremony_venue', 'reception_venue', 'accommodation', 'rehearsal_venue',
    'photographer_meeting', 'vendor_meeting', 'hair_makeup_venue', 'getting_ready_location'
  )),
  is_primary BOOLEAN DEFAULT false, -- Main venue for this role
  booking_status TEXT DEFAULT 'considering' CHECK (booking_status IN ('considering', 'contacted', 'booked', 'rejected')),
  booking_date DATE,
  estimated_cost DECIMAL(10,2),
  notes TEXT,
  custom_name TEXT, -- Override display name if different from Google Places
  contact_person TEXT,
  contact_email TEXT,
  contact_phone TEXT,
  added_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Search history and analytics for Places usage
CREATE TABLE IF NOT EXISTS google_places_searches (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  search_query TEXT NOT NULL,
  search_type TEXT NOT NULL CHECK (search_type IN ('autocomplete', 'nearby', 'text_search')),
  location POINT, -- Search center point
  radius_meters INTEGER, -- Search radius
  place_types TEXT[], -- Requested place types
  results_returned INTEGER DEFAULT 0,
  result_place_ids TEXT[], -- Place IDs that were returned
  selected_place_id VARCHAR(255), -- Which place user actually selected
  api_requests_made INTEGER DEFAULT 1, -- How many API calls this search required
  search_context TEXT, -- 'venue_search', 'vendor_directory', 'manual_lookup', etc.
  searched_at TIMESTAMP DEFAULT NOW()
);

-- Usage analytics and rate limiting
CREATE TABLE IF NOT EXISTS google_places_usage_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  api_endpoint TEXT NOT NULL, -- 'autocomplete', 'details', 'nearby', 'photos'
  request_count INTEGER DEFAULT 1,
  quota_consumed INTEGER DEFAULT 1, -- Some endpoints consume different quota amounts
  response_status INTEGER, -- HTTP status code
  response_time_ms INTEGER,
  error_message TEXT,
  user_id UUID REFERENCES auth.users(id),
  request_timestamp TIMESTAMP DEFAULT NOW(),
  date_bucket DATE DEFAULT CURRENT_DATE -- For daily usage tracking
);

-- Indexes for performance
CREATE INDEX idx_google_places_cache_place_id ON google_places_cache(place_id);
CREATE INDEX idx_google_places_cache_coordinates ON google_places_cache USING GIST (coordinates);
CREATE INDEX idx_google_places_cache_name ON google_places_cache USING GIN (to_tsvector('english', name));
CREATE INDEX idx_wedding_places_couple ON wedding_places(couple_id);
CREATE INDEX idx_wedding_places_role ON wedding_places(wedding_role);
CREATE INDEX idx_google_places_searches_user ON google_places_searches(user_id);
CREATE INDEX idx_google_places_usage_log_date ON google_places_usage_log(date_bucket);

-- Insert default configuration
INSERT INTO google_places_config (api_key_encrypted, daily_quota_limit) VALUES
('', 1000); -- API key will be set during configuration
```

#### API Endpoints Required

**1. Places Search & Autocomplete**
```typescript
// GET /api/places/search
// Search for places with autocomplete
interface GooglePlacesSearchRequest {
  query: string;
  type?: 'autocomplete' | 'text_search';
  location?: {
    lat: number;
    lng: number;
  };
  radius?: number; // meters
  placeTypes?: string[]; // 'restaurant', 'lodging', 'point_of_interest', etc.
  country?: string; // ISO country code
  language?: string; // ISO language code
  sessionToken?: string; // For autocomplete session management
}

interface GooglePlacesSearchResponse {
  places: GooglePlace[];
  sessionToken: string;
  usage: {
    requestsUsed: number;
    quotaRemaining: number;
    rateLimitRemaining: number;
  };
  searchStats: {
    totalResults: number;
    searchTimeMs: number;
    cacheHits: number;
    apiCalls: number;
  };
}

interface GooglePlace {
  placeId: string;
  name: string;
  formattedAddress: string;
  types: string[];
  rating?: number;
  priceLevel?: number;
  geometry: {
    location: {
      lat: number;
      lng: number;
    };
    viewport?: {
      northeast: { lat: number; lng: number };
      southwest: { lat: number; lng: number };
    };
  };
  photos?: GooglePlacePhoto[];
  businessHours?: GoogleBusinessHours;
  phoneNumber?: string;
  website?: string;
  utcOffset?: number;
  permanently_closed?: boolean;
  partialMatch?: boolean;
  confidence: number; // 0.0 to 1.0 based on search relevance
  distanceFromSearch?: number; // meters, if location-based search
  cachedAt?: string; // If returned from cache
}

interface GooglePlacePhoto {
  photoReference: string;
  width: number;
  height: number;
  attributions: string[];
}

interface GoogleBusinessHours {
  isOpenNow: boolean;
  weekdayText: string[];
  periods: {
    open: { day: number; time: string };
    close: { day: number; time: string };
  }[];
}
```

**2. Place Details & Photos**
```typescript
// GET /api/places/details/{placeId}
// Get comprehensive details for a specific place
interface GooglePlaceDetailsRequest {
  placeId: string;
  fields?: string[]; // Specific fields to retrieve
  language?: string;
  sessionToken?: string;
}

interface GooglePlaceDetailsResponse {
  place: DetailedGooglePlace;
  usage: {
    requestsUsed: number;
    quotaConsumed: number;
  };
  fromCache: boolean;
  cacheAge?: string;
}

interface DetailedGooglePlace extends GooglePlace {
  addressComponents: AddressComponent[];
  vicinity?: string;
  internationalPhoneNumber?: string;
  formattedPhoneNumber?: string;
  website?: string;
  openingHours?: GoogleBusinessHours;
  reviews?: GooglePlaceReview[];
  userRatingsTotal?: number;
  wheelchairAccessible?: boolean;
  deliveryOptions?: {
    delivery: boolean;
    dineIn: boolean;
    takeout: boolean;
    curbsidePickup: boolean;
  };
  plusCode?: {
    globalCode: string;
    compoundCode: string;
  };
  secondaryOpeningHours?: GoogleBusinessHours[];
}

interface AddressComponent {
  longName: string;
  shortName: string;
  types: string[];
}

interface GooglePlaceReview {
  authorName: string;
  authorUrl?: string;
  language?: string;
  originalLanguage?: string;
  profilePhotoUrl?: string;
  rating: number;
  relativeTimeDescription: string;
  text: string;
  time: number; // Unix timestamp
  translated?: boolean;
}

// GET /api/places/photos/{photoReference}
// Get high-resolution photo from Google Places
interface GooglePlacePhotoRequest {
  photoReference: string;
  maxWidth?: number;
  maxHeight?: number;
}

interface GooglePlacePhotoResponse {
  photoUrl: string;
  actualWidth: number;
  actualHeight: number;
  attributions: string[];
  usage: {
    quotaConsumed: number;
  };
}
```

**3. Nearby & Location-based Search**
```typescript
// GET /api/places/nearby
// Find places near a specific location
interface GoogleNearbySearchRequest {
  location: {
    lat: number;
    lng: number;
  };
  radius: number; // meters, max 50000
  type?: string; // Single place type
  keyword?: string; // Additional keyword filter
  name?: string; // Name filter
  minPriceLevel?: number; // 0-4
  maxPriceLevel?: number; // 0-4
  openNow?: boolean;
  rankBy?: 'prominence' | 'distance';
  pageToken?: string; // For pagination
}

interface GoogleNearbySearchResponse {
  places: GooglePlace[];
  nextPageToken?: string;
  usage: {
    requestsUsed: number;
    quotaConsumed: number;
  };
  searchStats: {
    totalResults: number;
    searchCenter: {
      lat: number;
      lng: number;
    };
    searchRadius: number;
    cacheHits: number;
  };
}

// POST /api/places/batch-details
// Get details for multiple places efficiently
interface GoogleBatchDetailsRequest {
  placeIds: string[];
  fields?: string[];
  language?: string;
}

interface GoogleBatchDetailsResponse {
  places: DetailedGooglePlace[];
  usage: {
    totalRequestsUsed: number;
    totalQuotaConsumed: number;
  };
  timing: {
    totalTimeMs: number;
    averageTimeMs: number;
  };
  cacheStats: {
    cacheHits: number;
    apiCalls: number;
  };
}
```

**4. Wedding Places Management**
```typescript
// POST /api/places/wedding-places
// Add a place to a wedding
interface AddWeddingPlaceRequest {
  placeId: string;
  weddingRole: 'ceremony_venue' | 'reception_venue' | 'accommodation' | 'rehearsal_venue' | 'photographer_meeting' | 'vendor_meeting' | 'hair_makeup_venue' | 'getting_ready_location';
  isPrimary?: boolean;
  bookingStatus?: 'considering' | 'contacted' | 'booked' | 'rejected';
  estimatedCost?: number;
  notes?: string;
  customName?: string;
  contactInfo?: {
    person?: string;
    email?: string;
    phone?: string;
  };
}

interface AddWeddingPlaceResponse {
  weddingPlace: WeddingPlace;
  placeDetails: DetailedGooglePlace;
}

interface WeddingPlace {
  id: string;
  placeId: string;
  weddingRole: string;
  isPrimary: boolean;
  bookingStatus: string;
  bookingDate?: string;
  estimatedCost?: number;
  notes?: string;
  customName?: string;
  contactPerson?: string;
  contactEmail?: string;
  contactPhone?: string;
  addedAt: string;
  updatedAt: string;
  place: DetailedGooglePlace;
}

// GET /api/places/wedding-places
// Get all places associated with a wedding
interface WeddingPlacesResponse {
  places: WeddingPlace[];
  groupedByRole: Record<string, WeddingPlace[]>;
  stats: {
    totalPlaces: number;
    bookedPlaces: number;
    estimatedTotalCost: number;
    placesWithContacts: number;
  };
}

// PUT /api/places/wedding-places/{id}
// Update wedding place information
interface UpdateWeddingPlaceRequest {
  bookingStatus?: 'considering' | 'contacted' | 'booked' | 'rejected';
  bookingDate?: string;
  estimatedCost?: number;
  notes?: string;
  customName?: string;
  contactInfo?: {
    person?: string;
    email?: string;
    phone?: string;
  };
  isPrimary?: boolean;
}
```

#### Frontend Components Required

**1. Google Places Autocomplete**
```typescript
// src/components/places/GooglePlacesAutocomplete.tsx
import React, { useState, useEffect, useRef } from 'react';
import { useGooglePlaces } from '@/hooks/useGooglePlaces';
import { useDebounce } from '@/hooks/useDebounce';

interface GooglePlacesAutocompleteProps {
  onPlaceSelect: (place: GooglePlace) => void;
  placeholder?: string;
  types?: string[];
  country?: string;
  location?: {
    lat: number;
    lng: number;
  };
  radius?: number;
  disabled?: boolean;
  value?: string;
  onChange?: (value: string) => void;
}

export function GooglePlacesAutocomplete({
  onPlaceSelect,
  placeholder = "Search for venues, vendors, or locations...",
  types = [],
  country,
  location,
  radius,
  disabled = false,
  value = '',
  onChange
}: GooglePlacesAutocompleteProps) {
  const [query, setQuery] = useState(value);
  const [suggestions, setSuggestions] = useState<GooglePlace[]>([]);
  const [isOpen, setIsOpen] = useState(false);
  const [selectedIndex, setSelectedIndex] = useState(-1);
  const [sessionToken, setSessionToken] = useState<string>('');
  
  const inputRef = useRef<HTMLInputElement>(null);
  const { searchPlaces, isLoading, error } = useGooglePlaces();
  const debouncedQuery = useDebounce(query, 300);

  useEffect(() => {
    if (onChange) {
      onChange(query);
    }
  }, [query, onChange]);

  useEffect(() => {
    if (debouncedQuery.trim().length >= 2) {
      performSearch(debouncedQuery);
    } else {
      setSuggestions([]);
      setIsOpen(false);
    }
  }, [debouncedQuery]);

  const performSearch = async (searchQuery: string) => {
    try {
      const result = await searchPlaces({
        query: searchQuery,
        type: 'autocomplete',
        location,
        radius,
        placeTypes: types,
        country,
        sessionToken
      });

      setSuggestions(result.places);
      setSessionToken(result.sessionToken);
      setIsOpen(true);
      setSelectedIndex(-1);
    } catch (err) {
      console.error('Places search failed:', err);
      setSuggestions([]);
      setIsOpen(false);
    }
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setQuery(e.target.value);
  };

  const handleSuggestionClick = (place: GooglePlace, index: number) => {
    setQuery(place.name);
    setIsOpen(false);
    setSelectedIndex(-1);
    onPlaceSelect(place);
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (!isOpen || suggestions.length === 0) return;

    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        setSelectedIndex(prev => 
          prev < suggestions.length - 1 ? prev + 1 : 0
        );
        break;
      
      case 'ArrowUp':
        e.preventDefault();
        setSelectedIndex(prev => 
          prev > 0 ? prev - 1 : suggestions.length - 1
        );
        break;
      
      case 'Enter':
        e.preventDefault();
        if (selectedIndex >= 0) {
          handleSuggestionClick(suggestions[selectedIndex], selectedIndex);
        }
        break;
      
      case 'Escape':
        setIsOpen(false);
        setSelectedIndex(-1);
        inputRef.current?.blur();
        break;
    }
  };

  const handleInputFocus = () => {
    if (suggestions.length > 0) {
      setIsOpen(true);
    }
  };

  const handleInputBlur = () => {
    // Delay closing to allow for clicks on suggestions
    setTimeout(() => {
      setIsOpen(false);
      setSelectedIndex(-1);
    }, 150);
  };

  return (
    <div className="relative">
      <div className="relative">
        <input
          ref={inputRef}
          type="text"
          value={query}
          onChange={handleInputChange}
          onKeyDown={handleKeyDown}
          onFocus={handleInputFocus}
          onBlur={handleInputBlur}
          placeholder={placeholder}
          disabled={disabled}
          className={`w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 ${
            disabled ? 'bg-gray-100 cursor-not-allowed' : 'bg-white'
          } ${error ? 'border-red-300' : 'border-gray-300'}`}
        />
        
        {/* Loading indicator */}
        {isLoading && (
          <div className="absolute inset-y-0 right-0 flex items-center pr-3">
            <div className="animate-spin h-4 w-4 border-2 border-blue-500 border-t-transparent rounded-full"></div>
          </div>
        )}

        {/* Google Places powered indicator */}
        <div className="absolute inset-y-0 right-0 flex items-center pr-8">
          <span className="text-xs text-gray-400">Powered by Google</span>
        </div>
      </div>

      {/* Suggestions dropdown */}
      {isOpen && suggestions.length > 0 && (
        <div className="absolute z-50 w-full mt-1 bg-white border border-gray-300 rounded-lg shadow-lg max-h-60 overflow-y-auto">
          {suggestions.map((place, index) => (
            <button
              key={place.placeId}
              type="button"
              className={`w-full px-4 py-3 text-left hover:bg-gray-50 border-b border-gray-100 last:border-b-0 ${
                index === selectedIndex ? 'bg-blue-50' : ''
              }`}
              onClick={() => handleSuggestionClick(place, index)}
            >
              <div className="flex items-start space-x-3">
                <div className="flex-shrink-0 mt-1">
                  {place.types.includes('restaurant') ? 'üçΩÔ∏è' :
                   place.types.includes('lodging') ? 'üè®' :
                   place.types.includes('church') || place.types.includes('place_of_worship') ? '‚õ™' :
                   place.types.includes('park') ? 'üå≥' :
                   'üìç'
                  }
                </div>
                
                <div className="flex-1 min-w-0">
                  <div className="font-medium text-gray-900 truncate">
                    {place.name}
                  </div>
                  <div className="text-sm text-gray-600 truncate">
                    {place.formattedAddress}
                  </div>
                  
                  <div className="flex items-center mt-1 space-x-2">
                    {place.rating && (
                      <div className="flex items-center text-xs text-yellow-600">
                        ‚≠ê {place.rating.toFixed(1)}
                      </div>
                    )}
                    
                    {place.priceLevel && (
                      <div className="text-xs text-gray-500">
                        {'$'.repeat(place.priceLevel)}
                      </div>
                    )}
                    
                    {place.distanceFromSearch && (
                      <div className="text-xs text-gray-500">
                        {(place.distanceFromSearch / 1000).toFixed(1)} km away
                      </div>
                    )}
                  </div>
                </div>
              </div>
            </button>
          ))}
        </div>
      )}

      {/* Error message */}
      {error && (
        <div className="mt-1 text-sm text-red-600">
          {error}
        </div>
      )}
    </div>
  );
}
```

**2. Place Details Component**
```typescript
// src/components/places/PlaceDetails.tsx
import React, { useState, useEffect } from 'react';
import { useGooglePlaces } from '@/hooks/useGooglePlaces';

interface PlaceDetailsProps {
  placeId: string;
  showPhotos?: boolean;
  showReviews?: boolean;
  showHours?: boolean;
  showContact?: boolean;
  onAddToWedding?: (place: DetailedGooglePlace) => void;
}

export function PlaceDetails({
  placeId,
  showPhotos = true,
  showReviews = true,
  showHours = true,
  showContact = true,
  onAddToWedding
}: PlaceDetailsProps) {
  const [place, setPlace] = useState<DetailedGooglePlace | null>(null);
  const [selectedPhotoIndex, setSelectedPhotoIndex] = useState(0);
  
  const { getPlaceDetails, getPlacePhoto, isLoading, error } = useGooglePlaces();

  useEffect(() => {
    loadPlaceDetails();
  }, [placeId]);

  const loadPlaceDetails = async () => {
    try {
      const result = await getPlaceDetails({
        placeId,
        fields: ['name', 'formatted_address', 'formatted_phone_number', 'website', 
                'rating', 'user_ratings_total', 'price_level', 'opening_hours', 
                'photos', 'reviews', 'geometry', 'address_components']
      });
      setPlace(result.place);
    } catch (err) {
      console.error('Failed to load place details:', err);
    }
  };

  const formatPhoneNumber = (phone?: string) => {
    if (!phone) return null;
    // Format international phone numbers nicely
    return phone.replace(/^\+1/, '').replace(/(\d{3})(\d{3})(\d{4})/, '($1) $2-$3');
  };

  const getPriceRangeText = (priceLevel?: number) => {
    if (!priceLevel) return 'Price not available';
    const levels = ['Free', 'Inexpensive', 'Moderate', 'Expensive', 'Very Expensive'];
    return levels[priceLevel] || 'Unknown';
  };

  if (isLoading) {
    return <div className="animate-pulse space-y-4">Loading place details...</div>;
  }

  if (error || !place) {
    return (
      <div className="text-center py-8">
        <div className="text-gray-500">Failed to load place details</div>
        <button 
          onClick={loadPlaceDetails}
          className="mt-2 text-blue-600 hover:text-blue-800 text-sm"
        >
          Try again
        </button>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-start justify-between">
        <div>
          <h2 className="text-2xl font-bold text-gray-900">{place.name}</h2>
          <p className="text-gray-600 mt-1">{place.formattedAddress}</p>
          
          <div className="flex items-center mt-2 space-x-4">
            {place.rating && (
              <div className="flex items-center">
                <span className="text-yellow-500">‚≠ê</span>
                <span className="ml-1 font-medium">{place.rating.toFixed(1)}</span>
                {place.userRatingsTotal && (
                  <span className="ml-1 text-gray-500 text-sm">
                    ({place.userRatingsTotal.toLocaleString()} reviews)
                  </span>
                )}
              </div>
            )}
            
            {place.priceLevel && (
              <div className="text-sm">
                <span className="text-gray-500">Price: </span>
                <span className="font-medium">{getPriceRangeText(place.priceLevel)}</span>
              </div>
            )}
          </div>
        </div>
        
        {onAddToWedding && (
          <button
            onClick={() => onAddToWedding(place)}
            className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
          >
            Add to Wedding
          </button>
        )}
      </div>

      {/* Photos */}
      {showPhotos && place.photos && place.photos.length > 0 && (
        <div className="space-y-3">
          <h3 className="text-lg font-semibold text-gray-900">Photos</h3>
          
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            {place.photos.slice(0, 6).map((photo, index) => (
              <div key={photo.photoReference} className="relative">
                <img
                  src={getPlacePhoto({
                    photoReference: photo.photoReference,
                    maxWidth: 400,
                    maxHeight: 300
                  })}
                  alt={`${place.name} - Photo ${index + 1}`}
                  className="w-full h-48 object-cover rounded-lg cursor-pointer hover:opacity-90"
                  onClick={() => setSelectedPhotoIndex(index)}
                />
              </div>
            ))}
          </div>
        </div>
      )}

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        {/* Contact Information */}
        {showContact && (
          <div className="space-y-3">
            <h3 className="text-lg font-semibold text-gray-900">Contact Information</h3>
            
            <div className="space-y-2">
              {place.formattedPhoneNumber && (
                <div className="flex items-center">
                  <span className="w-5 text-gray-400">üìû</span>
                  <a 
                    href={`tel:${place.formattedPhoneNumber}`}
                    className="ml-2 text-blue-600 hover:text-blue-800"
                  >
                    {formatPhoneNumber(place.formattedPhoneNumber)}
                  </a>
                </div>
              )}
              
              {place.website && (
                <div className="flex items-center">
                  <span className="w-5 text-gray-400">üåê</span>
                  <a 
                    href={place.website}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="ml-2 text-blue-600 hover:text-blue-800 truncate"
                  >
                    {place.website.replace(/^https?:\/\//, '')}
                  </a>
                </div>
              )}
              
              <div className="flex items-center">
                <span className="w-5 text-gray-400">üìç</span>
                <button
                  onClick={() => {
                    const url = `https://maps.google.com/maps?q=${encodeURIComponent(place.formattedAddress)}`;
                    window.open(url, '_blank');
                  }}
                  className="ml-2 text-blue-600 hover:text-blue-800 text-left"
                >
                  View on Google Maps
                </button>
              </div>
            </div>
          </div>
        )}

        {/* Opening Hours */}
        {showHours && place.openingHours && (
          <div className="space-y-3">
            <h3 className="text-lg font-semibold text-gray-900">Hours</h3>
            
            <div className={`inline-flex px-2 py-1 text-sm rounded-full ${
              place.openingHours.isOpenNow 
                ? 'bg-green-100 text-green-800' 
                : 'bg-red-100 text-red-800'
            }`}>
              {place.openingHours.isOpenNow ? 'Open Now' : 'Closed'}
            </div>
            
            {place.openingHours.weekdayText && (
              <div className="space-y-1">
                {place.openingHours.weekdayText.map((day, index) => (
                  <div key={index} className="text-sm text-gray-600">
                    {day}
                  </div>
                ))}
              </div>
            )}
          </div>
        )}
      </div>

      {/* Reviews */}
      {showReviews && place.reviews && place.reviews.length > 0 && (
        <div className="space-y-4">
          <h3 className="text-lg font-semibold text-gray-900">Recent Reviews</h3>
          
          <div className="space-y-4">
            {place.reviews.slice(0, 3).map((review, index) => (
              <div key={index} className="border-l-4 border-gray-200 pl-4">
                <div className="flex items-center justify-between mb-2">
                  <div className="flex items-center space-x-2">
                    <span className="font-medium text-gray-900">
                      {review.authorName}
                    </span>
                    <div className="flex items-center">
                      <span className="text-yellow-500">‚≠ê</span>
                      <span className="ml-1 text-sm">{review.rating}/5</span>
                    </div>
                  </div>
                  <span className="text-sm text-gray-500">
                    {review.relativeTimeDescription}
                  </span>
                </div>
                
                <p className="text-gray-700 text-sm leading-relaxed">
                  {review.text.length > 200 
                    ? `${review.text.substring(0, 200)}...` 
                    : review.text
                  }
                </p>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
}
```

### TESTING REQUIREMENTS

#### Unit Tests
- Google Places API client methods
- Places data caching and expiration logic
- Search query processing and filtering
- Rate limiting and quota management
- Photo URL generation and optimization

#### Integration Tests
- Complete Google Places API integration
- Place details retrieval and caching
- Nearby search with location parameters
- Photo API integration and display
- Error handling for API failures and rate limits

#### E2E Tests
- Places autocomplete user experience
- Place selection and detail viewing
- Wedding venue addition workflow
- Location-based vendor search
- Photo gallery and detail pages

### DEPENDENCIES & EFFORT ESTIMATE

#### Dependencies
- **Google Places API Key** - Valid API key with billing account
- **Location Services** - User geolocation for nearby searches
- **Image Processing** - Photo display and optimization
- **Wedding Management System** - Integration with venues and vendors

#### Effort Estimate: 16 development days
- **Google Places API Integration**: 4 days
- **Autocomplete & Search Components**: 3 days  
- **Place Details & Photos**: 3 days
- **Wedding Places Integration**: 3 days
- **Caching & Rate Limiting**: 2 days
- **Testing & Optimization**: 1 day

#### Risk Factors
- **Medium:** Google Places API rate limits and quota costs
- **Medium:** Location accuracy and search relevance
- **Low:** Photo loading performance and attribution
- **Low:** Address formatting and international support

### SUCCESS CRITERIA
1. Places autocomplete responds within 500ms for typical searches
2. Search results are relevant and accurately ranked
3. Place details include all essential business information
4. Photos load efficiently with proper attribution
5. Location-based searches return appropriate nearby results
6. API usage stays within daily quota limits
7. Wedding venue integration works seamlessly
8. International addresses and places are supported correctly