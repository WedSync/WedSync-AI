# TECHNICAL SPECIFICATION: WS-011 - Quick Actions
## Generated by Feature Development Session - 2025-08-21

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding photographer working efficiently throughout my day
**I want to:** Access frequently used actions with one click from anywhere in the platform
**So that:** I can complete common tasks in under 3 seconds instead of navigating through multiple pages

**Real Wedding Scenario:**
A photographer needs to: 1) Add new inquiry "Emma & David" during venue visit, 2) Send timeline update to Saturday's couple, 3) Create dietary form for next week's wedding. Currently requires 4+ clicks per task: Menu → Section → Page → Action = 12+ clicks total, taking 2+ minutes. With quick actions, they use floating "+" button or Cmd+N shortcut for instant access: "Add Client" modal opens immediately, "Send Message" loads with client pre-selected, "Create Form" starts with template picker - completing all 3 tasks in 30 seconds vs 3+ minutes, maintaining workflow momentum during busy periods.

### SPECIFICATION SOURCE
- **Feature ID:** WS-011
- **Original Spec:** /CORE-SPECIFICATIONS/02-WEDSYNC-SUPPLIER-PLATFORM/02-Dashboard/05-quick-actions md.md
- **Current Implementation:** 0% complete
- **Files to Modify:**
  - /src/components/dashboard/DashboardLayout.tsx (add quick actions bar)
- **New Files to Create:**
  - /src/components/actions/QuickActionsBar.tsx
  - /src/components/actions/QuickActionButton.tsx
  - /src/components/actions/ActionModal.tsx
  - /src/components/actions/ContextualActions.tsx
  - /src/lib/actions/actionRegistry.ts
  - /src/lib/stores/actionStore.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Quick action usage analytics
CREATE TABLE IF NOT EXISTS quick_action_usage (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  action_type TEXT NOT NULL,
  action_context TEXT, -- current page/section when action was triggered
  trigger_method TEXT CHECK (trigger_method IN ('click', 'keyboard', 'voice', 'gesture')) DEFAULT 'click',
  execution_time_ms INTEGER NOT NULL,
  success BOOLEAN DEFAULT true,
  error_message TEXT,
  session_id TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT NOW(),
  
  INDEX(user_id, action_type),
  INDEX(created_at),
  INDEX(session_id)
);

-- User action preferences and customization
CREATE TABLE IF NOT EXISTS action_preferences (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  favorite_actions TEXT[] DEFAULT ARRAY['new_client', 'create_form', 'send_message'],
  hidden_actions TEXT[] DEFAULT ARRAY[]::TEXT[],
  custom_shortcuts JSONB DEFAULT '{}', -- keyboard shortcuts
  action_order TEXT[] DEFAULT ARRAY[]::TEXT[],
  mobile_actions TEXT[] DEFAULT ARRAY['new_client', 'send_message', 'import_clients'],
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  
  UNIQUE(user_id)
);

-- Action suggestions based on user patterns
CREATE TABLE IF NOT EXISTS action_suggestions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  suggested_action TEXT NOT NULL,
  context_pattern JSONB NOT NULL, -- When/where to suggest
  confidence_score DECIMAL(3,2) NOT NULL, -- 0.00-1.00
  suggestion_reason TEXT,
  times_suggested INTEGER DEFAULT 0,
  times_accepted INTEGER DEFAULT 0,
  last_suggested_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW()
);
```

#### API Endpoints Required
```typescript
// GET /api/actions/available
interface GetAvailableActionsResponse {
  success: boolean;
  data: {
    actions: Array<{
      id: string;
      label: string;
      description: string;
      icon: string;
      category: 'client' | 'form' | 'communication' | 'journey' | 'import' | 'custom';
      shortcut?: string;
      tier: 'starter' | 'professional' | 'enterprise' | 'all';
      enabled: boolean;
      contextual: boolean; // Shows in specific contexts
      mobile: boolean; // Available on mobile
    }>;
    favorites: string[];
    recentlyUsed: Array<{
      actionId: string;
      lastUsed: string;
      frequency: number;
    }>;
    suggestions: Array<{
      actionId: string;
      reason: string;
      confidence: number;
    }>;
  };
}

// POST /api/actions/execute
interface ExecuteActionRequest {
  actionId: string;
  context?: {
    currentPage: string;
    clientId?: string;
    formId?: string;
    selectedItems?: string[];
  };
  parameters?: Record<string, any>;
  triggerMethod?: 'click' | 'keyboard' | 'voice' | 'gesture';
}

interface ExecuteActionResponse {
  success: boolean;
  data: {
    actionType: 'navigation' | 'modal' | 'inline' | 'background';
    result?: {
      url?: string; // For navigation
      modalComponent?: string; // For modal actions
      message?: string; // For background actions
      data?: any; // Action-specific data
    };
    executionTime: number; // milliseconds
  };
}

// PATCH /api/actions/preferences
interface UpdateActionPreferencesRequest {
  favoriteActions?: string[];
  hiddenActions?: string[];
  customShortcuts?: Record<string, string>;
  actionOrder?: string[];
  mobileActions?: string[];
}

// POST /api/actions/suggestion-feedback
interface ActionSuggestionFeedbackRequest {
  suggestionId: string;
  action: 'accepted' | 'dismissed' | 'not_now';
  context?: Record<string, any>;
}
```

#### Frontend Components Required
```typescript
// Component: QuickActionsBar
// Location: /src/components/actions/QuickActionsBar.tsx

interface QuickActionsBarProps {
  actions: QuickAction[];
  onActionClick: (action: QuickAction) => void;
  position: 'top' | 'floating' | 'sidebar';
  context?: ActionContext;
}

// Key functionality:
- Horizontal action bar with icon buttons
- Keyboard shortcut display on hover
- Recently used actions prioritization
- Contextual actions based on current page
- Loading states during action execution
- Success/error feedback
- Mobile: Floating action button (FAB)

// Component: QuickActionButton
// Location: /src/components/actions/QuickActionButton.tsx

interface QuickActionButtonProps {
  action: QuickAction;
  onClick: (action: QuickAction) => void;
  variant: 'primary' | 'secondary' | 'icon-only';
  showLabel?: boolean;
  disabled?: boolean;
}

// Key functionality:
- Icon with optional text label
- Tooltip with description and shortcut
- Loading state during execution
- Disabled state for unavailable actions
- Accessibility: ARIA labels and keyboard support
- Visual feedback on hover/press

// Component: ContextualActions
// Location: /src/components/actions/ContextualActions.tsx

interface ContextualActionsProps {
  context: ActionContext;
  selectedItems?: string[];
  onActionSelect: (action: QuickAction) => void;
}

// Key functionality:
- Context-aware action suggestions
- Bulk operation actions when items selected
- Smart action prioritization
- AI-powered suggestions
- Quick access to relevant workflows
- Integration with current page state

// Component: ActionModal
// Location: /src/components/actions/ActionModal.tsx

interface ActionModalProps {
  action: QuickAction;
  open: boolean;
  onClose: () => void;
  onComplete: (result: any) => void;
  prefillData?: Record<string, any>;
}

// Key functionality:
- Dynamic form generation based on action
- Prefilled data from context
- Step-by-step wizards for complex actions
- Real-time validation
- Auto-save drafts
- Cancel with confirmation
```

#### Integration Points
```typescript
// Action registry and execution engine
export class QuickActionRegistry {
  private actions: Map<string, QuickAction> = new Map();
  
  constructor() {
    this.registerDefaultActions();
  }
  
  private registerDefaultActions(): void {
    // Client actions
    this.register({
      id: 'new_client',
      label: 'Add Client',
      description: 'Create a new client profile',
      icon: 'UserPlus',
      category: 'client',
      shortcut: 'cmd+shift+n',
      tier: 'all',
      execute: this.executeNewClient.bind(this)
    });
    
    this.register({
      id: 'create_form',
      label: 'Create Form',
      description: 'Build a new form',
      icon: 'FileText',
      category: 'form',
      shortcut: 'cmd+shift+f',
      tier: 'all',
      execute: this.executeCreateForm.bind(this)
    });
    
    this.register({
      id: 'send_message',
      label: 'Send Message',
      description: 'Send email or SMS to clients',
      icon: 'Send',
      category: 'communication',
      shortcut: 'cmd+shift+m',
      tier: 'all',
      execute: this.executeSendMessage.bind(this)
    });
    
    this.register({
      id: 'import_clients',
      label: 'Import Clients',
      description: 'Upload CSV or Excel file',
      icon: 'Upload',
      category: 'import',
      tier: 'all',
      execute: this.executeImportClients.bind(this)
    });
    
    this.register({
      id: 'start_journey',
      label: 'Start Journey',
      description: 'Assign clients to journey',
      icon: 'Play',
      category: 'journey',
      tier: 'professional',
      execute: this.executeStartJourney.bind(this)
    });
  }
  
  async executeNewClient(context: ActionContext): Promise<ActionResult> {
    return {
      type: 'modal',
      component: 'NewClientModal',
      props: {
        prefillData: context.selectedItems ? {} : undefined
      }
    };
  }
  
  async executeCreateForm(context: ActionContext): Promise<ActionResult> {
    // Smart form suggestions based on context
    const suggestions = await this.getFormSuggestions(context);
    
    return {
      type: 'navigation',
      url: '/forms/create',
      state: { suggestions, context }
    };
  }
  
  async executeSendMessage(context: ActionContext): Promise<ActionResult> {
    if (context.clientId) {
      return {
        type: 'modal',
        component: 'SendMessageModal',
        props: {
          preselectedClient: context.clientId
        }
      };
    }
    
    return {
      type: 'modal',
      component: 'ClientSelectionModal',
      props: {
        nextAction: 'send_message'
      }
    };
  }
  
  private async getFormSuggestions(context: ActionContext): Promise<FormSuggestion[]> {
    // AI-powered form suggestions based on context
    if (context.clientId) {
      const client = await this.getClientData(context.clientId);
      const daysUntilWedding = this.calculateDaysUntilWedding(client.weddingDate);
      
      if (daysUntilWedding <= 30) {
        return [
          { template: 'final_details', reason: 'Wedding in 30 days' },
          { template: 'dietary_requirements', reason: 'Catering deadline approaching' }
        ];
      }
    }
    
    return [
      { template: 'client_questionnaire', reason: 'Most popular' },
      { template: 'timeline_preferences', reason: 'Frequently used' }
    ];
  }
}

// Store: actionStore
interface ActionStore {
  availableActions: QuickAction[];
  favorites: string[];
  recentlyUsed: ActionUsage[];
  executing: Record<string, boolean>;
  
  executeAction: (actionId: string, context?: ActionContext) => Promise<ActionResult>;
  trackUsage: (actionId: string, context: ActionContext, method: TriggerMethod) => void;
  updatePreferences: (preferences: Partial<ActionPreferences>) => Promise<void>;
  
  getContextualActions: (context: ActionContext) => QuickAction[];
  getSuggestedActions: (context: ActionContext) => ActionSuggestion[];
}

// Keyboard shortcuts handler
export function useQuickActionShortcuts() {
  const { executeAction } = useActionStore();
  
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.metaKey || event.ctrlKey) {
        const shortcutMap = {
          'n': 'new_client',
          'f': 'create_form',
          'm': 'send_message',
          'i': 'import_clients',
          'j': 'start_journey'
        };
        
        if (event.shiftKey && shortcutMap[event.key]) {
          event.preventDefault();
          executeAction(shortcutMap[event.key], {
            currentPage: window.location.pathname,
            triggerMethod: 'keyboard'
          });
        }
      }
    };
    
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [executeAction]);
}
```

### CODE EXAMPLES

#### Example 1: Context-Aware Action Execution
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
export class SmartActionExecutor {
  
  async executeWithContext(actionId: string, context: ActionContext): Promise<ActionResult> {
    const startTime = Date.now();
    
    try {
      // Step 1: Get action definition
      const action = this.registry.get(actionId);
      if (!action) {
        throw new Error(`Action ${actionId} not found`);
      }
      
      // Step 2: Check permissions and tier access
      const hasAccess = await this.checkActionAccess(action, context.userId);
      if (!hasAccess) {
        throw new Error(`Action ${actionId} not available for current tier`);
      }
      
      // Step 3: Gather contextual data
      const enrichedContext = await this.enrichContext(context);
      
      // Step 4: Execute action with enhanced context
      let result: ActionResult;
      
      switch (actionId) {
        case 'new_client':
          result = await this.executeNewClientWithContext(enrichedContext);
          break;
          
        case 'send_message':
          result = await this.executeSendMessageWithContext(enrichedContext);
          break;
          
        case 'create_form':
          result = await this.executeCreateFormWithContext(enrichedContext);
          break;
          
        default:
          result = await action.execute(enrichedContext);
      }
      
      // Step 5: Track successful execution
      const executionTime = Date.now() - startTime;
      await this.trackActionUsage(actionId, context, executionTime, true);
      
      return result;
      
    } catch (error) {
      // Step 6: Handle and track errors
      const executionTime = Date.now() - startTime;
      await this.trackActionUsage(actionId, context, executionTime, false, error.message);
      
      throw error;
    }
  }
  
  private async enrichContext(context: ActionContext): Promise<EnrichedActionContext> {
    const enriched: EnrichedActionContext = { ...context };
    
    // Add current client data if on client page
    if (context.clientId) {
      enriched.client = await this.getClientData(context.clientId);
    }
    
    // Add selection context
    if (context.selectedItems?.length) {
      enriched.selectedClients = await this.getMultipleClientData(context.selectedItems);
    }
    
    // Add page-specific context
    if (context.currentPage.includes('/forms/')) {
      enriched.activeForm = await this.getCurrentFormData(context.currentPage);
    }
    
    // Add user preferences
    enriched.userPreferences = await this.getUserPreferences(context.userId);
    
    return enriched;
  }
  
  private async executeNewClientWithContext(context: EnrichedActionContext): Promise<ActionResult> {
    const prefillData: Partial<ClientProfile> = {};
    
    // Smart prefilling based on context
    if (context.currentPage.includes('/import')) {
      // User was on import page, suggest they might want to import instead
      return {
        type: 'choice',
        title: 'Add Client',
        message: 'Would you like to add a single client or import multiple clients?',
        choices: [
          { label: 'Add Single Client', action: 'new_client_manual' },
          { label: 'Import Multiple', action: 'import_clients' }
        ]
      };
    }
    
    // Prefill based on recent patterns
    if (context.userPreferences?.defaultVenueType) {
      prefillData.venueType = context.userPreferences.defaultVenueType;
    }
    
    // Suggest similar clients if on client detail page
    if (context.client) {
      prefillData.packageTier = context.client.packageDetails?.tier;
      prefillData.referralSource = 'existing_client';
    }
    
    return {
      type: 'modal',
      component: 'NewClientModal',
      props: {
        prefillData,
        suggestions: await this.getClientSuggestions(context)
      }
    };
  }
  
  private async executeSendMessageWithContext(context: EnrichedActionContext): Promise<ActionResult> {
    // Smart message context detection
    if (context.selectedClients?.length > 1) {
      return {
        type: 'modal',
        component: 'BulkMessageModal',
        props: {
          preselectedClients: context.selectedClients,
          suggestedTemplates: await this.getSuggestedTemplates(context.selectedClients)
        }
      };
    }
    
    if (context.client) {
      const suggestedContent = await this.generateMessageSuggestions(context.client);
      
      return {
        type: 'modal',
        component: 'SendMessageModal',
        props: {
          preselectedClient: context.client,
          suggestedSubject: suggestedContent.subject,
          suggestedContent: suggestedContent.content
        }
      };
    }
    
    return {
      type: 'modal',
      component: 'ClientSelectionModal',
      props: {
        nextAction: 'send_message',
        recentClients: await this.getRecentlyActiveClients(context.userId)
      }
    };
  }
  
  private async trackActionUsage(
    actionId: string, 
    context: ActionContext, 
    executionTime: number, 
    success: boolean, 
    errorMessage?: string
  ): Promise<void> {
    await supabase
      .from('quick_action_usage')
      .insert({
        user_id: context.userId,
        action_type: actionId,
        action_context: context.currentPage,
        trigger_method: context.triggerMethod || 'click',
        execution_time_ms: executionTime,
        success,
        error_message: errorMessage,
        session_id: context.sessionId
      });
  }
}
```

#### Example 2: AI-Powered Action Suggestions
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
export class ActionSuggestionEngine {
  
  async generateSuggestions(context: ActionContext): Promise<ActionSuggestion[]> {
    const suggestions: ActionSuggestion[] = [];
    
    // Step 1: Time-based suggestions
    const timeBasedSuggestions = this.getTimeBasedSuggestions(context);
    suggestions.push(...timeBasedSuggestions);
    
    // Step 2: Context-based suggestions
    const contextSuggestions = await this.getContextBasedSuggestions(context);
    suggestions.push(...contextSuggestions);
    
    // Step 3: Pattern-based suggestions
    const patternSuggestions = await this.getPatternBasedSuggestions(context);
    suggestions.push(...patternSuggestions);
    
    // Step 4: Sort by confidence and return top 3
    return suggestions
      .sort((a, b) => b.confidence - a.confidence)
      .slice(0, 3);
  }
  
  private getTimeBasedSuggestions(context: ActionContext): ActionSuggestion[] {
    const now = new Date();
    const hour = now.getHours();
    const dayOfWeek = now.getDay();
    
    const suggestions: ActionSuggestion[] = [];
    
    // Morning suggestions (9-11 AM)
    if (hour >= 9 && hour <= 11) {
      suggestions.push({
        actionId: 'import_clients',
        reason: 'Good time to import new leads from overnight inquiries',
        confidence: 0.7,
        contextPattern: { timeOfDay: 'morning', dayType: 'weekday' }
      });
    }
    
    // Afternoon suggestions (1-4 PM)
    if (hour >= 13 && hour <= 16) {
      suggestions.push({
        actionId: 'send_message',
        reason: 'Peak client response time for follow-ups',
        confidence: 0.8,
        contextPattern: { timeOfDay: 'afternoon' }
      });
    }
    
    // Monday suggestions
    if (dayOfWeek === 1) {
      suggestions.push({
        actionId: 'create_form',
        reason: 'Start the week by creating forms for upcoming weddings',
        confidence: 0.6,
        contextPattern: { dayOfWeek: 'monday' }
      });
    }
    
    return suggestions;
  }
  
  private async getContextBasedSuggestions(context: ActionContext): Promise<ActionSuggestion[]> {
    const suggestions: ActionSuggestion[] = [];
    
    // Client page context
    if (context.clientId) {
      const client = await this.getClientData(context.clientId);
      const daysUntilWedding = this.calculateDaysUntilWedding(client.weddingDate);
      
      // Suggest creating forms for clients close to wedding
      if (daysUntilWedding <= 60 && daysUntilWedding > 7) {
        suggestions.push({
          actionId: 'create_form',
          reason: `${client.coupleNames} wedding is in ${daysUntilWedding} days - time for detailed forms`,
          confidence: 0.9,
          contextPattern: { 
            hasClient: true, 
            daysUntilWedding,
            weddingPhase: 'final_planning'
          }
        });
      }
      
      // Suggest sending messages to clients who haven't been contacted recently
      const daysSinceLastContact = await this.getDaysSinceLastContact(context.clientId);
      if (daysSinceLastContact > 14) {
        suggestions.push({
          actionId: 'send_message',
          reason: `No contact with ${client.coupleNames} for ${daysSinceLastContact} days`,
          confidence: 0.8,
          contextPattern: {
            hasClient: true,
            daysSinceContact: daysSinceLastContact
          }
        });
      }
    }
    
    // Dashboard context
    if (context.currentPage === '/dashboard') {
      const pendingTasks = await this.getPendingTaskCount(context.userId);
      if (pendingTasks > 5) {
        suggestions.push({
          actionId: 'send_message',
          reason: `${pendingTasks} pending tasks - send reminders to move things forward`,
          confidence: 0.7,
          contextPattern: {
            location: 'dashboard',
            pendingTasks
          }
        });
      }
    }
    
    return suggestions;
  }
  
  private async getPatternBasedSuggestions(context: ActionContext): Promise<ActionSuggestion[]> {
    // Analyze user's historical patterns
    const { data: usageHistory } = await supabase
      .from('quick_action_usage')
      .select('action_type, action_context, created_at')
      .eq('user_id', context.userId)
      .gte('created_at', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()) // Last 30 days
      .order('created_at', { ascending: false });
      
    if (!usageHistory?.length) return [];
    
    // Find patterns in user behavior
    const patterns = this.analyzeUsagePatterns(usageHistory);
    const suggestions: ActionSuggestion[] = [];
    
    // Suggest actions based on successful patterns
    for (const pattern of patterns) {
      if (pattern.confidence > 0.6 && this.matchesCurrentContext(pattern, context)) {
        suggestions.push({
          actionId: pattern.suggestedAction,
          reason: `You often ${pattern.suggestedAction.replace('_', ' ')} in this context`,
          confidence: pattern.confidence,
          contextPattern: pattern.contextPattern
        });
      }
    }
    
    return suggestions;
  }
  
  private analyzeUsagePatterns(usageHistory: ActionUsage[]): UsagePattern[] {
    // Group actions by context and time
    const contextGroups = this.groupBy(usageHistory, 'action_context');
    const patterns: UsagePattern[] = [];
    
    for (const [context, actions] of Object.entries(contextGroups)) {
      const actionCounts = this.countBy(actions, 'action_type');
      const totalActions = actions.length;
      
      for (const [actionType, count] of Object.entries(actionCounts)) {
        const frequency = count / totalActions;
        
        if (frequency > 0.3) { // Action represents 30%+ of usage in this context
          patterns.push({
            contextPattern: { location: context },
            suggestedAction: actionType,
            confidence: Math.min(0.9, frequency), // Cap at 90% confidence
            frequency: count,
            lastUsed: Math.max(...actions.filter(a => a.action_type === actionType)
              .map(a => new Date(a.created_at).getTime()))
          });
        }
      }
    }
    
    return patterns.sort((a, b) => b.confidence - a.confidence);
  }
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for keyboard shortcuts and action patterns
- [ ] Playwright: Test quick action execution and shortcuts
- [x] Filesystem: Access action component directories

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/hotkeys-js/hotkeys", "keyboard shortcuts", 2000);
await mcp__context7__get-library-docs("/radix-ui/primitives", "modal dialogs", 2000);
await mcp__context7__get-library-docs("/framer/motion", "action animations", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('Quick Actions', () => {
  it('should execute actions with correct context', async () => {
    const executor = new SmartActionExecutor();
    const context = {
      userId: 'user1',
      currentPage: '/clients/123',
      clientId: '123'
    };
    
    const result = await executor.executeWithContext('send_message', context);
    
    expect(result.type).toBe('modal');
    expect(result.props.preselectedClient).toBe('123');
  });
  
  it('should generate relevant action suggestions', async () => {
    const suggestionEngine = new ActionSuggestionEngine();
    const context = {
      userId: 'user1',
      currentPage: '/dashboard',
      clientId: '123'
    };
    
    const suggestions = await suggestionEngine.generateSuggestions(context);
    
    expect(suggestions.length).toBeLessThanOrEqual(3);
    expect(suggestions[0].confidence).toBeGreaterThan(0.5);
  });
  
  it('should track action usage correctly', async () => {
    const trackSpy = jest.spyOn(supabase.from('quick_action_usage'), 'insert');
    
    await executor.trackActionUsage('new_client', context, 150, true);
    
    expect(trackSpy).toHaveBeenCalledWith({
      user_id: 'user1',
      action_type: 'new_client',
      execution_time_ms: 150,
      success: true
    });
  });
});

describe('Keyboard Shortcuts', () => {
  it('should trigger actions via keyboard shortcuts', () => {
    const { result } = renderHook(() => useQuickActionShortcuts());
    const executeSpy = jest.spyOn(useActionStore.getState(), 'executeAction');
    
    fireEvent.keyDown(window, { 
      key: 'n', 
      metaKey: true, 
      shiftKey: true 
    });
    
    expect(executeSpy).toHaveBeenCalledWith('new_client', expect.any(Object));
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Quick actions execute correctly', async () => {
  await mcp__playwright__browser_navigate({url: '/dashboard'});
  
  // Test new client action
  await mcp__playwright__browser_click({
    element: 'Add client button',
    ref: '[data-testid="quick-action-new-client"]'
  });
  
  await mcp__playwright__browser_wait_for({text: 'New Client'});
  
  // Fill and submit
  await mcp__playwright__browser_type({
    element: 'Couple names',
    ref: '[name="coupleNames"]',
    text: 'John & Jane Smith'
  });
  
  await mcp__playwright__browser_click({
    element: 'Save client',
    ref: '[data-testid="save-client"]'
  });
  
  await mcp__playwright__browser_wait_for({text: 'Client created successfully'});
});

test('Keyboard shortcuts work correctly', async () => {
  await mcp__playwright__browser_navigate({url: '/dashboard'});
  
  // Test new client shortcut
  await mcp__playwright__browser_press_key({key: 'Meta+Shift+n'});
  await mcp__playwright__browser_wait_for({text: 'New Client'});
  
  // Close and test create form shortcut
  await mcp__playwright__browser_press_key({key: 'Escape'});
  await mcp__playwright__browser_press_key({key: 'Meta+Shift+f'});
  await mcp__playwright__browser_wait_for({url: '/forms/create'});
  
  // Test send message shortcut
  await mcp__playwright__browser_press_key({key: 'Meta+Shift+m'});
  await mcp__playwright__browser_wait_for({text: 'Send Message'});
});

test('Contextual actions appear correctly', async () => {
  await mcp__playwright__browser_navigate({url: '/clients/123'});
  
  // Verify contextual actions for client page
  await mcp__playwright__browser_wait_for({text: 'Send Message'});
  await mcp__playwright__browser_wait_for({text: 'Create Form'});
  
  // Test contextual send message
  await mcp__playwright__browser_click({
    element: 'Send message button',
    ref: '[data-testid="contextual-send-message"]'
  });
  
  // Verify client is preselected
  await mcp__playwright__browser_wait_for({text: 'John & Jane Smith'});
});

test('Mobile quick actions work', async () => {
  await mcp__playwright__browser_resize({width: 375, height: 667});
  await mcp__playwright__browser_navigate({url: '/dashboard'});
  
  // Test floating action button
  await mcp__playwright__browser_click({
    element: 'Floating action button',
    ref: '[data-testid="fab"]'
  });
  
  // Verify action menu appears
  await mcp__playwright__browser_wait_for({text: 'Add Client'});
  await mcp__playwright__browser_wait_for({text: 'Send Message'});
  
  // Test action execution
  await mcp__playwright__browser_click({
    element: 'Add Client',
    ref: '[data-testid="fab-new-client"]'
  });
  
  await mcp__playwright__browser_wait_for({text: 'New Client'});
});
```

### ACCEPTANCE CRITERIA
- [ ] All quick actions execute in under 3 seconds
- [ ] Keyboard shortcuts work consistently (Cmd+Shift+N, F, M, I, J)
- [ ] Contextual actions appear based on current page
- [ ] Mobile floating action button provides core actions
- [ ] Action suggestions adapt to user patterns
- [ ] Failed actions show clear error messages
- [ ] Success feedback confirms action completion
- [ ] Actions respect tier-based feature access
- [ ] Recently used actions appear first
- [ ] Custom shortcuts can be configured
- [ ] Bulk actions work with selected items
- [ ] Loading states prevent double-execution

### DEPENDENCIES
- Must complete after: WS-007 (Dashboard Layout), WS-008 (Navigation)
- Must complete before: None (enhances all features)
- Shares code with: All features (provides quick access)

### ESTIMATED EFFORT
- Team A Frontend: 18 hours
- Team B Backend: 10 hours
- Team C Integration: 4 hours
- Total: 32 hours