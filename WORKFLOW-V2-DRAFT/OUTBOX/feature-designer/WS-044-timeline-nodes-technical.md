# TECHNICAL SPECIFICATION: WS-044 - Timeline Nodes
## Generated by Feature Development Session - 2025-08-21

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding photographer who needs to send specific emails at exact times relative to the wedding date
**I want to:** Create timeline anchor points that automatically calculate when to send "2 weeks before", "1 day after", etc.
**So that:** Every couple gets timeline confirmations, photo delivery reminders, and follow-up requests at the perfect moment without manual tracking

**Real Wedding Scenario:**
A photographer sets up timeline nodes: "Send venue details request 8 weeks before wedding", "Timeline confirmation reminder 3 weeks before", "Sneak peek delivery 2 days after", "Full gallery delivery 3 weeks after". For a June 15th wedding, the system automatically schedules these for April 20th, May 25th, June 17th, and July 6th respectively.

### SPECIFICATION SOURCE
- **Feature ID:** WS-044
- **Original Spec:** /CORE-SPECIFICATIONS/02-WEDSYNC-SUPPLIER-PLATFORM/05-Customer-Journey/02-timeline-nodes md.md
- **Current Implementation:** 0% complete
- **Files to Modify:**
  - `/src/components/journey/canvas/TimelineNode.tsx` (new)
- **New Files to Create:**
  - `/src/components/journey/nodes/EmailTimelineNode.tsx`
  - `/src/components/journey/nodes/FormTimelineNode.tsx`
  - `/src/components/journey/nodes/ReminderTimelineNode.tsx`
  - `/src/lib/journey/timelineCalculator.ts`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Timeline node configurations
CREATE TABLE IF NOT EXISTS timeline_node_configs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  node_id UUID REFERENCES journey_nodes(id) ON DELETE CASCADE,
  anchor_type TEXT CHECK (anchor_type IN ('booking_date', 'wedding_date', 'fixed_date', 'relative_date')) NOT NULL,
  offset_value INTEGER NOT NULL, -- Can be negative for "before"
  offset_unit TEXT CHECK (offset_unit IN ('minutes', 'hours', 'days', 'weeks', 'months')) NOT NULL,
  business_hours_only BOOLEAN DEFAULT false,
  skip_weekends BOOLEAN DEFAULT false,
  timezone TEXT DEFAULT 'UTC',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Timeline execution tracking
CREATE TABLE IF NOT EXISTS timeline_executions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  node_id UUID REFERENCES journey_nodes(id) ON DELETE CASCADE,
  client_id UUID REFERENCES clients(id) ON DELETE CASCADE,
  calculated_date TIMESTAMPTZ NOT NULL,
  executed_at TIMESTAMPTZ,
  status TEXT CHECK (status IN ('scheduled', 'executed', 'failed', 'skipped')) DEFAULT 'scheduled',
  result JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_timeline_node_configs_node_id ON timeline_node_configs(node_id);
CREATE INDEX IF NOT EXISTS idx_timeline_executions_calculated_date ON timeline_executions(calculated_date);
CREATE INDEX IF NOT EXISTS idx_timeline_executions_status ON timeline_executions(status);
```

#### API Endpoints Required
```typescript
// POST /api/journey-nodes/timeline/calculate
interface CalculateTimelineRequest {
  anchor_type: string;
  offset_value: number;
  offset_unit: string;
  wedding_date: string;
  booking_date?: string;
  fixed_date?: string;
  business_hours_only: boolean;
  skip_weekends: boolean;
  timezone: string;
}

interface CalculateTimelineResponse {
  calculated_date: string;
  business_day_adjusted: boolean;
  timezone_offset: number;
}

// GET /api/clients/[id]/timeline-preview
interface TimelinePreviewResponse {
  timeline_items: Array<{
    node_id: string;
    node_name: string;
    calculated_date: string;
    action_type: string;
    status: string;
  }>;
}
```

#### Frontend Components Required
```typescript
// Component: TimelineNode
interface TimelineNodeProps {
  node: JourneyNode;
  config: TimelineNodeConfig;
  onConfigChange: (config: TimelineNodeConfig) => void;
  previewDate?: Date;
}

// Key functionality:
- Visual timeline representation with anchor point
- Offset configuration (before/after, value, unit)
- Date preview calculation
- Business hours/weekend handling
- Validation feedback

// Component: EmailTimelineNode
interface EmailTimelineNodeProps extends TimelineNodeProps {
  emailConfig: {
    template_id?: string;
    subject: string;
    content: string;
  };
}

// Key functionality:
- Email template selection
- Subject line with merge tags
- Content editor with personalization
- Send time preview
- Delivery confirmation tracking

// Component: FormTimelineNode
interface FormTimelineNodeProps extends TimelineNodeProps {
  formConfig: {
    form_id: string;
    message?: string;
    reminder_after_days?: number;
  };
}

// Key functionality:
- Form selection dropdown
- Custom message addition
- Reminder configuration
- Completion tracking
```

#### Integration Points
```typescript
// Service: TimelineCalculator
// Dependencies: date-fns, timezone libraries

class TimelineCalculator {
  static calculateExecutionDate(config: TimelineNodeConfig, dates: ClientDates): Date {
    const { anchor_type, offset_value, offset_unit, business_hours_only, skip_weekends, timezone } = config;
    const { wedding_date, booking_date, fixed_date } = dates;
    
    let anchor: Date;
    switch (anchor_type) {
      case 'wedding_date':
        anchor = new Date(wedding_date);
        break;
      case 'booking_date':
        anchor = new Date(booking_date || wedding_date);
        break;
      case 'fixed_date':
        anchor = new Date(fixed_date || new Date());
        break;
      default:
        throw new Error(`Invalid anchor type: ${anchor_type}`);
    }
    
    // Apply offset
    let targetDate = this.applyOffset(anchor, offset_value, offset_unit);
    
    // Apply business constraints
    if (skip_weekends) {
      targetDate = this.adjustForWeekends(targetDate);
    }
    
    if (business_hours_only) {
      targetDate = this.adjustForBusinessHours(targetDate);
    }
    
    // Apply timezone
    return this.adjustForTimezone(targetDate, timezone);
  }
  
  private static applyOffset(date: Date, value: number, unit: string): Date {
    switch (unit) {
      case 'minutes':
        return addMinutes(date, value);
      case 'hours':
        return addHours(date, value);
      case 'days':
        return addDays(date, value);
      case 'weeks':
        return addWeeks(date, value);
      case 'months':
        return addMonths(date, value);
      default:
        throw new Error(`Invalid offset unit: ${unit}`);
    }
  }
  
  private static adjustForWeekends(date: Date): Date {
    if (isWeekend(date)) {
      // Move to next Monday
      return nextMonday(date);
    }
    return date;
  }
  
  private static adjustForBusinessHours(date: Date): Date {
    const hour = date.getHours();
    if (hour < 9) {
      // Move to 9 AM
      date.setHours(9, 0, 0, 0);
    } else if (hour >= 17) {
      // Move to 9 AM next business day
      const nextDay = addDays(date, 1);
      nextDay.setHours(9, 0, 0, 0);
      return this.adjustForWeekends(nextDay);
    }
    return date;
  }
  
  static validateTimelineConfig(config: TimelineNodeConfig): ValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];
    
    if (!config.anchor_type) {
      errors.push('Anchor type is required');
    }
    
    if (config.offset_value === undefined || config.offset_value === null) {
      errors.push('Offset value is required');
    }
    
    if (!config.offset_unit) {
      errors.push('Offset unit is required');
    }
    
    // Warning for extreme offsets
    if (Math.abs(config.offset_value) > 365 && config.offset_unit === 'days') {
      warnings.push('Offset of more than 365 days may be excessive');
    }
    
    if (config.offset_value > 0 && config.anchor_type === 'wedding_date' && 
        ['days', 'weeks', 'months'].includes(config.offset_unit)) {
      warnings.push('Positive offset from wedding date schedules action AFTER the wedding');
    }
    
    return {
      isValid: errors.length === 0,
      errors,
      warnings
    };
  }
}
```

### CODE EXAMPLES

#### Example 1: Timeline Node Configuration
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { useState, useEffect } from 'react';
import { Calendar, Clock, AlertTriangle } from 'lucide-react';

interface TimelineNodeConfigProps {
  config: TimelineNodeConfig;
  onChange: (config: TimelineNodeConfig) => void;
  previewDates: {
    wedding_date: string;
    booking_date?: string;
  };
}

export function TimelineNodeConfig({ config, onChange, previewDates }: TimelineNodeConfigProps) {
  const [previewDate, setPreviewDate] = useState<Date | null>(null);
  const [validation, setValidation] = useState<ValidationResult>({ isValid: true, errors: [], warnings: [] });
  
  useEffect(() => {
    // Calculate preview date
    try {
      const calculated = TimelineCalculator.calculateExecutionDate(config, previewDates);
      setPreviewDate(calculated);
    } catch (error) {
      setPreviewDate(null);
    }
    
    // Validate configuration
    const validationResult = TimelineCalculator.validateTimelineConfig(config);
    setValidation(validationResult);
  }, [config, previewDates]);
  
  const handleConfigChange = (field: string, value: any) => {
    const newConfig = { ...config, [field]: value };
    onChange(newConfig);
  };
  
  return (
    <div className="space-y-4 p-4 border border-gray-200 rounded-lg">
      <div className="flex items-center gap-2">
        <Clock className="w-4 h-4 text-blue-500" />
        <h3 className="font-medium">Timeline Configuration</h3>
      </div>
      
      {/* Anchor Type Selection */}
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-2">
          Anchor Point
        </label>
        <select
          value={config.anchor_type}
          onChange={(e) => handleConfigChange('anchor_type', e.target.value)}
          className="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500"
        >
          <option value="">Select anchor point...</option>
          <option value="wedding_date">Wedding Date</option>
          <option value="booking_date">Booking Date</option>
          <option value="fixed_date">Fixed Date</option>
        </select>
      </div>
      
      {/* Offset Configuration */}
      <div className="grid grid-cols-3 gap-2">
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Value
          </label>
          <input
            type="number"
            value={config.offset_value || ''}
            onChange={(e) => handleConfigChange('offset_value', parseInt(e.target.value) || 0)}
            placeholder="0"
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500"
          />
        </div>
        
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Unit
          </label>
          <select
            value={config.offset_unit}
            onChange={(e) => handleConfigChange('offset_unit', e.target.value)}
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500"
          >
            <option value="">Unit...</option>
            <option value="days">Days</option>
            <option value="weeks">Weeks</option>
            <option value="months">Months</option>
          </select>
        </div>
        
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Direction
          </label>
          <select
            value={config.offset_value >= 0 ? 'after' : 'before'}
            onChange={(e) => {
              const direction = e.target.value;
              const value = Math.abs(config.offset_value || 0);
              handleConfigChange('offset_value', direction === 'before' ? -value : value);
            }}
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500"
          >
            <option value="before">Before</option>
            <option value="after">After</option>
          </select>
        </div>
      </div>
      
      {/* Business Constraints */}
      <div className="space-y-2">
        <label className="flex items-center gap-2">
          <input
            type="checkbox"
            checked={config.skip_weekends}
            onChange={(e) => handleConfigChange('skip_weekends', e.target.checked)}
            className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
          />
          <span className="text-sm text-gray-700">Skip weekends</span>
        </label>
        
        <label className="flex items-center gap-2">
          <input
            type="checkbox"
            checked={config.business_hours_only}
            onChange={(e) => handleConfigChange('business_hours_only', e.target.checked)}
            className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
          />
          <span className="text-sm text-gray-700">Business hours only (9 AM - 5 PM)</span>
        </label>
      </div>
      
      {/* Preview */}
      {previewDate && (
        <div className="bg-blue-50 border border-blue-200 rounded-md p-3">
          <div className="flex items-center gap-2">
            <Calendar className="w-4 h-4 text-blue-600" />
            <span className="text-sm font-medium text-blue-900">Preview</span>
          </div>
          <p className="text-sm text-blue-800 mt-1">
            Will execute on: {format(previewDate, 'PPPP')} at {format(previewDate, 'p')}
          </p>
        </div>
      )}
      
      {/* Validation Messages */}
      {validation.errors.map((error, index) => (
        <div key={index} className="flex items-center gap-2 text-red-600 text-sm">
          <AlertTriangle className="w-4 h-4" />
          {error}
        </div>
      ))}
      
      {validation.warnings.map((warning, index) => (
        <div key={index} className="flex items-center gap-2 text-amber-600 text-sm">
          <AlertTriangle className="w-4 h-4" />
          {warning}
        </div>
      ))}
    </div>
  );
}
```

### ACCEPTANCE CRITERIA
- [x] Timeline nodes calculate dates accurately for all anchor types
- [x] Business hours and weekend constraints work correctly
- [x] Visual preview shows calculated execution date
- [x] Validation prevents invalid configurations
- [x] Performance: Timeline calculations complete in <100ms
- [x] Security: Timeline configurations isolated by supplier
- [x] Accessibility: Form inputs keyboard accessible, screen reader friendly

### DEPENDENCIES
- Must complete after: WS-043 (Journey Canvas)
- Must complete before: WS-045 (Conditional Branching)
- Shares code with: Date utilities, journey execution engine

### ESTIMATED EFFORT
- Team A Frontend: 16 hours
- Team B Backend: 12 hours
- Team C Integration: 6 hours
- Total: 34 hours