# TECHNICAL SPECIFICATION: WS-204 - Presence Tracking System
## Generated by Feature Development Session - 2025-08-25

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding venue coordinator working with multiple suppliers
**I want to:** See when photographers, caterers, and florists are online and actively viewing wedding details
**So that:** I can coordinate in real-time and get immediate responses, saving 3-4 hours per wedding on phone tag

**Real Wedding Scenario:**
The venue coordinator needs to confirm final setup details 2 days before the wedding. She sees the photographer is online and viewing the timeline, the florist is idle but was active 5 minutes ago, and the caterer is offline. She messages the photographer knowing they'll see it immediately, sends a quick note to the florist who will likely see it soon, and schedules an email for the caterer. Without presence tracking, she'd call all three, likely reaching voicemail and playing phone tag for hours.

### SPECIFICATION SOURCE
- **Feature ID:** WS-204
- **Original Spec:** /CORE-SPECIFICATIONS/01-TECHNICAL-ARCHITECTURE/04-Real-time-Systems/03-presence-tracking md.md
- **Current Implementation:** 0% complete
- **Files to Modify:**
  - /wedsync/src/components/providers/RealtimeProvider.tsx
  - /wedsync/src/hooks/usePresence.ts
  - /wedsync/src/components/ui/Avatar.tsx
- **New Files to Create:**
  - /wedsync/src/lib/presence/presence-manager.ts
  - /wedsync/src/lib/presence/activity-tracker.ts
  - /wedsync/src/components/presence/PresenceIndicator.tsx
  - /wedsync/src/components/presence/PresenceList.tsx
  - /wedsync/src/types/presence.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Presence data uses Supabase Realtime Presence (in-memory only)
-- But we need tables for settings and last seen tracking

CREATE TABLE IF NOT EXISTS presence_settings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE UNIQUE,
  visibility TEXT CHECK (visibility IN ('everyone', 'team', 'contacts', 'nobody')) DEFAULT 'contacts',
  show_activity BOOLEAN DEFAULT true,
  show_current_page BOOLEAN DEFAULT false,
  appear_offline BOOLEAN DEFAULT false,
  custom_status TEXT,
  custom_status_emoji TEXT,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Last seen tracking (persisted data)
CREATE TABLE IF NOT EXISTS user_last_seen (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE UNIQUE,
  last_seen_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  last_page TEXT,
  last_device TEXT,
  last_activity_type TEXT,
  session_duration_minutes INTEGER
);

-- Activity logs for enterprise analytics
CREATE TABLE IF NOT EXISTS presence_activity_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  activity_type TEXT NOT NULL,
  page_viewed TEXT,
  timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  device_type TEXT,
  session_id UUID,
  -- Only for Enterprise tier
  metadata JSONB DEFAULT '{}'::jsonb
);

-- Indexes
CREATE INDEX idx_presence_settings_user ON presence_settings(user_id);
CREATE INDEX idx_last_seen_user ON user_last_seen(user_id);
CREATE INDEX idx_activity_logs_org ON presence_activity_logs(organization_id, timestamp);
```

#### API Endpoints Required
```typescript
// POST /api/presence/track
interface TrackPresenceRequest {
  status: 'online' | 'idle' | 'away' | 'busy';
  currentPage?: string;
  isTyping?: boolean;
  device?: 'desktop' | 'mobile' | 'tablet';
}

interface TrackPresenceResponse {
  success: boolean;
  broadcastId: string;
}

// GET /api/presence/users
interface GetPresenceRequest {
  userIds?: string[];
  organizationId?: string;
  weddingId?: string;
}

interface GetPresenceResponse {
  users: {
    userId: string;
    status: 'online' | 'idle' | 'away' | 'offline' | 'busy';
    lastSeen: string;
    currentPage?: string;
    isTyping?: boolean;
    device?: string;
    customStatus?: string;
    customEmoji?: string;
  }[];
}

// PUT /api/presence/settings
interface UpdateSettingsRequest {
  visibility?: 'everyone' | 'team' | 'contacts' | 'nobody';
  showActivity?: boolean;
  showCurrentPage?: boolean;
  appearOffline?: boolean;
  customStatus?: string;
  customEmoji?: string;
}

interface UpdateSettingsResponse {
  success: boolean;
  settings: PresenceSettings;
}

// GET /api/presence/analytics
interface GetAnalyticsRequest {
  organizationId: string;
  startDate: string;
  endDate: string;
  groupBy?: 'hour' | 'day' | 'week';
}

interface GetAnalyticsResponse {
  totalSessions: number;
  averageSessionDuration: number;
  peakHours: { hour: number; count: number }[];
  mostActiveUsers: { userId: string; minutes: number }[];
  pageViews: { page: string; views: number }[];
}
```

#### Frontend Components Required
```typescript
// Component: PresenceIndicator
// Location: /src/components/presence/PresenceIndicator.tsx

interface PresenceIndicatorProps {
  userId: string;
  size?: 'sm' | 'md' | 'lg';
  showLabel?: boolean;
  showActivity?: boolean;
  position?: 'top-right' | 'bottom-right' | 'top-left' | 'bottom-left';
}

// Key functionality:
- Display colored dot based on status
- Show custom status and emoji
- Tooltip with last seen time
- Pulse animation for typing
- Respect privacy settings

// Component: PresenceList
// Location: /src/components/presence/PresenceList.tsx

interface PresenceListProps {
  context: 'wedding' | 'organization' | 'collaboration';
  contextId: string;
  showOffline?: boolean;
  groupByStatus?: boolean;
}

// Key functionality:
- List all users with presence
- Group by online/away/offline
- Real-time status updates
- Click to view user profile
- Filter by role or team

// Component: ActivityTracker
// Location: /src/components/presence/ActivityTracker.tsx

interface ActivityTrackerProps {
  trackMouse?: boolean;
  trackKeyboard?: boolean;
  trackFocus?: boolean;
  idleTimeout?: number;
}

// Key functionality:
- Monitor user activity
- Detect idle state
- Handle page visibility
- Batch presence updates
- Respect user preferences
```

#### Integration Points
```typescript
// Service: PresenceManager
// Dependencies: Supabase Presence, user settings, activity tracker

class PresenceManager {
  private presenceChannel: RealtimeChannel | null = null;
  private activityTimer: NodeJS.Timeout | null = null;
  private currentStatus: PresenceStatus = 'online';
  private lastActivity: Date = new Date();
  
  async initialize(userId: string): Promise<void> {
    // Load user settings
    // Join presence channel
    // Start activity tracking
    // Broadcast initial presence
  }
  
  async updatePresence(data: Partial<PresenceData>): Promise<void> {
    // Update local state
    // Broadcast to channel
    // Debounce rapid updates
  }
  
  async trackActivity(type: ActivityType): Promise<void> {
    // Reset idle timer
    // Update status if needed
    // Log for analytics (Enterprise)
  }
  
  async setCustomStatus(status: string, emoji?: string): Promise<void> {
    // Update settings
    // Broadcast to presence
  }
  
  async cleanup(): Promise<void> {
    // Leave presence channel
    // Clear timers
    // Update last seen
  }
}
```

### CODE EXAMPLES

#### Example 1: Presence Hook Implementation
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { useEffect, useState, useCallback, useRef } from 'react';
import { RealtimeChannel, RealtimePresenceState } from '@supabase/supabase-js';
import { supabase } from '@/lib/supabase';

export function usePresence(channelName: string, userId: string) {
  const [presenceState, setPresenceState] = useState<RealtimePresenceState>({});
  const [myStatus, setMyStatus] = useState<PresenceStatus>('online');
  const channelRef = useRef<RealtimeChannel | null>(null);
  const activityTimerRef = useRef<NodeJS.Timeout | null>(null);
  
  // Step 1: Initialize presence channel
  useEffect(() => {
    const channel = supabase.channel(channelName, {
      config: {
        presence: {
          key: userId,
        },
      },
    });
    
    // Step 2: Track presence state
    channel
      .on('presence', { event: 'sync' }, () => {
        const state = channel.presenceState();
        setPresenceState(state);
      })
      .on('presence', { event: 'join' }, ({ key, newPresences }) => {
        console.log('User joined:', key, newPresences);
      })
      .on('presence', { event: 'leave' }, ({ key, leftPresences }) => {
        console.log('User left:', key, leftPresences);
      });
    
    // Step 3: Subscribe and track self
    channel.subscribe(async (status) => {
      if (status === 'SUBSCRIBED') {
        await channel.track({
          status: 'online',
          lastActivity: new Date().toISOString(),
          device: getDeviceType(),
          userId,
        });
      }
    });
    
    channelRef.current = channel;
    
    // Step 4: Cleanup on unmount
    return () => {
      if (channelRef.current) {
        channelRef.current.untrack();
        channelRef.current.unsubscribe();
      }
    };
  }, [channelName, userId]);
  
  // Step 5: Activity tracking
  const trackActivity = useCallback(() => {
    // Reset idle timer
    if (activityTimerRef.current) {
      clearTimeout(activityTimerRef.current);
    }
    
    // Update to online if was idle/away
    if (myStatus !== 'online' && myStatus !== 'busy') {
      setMyStatus('online');
      channelRef.current?.track({ 
        status: 'online',
        lastActivity: new Date().toISOString()
      });
    }
    
    // Set idle timer (2 minutes)
    activityTimerRef.current = setTimeout(() => {
      setMyStatus('idle');
      channelRef.current?.track({ status: 'idle' });
      
      // Set away timer (10 minutes total)
      activityTimerRef.current = setTimeout(() => {
        setMyStatus('away');
        channelRef.current?.track({ status: 'away' });
      }, 8 * 60 * 1000);
    }, 2 * 60 * 1000);
  }, [myStatus]);
  
  return {
    presenceState,
    myStatus,
    trackActivity,
    setCustomStatus: (status: string) => {
      channelRef.current?.track({ customStatus: status });
    }
  };
}
```

#### Example 2: Activity Tracker Component
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { useEffect, useRef } from 'react';

export function ActivityTracker({ 
  onActivity,
  idleTimeout = 120000 // 2 minutes
}: {
  onActivity: () => void;
  idleTimeout?: number;
}) {
  const lastActivityRef = useRef<Date>(new Date());
  const idleTimerRef = useRef<NodeJS.Timeout | null>(null);
  
  useEffect(() => {
    // Step 1: Define activity handler
    const handleActivity = (e: Event) => {
      const now = new Date();
      const timeSinceLastActivity = now.getTime() - lastActivityRef.current.getTime();
      
      // Debounce - only track if 2+ seconds since last
      if (timeSinceLastActivity > 2000) {
        lastActivityRef.current = now;
        onActivity();
      }
    };
    
    // Step 2: Track various activity types
    const events = [
      'mousedown',
      'mousemove', 
      'keypress',
      'scroll',
      'touchstart',
      'click'
    ];
    
    events.forEach(event => {
      document.addEventListener(event, handleActivity);
    });
    
    // Step 3: Track page visibility
    const handleVisibilityChange = () => {
      if (document.hidden) {
        // Page hidden - user switched tabs
        console.log('User switched away');
      } else {
        // Page visible again
        onActivity();
      }
    };
    
    document.addEventListener('visibilitychange', handleVisibilityChange);
    
    // Step 4: Track window focus
    const handleFocus = () => onActivity();
    const handleBlur = () => console.log('Window lost focus');
    
    window.addEventListener('focus', handleFocus);
    window.addEventListener('blur', handleBlur);
    
    // Step 5: Cleanup
    return () => {
      events.forEach(event => {
        document.removeEventListener(event, handleActivity);
      });
      document.removeEventListener('visibilitychange', handleVisibilityChange);
      window.removeEventListener('focus', handleFocus);
      window.removeEventListener('blur', handleBlur);
    };
  }, [onActivity, idleTimeout]);
  
  return null; // Invisible component
}
```

#### Example 3: Presence Indicator with Privacy
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { usePresence } from '@/hooks/usePresence';
import { Avatar } from '@/components/ui/Avatar';

export function PresenceIndicator({ 
  userId,
  size = 'md',
  showActivity = true 
}: PresenceIndicatorProps) {
  const { presenceState } = usePresence('global', userId);
  const userPresence = presenceState[userId]?.[0];
  
  // Check privacy settings
  const [settings, setSettings] = useState<PresenceSettings | null>(null);
  
  useEffect(() => {
    // Load user's privacy settings
    supabase
      .from('presence_settings')
      .select('*')
      .eq('user_id', userId)
      .single()
      .then(({ data }) => setSettings(data));
  }, [userId]);
  
  // Respect privacy settings
  if (settings?.appear_offline || settings?.visibility === 'nobody') {
    return <div className="w-2 h-2 bg-gray-400 rounded-full" />;
  }
  
  const statusColors = {
    online: 'bg-green-500',
    idle: 'bg-yellow-500',
    away: 'bg-gray-400',
    offline: 'bg-gray-400',
    busy: 'bg-red-500'
  };
  
  const status = userPresence?.status || 'offline';
  
  return (
    <div className="relative inline-block">
      <Avatar userId={userId} size={size} />
      
      {/* Status dot */}
      <div 
        className={`
          absolute bottom-0 right-0 
          w-3 h-3 rounded-full border-2 border-white
          ${statusColors[status]}
          ${userPresence?.isTyping ? 'animate-pulse' : ''}
        `}
      />
      
      {/* Custom status */}
      {showActivity && userPresence?.customStatus && (
        <div className="absolute -bottom-5 left-0 text-xs bg-white shadow-md rounded px-1">
          {userPresence.customEmoji} {userPresence.customStatus}
        </div>
      )}
      
      {/* Tooltip with details */}
      <Tooltip>
        <div className="text-sm">
          <p className="font-semibold">{status}</p>
          {userPresence?.currentPage && settings?.show_current_page && (
            <p className="text-xs">Viewing: {userPresence.currentPage}</p>
          )}
          {userPresence?.lastActivity && (
            <p className="text-xs">
              Last active: {formatRelativeTime(userPresence.lastActivity)}
            </p>
          )}
        </div>
      </Tooltip>
    </div>
  );
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for Supabase Presence, activity tracking
- [x] Playwright: Test presence updates, privacy settings
- [x] Filesystem: Access presence components and hooks
- [x] Supabase: Configure presence channels

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/supabase/supabase", "realtime presence", 3000);
await mcp__context7__get-library-docs("/vercel/next.js", "page visibility api", 2000);
await mcp__context7__get-library-docs("/react/react", "activity tracking hooks", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('PresenceManager', () => {
  it('should update status based on activity', () => {
    const manager = new PresenceManager();
    
    // Active - should be online
    manager.trackActivity('mouse');
    expect(manager.getStatus()).toBe('online');
    
    // No activity for 2 minutes - should be idle
    jest.advanceTimersByTime(2 * 60 * 1000);
    expect(manager.getStatus()).toBe('idle');
    
    // No activity for 10 minutes - should be away
    jest.advanceTimersByTime(8 * 60 * 1000);
    expect(manager.getStatus()).toBe('away');
  });
  
  it('should respect privacy settings', () => {
    const manager = new PresenceManager({
      appearOffline: true
    });
    
    expect(manager.getBroadcastStatus()).toBe('offline');
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Presence indicators update in real-time', async () => {
  // Open two browser tabs
  const tab1 = await mcp__playwright__browser_navigate({url: '/dashboard'});
  const tab2 = await mcp__playwright__browser_tabs({action: 'new'});
  await mcp__playwright__browser_navigate({url: '/dashboard'});
  
  // User 1 goes idle
  await mcp__playwright__browser_wait_for({time: 120}); // 2 minutes
  
  // Check User 1 shows as idle in tab 2
  await mcp__playwright__browser_tabs({action: 'select', index: 1});
  await mcp__playwright__browser_snapshot();
  // Verify idle indicator
  
  // User 1 becomes active again
  await mcp__playwright__browser_tabs({action: 'select', index: 0});
  await mcp__playwright__browser_click({
    element: 'Any element',
    ref: 'body'
  });
  
  // Verify status updates to online
});
```

### ACCEPTANCE CRITERIA
- [ ] Status updates within 2 seconds of activity change
- [ ] Idle detection after 2 minutes of inactivity
- [ ] Away status after 10 minutes of inactivity
- [ ] Privacy settings respected (appear offline works)
- [ ] Typing indicators show for < 3 seconds after typing stops
- [ ] Maximum 50 presence subscriptions per user
- [ ] Performance: Presence updates use < 1% CPU
- [ ] Security: Users only see presence based on permissions
- [ ] Accessibility: Screen readers announce presence changes

### DEPENDENCIES
- Must complete after: WS-202 (Realtime), WS-203 (Channels)
- Must complete before: Collaboration features that depend on presence
- Shares code with: WS-202 (Realtime base), WS-203 (Channel subscriptions)

### ESTIMATED EFFORT
- Team A Frontend: 24 hours
- Team B Backend: 8 hours
- Team C Integration: 4 hours
- Team D Platform: 12 hours
- Team E General: 0 hours
- Team F Workflows: 0 hours
- Team G Performance: 4 hours
- Total: 52 hours