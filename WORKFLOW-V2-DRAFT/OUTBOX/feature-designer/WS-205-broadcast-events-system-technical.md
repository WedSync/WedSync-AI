# TECHNICAL SPECIFICATION: WS-205 - Broadcast Events System
## Generated by Feature Development Session - 2025-08-25

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding photographer managing 15 active weddings
**I want to:** Receive system-wide updates and wedding-specific notifications in an organized way
**So that:** I never miss critical updates like payment deadlines or wedding timeline changes, preventing disasters and saving 4+ hours weekly on checking for updates

**Real Wedding Scenario:**
A photographer needs to know immediately when: the platform has scheduled maintenance during a busy weekend, their subscription is about to expire, a couple has changed the ceremony time for tomorrow's wedding, or a new feature launches that could save them hours. Without organized broadcasts, they'd need to constantly check emails, dashboard alerts, and individual wedding pages. With this system, critical updates appear instantly while less urgent ones are batched appropriately.

### SPECIFICATION SOURCE
- **Feature ID:** WS-205
- **Original Spec:** /CORE-SPECIFICATIONS/01-TECHNICAL-ARCHITECTURE/04-Real-time-Systems/04-broadcast-events md.md
- **Current Implementation:** 0% complete
- **Files to Modify:**
  - /wedsync/src/components/providers/RealtimeProvider.tsx
  - /wedsync/src/hooks/useNotifications.ts
  - /wedsync/src/components/layout/Header.tsx
- **New Files to Create:**
  - /wedsync/src/lib/broadcast/broadcast-manager.ts
  - /wedsync/src/lib/broadcast/event-dispatcher.ts
  - /wedsync/src/lib/broadcast/priority-queue.ts
  - /wedsync/src/components/broadcast/BroadcastToast.tsx
  - /wedsync/src/components/broadcast/BroadcastCenter.tsx
  - /wedsync/src/types/broadcast.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Broadcast definitions
CREATE TABLE IF NOT EXISTS broadcasts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  type TEXT NOT NULL CHECK (type IN (
    'maintenance.scheduled', 'maintenance.started', 'maintenance.completed',
    'feature.released', 'security.alert',
    'tier.upgraded', 'tier.downgraded', 'payment.required',
    'trial.ending', 'usage.limit.approaching',
    'form.locked', 'journey.updated', 'timeline.changed',
    'supplier.joined', 'couple.connected'
  )),
  priority TEXT NOT NULL CHECK (priority IN ('critical', 'high', 'normal', 'low')),
  title TEXT NOT NULL,
  message TEXT NOT NULL,
  action_label TEXT,
  action_url TEXT,
  expires_at TIMESTAMP WITH TIME ZONE,
  targeting JSONB DEFAULT '{}'::jsonb,
  created_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  scheduled_for TIMESTAMP WITH TIME ZONE,
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'sent', 'cancelled')),
  metadata JSONB DEFAULT '{}'::jsonb
);

-- Broadcast delivery tracking
CREATE TABLE IF NOT EXISTS broadcast_deliveries (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  broadcast_id UUID REFERENCES broadcasts(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  delivered_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  read_at TIMESTAMP WITH TIME ZONE,
  acknowledged_at TIMESTAMP WITH TIME ZONE,
  delivery_channel TEXT CHECK (delivery_channel IN ('realtime', 'email', 'sms', 'push', 'in_app')),
  delivery_status TEXT DEFAULT 'pending',
  error_message TEXT,
  UNIQUE(broadcast_id, user_id, delivery_channel)
);

-- User broadcast preferences
CREATE TABLE IF NOT EXISTS broadcast_preferences (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE UNIQUE,
  system_broadcasts BOOLEAN DEFAULT true,
  business_broadcasts BOOLEAN DEFAULT true,
  collaboration_broadcasts BOOLEAN DEFAULT true,
  critical_only BOOLEAN DEFAULT false,
  delivery_channels JSONB DEFAULT '["realtime", "in_app"]'::jsonb,
  quiet_hours_start TIME,
  quiet_hours_end TIME,
  timezone TEXT DEFAULT 'UTC',
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Broadcast segments for targeting
CREATE TABLE IF NOT EXISTS broadcast_segments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL UNIQUE,
  description TEXT,
  criteria JSONB NOT NULL, -- e.g., {"tier": ["professional"], "userType": "supplier"}
  user_count INTEGER DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Analytics for broadcast effectiveness
CREATE TABLE IF NOT EXISTS broadcast_analytics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  broadcast_id UUID REFERENCES broadcasts(id) ON DELETE CASCADE,
  total_targeted INTEGER DEFAULT 0,
  total_delivered INTEGER DEFAULT 0,
  total_read INTEGER DEFAULT 0,
  total_acknowledged INTEGER DEFAULT 0,
  total_action_clicked INTEGER DEFAULT 0,
  avg_time_to_read INTERVAL,
  calculated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_broadcasts_scheduled ON broadcasts(scheduled_for) WHERE status = 'pending';
CREATE INDEX idx_broadcasts_type ON broadcasts(type);
CREATE INDEX idx_deliveries_user ON broadcast_deliveries(user_id, delivered_at DESC);
CREATE INDEX idx_deliveries_unread ON broadcast_deliveries(user_id) WHERE read_at IS NULL;
```

#### API Endpoints Required
```typescript
// POST /api/broadcast/send
interface SendBroadcastRequest {
  type: BroadcastType;
  priority: 'critical' | 'high' | 'normal' | 'low';
  title: string;
  message: string;
  action?: {
    label: string;
    url: string;
  };
  targeting?: {
    segments?: string[];
    tiers?: string[];
    userTypes?: ('supplier' | 'couple')[];
    userIds?: string[];
  };
  scheduledFor?: string;
  expiresAt?: string;
}

interface SendBroadcastResponse {
  success: boolean;
  broadcastId: string;
  targetedUsers: number;
  scheduledTime?: string;
}

// GET /api/broadcast/inbox
interface GetBroadcastInboxRequest {
  unreadOnly?: boolean;
  priority?: string[];
  limit?: number;
  offset?: number;
}

interface GetBroadcastInboxResponse {
  broadcasts: {
    id: string;
    type: string;
    priority: string;
    title: string;
    message: string;
    action?: { label: string; url: string };
    deliveredAt: string;
    readAt?: string;
    expiresAt?: string;
  }[];
  unreadCount: number;
  totalCount: number;
}

// POST /api/broadcast/acknowledge
interface AcknowledgeBroadcastRequest {
  broadcastId: string;
  action?: 'read' | 'acknowledged' | 'dismissed';
}

interface AcknowledgeBroadcastResponse {
  success: boolean;
  acknowledgedAt: string;
}

// PUT /api/broadcast/preferences
interface UpdatePreferencesRequest {
  systemBroadcasts?: boolean;
  businessBroadcasts?: boolean;
  collaborationBroadcasts?: boolean;
  criticalOnly?: boolean;
  deliveryChannels?: ('realtime' | 'email' | 'sms' | 'push' | 'in_app')[];
  quietHours?: {
    start: string; // "22:00"
    end: string;   // "08:00"
    timezone: string;
  };
}

interface UpdatePreferencesResponse {
  success: boolean;
  preferences: BroadcastPreferences;
}
```

#### Frontend Components Required
```typescript
// Component: BroadcastCenter
// Location: /src/components/broadcast/BroadcastCenter.tsx

interface BroadcastCenterProps {
  userId: string;
  position?: 'top-right' | 'bottom-right' | 'center';
  maxVisible?: number;
}

// Key functionality:
- Display broadcast notifications
- Stack multiple broadcasts
- Priority-based ordering
- Auto-dismiss based on priority
- Action buttons for CTAs
- Mark as read on view

// Component: BroadcastToast
// Location: /src/components/broadcast/BroadcastToast.tsx

interface BroadcastToastProps {
  broadcast: Broadcast;
  onDismiss: () => void;
  onAction?: () => void;
  autoHideDuration?: number;
}

// Key functionality:
- Show individual broadcast
- Color coding by priority
- Countdown timer for auto-dismiss
- Swipe to dismiss on mobile
- Click action handling

// Component: BroadcastInbox
// Location: /src/components/broadcast/BroadcastInbox.tsx

interface BroadcastInboxProps {
  showUnreadOnly?: boolean;
  groupByDate?: boolean;
  onBroadcastRead?: (id: string) => void;
}

// Key functionality:
- List all broadcasts
- Filter by priority/type
- Mark as read/unread
- Bulk actions
- Search broadcasts
```

#### Integration Points
```typescript
// Service: BroadcastManager
// Dependencies: Supabase client, notification service, analytics

class BroadcastManager {
  private queue: PriorityQueue<Broadcast>;
  private activeChannel: RealtimeChannel | null = null;
  private preferences: BroadcastPreferences | null = null;
  
  async initialize(userId: string): Promise<void> {
    // Load user preferences
    // Subscribe to broadcast channels
    // Fetch undelivered broadcasts
    // Initialize priority queue
  }
  
  async sendBroadcast(broadcast: BroadcastPayload): Promise<void> {
    // Validate broadcast
    // Determine target users
    // Queue for delivery
    // Track analytics
  }
  
  async receiveBroadcast(broadcast: Broadcast): Promise<void> {
    // Check user preferences
    // Check quiet hours
    // Add to priority queue
    // Trigger UI notification
  }
  
  async acknowledgeBroadcast(id: string, action: string): Promise<void> {
    // Update delivery record
    // Track analytics
    // Remove from queue
  }
  
  private shouldDeliver(broadcast: Broadcast): boolean {
    // Check preferences
    // Check targeting
    // Check expiry
    // Check quiet hours
  }
}
```

### CODE EXAMPLES

#### Example 1: Broadcast Priority Queue Implementation
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { supabase } from '@/lib/supabase';

class BroadcastPriorityQueue {
  private queue: Map<string, Broadcast[]> = new Map([
    ['critical', []],
    ['high', []],
    ['normal', []],
    ['low', []]
  ]);
  
  private maxQueueSize = 50;
  private displayTimeout: Map<string, NodeJS.Timeout> = new Map();
  
  // Step 1: Add broadcast to appropriate priority queue
  async enqueue(broadcast: Broadcast): Promise<void> {
    const priority = broadcast.priority || 'normal';
    const queue = this.queue.get(priority) || [];
    
    // Check if already in queue
    if (queue.find(b => b.id === broadcast.id)) {
      return;
    }
    
    // Add to queue
    queue.push(broadcast);
    
    // Trim queue if too large
    if (queue.length > this.maxQueueSize) {
      queue.shift(); // Remove oldest
    }
    
    this.queue.set(priority, queue);
    
    // Step 2: Process based on priority
    await this.processQueue();
  }
  
  // Step 3: Process queue with priority rules
  private async processQueue(): Promise<void> {
    // Critical: Show immediately, require acknowledgment
    const critical = this.queue.get('critical') || [];
    if (critical.length > 0) {
      const broadcast = critical.shift()!;
      await this.displayBroadcast(broadcast, {
        autoHide: false,
        requireAck: true,
        sound: true
      });
      return;
    }
    
    // High: Show immediately, auto-hide after 10s
    const high = this.queue.get('high') || [];
    if (high.length > 0) {
      const broadcast = high.shift()!;
      await this.displayBroadcast(broadcast, {
        autoHide: true,
        duration: 10000
      });
      return;
    }
    
    // Normal: Show with 5s auto-hide
    const normal = this.queue.get('normal') || [];
    if (normal.length > 0) {
      const broadcast = normal.shift()!;
      await this.displayBroadcast(broadcast, {
        autoHide: true,
        duration: 5000
      });
      return;
    }
    
    // Low: Batch and show in notification center only
    const low = this.queue.get('low') || [];
    if (low.length >= 3) {
      // Batch low priority
      await this.batchLowPriority(low.splice(0, 3));
    }
  }
  
  // Step 4: Display broadcast with options
  private async displayBroadcast(
    broadcast: Broadcast,
    options: DisplayOptions
  ): Promise<void> {
    // Emit to UI
    window.dispatchEvent(new CustomEvent('broadcast:show', {
      detail: { broadcast, options }
    }));
    
    // Track delivery
    await supabase
      .from('broadcast_deliveries')
      .upsert({
        broadcast_id: broadcast.id,
        user_id: broadcast.userId,
        delivered_at: new Date().toISOString(),
        delivery_channel: 'realtime'
      });
    
    // Auto-hide if configured
    if (options.autoHide) {
      const timeout = setTimeout(() => {
        this.hideBroadcast(broadcast.id);
      }, options.duration);
      
      this.displayTimeout.set(broadcast.id, timeout);
    }
  }
}
```

#### Example 2: Real-time Broadcast Subscription
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { useEffect, useState } from 'react';
import { supabase } from '@/lib/supabase';

export function useBroadcastSubscription(userId: string) {
  const [broadcasts, setBroadcasts] = useState<Broadcast[]>([]);
  const [unreadCount, setUnreadCount] = useState(0);
  
  useEffect(() => {
    // Step 1: Subscribe to global broadcasts
    const globalChannel = supabase
      .channel('broadcast:global')
      .on('broadcast', { event: '*' }, async (payload) => {
        // Check if user should receive this
        if (shouldReceiveBroadcast(payload.payload, userId)) {
          handleNewBroadcast(payload.payload);
        }
      });
    
    // Step 2: Subscribe to segment broadcasts
    const segmentChannel = supabase
      .channel(`broadcast:segment:${getUserSegment(userId)}`)
      .on('broadcast', { event: '*' }, (payload) => {
        handleNewBroadcast(payload.payload);
      });
    
    // Step 3: Subscribe to individual broadcasts
    const individualChannel = supabase
      .channel(`broadcast:user:${userId}`)
      .on('broadcast', { event: '*' }, (payload) => {
        handleNewBroadcast(payload.payload);
      });
    
    // Step 4: Handle new broadcasts
    const handleNewBroadcast = async (broadcast: Broadcast) => {
      // Check user preferences
      const { data: prefs } = await supabase
        .from('broadcast_preferences')
        .select('*')
        .eq('user_id', userId)
        .single();
      
      // Filter based on preferences
      if (shouldDisplay(broadcast, prefs)) {
        setBroadcasts(prev => [...prev, broadcast]);
        setUnreadCount(prev => prev + 1);
        
        // Show notification based on priority
        if (broadcast.priority === 'critical') {
          showCriticalNotification(broadcast);
        } else if (broadcast.priority === 'high') {
          showToast(broadcast);
        }
      }
    };
    
    // Subscribe all channels
    globalChannel.subscribe();
    segmentChannel.subscribe();
    individualChannel.subscribe();
    
    // Step 5: Fetch missed broadcasts
    fetchMissedBroadcasts();
    
    // Cleanup
    return () => {
      globalChannel.unsubscribe();
      segmentChannel.unsubscribe();
      individualChannel.unsubscribe();
    };
  }, [userId]);
  
  const fetchMissedBroadcasts = async () => {
    const { data } = await supabase
      .from('broadcast_deliveries')
      .select(`
        *,
        broadcast:broadcasts(*)
      `)
      .eq('user_id', userId)
      .is('read_at', null)
      .order('delivered_at', { ascending: false });
    
    if (data) {
      setBroadcasts(data.map(d => d.broadcast));
      setUnreadCount(data.length);
    }
  };
  
  return {
    broadcasts,
    unreadCount,
    markAsRead: async (broadcastId: string) => {
      await supabase
        .from('broadcast_deliveries')
        .update({ read_at: new Date().toISOString() })
        .eq('broadcast_id', broadcastId)
        .eq('user_id', userId);
      
      setUnreadCount(prev => Math.max(0, prev - 1));
    }
  };
}
```

#### Example 3: Broadcast Toast Component
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { X, AlertCircle, Info, CheckCircle, AlertTriangle } from 'lucide-react';

export function BroadcastToast({ 
  broadcast,
  onDismiss,
  onAction,
  autoHideDuration
}: BroadcastToastProps) {
  const [isVisible, setIsVisible] = useState(true);
  const [timeLeft, setTimeLeft] = useState(autoHideDuration || 0);
  
  // Priority-based styling
  const priorityStyles = {
    critical: {
      bg: 'bg-red-500',
      icon: AlertCircle,
      textColor: 'text-white',
      requiresAck: true
    },
    high: {
      bg: 'bg-orange-500',
      icon: AlertTriangle,
      textColor: 'text-white',
      requiresAck: false
    },
    normal: {
      bg: 'bg-blue-500',
      icon: Info,
      textColor: 'text-white',
      requiresAck: false
    },
    low: {
      bg: 'bg-gray-500',
      icon: CheckCircle,
      textColor: 'text-white',
      requiresAck: false
    }
  };
  
  const style = priorityStyles[broadcast.priority];
  const Icon = style.icon;
  
  // Auto-hide timer
  useEffect(() => {
    if (!autoHideDuration || style.requiresAck) return;
    
    const timer = setInterval(() => {
      setTimeLeft(prev => {
        if (prev <= 100) {
          setIsVisible(false);
          return 0;
        }
        return prev - 100;
      });
    }, 100);
    
    return () => clearInterval(timer);
  }, [autoHideDuration, style.requiresAck]);
  
  // Handle dismiss
  const handleDismiss = async () => {
    if (style.requiresAck) {
      // Require confirmation for critical
      if (!confirm('Are you sure you want to dismiss this critical alert?')) {
        return;
      }
    }
    
    setIsVisible(false);
    setTimeout(onDismiss, 300); // After animation
    
    // Track dismissal
    await supabase
      .from('broadcast_deliveries')
      .update({ 
        acknowledged_at: new Date().toISOString() 
      })
      .eq('broadcast_id', broadcast.id);
  };
  
  return (
    <AnimatePresence>
      {isVisible && (
        <motion.div
          initial={{ opacity: 0, x: 100 }}
          animate={{ opacity: 1, x: 0 }}
          exit={{ opacity: 0, x: 100 }}
          className={`
            relative flex items-start gap-3 p-4 rounded-lg shadow-lg
            ${style.bg} ${style.textColor}
            max-w-md min-w-[320px]
          `}
        >
          {/* Icon */}
          <Icon className="w-5 h-5 flex-shrink-0 mt-0.5" />
          
          {/* Content */}
          <div className="flex-1 min-w-0">
            <h4 className="font-semibold text-sm">
              {broadcast.title}
            </h4>
            <p className="text-sm opacity-90 mt-1">
              {broadcast.message}
            </p>
            
            {/* Action button */}
            {broadcast.action && (
              <button
                onClick={onAction}
                className="mt-2 text-xs underline hover:no-underline"
              >
                {broadcast.action.label} →
              </button>
            )}
          </div>
          
          {/* Dismiss button */}
          {!style.requiresAck && (
            <button
              onClick={handleDismiss}
              className="flex-shrink-0 hover:opacity-70"
            >
              <X className="w-4 h-4" />
            </button>
          )}
          
          {/* Progress bar for auto-hide */}
          {autoHideDuration && !style.requiresAck && (
            <div className="absolute bottom-0 left-0 right-0 h-1 bg-black/20">
              <div 
                className="h-full bg-white/50 transition-all duration-100"
                style={{ 
                  width: `${(timeLeft / autoHideDuration) * 100}%` 
                }}
              />
            </div>
          )}
          
          {/* Acknowledge button for critical */}
          {style.requiresAck && (
            <button
              onClick={handleDismiss}
              className="mt-2 px-3 py-1 bg-white text-red-500 rounded text-sm font-medium"
            >
              Acknowledge
            </button>
          )}
        </motion.div>
      )}
    </AnimatePresence>
  );
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for broadcast patterns, priority queues
- [x] Playwright: Test broadcast delivery, priority handling
- [x] Filesystem: Access broadcast components and services
- [x] Supabase: Configure broadcast channels and delivery

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/supabase/supabase", "broadcast events", 3000);
await mcp__context7__get-library-docs("/vercel/next.js", "server sent events", 2000);
await mcp__context7__get-library-docs("/react/react", "toast notifications", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('BroadcastManager', () => {
  it('should respect priority ordering', () => {
    const manager = new BroadcastManager();
    
    manager.enqueue({ priority: 'low', id: '1' });
    manager.enqueue({ priority: 'critical', id: '2' });
    manager.enqueue({ priority: 'normal', id: '3' });
    
    const next = manager.getNext();
    expect(next.id).toBe('2'); // Critical first
  });
  
  it('should filter broadcasts based on user preferences', () => {
    const prefs = {
      criticalOnly: true,
      systemBroadcasts: false
    };
    
    const shouldReceive = manager.shouldDeliver(broadcast, prefs);
    expect(shouldReceive).toBe(broadcast.priority === 'critical');
  });
  
  it('should respect quiet hours', () => {
    const prefs = {
      quietHours: { start: '22:00', end: '08:00' }
    };
    
    // Test at 23:00 - should not deliver
    // Test at 09:00 - should deliver
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Broadcast priority handling', async () => {
  await mcp__playwright__browser_navigate({url: '/dashboard'});
  
  // Send multiple broadcasts with different priorities
  await sendBroadcast({ priority: 'low', title: 'Low priority' });
  await sendBroadcast({ priority: 'critical', title: 'Critical alert' });
  await sendBroadcast({ priority: 'normal', title: 'Normal update' });
  
  // Verify critical appears first
  await mcp__playwright__browser_snapshot();
  
  // Verify critical requires acknowledgment
  const dismissButton = await page.locator('[data-broadcast-dismiss]').first();
  expect(dismissButton).toContainText('Acknowledge');
  
  // Verify normal auto-hides after 5 seconds
  await mcp__playwright__browser_wait_for({time: 5});
  // Check normal broadcast is gone
});
```

### ACCEPTANCE CRITERIA
- [ ] Critical broadcasts show immediately and require acknowledgment
- [ ] High priority shows for 10 seconds with auto-hide
- [ ] Normal priority shows for 5 seconds with auto-hide
- [ ] Low priority batches in notification center
- [ ] User preferences respected for all broadcasts
- [ ] Quiet hours prevent non-critical broadcasts
- [ ] Delivery tracking accurate for analytics
- [ ] Rate limits enforced (1 global/hour, 3 segment/day)
- [ ] Performance: Broadcast processing < 100ms
- [ ] Security: No sensitive data in broadcasts
- [ ] Accessibility: Screen readers announce broadcasts by priority

### DEPENDENCIES
- Must complete after: WS-202 (Realtime), WS-203 (Channels)
- Must complete before: Features requiring system notifications
- Shares code with: WS-202 (Realtime base), WS-203 (Channel infrastructure)

### ESTIMATED EFFORT
- Team A Frontend: 20 hours
- Team B Backend: 16 hours
- Team C Integration: 8 hours
- Team D Platform: 12 hours
- Team E General: 0 hours
- Team F Workflows: 4 hours
- Team G Performance: 4 hours
- Total: 64 hours