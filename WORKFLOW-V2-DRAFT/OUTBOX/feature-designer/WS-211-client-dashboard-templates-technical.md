# TECHNICAL SPECIFICATION: WS-211 - Client Dashboard Templates
## Generated by Feature Development Session - 2025-08-25

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding photographer managing 30+ active clients with different packages
**I want to:** Create reusable dashboard templates for each service tier that automatically apply to new clients
**So that:** I save 2 hours per client on dashboard setup and ensure consistent experiences, saving 60+ hours monthly

**Real Wedding Scenario:**
A photographer offers three packages: Essential ($2k), Premium ($4k), and Luxury ($6k+). Each package includes different deliverables and timelines. Currently, they manually configure each client's dashboard, often forgetting to add certain sections or using inconsistent layouts. With templates, luxury clients automatically get a dashboard with album design tools, premium clients get standard galleries, and essential clients get basic delivery options. When they book a client at The Willows venue (where they shoot monthly), that venue's specific template applies with parking maps and preferred vendor contacts already configured.

### SPECIFICATION SOURCE
- **Feature ID:** WS-211
- **Original Spec:** /CORE-SPECIFICATIONS/02-WEDSYNC-SUPPLIER-PLATFORM/07-Client-Dashboard-Builder/01-dashboard-templates md.md
- **Current Implementation:** 0% complete
- **Files to Modify:**
  - /wedsync/src/app/(dashboard)/clients/[id]/dashboard/page.tsx
  - /wedsync/src/components/dashboard/DashboardBuilder.tsx
- **New Files to Create:**
  - /wedsync/src/lib/dashboard/template-manager.ts
  - /wedsync/src/lib/dashboard/template-engine.ts
  - /wedsync/src/components/dashboard/templates/TemplateSelector.tsx
  - /wedsync/src/components/dashboard/templates/TemplateEditor.tsx
  - /wedsync/src/components/dashboard/templates/SectionLibrary.tsx
  - /wedsync/src/types/dashboard-templates.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Dashboard templates
CREATE TABLE IF NOT EXISTS dashboard_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES suppliers(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  description TEXT,
  category TEXT CHECK (category IN ('default', 'package', 'venue', 'custom')),
  sections JSONB NOT NULL DEFAULT '[]'::jsonb,
  layout TEXT CHECK (layout IN ('single_column', 'sidebar', 'grid')) DEFAULT 'single_column',
  branding JSONB DEFAULT '{}'::jsonb,
  visibility_rules JSONB DEFAULT '{}'::jsonb,
  is_default BOOLEAN DEFAULT false,
  is_active BOOLEAN DEFAULT true,
  version INTEGER DEFAULT 1,
  parent_template_id UUID REFERENCES dashboard_templates(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(supplier_id, name)
);

-- Dashboard sections library
CREATE TABLE IF NOT EXISTS dashboard_sections (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES suppliers(id) ON DELETE CASCADE,
  type TEXT CHECK (type IN (
    'welcome', 'journey_progress', 'forms', 'documents', 
    'faqs', 'articles', 'progress_charts', 'activity_feed',
    'gallery', 'timeline', 'vendor_list', 'custom'
  )),
  name TEXT NOT NULL,
  config JSONB NOT NULL,
  content JSONB DEFAULT '{}'::jsonb,
  is_reusable BOOLEAN DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Template assignments
CREATE TABLE IF NOT EXISTS template_assignments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id UUID REFERENCES dashboard_templates(id) ON DELETE CASCADE,
  client_id UUID REFERENCES clients(id) ON DELETE CASCADE,
  assigned_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  assigned_by UUID REFERENCES auth.users(id),
  assignment_rule TEXT, -- 'manual', 'package', 'venue', 'default'
  overrides JSONB DEFAULT '{}'::jsonb,
  UNIQUE(client_id)
);

-- Auto-assignment rules
CREATE TABLE IF NOT EXISTS template_assignment_rules (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES suppliers(id) ON DELETE CASCADE,
  template_id UUID REFERENCES dashboard_templates(id) ON DELETE CASCADE,
  rule_type TEXT CHECK (rule_type IN ('package', 'venue', 'tag', 'custom')),
  conditions JSONB NOT NULL, -- e.g., {"package": "luxury"} or {"venue": "The Willows"}
  priority INTEGER DEFAULT 0,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Template usage analytics
CREATE TABLE IF NOT EXISTS template_analytics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id UUID REFERENCES dashboard_templates(id) ON DELETE CASCADE,
  client_id UUID REFERENCES clients(id),
  event_type TEXT CHECK (event_type IN ('view', 'interact', 'complete', 'feedback')),
  section_id TEXT,
  metadata JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_templates_supplier ON dashboard_templates(supplier_id);
CREATE INDEX idx_templates_default ON dashboard_templates(supplier_id, is_default);
CREATE INDEX idx_sections_supplier ON dashboard_sections(supplier_id, type);
CREATE INDEX idx_assignments_client ON template_assignments(client_id);
CREATE INDEX idx_assignment_rules_supplier ON template_assignment_rules(supplier_id);
CREATE INDEX idx_template_analytics_template ON template_analytics(template_id);
```

#### API Endpoints Required
```typescript
// GET /api/dashboard/templates
interface GetTemplatesRequest {
  category?: 'default' | 'package' | 'venue' | 'custom';
  includeInactive?: boolean;
}

interface GetTemplatesResponse {
  templates: DashboardTemplate[];
  defaultTemplate?: DashboardTemplate;
}

// POST /api/dashboard/templates
interface CreateTemplateRequest {
  name: string;
  description?: string;
  category: 'default' | 'package' | 'venue' | 'custom';
  sections: DashboardSection[];
  layout: 'single_column' | 'sidebar' | 'grid';
  branding?: BrandingConfig;
  visibilityRules?: VisibilityRules;
  isDefault?: boolean;
}

interface CreateTemplateResponse {
  success: boolean;
  template: DashboardTemplate;
}

// POST /api/dashboard/templates/:id/clone
interface CloneTemplateRequest {
  newName: string;
  modifications?: Partial<DashboardTemplate>;
}

interface CloneTemplateResponse {
  success: boolean;
  template: DashboardTemplate;
}

// POST /api/dashboard/templates/:id/assign
interface AssignTemplateRequest {
  clientIds: string[];
  overrides?: Record<string, any>;
}

interface AssignTemplateResponse {
  success: boolean;
  assigned: number;
  failed: string[];
}

// POST /api/dashboard/templates/rules
interface CreateAssignmentRuleRequest {
  templateId: string;
  ruleType: 'package' | 'venue' | 'tag' | 'custom';
  conditions: Record<string, any>;
  priority?: number;
}

interface CreateAssignmentRuleResponse {
  success: boolean;
  rule: AssignmentRule;
}
```

#### Frontend Components Required
```typescript
// Component: TemplateSelector
// Location: /src/components/dashboard/templates/TemplateSelector.tsx

interface TemplateSelectorProps {
  currentTemplate?: DashboardTemplate;
  onSelect: (template: DashboardTemplate) => void;
  showPreview?: boolean;
}

// Key functionality:
- Grid view of available templates
- Category filtering
- Template preview on hover
- Quick apply button
- Template statistics (usage count)
- Default template indicator

// Component: TemplateEditor
// Location: /src/components/dashboard/templates/TemplateEditor.tsx

interface TemplateEditorProps {
  template: DashboardTemplate;
  onSave: (template: DashboardTemplate) => void;
  onCancel: () => void;
}

// Key functionality:
- Drag-and-drop section ordering
- Section configuration panels
- Layout switcher (single/sidebar/grid)
- Branding customization
- Visibility rules builder
- Live preview mode

// Component: SectionLibrary
// Location: /src/components/dashboard/templates/SectionLibrary.tsx

interface SectionLibraryProps {
  onAddSection: (section: DashboardSection) => void;
  availableSections: DashboardSection[];
}

// Key functionality:
- Categorized section browser
- Section templates
- Custom section creator
- Reusable section management
- Section preview cards
```

#### Integration Points
```typescript
// Service: TemplateManager
// Dependencies: Database, assignment rules, analytics

class TemplateManager {
  async createTemplate(template: TemplateDefinition): Promise<DashboardTemplate> {
    // Validate template structure
    // Create template record
    // Set default if specified
    // Return created template
  }
  
  async assignTemplate(clientId: string, templateId?: string): Promise<void> {
    // If no templateId, find matching template
    // Check assignment rules
    // Apply template to client
    // Record assignment
  }
  
  async findMatchingTemplate(client: Client): Promise<DashboardTemplate | null> {
    // Check venue-specific templates
    // Check package-based templates
    // Check custom rules
    // Return highest priority match
  }
  
  async applyTemplateOverrides(
    template: DashboardTemplate,
    overrides: Record<string, any>
  ): Promise<DashboardTemplate> {
    // Merge overrides with template
    // Validate resulting structure
    // Return modified template
  }
}

// Service: TemplateEngine
class TemplateEngine {
  async renderDashboard(
    template: DashboardTemplate,
    client: Client
  ): Promise<RenderedDashboard> {
    // Process visibility rules
    // Inject client data
    // Apply branding
    // Render sections
  }
  
  async processVisibilityRules(
    rules: VisibilityRules,
    context: ClientContext
  ): Promise<boolean> {
    // Evaluate conditions
    // Check dates/milestones
    // Return visibility decision
  }
}
```

### CODE EXAMPLES

#### Example 1: Template Assignment with Rules
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { supabase } from '@/lib/supabase';

export class TemplateAssignmentService {
  async autoAssignTemplate(client: Client): Promise<DashboardTemplate> {
    // Step 1: Get all active assignment rules for supplier
    const { data: rules } = await supabase
      .from('template_assignment_rules')
      .select(`
        *,
        template:dashboard_templates(*)
      `)
      .eq('supplier_id', client.supplier_id)
      .eq('is_active', true)
      .order('priority', { ascending: false });
    
    // Step 2: Evaluate rules in priority order
    for (const rule of rules || []) {
      if (this.evaluateRule(rule, client)) {
        // Step 3: Assign matching template
        await supabase
          .from('template_assignments')
          .upsert({
            template_id: rule.template_id,
            client_id: client.id,
            assignment_rule: rule.rule_type,
            assigned_at: new Date().toISOString()
          });
        
        // Step 4: Track assignment
        await this.trackAssignment(rule.template_id, client.id, rule.rule_type);
        
        return rule.template;
      }
    }
    
    // Step 5: Fall back to default template
    const { data: defaultTemplate } = await supabase
      .from('dashboard_templates')
      .select('*')
      .eq('supplier_id', client.supplier_id)
      .eq('is_default', true)
      .single();
    
    if (defaultTemplate) {
      await supabase
        .from('template_assignments')
        .upsert({
          template_id: defaultTemplate.id,
          client_id: client.id,
          assignment_rule: 'default'
        });
      
      return defaultTemplate;
    }
    
    // Step 6: Create basic template if no default exists
    return this.createBasicTemplate(client.supplier_id);
  }
  
  private evaluateRule(rule: AssignmentRule, client: Client): boolean {
    const conditions = rule.conditions as any;
    
    switch (rule.rule_type) {
      case 'package':
        return client.package === conditions.package;
        
      case 'venue':
        return client.venue?.name === conditions.venue ||
               client.venue?.id === conditions.venue_id;
        
      case 'tag':
        return client.tags?.some(tag => 
          conditions.tags?.includes(tag)
        );
        
      case 'custom':
        // Evaluate custom JSON logic
        return this.evaluateCustomConditions(conditions, client);
        
      default:
        return false;
    }
  }
  
  private evaluateCustomConditions(
    conditions: any,
    client: Client
  ): boolean {
    // Handle complex conditions like:
    // {"and": [{"guest_count": {">": 150}}, {"season": "summer"}]}
    
    if (conditions.and) {
      return conditions.and.every((cond: any) => 
        this.evaluateCustomConditions(cond, client)
      );
    }
    
    if (conditions.or) {
      return conditions.or.some((cond: any) => 
        this.evaluateCustomConditions(cond, client)
      );
    }
    
    // Evaluate single condition
    const [field, operator, value] = Object.entries(conditions)[0];
    const clientValue = this.getNestedValue(client, field);
    
    return this.compareValues(clientValue, operator, value);
  }
}
```

#### Example 2: Template Editor with Drag-and-Drop
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { DragDropContext, Droppable, Draggable } from '@hello-pangea/dnd';
import { useState } from 'react';

export function TemplateEditor({ template, onSave }: TemplateEditorProps) {
  const [sections, setSections] = useState(template.sections);
  const [layout, setLayout] = useState(template.layout);
  const [previewMode, setPreviewMode] = useState(false);
  
  const handleDragEnd = (result: DropResult) => {
    if (!result.destination) return;
    
    const items = Array.from(sections);
    const [reorderedItem] = items.splice(result.source.index, 1);
    items.splice(result.destination.index, 0, reorderedItem);
    
    setSections(items);
  };
  
  const addSection = (sectionType: string) => {
    const newSection: DashboardSection = {
      id: crypto.randomUUID(),
      type: sectionType,
      title: `New ${sectionType} Section`,
      config: getDefaultConfig(sectionType),
      visibility: { always: true }
    };
    
    setSections([...sections, newSection]);
  };
  
  const updateSection = (sectionId: string, updates: Partial<DashboardSection>) => {
    setSections(sections.map(s => 
      s.id === sectionId ? { ...s, ...updates } : s
    ));
  };
  
  const handleSave = async () => {
    const updatedTemplate: DashboardTemplate = {
      ...template,
      sections,
      layout,
      updated_at: new Date().toISOString()
    };
    
    const { error } = await supabase
      .from('dashboard_templates')
      .update(updatedTemplate)
      .eq('id', template.id);
    
    if (!error) {
      onSave(updatedTemplate);
      toast.success('Template saved successfully');
    }
  };
  
  return (
    <div className="flex gap-6">
      {/* Section Library Sidebar */}
      <div className="w-64 border-r pr-6">
        <h3 className="font-semibold mb-4">Add Sections</h3>
        <SectionLibrary onAddSection={addSection} />
      </div>
      
      {/* Main Editor Area */}
      <div className="flex-1">
        {/* Layout Selector */}
        <div className="mb-6">
          <label className="block text-sm font-medium mb-2">Layout</label>
          <div className="flex gap-2">
            {['single_column', 'sidebar', 'grid'].map(l => (
              <button
                key={l}
                onClick={() => setLayout(l as any)}
                className={`px-4 py-2 rounded ${
                  layout === l ? 'bg-primary text-white' : 'bg-gray-100'
                }`}
              >
                {l.replace('_', ' ')}
              </button>
            ))}
          </div>
        </div>
        
        {/* Sections Editor */}
        <DragDropContext onDragEnd={handleDragEnd}>
          <Droppable droppableId="sections">
            {(provided) => (
              <div
                {...provided.droppableProps}
                ref={provided.innerRef}
                className="space-y-4"
              >
                {sections.map((section, index) => (
                  <Draggable
                    key={section.id}
                    draggableId={section.id}
                    index={index}
                  >
                    {(provided, snapshot) => (
                      <div
                        ref={provided.innerRef}
                        {...provided.draggableProps}
                        className={`
                          bg-white rounded-lg shadow p-4
                          ${snapshot.isDragging ? 'shadow-lg' : ''}
                        `}
                      >
                        <div className="flex items-center justify-between">
                          <div
                            {...provided.dragHandleProps}
                            className="cursor-move"
                          >
                            <GripVertical className="w-5 h-5 text-gray-400" />
                          </div>
                          
                          <div className="flex-1 mx-4">
                            <input
                              type="text"
                              value={section.title}
                              onChange={(e) => updateSection(section.id, {
                                title: e.target.value
                              })}
                              className="font-medium text-lg"
                            />
                            <p className="text-sm text-gray-500">
                              {section.type}
                            </p>
                          </div>
                          
                          <div className="flex gap-2">
                            <button
                              onClick={() => openSectionConfig(section)}
                              className="p-2 hover:bg-gray-100 rounded"
                            >
                              <Settings className="w-4 h-4" />
                            </button>
                            <button
                              onClick={() => removeSection(section.id)}
                              className="p-2 hover:bg-red-50 rounded text-red-500"
                            >
                              <Trash className="w-4 h-4" />
                            </button>
                          </div>
                        </div>
                        
                        {/* Section Preview */}
                        <div className="mt-4 p-3 bg-gray-50 rounded">
                          <SectionPreview section={section} />
                        </div>
                      </div>
                    )}
                  </Draggable>
                ))}
                {provided.placeholder}
              </div>
            )}
          </Droppable>
        </DragDropContext>
        
        {/* Action Buttons */}
        <div className="flex justify-between mt-8">
          <button
            onClick={() => setPreviewMode(!previewMode)}
            className="px-4 py-2 border rounded"
          >
            {previewMode ? 'Edit Mode' : 'Preview'}
          </button>
          
          <div className="flex gap-2">
            <button
              onClick={onCancel}
              className="px-4 py-2 border rounded"
            >
              Cancel
            </button>
            <button
              onClick={handleSave}
              className="px-4 py-2 bg-primary text-white rounded"
            >
              Save Template
            </button>
          </div>
        </div>
      </div>
      
      {/* Preview Panel */}
      {previewMode && (
        <div className="w-96 border-l pl-6">
          <h3 className="font-semibold mb-4">Live Preview</h3>
          <DashboardPreview
            template={{ ...template, sections, layout }}
            sampleClient={getSampleClient()}
          />
        </div>
      )}
    </div>
  );
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for drag-and-drop libraries, template patterns
- [x] Playwright: Test template creation, assignment flows
- [x] Filesystem: Access template components and services
- [x] PostgreSQL: Manage template data and rules

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/hello-pangea/dnd", "drag and drop", 3000);
await mcp__context7__get-library-docs("/vercel/next.js", "dynamic imports", 2000);
await mcp__context7__get-library-docs("/tailwindcss/tailwindcss", "component variants", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('TemplateManager', () => {
  it('should auto-assign template based on package', async () => {
    const client = { package: 'luxury', venue: null };
    const template = await manager.autoAssignTemplate(client);
    expect(template.name).toBe('Luxury Experience Dashboard');
  });
  
  it('should prioritize venue templates over package templates', async () => {
    const client = { package: 'standard', venue: { name: 'The Willows' }};
    const template = await manager.autoAssignTemplate(client);
    expect(template.name).toBe('The Willows Venue Dashboard');
  });
  
  it('should fall back to default template', async () => {
    const client = { package: null, venue: null };
    const template = await manager.autoAssignTemplate(client);
    expect(template.is_default).toBe(true);
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Create and assign dashboard template', async () => {
  await mcp__playwright__browser_navigate({url: '/settings/dashboard-templates'});
  
  // Create new template
  await mcp__playwright__browser_click({
    element: 'Create Template button',
    ref: 'create-template-btn'
  });
  
  // Configure template
  await mcp__playwright__browser_type({
    element: 'Template name input',
    ref: 'template-name',
    text: 'Premium Wedding Dashboard'
  });
  
  // Add sections via drag-drop
  await mcp__playwright__browser_drag({
    startElement: 'Welcome section in library',
    startRef: 'section-welcome',
    endElement: 'Template canvas',
    endRef: 'template-canvas'
  });
  
  // Save template
  await mcp__playwright__browser_click({
    element: 'Save Template button',
    ref: 'save-template-btn'
  });
  
  // Verify template created
  await mcp__playwright__browser_snapshot();
});
```

### ACCEPTANCE CRITERIA
- [ ] Create templates with 8+ section types
- [ ] Drag-and-drop section reordering works
- [ ] Auto-assignment based on package/venue works
- [ ] Templates clone with modifications
- [ ] Override specific sections per client
- [ ] Default template fallback works
- [ ] Layout options (single/sidebar/grid) render correctly
- [ ] Performance: Template renders < 500ms
- [ ] Security: Templates isolated per supplier
- [ ] Accessibility: Keyboard navigation for all template operations

### DEPENDENCIES
- Must complete after: WS-196 (API Routes Structure)
- Must complete before: WS-212 (Section Configuration)
- Shares code with: Client dashboard rendering system

### ESTIMATED EFFORT
- Team A Frontend: 32 hours
- Team B Backend: 20 hours
- Team C Integration: 4 hours
- Team D Platform: 8 hours
- Team E General: 0 hours
- Team F Workflows: 8 hours
- Team G Performance: 4 hours
- Total: 76 hours