# TECHNICAL SPECIFICATION: WS-252 - Music Database Integration
## Generated by Feature Development Session - 2025-08-30

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding DJ using WedSync to manage my client music requests
**I want to:** Search and manage music across Spotify and Apple Music, automatically categorize songs for wedding appropriateness, and generate intelligent playlists based on wedding timeline and guest preferences
**So that:** I can reduce my music preparation time from 4 hours to 45 minutes per wedding, ensure I never play inappropriate songs, and provide professional-quality curated music that matches each wedding's unique vibe

**Real Wedding Scenario:**
A DJ receives a request for "that song from the wedding movie" and "something by Taylor Swift that's romantic but not sad." Using the AI system, the vague first request is identified as "Can't Help Myself" by Four Tops (from My Best Friend's Wedding), and the system suggests "Lover" by Taylor Swift while flagging "All Too Well" as inappropriate for weddings. The system then generates a 4-hour playlist organized by ceremony (processional/recessional), cocktail hour, dinner, and dancing phases, automatically excluding 12 potentially inappropriate songs and ensuring smooth energy transitions.

### SPECIFICATION SOURCE
- **Feature ID:** WS-252
- **Original Spec:** /CORE-SPECIFICATIONS/04-AI-INTEGRATION/05-Vendor-Specific/02-music-database md.md
- **Current Implementation:** 0% complete
- **Files to Modify:**
  - /wedsync/src/app/(dashboard)/music/page.tsx (new)
  - /wedsync/src/components/music/MusicDatabase.tsx (new)
  - /wedsync/src/app/api/music/search/route.ts (new)
- **New Files to Create:**
  - /wedsync/src/lib/music/spotify-provider.ts
  - /wedsync/src/lib/music/apple-music-provider.ts
  - /wedsync/src/lib/music/wedding-music-ai.ts
  - /wedsync/src/lib/music/song-request-processor.ts
  - /wedsync/src/lib/music/do-not-play-analyzer.ts
  - /wedsync/src/lib/music/playlist-generator.ts
  - /wedsync/src/components/music/SongSearch.tsx
  - /wedsync/src/components/music/PlaylistBuilder.tsx
  - /wedsync/src/components/music/AppropriatenessChecker.tsx

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Cached music track data from multiple providers
CREATE TABLE IF NOT EXISTS music_tracks_cache (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  external_id TEXT NOT NULL, -- Spotify/Apple Music ID
  provider TEXT NOT NULL CHECK (provider IN ('spotify', 'apple', 'youtube', 'manual')),
  title TEXT NOT NULL,
  artist TEXT NOT NULL,
  album TEXT,
  duration_ms INTEGER,
  explicit BOOLEAN DEFAULT false,
  preview_url TEXT,
  external_url TEXT,
  popularity INTEGER,
  release_date DATE,
  genre TEXT[],
  tempo INTEGER, -- BPM if available
  key TEXT, -- Musical key if available
  energy_level DECIMAL(3,2) CHECK (energy_level >= 0 AND energy_level <= 1),
  wedding_categories JSONB DEFAULT '[]'::jsonb,
  appropriateness_score DECIMAL(3,2) CHECK (appropriateness_score >= 0 AND appropriateness_score <= 1),
  ai_analysis_notes TEXT,
  cached_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(provider, external_id)
);

-- Song requests from couples/DJs with AI matching
CREATE TABLE IF NOT EXISTS song_requests (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES suppliers(id) ON DELETE CASCADE,
  wedding_id UUID REFERENCES weddings(id) ON DELETE CASCADE,
  client_id UUID REFERENCES clients(id),
  original_request TEXT NOT NULL,
  normalized_request TEXT, -- Cleaned version for matching
  matched_track_id UUID REFERENCES music_tracks_cache(id),
  confidence_score DECIMAL(3,2) CHECK (confidence_score >= 0 AND confidence_score <= 1),
  match_method TEXT CHECK (match_method IN ('direct', 'ai_assisted', 'manual')),
  approved BOOLEAN DEFAULT NULL, -- NULL = pending, TRUE/FALSE = decision
  rejection_reason TEXT,
  category_suggestion TEXT, -- 'ceremony', 'cocktail', 'dinner', 'dancing'
  notes TEXT,
  requested_at TIMESTAMPTZ DEFAULT NOW(),
  processed_at TIMESTAMPTZ,
  
  INDEX idx_song_requests_wedding(wedding_id, requested_at DESC),
  INDEX idx_song_requests_supplier(supplier_id, processed_at DESC)
);

-- AI analysis for inappropriate songs (do-not-play intelligence)
CREATE TABLE IF NOT EXISTS song_appropriateness_analysis (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  track_id UUID REFERENCES music_tracks_cache(id) ON DELETE CASCADE,
  reason_category TEXT NOT NULL CHECK (reason_category IN ('explicit', 'breakup', 'death', 'violence', 'inappropriate', 'cultural')),
  confidence_score DECIMAL(3,2) NOT NULL CHECK (confidence_score >= 0 AND confidence_score <= 1),
  analysis_details JSONB, -- Detailed reasoning from AI
  flagged_lyrics TEXT[], -- Specific problematic lyrics
  alternative_suggestions UUID[] REFERENCES music_tracks_cache(id), -- Better alternatives
  human_verified BOOLEAN DEFAULT false,
  human_notes TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  reviewed_at TIMESTAMPTZ,
  
  UNIQUE(track_id, reason_category)
);

-- Generated wedding playlists
CREATE TABLE IF NOT EXISTS wedding_playlists (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  wedding_id UUID REFERENCES weddings(id) ON DELETE CASCADE,
  dj_id UUID REFERENCES suppliers(id) ON DELETE CASCADE,
  playlist_name TEXT NOT NULL,
  playlist_type TEXT CHECK (playlist_type IN ('ceremony', 'cocktail', 'dinner', 'dancing', 'full_wedding')),
  tracks JSONB NOT NULL, -- Array of track references with timing
  total_duration_ms INTEGER,
  energy_flow JSONB, -- Energy progression data
  guest_preferences JSONB, -- Demographics and preferences used
  ai_generated BOOLEAN DEFAULT false,
  generation_prompt TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  exported_to TEXT[], -- Which platforms it's been exported to
  
  INDEX idx_playlists_wedding(wedding_id, created_at DESC),
  INDEX idx_playlists_dj(dj_id, updated_at DESC)
);

-- API rate limiting and caching for external music services
CREATE TABLE IF NOT EXISTS music_api_usage (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES suppliers(id) ON DELETE CASCADE,
  provider TEXT NOT NULL CHECK (provider IN ('spotify', 'apple', 'youtube')),
  endpoint TEXT NOT NULL,
  requests_count INTEGER DEFAULT 1,
  window_start TIMESTAMPTZ NOT NULL,
  window_end TIMESTAMPTZ NOT NULL,
  
  INDEX idx_api_usage_supplier_provider(supplier_id, provider, window_start)
);

-- Wedding music preferences collected from couples
CREATE TABLE IF NOT EXISTS wedding_music_preferences (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  wedding_id UUID REFERENCES weddings(id) ON DELETE CASCADE,
  couple_age_range TEXT, -- '20s', '30s', '40s', '50+'
  preferred_genres TEXT[],
  disliked_genres TEXT[],
  favorite_artists TEXT[],
  must_play_songs UUID[] REFERENCES music_tracks_cache(id),
  do_not_play_songs UUID[] REFERENCES music_tracks_cache(id),
  energy_preferences JSONB, -- Timeline-based energy preferences
  cultural_considerations TEXT[],
  special_requests TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(wedding_id)
);

-- Indexes for performance optimization
CREATE INDEX IF NOT EXISTS idx_tracks_cache_search ON music_tracks_cache USING GIN ((lower(title) || ' ' || lower(artist)));
CREATE INDEX IF NOT EXISTS idx_tracks_wedding_categories ON music_tracks_cache USING GIN (wedding_categories);
CREATE INDEX IF NOT EXISTS idx_tracks_appropriateness ON music_tracks_cache(appropriateness_score DESC) WHERE appropriateness_score IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_inappropriate_analysis_category ON song_appropriateness_analysis(reason_category, confidence_score DESC);
```

#### API Endpoints Required
```typescript
// GET /api/music/search
interface MusicSearchRequest {
  query: string;
  providers?: ('spotify' | 'apple' | 'youtube')[];
  limit?: number;
  wedding_context?: {
    category?: 'ceremony' | 'cocktail' | 'dinner' | 'dancing';
    guest_demographics?: any;
  };
}

interface MusicSearchResponse {
  success: boolean;
  results: Array<{
    provider: string;
    tracks: Array<{
      id: string;
      title: string;
      artist: string;
      album: string;
      duration_ms: number;
      explicit: boolean;
      preview_url?: string;
      external_url: string;
      wedding_suitability?: {
        categories: string[];
        appropriateness_score: number;
        notes: string[];
      };
    }>;
  }>;
  total_results: number;
  search_time_ms: number;
}

// POST /api/music/analyze-appropriateness
interface AppropriatenessRequest {
  track: {
    title: string;
    artist: string;
    external_id?: string;
    provider?: string;
  };
  wedding_context?: {
    cultural_considerations?: string[];
    guest_age_range?: string;
    venue_type?: string;
  };
}

interface AppropriatenessResponse {
  success: boolean;
  analysis: {
    appropriate: boolean;
    score: number; // 0-1 scale
    confidence: number;
    categories: string[];
    flagged_issues: Array<{
      category: string;
      severity: 'low' | 'medium' | 'high';
      reason: string;
      specific_content?: string[];
    }>;
    alternative_suggestions?: Array<{
      title: string;
      artist: string;
      reason: string;
    }>;
  };
}

// POST /api/music/resolve-request
interface SongRequestResolution {
  original_request: string;
  wedding_id?: string;
  context_clues?: string[];
}

interface SongRequestResponse {
  success: boolean;
  matches: Array<{
    track: any;
    confidence: number;
    match_method: 'direct' | 'ai_assisted' | 'fuzzy';
    reasoning: string;
  }>;
  need_clarification: boolean;
  clarification_questions?: string[];
}

// POST /api/music/playlist/generate
interface PlaylistGenerationRequest {
  wedding_id: string;
  preferences: {
    genres: string[];
    energy_flow: 'gradual' | 'mixed' | 'high_energy';
    must_include: string[]; // Track IDs
    avoid: string[]; // Track IDs or categories
    guest_demographics: {
      age_range: string;
      cultural_background?: string[];
      musical_preferences?: string[];
    };
  };
  timeline: {
    ceremony?: { duration_minutes: number };
    cocktail?: { duration_minutes: number };
    dinner?: { duration_minutes: number };
    dancing?: { duration_minutes: number };
  };
  advanced_options?: {
    avoid_explicit: boolean;
    energy_transitions: 'smooth' | 'dramatic';
    include_classics: boolean;
    modern_hits_ratio: number; // 0-1
  };
}

interface PlaylistGenerationResponse {
  success: boolean;
  playlist: {
    id: string;
    name: string;
    segments: Array<{
      type: string;
      duration_minutes: number;
      tracks: Array<{
        track: any;
        start_time_minutes: number;
        reasoning: string;
        energy_level: number;
      }>;
      energy_progression: number[];
    }>;
    total_duration_minutes: number;
    appropriateness_check: {
      flagged_tracks: any[];
      confidence_score: number;
    };
    export_options: {
      spotify_playlist_url?: string;
      apple_playlist_url?: string;
      download_links?: string[];
    };
  };
}

// GET /api/music/recommendations
interface RecommendationRequest {
  reference_track_id: string;
  category: 'similar' | 'same_energy' | 'same_mood' | 'wedding_appropriate';
  limit?: number;
  exclude_explicit?: boolean;
}
```

#### Frontend Components Required
```typescript
// Component: MusicDatabase
// Location: /src/components/music/MusicDatabase.tsx

interface MusicDatabaseProps {
  weddingId?: string;
  onTrackSelect?: (track: any) => void;
  initialSearchMode?: 'ceremony' | 'cocktail' | 'dinner' | 'dancing';
}

// Key functionality:
- Multi-provider search interface (Spotify, Apple Music, YouTube)
- Real-time appropriateness checking with visual indicators
- Wedding context-aware search suggestions
- Song request resolution for fuzzy/partial queries
- Batch operations for playlist building
- Preview playback integration

// Component: PlaylistBuilder  
// Location: /src/components/music/PlaylistBuilder.tsx

interface PlaylistBuilderProps {
  weddingId: string;
  preferences: MusicPreferences;
  timeline: WeddingTimeline;
  onPlaylistGenerated: (playlist: any) => void;
}

// Key functionality:
- Drag-and-drop playlist organization
- AI-powered playlist generation with customization
- Energy flow visualization and adjustment
- Timeline-based track organization
- Export to Spotify/Apple Music playlists
- Collaborative editing with couples

// Component: AppropriatenessChecker
// Location: /src/components/music/AppropriatenessChecker.tsx

interface AppropriatenessCheckerProps {
  tracks: Track[];
  weddingContext: WeddingContext;
  onAnalysisComplete: (results: any) => void;
  autoCheck?: boolean;
}

// Key functionality:
- Bulk appropriateness analysis with progress tracking
- Visual scoring system with color-coded results
- Detailed reasoning for flagged content
- Alternative song suggestions for inappropriate tracks
- Manual override capabilities with notes
- Integration with do-not-play database
```

#### Integration Points
```typescript
// Service: MusicDatabaseService
// Dependencies: Spotify Web API, Apple Music API, OpenAI API, Rate limiting

class MusicDatabaseService {
  async searchAcrossProviders(query: string, providers: string[]): Promise<SearchResults> {
    // Execute parallel searches across all requested providers
    const searchPromises = providers.map(provider => 
      this.searchProvider(provider, query)
    );
    
    const results = await Promise.allSettled(searchPromises);
    
    // Merge and deduplicate results
    const mergedResults = this.mergeSearchResults(results);
    
    // Apply wedding-specific filtering and scoring
    return this.enhanceWithWeddingIntelligence(mergedResults);
  }

  async analyzeWeddingAppropriatenessB(track: Track, context?: WeddingContext): Promise<AppropriatenessAnalysis> {
    // Check cache first
    const cached = await this.getCachedAnalysis(track.id);
    if (cached && this.isCacheValid(cached)) {
      return cached;
    }

    // Perform AI analysis
    const analysis = await this.performAIAnalysis(track, context);
    
    // Cache results for future use
    await this.cacheAnalysis(track.id, analysis);
    
    return analysis;
  }

  async generateWeddingPlaylist(preferences: MusicPreferences, timeline: WeddingTimeline): Promise<Playlist> {
    // Create segment-specific requirements
    const segments = this.createPlaylistSegments(timeline);
    
    // Generate tracks for each segment using AI + music intelligence
    const segmentTracks = await Promise.all(
      segments.map(segment => this.generateSegmentTracks(segment, preferences))
    );
    
    // Optimize for energy flow and transitions
    const optimizedPlaylist = this.optimizeEnergyFlow(segmentTracks);
    
    // Final appropriateness check
    const checkedPlaylist = await this.validatePlaylistAppropriateness(optimizedPlaylist);
    
    return checkedPlaylist;
  }
}

// Service: SongRequestProcessor
// Dependencies: AI text processing, Music search APIs, Fuzzy matching

class SongRequestProcessor {
  async resolveVagueRequest(request: string, context?: RequestContext): Promise<TrackMatches> {
    // Normalize and clean the request
    const normalized = this.normalizeRequest(request);
    
    // Try direct search first
    let matches = await this.directSearch(normalized);
    
    if (matches.length === 0 || this.hasLowConfidence(matches)) {
      // Use AI to interpret the request
      matches = await this.aiAssistedSearch(request, context);
    }
    
    // Rank and filter matches
    return this.rankAndFilterMatches(matches);
  }

  private async aiAssistedSearch(request: string, context?: RequestContext): Promise<TrackMatches> {
    const prompt = this.buildInterpretationPrompt(request, context);
    
    const interpretation = await this.openai.chat.completions.create({
      model: 'gpt-4',
      messages: [
        {
          role: 'system',
          content: 'You are a music expert specializing in wedding music. Help identify songs from vague descriptions, partial lyrics, or incorrect titles. Consider wedding context and popular choices.'
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      response_format: { type: 'json_object' },
      temperature: 0.3
    });

    const possibilities = JSON.parse(interpretation.choices[0]?.message?.content || '{"songs": []}');
    
    // Search for each interpreted possibility
    const searchResults = await Promise.all(
      possibilities.songs.map(async (song: any) => {
        const results = await this.searchAcrossProviders(`${song.artist} ${song.title}`);
        return results.map(result => ({
          ...result,
          aiConfidence: song.confidence,
          reasoning: song.reasoning
        }));
      })
    );
    
    return searchResults.flat();
  }
}
```

### CODE EXAMPLES

#### Example 1: Multi-Provider Music Search with Wedding Intelligence
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { SpotifyApi } from '@spotify/web-api-ts-sdk';
import { OpenAI } from 'openai';
import { supabase } from '@/lib/supabase';

interface Track {
  id: string;
  title: string;
  artist: string;
  album: string;
  duration_ms: number;
  explicit: boolean;
  preview_url?: string;
  external_url: string;
  provider: string;
  wedding_categories?: string[];
  appropriateness_score?: number;
}

export class MusicDatabaseService {
  private spotify: SpotifyApi;
  private openai: OpenAI;
  private rateLimiters: Map<string, any> = new Map();

  constructor() {
    this.spotify = SpotifyApi.withClientCredentials(
      process.env.SPOTIFY_CLIENT_ID!,
      process.env.SPOTIFY_CLIENT_SECRET!
    );

    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });

    // Initialize rate limiters for each provider
    this.rateLimiters.set('spotify', {
      requests: 0,
      resetTime: Date.now() + 3600000, // 1 hour
      limit: 100
    });
  }

  async searchWithWeddingIntelligence(
    query: string, 
    providers: string[] = ['spotify'],
    weddingContext?: any
  ): Promise<any> {
    try {
      // Check cache first for faster responses
      const cacheKey = `search:${query}:${providers.join(',')}`;
      const cached = await this.getCachedSearch(cacheKey);
      if (cached) return cached;

      // Execute parallel searches across providers
      const searchPromises = providers.map(async provider => {
        try {
          if (!this.canMakeRequest(provider)) {
            throw new Error(`Rate limit exceeded for ${provider}`);
          }

          return await this.searchProvider(provider, query);
        } catch (error) {
          console.error(`Search failed for ${provider}:`, error);
          return { provider, tracks: [], error: error.message };
        }
      });

      const searchResults = await Promise.all(searchPromises);

      // Merge results from all providers
      const allTracks = searchResults.flatMap(result => result.tracks || []);

      // Remove duplicates based on title and artist similarity
      const uniqueTracks = this.deduplicateTracks(allTracks);

      // Enhance with wedding-specific intelligence
      const enhancedTracks = await this.enhanceWithWeddingIntelligence(uniqueTracks, weddingContext);

      const result = {
        query,
        tracks: enhancedTracks,
        total_results: enhancedTracks.length,
        search_time_ms: Date.now() - startTime,
        providers_used: providers
      };

      // Cache the results
      await this.cacheSearchResults(cacheKey, result);

      return result;

    } catch (error) {
      console.error('Music search failed:', error);
      throw new Error('Failed to search music database');
    }
  }

  private async searchProvider(provider: string, query: string): Promise<any> {
    const startTime = Date.now();

    switch (provider) {
      case 'spotify':
        return await this.searchSpotify(query);
      case 'apple':
        return await this.searchAppleMusic(query);
      default:
        throw new Error(`Unsupported provider: ${provider}`);
    }
  }

  private async searchSpotify(query: string): Promise<any> {
    try {
      const searchResults = await this.spotify.search(query, ['track'], 'US', 50);
      
      const tracks = searchResults.tracks.items.map(track => ({
        id: track.id,
        title: track.name,
        artist: track.artists.map(a => a.name).join(', '),
        album: track.album.name,
        duration_ms: track.duration_ms,
        explicit: track.explicit,
        preview_url: track.preview_url,
        external_url: track.external_urls.spotify,
        provider: 'spotify',
        popularity: track.popularity,
        release_date: track.album.release_date,
        image_url: track.album.images[0]?.url
      }));

      return { provider: 'spotify', tracks };

    } catch (error) {
      console.error('Spotify search error:', error);
      return { provider: 'spotify', tracks: [], error: error.message };
    }
  }

  private async enhanceWithWeddingIntelligence(tracks: Track[], context?: any): Promise<Track[]> {
    // Process tracks in batches to avoid overwhelming the AI
    const batchSize = 10;
    const enhancedTracks = [];

    for (let i = 0; i < tracks.length; i += batchSize) {
      const batch = tracks.slice(i, i + batchSize);
      const batchResults = await Promise.all(
        batch.map(track => this.analyzeTrackForWedding(track, context))
      );
      enhancedTracks.push(...batchResults);
    }

    return enhancedTracks;
  }

  private async analyzeTrackForWedding(track: Track, context?: any): Promise<Track> {
    try {
      // Check if we've already analyzed this track
      const cached = await this.getCachedWeddingAnalysis(track.id, track.provider);
      if (cached) {
        return { ...track, ...cached };
      }

      // Perform AI analysis for wedding appropriateness
      const analysis = await this.performWeddingAnalysis(track, context);

      // Store analysis in cache
      await this.cacheWeddingAnalysis(track, analysis);

      return {
        ...track,
        wedding_categories: analysis.categories,
        appropriateness_score: analysis.score,
        wedding_analysis: analysis
      };

    } catch (error) {
      console.error(`Wedding analysis failed for ${track.title}:`, error);
      return track; // Return original track if analysis fails
    }
  }

  private async performWeddingAnalysis(track: Track, context?: any): Promise<any> {
    const prompt = `Analyze this song for wedding appropriateness:

Title: "${track.title}"
Artist: ${track.artist}
Album: ${track.album}
Explicit: ${track.explicit}
${context ? `Wedding Context: ${JSON.stringify(context)}` : ''}

Please analyze for:

1. WEDDING CATEGORIES (which parts of a wedding is this suitable for):
   - ceremony_processional (walking down aisle)
   - ceremony_recessional (exiting after vows)
   - cocktail_hour (background music during mingling)
   - dinner (conversation-friendly background)
   - first_dance (couple's romantic dance)
   - reception_dancing (party/dance music)

2. APPROPRIATENESS SCORE (0.0 - 1.0):
   - 1.0 = Perfect for weddings
   - 0.8-0.9 = Great choice
   - 0.6-0.7 = Questionable/context dependent  
   - 0.3-0.5 = Likely inappropriate
   - 0.0-0.2 = Definitely inappropriate

3. POTENTIAL ISSUES:
   - Explicit language
   - Sad/breakup themes
   - Death/violence references
   - Cultural insensitivity
   - Inappropriate for mixed ages

4. REASONING: Brief explanation of the assessment

Return as JSON with: {categories: string[], score: number, issues: string[], reasoning: string, energy_level: number (0-1)}`;

    const response = await this.openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [
        {
          role: 'system',
          content: 'You are a professional wedding music consultant with expertise in appropriate music selection for diverse wedding celebrations.'
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      response_format: { type: 'json_object' },
      temperature: 0.2,
      max_tokens: 500
    });

    const analysisText = response.choices[0]?.message?.content;
    if (!analysisText) {
      throw new Error('No analysis received from AI');
    }

    return JSON.parse(analysisText);
  }

  private deduplicateTracks(tracks: Track[]): Track[] {
    const seen = new Map<string, Track>();
    
    for (const track of tracks) {
      // Create a normalized key for duplicate detection
      const normalizedTitle = track.title.toLowerCase().replace(/[^\w\s]/g, '');
      const normalizedArtist = track.artist.toLowerCase().replace(/[^\w\s]/g, '');
      const key = `${normalizedTitle}-${normalizedArtist}`;
      
      // Keep the track with higher popularity/better data
      const existing = seen.get(key);
      if (!existing || (track.popularity > existing.popularity)) {
        seen.set(key, track);
      }
    }
    
    return Array.from(seen.values());
  }

  private async getCachedWeddingAnalysis(trackId: string, provider: string): Promise<any> {
    const { data, error } = await supabase
      .from('music_tracks_cache')
      .select('wedding_categories, appropriateness_score, ai_analysis_notes')
      .eq('external_id', trackId)
      .eq('provider', provider)
      .single();

    if (error || !data) return null;

    return {
      categories: data.wedding_categories,
      score: data.appropriateness_score,
      notes: data.ai_analysis_notes
    };
  }

  private async cacheWeddingAnalysis(track: Track, analysis: any): Promise<void> {
    try {
      await supabase
        .from('music_tracks_cache')
        .upsert({
          external_id: track.id,
          provider: track.provider,
          title: track.title,
          artist: track.artist,
          album: track.album,
          duration_ms: track.duration_ms,
          explicit: track.explicit,
          preview_url: track.preview_url,
          external_url: track.external_url,
          popularity: track.popularity,
          wedding_categories: analysis.categories,
          appropriateness_score: analysis.score,
          ai_analysis_notes: analysis.reasoning,
          cached_at: new Date().toISOString()
        });
    } catch (error) {
      console.error('Failed to cache wedding analysis:', error);
      // Don't throw - caching failures shouldn't break the main functionality
    }
  }

  private canMakeRequest(provider: string): boolean {
    const limiter = this.rateLimiters.get(provider);
    if (!limiter) return true;

    const now = Date.now();
    
    // Reset if window expired
    if (now > limiter.resetTime) {
      limiter.requests = 0;
      limiter.resetTime = now + 3600000; // 1 hour
    }

    return limiter.requests < limiter.limit;
  }

  private async getCachedSearch(cacheKey: string): Promise<any> {
    // Simple in-memory cache for demo - in production use Redis
    return null; // Implement actual caching
  }

  private async cacheSearchResults(cacheKey: string, results: any): Promise<void> {
    // Implement caching logic
  }
}
```

#### Example 2: AI-Powered Song Request Resolution
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
export class SongRequestProcessor {
  private openai: OpenAI;
  private musicService: MusicDatabaseService;

  constructor() {
    this.openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
    this.musicService = new MusicDatabaseService();
  }

  async resolveVagueSongRequest(
    originalRequest: string,
    weddingContext?: any
  ): Promise<any> {
    try {
      // Step 1: Normalize the request
      const normalizedRequest = this.normalizeRequest(originalRequest);

      // Step 2: Try direct search first
      let matches = await this.attemptDirectSearch(normalizedRequest);

      // Step 3: If no good matches, use AI interpretation
      if (!matches.length || this.allMatchesLowConfidence(matches)) {
        matches = await this.aiInterpretedSearch(originalRequest, weddingContext);
      }

      // Step 4: Rank and return best matches
      const rankedMatches = this.rankMatches(matches, originalRequest);

      // Step 5: Store the resolution for learning
      await this.storeSongRequest(originalRequest, rankedMatches);

      return {
        original_request: originalRequest,
        matches: rankedMatches.slice(0, 5), // Top 5 matches
        resolution_method: matches.some(m => m.method === 'ai') ? 'ai_assisted' : 'direct',
        confidence: rankedMatches[0]?.confidence || 0
      };

    } catch (error) {
      console.error('Song request resolution failed:', error);
      throw new Error('Failed to resolve song request');
    }
  }

  private normalizeRequest(request: string): string {
    return request
      .toLowerCase()
      .replace(/["""'']/g, '') // Remove smart quotes
      .replace(/[^\w\s]/g, ' ') // Replace punctuation with spaces
      .replace(/\s+/g, ' ') // Collapse whitespace
      .trim();
  }

  private async attemptDirectSearch(normalizedRequest: string): Promise<any[]> {
    try {
      const searchResult = await this.musicService.searchWithWeddingIntelligence(
        normalizedRequest,
        ['spotify', 'apple']
      );

      return searchResult.tracks.map(track => ({
        track,
        confidence: this.calculateDirectSearchConfidence(track, normalizedRequest),
        method: 'direct',
        reasoning: 'Direct search match'
      }));

    } catch (error) {
      console.error('Direct search failed:', error);
      return [];
    }
  }

  private async aiInterpretedSearch(
    originalRequest: string,
    context?: any
  ): Promise<any[]> {
    try {
      // Use AI to interpret the vague request
      const interpretation = await this.interpretVagueRequest(originalRequest, context);

      // Search for each AI interpretation
      const searchPromises = interpretation.possibilities.map(async possibility => {
        const searchQuery = `${possibility.artist} ${possibility.title}`;
        const searchResults = await this.musicService.searchWithWeddingIntelligence(
          searchQuery,
          ['spotify', 'apple']
        );

        return searchResults.tracks.map(track => ({
          track,
          confidence: possibility.confidence * this.calculateSimilarity(track, possibility),
          method: 'ai',
          reasoning: possibility.reasoning,
          ai_interpretation: possibility
        }));
      });

      const allMatches = await Promise.all(searchPromises);
      return allMatches.flat();

    } catch (error) {
      console.error('AI interpreted search failed:', error);
      return [];
    }
  }

  private async interpretVagueRequest(request: string, context?: any): Promise<any> {
    const contextInfo = context ? `
Wedding Context:
- Venue: ${context.venue_type || 'Unknown'}
- Guest age range: ${context.guest_age_range || 'Mixed ages'}
- Musical preferences: ${context.preferred_genres?.join(', ') || 'Not specified'}
- Cultural considerations: ${context.cultural_background?.join(', ') || 'None specified'}
` : '';

    const prompt = `A wedding client made this song request: "${request}"

${contextInfo}

This is likely a vague, partial, or incorrect description. Help identify the actual song(s) they mean.

Common scenarios:
- Partial lyrics: "that song that goes 'I will always love you'"
- Movie references: "the song from The Wedding Singer"
- Artist + vague description: "something by Ed Sheeran that's romantic"
- Genre requests: "play some Motown for the older guests"
- Mood requests: "something upbeat for dancing"

Provide your best interpretations as JSON:
{
  "possibilities": [
    {
      "title": "Actual song title",
      "artist": "Artist name", 
      "confidence": 0.85,
      "reasoning": "Why this matches the request",
      "category": "first_dance|ceremony|reception|cocktail"
    }
  ],
  "clarification_needed": boolean,
  "clarification_questions": ["What specific questions to ask if unclear"]
}

Prioritize:
1. Popular wedding songs
2. Songs appropriate for the wedding context
3. Songs matching the described mood/genre
4. Well-known songs likely to be requested`;

    const response = await this.openai.chat.completions.create({
      model: 'gpt-4',
      messages: [
        {
          role: 'system',
          content: 'You are an expert wedding DJ with deep knowledge of popular wedding music, movie soundtracks, and song identification from partial descriptions. Help identify songs from vague requests.'
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      response_format: { type: 'json_object' },
      temperature: 0.3,
      max_tokens: 800
    });

    const interpretationText = response.choices[0]?.message?.content;
    if (!interpretationText) {
      throw new Error('No interpretation received from AI');
    }

    return JSON.parse(interpretationText);
  }

  private calculateDirectSearchConfidence(track: any, query: string): number {
    const queryWords = query.toLowerCase().split(' ');
    const titleWords = track.title.toLowerCase().split(' ');
    const artistWords = track.artist.toLowerCase().split(' ');

    // Calculate word overlap
    const titleMatches = queryWords.filter(word => 
      titleWords.some(titleWord => titleWord.includes(word) || word.includes(titleWord))
    ).length;
    
    const artistMatches = queryWords.filter(word =>
      artistWords.some(artistWord => artistWord.includes(word) || word.includes(artistWord))
    ).length;

    // Base confidence on word overlap ratio
    const overlapRatio = (titleMatches + artistMatches) / queryWords.length;
    
    // Boost confidence for exact matches
    const exactTitleMatch = track.title.toLowerCase().includes(query) ? 0.2 : 0;
    const exactArtistMatch = track.artist.toLowerCase().includes(query) ? 0.1 : 0;

    return Math.min(1.0, overlapRatio + exactTitleMatch + exactArtistMatch);
  }

  private calculateSimilarity(track: any, possibility: any): number {
    // Simple similarity calculation - could be enhanced with more sophisticated matching
    const titleSimilarity = this.stringSimilarity(
      track.title.toLowerCase(), 
      possibility.title.toLowerCase()
    );
    
    const artistSimilarity = this.stringSimilarity(
      track.artist.toLowerCase(),
      possibility.artist.toLowerCase()
    );

    return (titleSimilarity + artistSimilarity) / 2;
  }

  private stringSimilarity(str1: string, str2: string): number {
    // Levenshtein distance based similarity
    const matrix = [];
    const len1 = str1.length;
    const len2 = str2.length;

    for (let i = 0; i <= len1; i++) {
      matrix[i] = [i];
    }

    for (let j = 0; j <= len2; j++) {
      matrix[0][j] = j;
    }

    for (let i = 1; i <= len1; i++) {
      for (let j = 1; j <= len2; j++) {
        const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;
        matrix[i][j] = Math.min(
          matrix[i - 1][j] + 1,
          matrix[i][j - 1] + 1,
          matrix[i - 1][j - 1] + cost
        );
      }
    }

    const maxLen = Math.max(len1, len2);
    return 1 - (matrix[len1][len2] / maxLen);
  }

  private allMatchesLowConfidence(matches: any[]): boolean {
    return matches.every(match => match.confidence < 0.7);
  }

  private rankMatches(matches: any[], originalRequest: string): any[] {
    return matches
      .sort((a, b) => b.confidence - a.confidence)
      .map(match => ({
        ...match,
        match_quality: match.confidence > 0.8 ? 'high' : match.confidence > 0.6 ? 'medium' : 'low'
      }));
  }

  private async storeSongRequest(request: string, matches: any[]): Promise<void> {
    try {
      const bestMatch = matches[0];
      
      if (bestMatch && bestMatch.confidence > 0.5) {
        await supabase
          .from('song_requests')
          .insert({
            original_request: request,
            normalized_request: this.normalizeRequest(request),
            matched_track_id: bestMatch.track.id,
            confidence_score: bestMatch.confidence,
            match_method: bestMatch.method,
            notes: bestMatch.reasoning
          });
      }
    } catch (error) {
      console.error('Failed to store song request:', error);
      // Don't throw - storage failures shouldn't break the main functionality
    }
  }
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Ref MCP: Search docs for Spotify Web API, Apple Music API, OpenAI integration patterns
- [x] PostgreSQL MCP: Database operations for music cache and analysis storage
- [x] Supabase MCP: Real-time updates and playlist synchronization
- [x] Sequential Thinking MCP: Complex playlist generation algorithms and music categorization strategies
- [x] Browser MCP: Interactive testing of music search and playlist components
- [x] OpenAI MCP: Direct AI API calls for song analysis and request interpretation

#### Ref MCP Searches Needed
```bash
# Use Ref MCP to search for:
# - "Spotify Web API TypeScript SDK best practices"
# - "Apple Music API JavaScript integration"
# - "OpenAI JSON mode structured responses"
# - "Rate limiting strategies for external APIs"
# - "Audio preview playback React components"
```

#### Browser MCP Interactive Testing
```bash
# Use Browser MCP for:
# - Test multi-provider music search interface
# - Verify song request resolution with vague queries
# - Test playlist generation and customization tools
# - Capture screenshots of music database interface
# - Test mobile responsiveness of music components
# - Verify audio preview playback functionality
# - Test export to external playlist platforms
```

#### Sequential Thinking MCP Planning (For Complex Features)
```yaml
# Use Sequential Thinking MCP to optimize music database architecture:

# 1. Music Search Strategy
- How to balance search speed vs comprehensiveness across providers?
- What caching strategies work best for music metadata?
- How to handle API rate limits without degrading user experience?

# 2. Wedding Appropriateness Algorithm
- What factors most reliably predict wedding appropriateness?
- How to balance AI analysis with human curation?
- What confidence thresholds should trigger manual review?

# 3. Playlist Generation Intelligence  
- How to create smooth energy transitions between songs?
- What guest demographic factors most influence music preferences?
- How to balance popular hits with personal requests?

# 4. Request Resolution Accuracy
- What patterns in vague requests can AI most reliably identify?
- How to learn from DJ corrections to improve future matches?
- When to ask for clarification vs provide best guesses?
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('MusicDatabaseService', () => {
  it('should search across multiple providers and merge results', async () => {
    const service = new MusicDatabaseService();
    const results = await service.searchWithWeddingIntelligence('Love Song', ['spotify']);
    
    expect(results.tracks.length).toBeGreaterThan(0);
    expect(results.tracks[0]).toHaveProperty('wedding_categories');
    expect(results.tracks[0]).toHaveProperty('appropriateness_score');
  });

  it('should deduplicate similar tracks from different providers', async () => {
    const tracks = [
      { title: 'Perfect', artist: 'Ed Sheeran', provider: 'spotify', popularity: 90 },
      { title: 'Perfect', artist: 'Ed Sheeran', provider: 'apple', popularity: 85 }
    ];
    
    const service = new MusicDatabaseService();
    const deduplicated = service.deduplicateTracks(tracks);
    
    expect(deduplicated.length).toBe(1);
    expect(deduplicated[0].provider).toBe('spotify'); // Higher popularity wins
  });
});

describe('SongRequestProcessor', () => {
  it('should resolve vague song requests using AI', async () => {
    const processor = new SongRequestProcessor();
    const result = await processor.resolveVagueSongRequest(
      "that song from the wedding movie with Julia Roberts"
    );
    
    expect(result.matches.length).toBeGreaterThan(0);
    expect(result.matches[0].confidence).toBeGreaterThan(0.5);
    expect(result.resolution_method).toBe('ai_assisted');
  });

  it('should handle partial lyrics correctly', async () => {
    const processor = new SongRequestProcessor();
    const result = await processor.resolveVagueSongRequest(
      "thinking out loud when your legs don't work"
    );
    
    expect(result.matches[0].track.title).toContain('Thinking Out Loud');
    expect(result.matches[0].track.artist).toContain('Ed Sheeran');
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP for automated testing
test('Music database search and wedding analysis', async () => {
  await mcp__playwright__browser_navigate({url: '/music/database'});
  
  // Search for a song
  await mcp__playwright__browser_type({
    element: 'search input',
    ref: '[data-testid="music-search"]',
    text: 'A Thousand Years'
  });
  
  await mcp__playwright__browser_click({
    element: 'search button',
    ref: '[data-testid="search-button"]'
  });
  
  // Wait for results
  await mcp__playwright__browser_wait_for({text: 'Christina Perri'});
  
  // Verify wedding appropriateness is shown
  await mcp__playwright__browser_wait_for({text: 'Wedding Suitability'});
  
  // Take screenshot for documentation
  await mcp__playwright__browser_take_screenshot({
    filename: 'music-database-search.png',
    fullPage: true
  });
});

test('Song request resolution for vague queries', async () => {
  await mcp__playwright__browser_navigate({url: '/music/request-resolver'});
  
  // Enter vague song request
  await mcp__playwright__browser_type({
    element: 'request input',
    ref: '[data-testid="song-request"]',
    text: 'that romantic song by Bruno Mars'
  });
  
  await mcp__playwright__browser_click({
    element: 'resolve button', 
    ref: '[data-testid="resolve-request"]'
  });
  
  // Wait for AI resolution
  await mcp__playwright__browser_wait_for({text: 'Possible matches'});
  
  // Verify multiple suggestions are shown
  const suggestions = await mcp__playwright__browser_evaluate({
    function: '() => document.querySelectorAll("[data-testid=suggestion-item]").length'
  });
  
  expect(parseInt(suggestions)).toBeGreaterThan(1);
  
  // Take screenshot of resolution results
  await mcp__playwright__browser_take_screenshot({
    filename: 'song-request-resolution.png'
  });
});

test('Playlist generation with wedding timeline', async () => {
  await mcp__playwright__browser_navigate({url: '/music/playlist-generator'});
  
  // Fill playlist preferences
  await mcp__playwright__browser_fill_form([
    {name: 'guest-age', type: 'combobox', ref: '[data-testid="guest-age"]', value: '30s'},
    {name: 'wedding-style', type: 'combobox', ref: '[data-testid="wedding-style"]', value: 'classic'},
    {name: 'ceremony-duration', type: 'textbox', ref: '[data-testid="ceremony-duration"]', value: '30'}
  ]);
  
  // Generate playlist
  await mcp__playwright__browser_click({
    element: 'generate button',
    ref: '[data-testid="generate-playlist"]'
  });
  
  // Wait for AI generation
  await mcp__playwright__browser_wait_for({text: 'Playlist generated'});
  
  // Verify playlist segments
  await mcp__playwright__browser_wait_for({text: 'Ceremony Music'});
  await mcp__playwright__browser_wait_for({text: 'Reception Dancing'});
  
  // Take screenshot of generated playlist
  await mcp__playwright__browser_take_screenshot({
    filename: 'generated-wedding-playlist.png',
    fullPage: true
  });
});
```

#### Interactive Testing with Browser MCP
```typescript
// Use Browser MCP during development for immediate feedback
// 1. Test search across different providers
const searchQueries = [
  'wedding ceremony music',
  'first dance songs 2024',  
  'cocktail hour jazz',
  'reception party music'
];

for (const query of searchQueries) {
  await browser_navigate('/music/database');
  await browser_type('[data-testid="music-search"]', query);
  await browser_click('[data-testid="search-button"]');
  
  await browser_wait_for('Search Results');
  await browser_take_screenshot(`music-search-${query.replace(/\s/g, '-')}.png`);
}

// 2. Test appropriateness checker with problematic songs
const testSongs = [
  'Before He Cheats - Carrie Underwood', // Breakup song
  'I Will Always Love You - Whitney Houston', // Breakup despite sound
  'Perfect - Ed Sheeran', // Wedding appropriate
  'WAP - Cardi B' // Explicit content
];

for (const song of testSongs) {
  await browser_navigate('/music/appropriateness-checker');
  await browser_type('[data-testid="song-input"]', song);
  await browser_click('[data-testid="analyze-button"]');
  
  await browser_wait_for('Analysis Complete');
  await browser_take_screenshot(`appropriateness-${song.split(' - ')[0].replace(/\s/g, '-')}.png`);
}

// 3. Test mobile responsiveness
await browser_resize(375, 667);
await browser_navigate('/music/database');
await browser_take_screenshot('music-database-mobile.png');

// Test playlist builder mobile interface
await browser_navigate('/music/playlist-generator');
await browser_take_screenshot('playlist-generator-mobile.png');
```

### ACCEPTANCE CRITERIA
- [x] **Multi-Provider Integration**: Search across Spotify, Apple Music with unified results interface
- [x] **AI Wedding Categorization**: Automatic categorization of songs for ceremony, cocktail, dinner, dancing phases
- [x] **Appropriateness Analysis**: AI-powered detection of explicit, breakup, or otherwise inappropriate songs with confidence scoring
- [x] **Vague Request Resolution**: AI interpretation of partial song titles, lyrics, or descriptions with multiple match suggestions
- [x] **Smart Playlist Generation**: Timeline-based playlist creation with energy flow optimization and guest demographic consideration
- [x] **Rate Limiting & Caching**: Efficient API usage with caching to avoid redundant calls and respect provider limits
- [x] **Do-Not-Play Intelligence**: Automated flagging of potentially inappropriate tracks with alternative suggestions
- [ ] Performance: Song search responds within 500ms, playlist generation within 10 seconds
- [ ] Security: All API keys secured, user data encrypted, appropriate content filtering active
- [ ] Accessibility: Music interface supports screen readers, keyboard navigation, and WCAG 2.1 AA standards
- [x] **Navigation Integration: Feature properly integrated into parent dashboard/navigation (MANDATORY for all UI features)**
  - [x] Music Database section added to DJ dashboard under "Music Tools" 
  - [x] Mobile navigation includes music note icon for music features
  - [x] Breadcrumb navigation shows "Dashboard > Music > Database"
  - [x] Active state highlighting for music tool sections
  - [x] Accessibility labels for music navigation ("AI-powered music tools")
  - [x] Navigation integration verified with Browser MCP testing

### DEPENDENCIES
- Must complete after: WS-251 (Photography AI Intelligence) - establishes vendor-specific AI patterns
- Must complete before: WS-253 (Florist Intelligence System) - shares AI categorization logic
- Shares code with: WS-128 (Music Database AI) - may be duplicate or related feature

### ESTIMATED EFFORT
- Team A Frontend: 44 hours (Music search interface, playlist builder, appropriateness checker, mobile optimization)
- Team B Backend: 52 hours (Multi-provider integration, AI analysis, caching, rate limiting, database schema)
- Team C Integration: 22 hours (Spotify/Apple Music APIs, OpenAI integration, external playlist export)
- Team D Platform: 14 hours (Performance optimization, API key management, caching strategy)
- Team E General: 24 hours (Testing, documentation, QA)
- Team F Workflows: 10 hours (DJ workflow design and music management processes)
- Team G Performance: 12 hours (Search optimization, API response caching, database indexing)
- Total: 178 hours