# TECHNICAL SPECIFICATION: WS-100 - System Health Monitoring
## Generated by Feature Development Session - August 22, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding photographer coordinating a timeline during a Saturday wedding
**I want to:** Always access vendor information and timeline updates reliably
**So that:** I never miss critical wedding moments due to system downtime or slow performance

**Real Wedding Scenario:**
A venue coordinator sends a last-minute ceremony location change through WedSync at 2:30 PM - the wedding starts at 3:00 PM. System health monitoring ensures the database responds within 200ms, the notification service sends SMS alerts to all vendors instantly, and the photographer receives the update in time to relocate equipment. Without monitoring, a slow database could delay this critical update.

### SPECIFICATION SOURCE
- **Feature ID:** WS-100
- **Original Spec:** /CORE-SPECIFICATIONS/07-ADMIN-DASHBOARD/01-Overview/02-system-health md.md
- **Current Implementation:** 0% complete
- **Files to Modify:**
  - `/wedsync/app/api/health/system/route.ts` (create new)
  - `/wedsync/lib/monitoring/health-monitor.ts` (create new)
- **New Files to Create:**
  - `/wedsync/src/components/admin/SystemHealthDashboard.tsx`
  - `/wedsync/src/components/admin/ServiceCard.tsx`
  - `/wedsync/src/components/admin/PerformanceChart.tsx`
  - `/wedsync/src/hooks/useSystemHealth.ts`
  - `/wedsync/lib/monitoring/alert-manager.ts`
  - `/wedsync/supabase/migrations/20250822000003_system_health_tables.sql`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Health check tracking
CREATE TABLE IF NOT EXISTS health_checks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  service VARCHAR(50) NOT NULL,
  status VARCHAR(20) NOT NULL CHECK (status IN ('healthy', 'degraded', 'down')),
  latency INTEGER, -- milliseconds
  error_message TEXT,
  metadata JSONB DEFAULT '{}',
  checked_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_health_checks_service_time ON health_checks(service, checked_at DESC);
CREATE INDEX idx_health_checks_status ON health_checks(status, checked_at DESC);

-- System performance metrics
CREATE TABLE IF NOT EXISTS system_metrics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  metric_type VARCHAR(50) NOT NULL, -- 'cpu_usage', 'memory_usage', 'response_time', 'error_rate'
  value DECIMAL(10,4) NOT NULL,
  metadata JSONB DEFAULT '{}',
  recorded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_system_metrics_type_time ON system_metrics(metric_type, recorded_at DESC);

-- Service status history for trend analysis
CREATE TABLE IF NOT EXISTS service_status_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  service VARCHAR(50) NOT NULL,
  status VARCHAR(20) NOT NULL,
  uptime_percentage DECIMAL(5,2),
  avg_response_time INTEGER,
  error_count INTEGER DEFAULT 0,
  recorded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Alert log for tracking notifications
CREATE TABLE IF NOT EXISTS system_alerts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  alert_type VARCHAR(50) NOT NULL,
  severity VARCHAR(20) NOT NULL CHECK (severity IN ('info', 'warning', 'critical')),
  message TEXT NOT NULL,
  metric_value DECIMAL(10,4),
  threshold_value DECIMAL(10,4),
  resolved_at TIMESTAMP WITH TIME ZONE NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

#### API Endpoints Required
```typescript
// GET /api/health/system
interface SystemHealthResponse {
  overall: 'healthy' | 'degraded' | 'critical';
  infrastructure: {
    serverUptime: number; // percentage
    responseTime: number; // milliseconds
    cpuUsage: number; // percentage
    memoryUsage: number; // percentage
    diskSpace: number; // percentage
  };
  services: {
    database: ServiceStatus;
    redis: ServiceStatus;
    stripe: ServiceStatus;
    emailService: ServiceStatus;
    smsService: ServiceStatus;
  };
  apiHealth: {
    requestsPerMinute: number;
    errorRate: number;
    p95ResponseTime: number;
    p99ResponseTime: number;
  };
  timestamp: string;
}

interface ServiceStatus {
  status: 'healthy' | 'degraded' | 'down';
  latency: number;
  lastCheck: string;
  errorCount24h: number;
  uptime24h: number; // percentage
}

// POST /api/health/check/:service
interface HealthCheckRequest {
  service: string;
  timeout?: number;
}

// GET /api/health/metrics/history
interface HistoryRequest {
  metric: string;
  timeRange: '1h' | '24h' | '7d' | '30d';
}

interface HistoryResponse {
  data: Array<{
    timestamp: string;
    value: number;
  }>;
  summary: {
    min: number;
    max: number;
    avg: number;
    current: number;
  };
}
```

#### Frontend Components Required
```typescript
// Component: SystemHealthDashboard
// Location: /src/components/admin/SystemHealthDashboard.tsx

interface Props {
  refreshInterval?: number; // milliseconds, default 30000
  showAlerts?: boolean;
}

// Key functionality:
- Real-time system health overview
- Service status grid with color coding
- Performance charts with time series data
- Alert notifications and acknowledgment

// Component: ServiceCard
// Location: /src/components/admin/ServiceCard.tsx

interface Props {
  name: string;
  status: ServiceStatus;
  showDetails?: boolean;
  onStatusClick?: () => void;
}

// Key functionality:
- Service status indicator with colors
- Latency and uptime display
- Historical trend mini-chart
- Click-through to detailed service view

// Component: PerformanceChart
// Location: /src/components/admin/PerformanceChart.tsx

interface Props {
  data: Array<{ timestamp: string; value: number }>;
  title: string;
  unit: string;
  thresholds?: { warning: number; critical: number };
  timeRange: string;
}

// Key functionality:
- Interactive time series charts
- Threshold lines for warning/critical levels
- Zoom and pan capabilities
- Export chart data
```

#### Integration Points
```typescript
// Service: HealthMonitor
// Dependencies: Supabase, Redis, Stripe, SendGrid, Twilio

class HealthMonitor {
  private checks = new Map<string, HealthCheck>();
  
  async checkAllServices(): Promise<SystemHealth> {
    const [infrastructure, services, apiHealth] = await Promise.allSettled([
      this.checkInfrastructure(),
      this.checkExternalServices(),
      this.checkApiHealth()
    ]);
    
    return this.aggregateResults({ infrastructure, services, apiHealth });
  }
  
  private async checkExternalServices() {
    // Test Supabase connectivity
    // Test Redis connectivity  
    // Test Stripe API status
    // Test SendGrid email delivery
    // Test Twilio SMS capability
  }
  
  private async checkInfrastructure() {
    // CPU and memory usage via Node.js process metrics
    // Response time from internal health endpoint
    // Disk space if applicable
  }
}

// Service: AlertManager
// Dependencies: Slack webhook, email notifications

class AlertManager {
  async checkThresholds(metrics: SystemHealth) {
    const alerts = this.evaluateThresholds(metrics);
    
    if (alerts.length > 0) {
      await Promise.all([
        this.sendSlackAlerts(alerts),
        this.saveAlertsToDatabase(alerts),
        this.sendEmailAlerts(alerts.filter(a => a.severity === 'critical'))
      ]);
    }
  }
  
  private evaluateThresholds(metrics: SystemHealth) {
    // Check response time thresholds
    // Check error rate limits  
    // Check service availability
    // Check resource utilization
  }
}

// Hook: useSystemHealth
export function useSystemHealth(refreshInterval: number = 30000) {
  // Real-time health monitoring with auto-refresh
  // WebSocket connection for instant alerts
  // Error handling and retry logic
}
```

### CODE EXAMPLES

#### Example 1: Health Check API Implementation
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { createClient } from '@supabase/supabase-js';
import { Redis } from '@upstash/redis';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_KEY!
);

const redis = new Redis({
  url: process.env.UPSTASH_REDIS_URL!,
  token: process.env.UPSTASH_REDIS_TOKEN!
});

export async function GET() {
  const startTime = Date.now();
  
  try {
    // Check all services in parallel
    const [dbCheck, redisCheck, stripeCheck] = await Promise.allSettled([
      checkDatabase(),
      checkRedis(), 
      checkStripe()
    ]);
    
    // Calculate overall health
    const services = {
      database: getServiceStatus(dbCheck),
      redis: getServiceStatus(redisCheck),
      stripe: getServiceStatus(stripeCheck)
    };
    
    const overall = calculateOverallHealth(services);
    
    // Get infrastructure metrics
    const infrastructure = {
      serverUptime: process.uptime() / 86400 * 100, // Convert to percentage
      responseTime: Date.now() - startTime,
      cpuUsage: process.cpuUsage().system / 1000000, // Convert to percentage
      memoryUsage: (process.memoryUsage().heapUsed / process.memoryUsage().heapTotal) * 100,
      diskSpace: 85 // This would come from OS metrics in production
    };
    
    const healthData = {
      overall,
      infrastructure,
      services,
      timestamp: new Date().toISOString()
    };
    
    // Store health check results
    await Promise.all(
      Object.entries(services).map(([service, status]) =>
        supabase.from('health_checks').insert({
          service,
          status: status.status,
          latency: status.latency,
          error_message: status.status === 'down' ? 'Service check failed' : null
        })
      )
    );
    
    return Response.json(healthData);
    
  } catch (error) {
    console.error('Health check failed:', error);
    return Response.json({ 
      overall: 'critical',
      error: 'Health check system failure'
    }, { status: 500 });
  }
}

async function checkDatabase() {
  const start = Date.now();
  const { error } = await supabase
    .from('health_checks')
    .select('id')
    .limit(1);
    
  return {
    status: error ? 'down' : 'healthy',
    latency: Date.now() - start,
    error: error?.message
  };
}

async function checkRedis() {
  const start = Date.now();
  try {
    await redis.ping();
    return {
      status: 'healthy' as const,
      latency: Date.now() - start
    };
  } catch (error) {
    return {
      status: 'down' as const,
      latency: -1,
      error: error.message
    };
  }
}
```

#### Example 2: Real-time Health Dashboard
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';

interface SystemHealth {
  overall: 'healthy' | 'degraded' | 'critical';
  infrastructure: {
    responseTime: number;
    cpuUsage: number;
    memoryUsage: number;
  };
  services: Record<string, {
    status: 'healthy' | 'degraded' | 'down';
    latency: number;
  }>;
}

export function SystemHealthDashboard() {
  const [health, setHealth] = useState<SystemHealth | null>(null);
  const [loading, setLoading] = useState(true);
  const [lastUpdate, setLastUpdate] = useState<Date>(new Date());
  
  useEffect(() => {
    const fetchHealth = async () => {
      try {
        const response = await fetch('/api/health/system');
        const data = await response.json();
        setHealth(data);
        setLastUpdate(new Date());
      } catch (error) {
        console.error('Failed to fetch health data:', error);
      } finally {
        setLoading(false);
      }
    };
    
    fetchHealth();
    const interval = setInterval(fetchHealth, 30000); // Refresh every 30 seconds
    
    return () => clearInterval(interval);
  }, []);
  
  const getStatusColor = (status: string) => {
    switch (status) {
      case 'healthy': return 'bg-green-500';
      case 'degraded': return 'bg-yellow-500';
      case 'down': case 'critical': return 'bg-red-500';
      default: return 'bg-gray-500';
    }
  };
  
  if (loading) return <div>Loading system health...</div>;
  if (!health) return <div>Failed to load health data</div>;
  
  return (
    <div className="space-y-6 p-6">
      {/* Overall Status */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            System Health
            <Badge className={getStatusColor(health.overall)}>
              {health.overall}
            </Badge>
          </CardTitle>
          <p className="text-sm text-muted-foreground">
            Last updated: {lastUpdate.toLocaleTimeString()}
          </p>
        </CardHeader>
      </Card>
      
      {/* Infrastructure Metrics */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-sm">Response Time</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{health.infrastructure.responseTime}ms</div>
            <p className="text-xs text-muted-foreground">
              Target: &lt; 200ms
            </p>
          </CardContent>
        </Card>
        
        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-sm">CPU Usage</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{health.infrastructure.cpuUsage.toFixed(1)}%</div>
            <p className="text-xs text-muted-foreground">
              Warning: &gt; 80%
            </p>
          </CardContent>
        </Card>
        
        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-sm">Memory Usage</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{health.infrastructure.memoryUsage.toFixed(1)}%</div>
            <p className="text-xs text-muted-foreground">
              Warning: &gt; 85%
            </p>
          </CardContent>
        </Card>
      </div>
      
      {/* Services Status */}
      <Card>
        <CardHeader>
          <CardTitle>Service Status</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            {Object.entries(health.services).map(([name, service]) => (
              <div key={name} className="flex items-center justify-between p-3 border rounded">
                <div>
                  <div className="font-medium capitalize">{name}</div>
                  <div className="text-sm text-muted-foreground">
                    {service.latency}ms latency
                  </div>
                </div>
                <Badge className={getStatusColor(service.status)}>
                  {service.status}
                </Badge>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [ ] Context7: Load docs for monitoring libraries, Prometheus
- [ ] PostgreSQL: Create health check and metrics tables
- [ ] Filesystem: Create monitoring components

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/prometheus/client_nodejs", "metrics collection", 2000);
await mcp__context7__get-library-docs("/recharts/recharts", "time series charts", 1500);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('System Health Monitoring', () => {
  it('should check all services and return health status', () => {
    // Test health check aggregation
  });
  
  it('should detect service degradation correctly', () => {
    // Test threshold detection and status calculation
  });
  
  it('should store health check history', () => {
    // Test database logging of health checks
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('System health dashboard shows accurate status', async () => {
  await mcp__playwright__browser_navigate({url: '/admin/health'});
  await mcp__playwright__browser_snapshot();
  // Verify all service cards are present and show correct status
});
```

### ACCEPTANCE CRITERIA
- [ ] Dashboard shows real-time status of all critical services
- [ ] Health checks run every 30 seconds automatically
- [ ] Alert notifications trigger when thresholds exceeded
- [ ] Historical data preserved for trend analysis
- [ ] Performance: Health check API responds under 500ms
- [ ] Security: Admin-only access with proper authentication
- [ ] Accessibility: Status indicators are screen reader accessible

### DEPENDENCIES
- Must complete after: Infrastructure setup, Database connections
- Must complete before: WS-101 (Alert System)
- Shares code with: WS-103 (Error Tracking), WS-098 (Rollback Procedures)

### ESTIMATED EFFORT
- Team A Frontend: 12 hours (dashboard UI, charts, real-time updates)
- Team B Backend: 16 hours (health monitoring system, API endpoints, database setup)
- Team C Integration: 6 hours (external service checks, alert integration)
- Total: 34 hours