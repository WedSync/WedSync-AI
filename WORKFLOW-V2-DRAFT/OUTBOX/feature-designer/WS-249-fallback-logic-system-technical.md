# TECHNICAL SPECIFICATION: WS-249 - Fallback Logic System
## Generated by Feature Development Session - 2025-08-30

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding photographer using WedSync's AI chatbot on their client forms
**I want to:** Have graceful fallback handling when the AI can't answer client questions
**So that:** My clients never feel abandoned and always have a path to get help, maintaining professional image while capturing unanswered questions for knowledge base improvement

**Real Wedding Scenario:**
A bride asks the AI chatbot "Can you accommodate my grandfather's wheelchair during the outdoor ceremony photos?" The AI has 45% confidence it understands the accessibility requirements but doesn't have specific venue layout information. Instead of giving a potentially wrong answer, the system gracefully escalates to the photographer with context, logs the question for future training, and offers immediate contact options while maintaining a professional, helpful tone.

### SPECIFICATION SOURCE
- **Feature ID:** WS-249
- **Original Spec:** /CORE-SPECIFICATIONS/04-AI-INTEGRATION/04-Chatbot/03-fallback-logic md.md
- **Current Implementation:** 0% complete
- **Files to Modify:** 
  - /wedsync/src/lib/ai/chatbot-fallback.ts (new)
  - /wedsync/src/lib/ai/confidence-scorer.ts (new)
  - /wedsync/src/components/ai/ChatbotInterface.tsx
  - /wedsync/src/app/api/ai/chatbot/route.ts
- **New Files to Create:** 
  - /wedsync/src/lib/ai/fallback-learning.ts
  - /wedsync/src/lib/ai/contact-escalation.ts
  - /wedsync/src/components/ai/FallbackResponse.tsx

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Chatbot fallback tracking
CREATE TABLE IF NOT EXISTS chatbot_fallbacks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES suppliers(id) ON DELETE CASCADE,
  client_id UUID REFERENCES clients(id) ON DELETE CASCADE,
  query TEXT NOT NULL,
  confidence_score DECIMAL(3,2) CHECK (confidence_score >= 0 AND confidence_score <= 1),
  fallback_reason TEXT NOT NULL CHECK (fallback_reason IN ('low_confidence', 'no_match', 'ambiguous', 'out_of_scope', 'technical_error')),
  escalation_method TEXT CHECK (escalation_method IN ('email', 'phone', 'calendar')),
  resolved BOOLEAN DEFAULT false,
  response_message TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unanswered queries for learning
CREATE TABLE IF NOT EXISTS unanswered_queries (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES suppliers(id) ON DELETE CASCADE,
  query TEXT NOT NULL,
  frequency INTEGER DEFAULT 1,
  last_asked TIMESTAMPTZ DEFAULT NOW(),
  suggested_answer TEXT,
  added_to_faq BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(supplier_id, query)
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_fallbacks_supplier_created ON chatbot_fallbacks(supplier_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_unanswered_frequency ON unanswered_queries(supplier_id, frequency DESC, last_asked DESC);
CREATE INDEX IF NOT EXISTS idx_fallbacks_unresolved ON chatbot_fallbacks(supplier_id, resolved) WHERE NOT resolved;
```

#### API Endpoints Required
```typescript
// POST /api/ai/chatbot/fallback
interface FallbackRequestBody {
  query: string;
  supplierId: string;
  clientId: string;
  confidence: number;
  originalResponse?: string;
  fallbackReason: 'low_confidence' | 'no_match' | 'ambiguous' | 'out_of_scope' | 'technical_error';
}

interface FallbackResponseBody {
  success: boolean;
  fallbackResponse: {
    message: string;
    suggestions?: string[];
    contactOptions: {
      email: boolean;
      phone: boolean;
      calendar: boolean;
    };
    escalationId: string;
    urgency: 'low' | 'medium' | 'high';
  };
  error?: string;
}

// GET /api/ai/chatbot/unanswered/{supplierId}
interface UnansweredQueriesResponse {
  queries: Array<{
    id: string;
    query: string;
    frequency: number;
    lastAsked: string;
    suggestedAnswer?: string;
    addedToFAQ: boolean;
  }>;
  totalCount: number;
}

// POST /api/ai/chatbot/resolve-fallback
interface ResolveFallbackRequest {
  fallbackId: string;
  resolutionMethod: 'answered' | 'escalated' | 'faq_added';
  notes?: string;
}
```

#### Frontend Components Required
```typescript
// Component: FallbackResponse
// Location: /src/components/ai/FallbackResponse.tsx

interface FallbackResponseProps {
  message: string;
  suggestions?: string[];
  contactOptions: {
    email: boolean;
    phone: boolean;
    calendar: boolean;
  };
  urgency: 'low' | 'medium' | 'high';
  onContactSelect: (method: string) => void;
  onSuggestionClick: (suggestion: string) => void;
}

// Key functionality:
- Display graceful fallback message with professional tone
- Show suggested alternative questions if available
- Present contact options based on urgency level
- Track user interactions for analytics
- Responsive design for mobile and desktop
```

#### Integration Points
```typescript
// Service: ChatbotFallbackService
// Dependencies: AI API, Email service, Calendar service, Analytics

class ChatbotFallbackService {
  async handleFallback(query: string, confidence: number, context: ChatContext) {
    // Determine fallback strategy based on confidence score
    const strategy = this.determineFallbackStrategy(confidence);
    
    // Generate appropriate response message
    const response = await this.generateFallbackResponse(query, strategy, context);
    
    // Log for learning and analytics
    await this.logFallback(query, confidence, context);
    
    // Return structured fallback response
    return response;
  }

  async processUnansweredQueries(supplierId: string) {
    // Identify frequently asked questions that need FAQ entries
    const candidates = await this.findFAQCandidates(supplierId);
    
    // Generate suggested answers using AI
    for (const candidate of candidates) {
      const suggestion = await this.generateSuggestedAnswer(candidate.query);
      await this.updateUnansweredQuery(candidate.id, { suggestedAnswer: suggestion });
    }
  }
}

// Service: ContactEscalationService
// Dependencies: Notification service, Calendar service, CRM integration

class ContactEscalationService {
  async escalateToHuman(query: string, clientInfo: ClientInfo, urgency: string) {
    // Create escalation record
    const escalation = await this.createEscalation(query, clientInfo, urgency);
    
    // Notify supplier based on urgency
    await this.notifySupplier(escalation);
    
    // Offer appropriate contact methods to client
    return this.buildContactResponse(escalation);
  }
}
```

### CODE EXAMPLES

#### Example 1: Confidence-Based Fallback Logic
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { supabase } from '@/lib/supabase';
import { ChatbotFallbackService } from '@/lib/ai/chatbot-fallback';

export class ConfidenceBasedFallback {
  private fallbackService: ChatbotFallbackService;

  constructor() {
    this.fallbackService = new ChatbotFallbackService();
  }

  async handleChatResponse(query: string, aiResponse: string, confidence: number, context: ChatContext) {
    // High confidence - direct answer
    if (confidence > 0.8) {
      return {
        type: 'direct',
        message: aiResponse,
        confidence: confidence
      };
    }
    
    // Medium confidence - qualified answer
    if (confidence > 0.6) {
      return {
        type: 'qualified',
        message: `Based on my knowledge, ${aiResponse.toLowerCase()}. For more specific details, I'd recommend confirming with ${context.supplierName}.`,
        confidence: confidence,
        contactSuggestion: true
      };
    }
    
    // Low confidence - suggest similar or escalate
    if (confidence > 0.4) {
      const similarQuestions = await this.findSimilarQuestions(query, context.supplierId);
      return {
        type: 'suggestions',
        message: "I'm not entirely sure about that specific question, but I can help with these related topics:",
        suggestions: similarQuestions.slice(0, 3),
        contactOffer: true
      };
    }
    
    // Very low confidence - escalate to human
    return await this.fallbackService.escalateToHuman(query, context);
  }

  private async findSimilarQuestions(query: string, supplierId: string) {
    const { data: faqs } = await supabase
      .from('chatbot_knowledge_base')
      .select('question, answer')
      .eq('supplier_id', supplierId)
      .limit(10);
      
    // Simple similarity matching (could be enhanced with vector search)
    const queryWords = query.toLowerCase().split(' ');
    
    return faqs?.filter(faq => {
      const faqWords = faq.question.toLowerCase().split(' ');
      const commonWords = queryWords.filter(word => faqWords.includes(word));
      return commonWords.length >= 2; // At least 2 words in common
    }).slice(0, 3) || [];
  }
}
```

#### Example 2: Learning from Unanswered Queries
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { supabase } from '@/lib/supabase';
import { OpenAI } from 'openai';

export class FallbackLearningSystem {
  private openai: OpenAI;

  constructor() {
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });
  }

  async processUnansweredQueries(supplierId: string) {
    // Get frequently asked unanswered questions
    const { data: queries } = await supabase
      .from('unanswered_queries')
      .select('*')
      .eq('supplier_id', supplierId)
      .gte('frequency', 5) // Asked at least 5 times
      .eq('added_to_faq', false)
      .order('frequency', { ascending: false })
      .limit(10);

    if (!queries?.length) return;

    for (const query of queries) {
      try {
        // Generate suggested answer using AI
        const suggestedAnswer = await this.generateSuggestedAnswer(query.query, supplierId);
        
        // Update the query with suggested answer
        await supabase
          .from('unanswered_queries')
          .update({ 
            suggested_answer: suggestedAnswer,
            updated_at: new Date().toISOString()
          })
          .eq('id', query.id);

        // Notify supplier about the suggestion
        await this.notifySupplierAboutFAQSuggestion(supplierId, query, suggestedAnswer);
        
      } catch (error) {
        console.error(`Error processing unanswered query ${query.id}:`, error);
      }
    }
  }

  private async generateSuggestedAnswer(query: string, supplierId: string): Promise<string> {
    // Get supplier's existing knowledge base for context
    const { data: knowledge } = await supabase
      .from('chatbot_knowledge_base')
      .select('question, answer')
      .eq('supplier_id', supplierId);

    const context = knowledge?.map(k => `Q: ${k.question}\nA: ${k.answer}`).join('\n\n') || '';

    const completion = await this.openai.chat.completions.create({
      model: "gpt-4",
      messages: [
        {
          role: "system",
          content: "You are helping a wedding vendor create FAQ answers. Generate a helpful, professional answer that a wedding vendor would give to their clients. Keep it concise but thorough."
        },
        {
          role: "user", 
          content: `Based on this existing knowledge base:\n\n${context}\n\nGenerate an appropriate answer for this frequently asked question: "${query}"`
        }
      ],
      max_tokens: 300,
      temperature: 0.7
    });

    return completion.choices[0]?.message?.content || "I'd be happy to discuss this with you personally. Please contact me directly.";
  }

  private async notifySupplierAboutFAQSuggestion(supplierId: string, query: any, suggestedAnswer: string) {
    // Implementation would send email/notification to supplier
    // about the suggested FAQ entry for review and approval
  }
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Ref MCP: Search docs for OpenAI SDK, Supabase patterns
- [x] PostgreSQL MCP: Database operations for fallback tracking
- [x] Supabase MCP: Real-time notifications and authentication
- [x] Sequential Thinking MCP: Complex fallback decision tree planning
- [ ] Browser MCP: Interactive testing of fallback flows
- [ ] Filesystem MCP: Log file management for debugging

#### Ref MCP Searches Needed
```bash
# Use Ref MCP to search for:
# - "OpenAI confidence scoring best practices"
# - "Supabase real-time subscriptions patterns"
# - "React error boundary components"
# - "TypeScript discriminated unions for AI responses"
```

#### Browser MCP Interactive Testing
```bash
# Use Browser MCP for:
# - Test fallback messages appear correctly
# - Verify contact escalation buttons work
# - Test suggestion clicking functionality  
# - Screenshot fallback UI states for documentation
# - Verify responsive design across devices
# - Test escalation flow from client perspective
```

#### Sequential Thinking MCP Planning (For Complex Features)
```yaml
# Use Sequential Thinking MCP to structure fallback decision logic:

# 1. Confidence Assessment
- How to determine when AI response is insufficient?
- What confidence thresholds work best for wedding context?
- How to balance being helpful vs being accurate?

# 2. Fallback Strategy Selection
- When to suggest similar questions vs escalate?
- How to personalize fallback messages by vendor type?
- What escalation urgency levels are needed?

# 3. Learning System Design
- How to identify patterns in unanswered questions?
- When to automatically suggest FAQ additions?
- How to balance automation with human oversight?

# 4. User Experience Flow
- How to make fallback feel natural, not like failure?
- What contact options to offer in different scenarios?
- How to maintain conversation context during escalation?
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('ChatbotFallbackService', () => {
  it('should return direct answer for high confidence (>0.8)', async () => {
    const service = new ChatbotFallbackService();
    const result = await service.handleResponse('What time is the ceremony?', 0.9);
    expect(result.type).toBe('direct');
  });

  it('should escalate to human for very low confidence (<0.4)', async () => {
    const service = new ChatbotFallbackService();
    const result = await service.handleResponse('Complex venue accessibility question', 0.2);
    expect(result.type).toBe('escalation');
    expect(result.contactOptions).toBeDefined();
  });

  it('should suggest similar questions for medium-low confidence', async () => {
    const service = new ChatbotFallbackService();
    const result = await service.handleResponse('Photo timeline question', 0.5);
    expect(result.type).toBe('suggestions');
    expect(result.suggestions.length).toBeLessThanOrEqual(3);
  });
});

describe('UnansweredQueryLearning', () => {
  it('should identify FAQ candidates based on frequency', async () => {
    const learning = new FallbackLearningSystem();
    const candidates = await learning.findFAQCandidates('supplier-123');
    expect(candidates.every(c => c.frequency >= 5)).toBe(true);
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP for automated testing
test('Fallback flow - low confidence response', async () => {
  await mcp__playwright__browser_navigate({url: '/chat/supplier-123'});
  
  // Send message that will trigger fallback
  await mcp__playwright__browser_type({
    element: 'chat input',
    ref: 'input[data-testid="chat-input"]',
    text: 'Can you accommodate my wheelchair-bound grandfather?'
  });
  
  await mcp__playwright__browser_click({
    element: 'send button',
    ref: 'button[data-testid="send-button"]'
  });
  
  // Verify fallback response appears
  await mcp__playwright__browser_wait_for({text: 'connect you directly'});
  
  // Take screenshot for documentation
  await mcp__playwright__browser_take_screenshot({
    filename: 'fallback-response-wheelchair-question.png',
    fullPage: false
  });
  
  // Verify contact options are present
  const snapshot = await mcp__playwright__browser_snapshot();
  expect(snapshot).toContain('Contact options');
});

test('Escalation urgency assessment', async () => {
  await mcp__playwright__browser_navigate({url: '/chat/supplier-123'});
  
  // Test urgent query
  await mcp__playwright__browser_type({
    element: 'chat input',
    ref: 'input[data-testid="chat-input"]',
    text: 'Emergency - wedding is tomorrow and need help!'
  });
  
  // Verify high urgency escalation
  await mcp__playwright__browser_wait_for({text: 'urgent'});
  
  // Verify phone option is prioritized for urgent queries
  const phoneButton = await mcp__playwright__browser_snapshot();
  expect(phoneButton).toContain('Call now');
});
```

#### Interactive Testing with Browser MCP
```typescript
// Use Browser MCP during development for immediate feedback
// 1. Navigate to chat interface
await browser_navigate('/chat/demo-photographer');

// 2. Test various confidence scenarios
const testQueries = [
  { query: 'What time should we arrive?', expectedType: 'direct' },
  { query: 'Can you do drone photography?', expectedType: 'qualified' },
  { query: 'Special accessibility needs for ceremony', expectedType: 'escalation' }
];

for (const test of testQueries) {
  // Send query
  await browser_type('input[data-testid="chat-input"]', test.query);
  await browser_click('button[data-testid="send-button"]');
  
  // Capture response
  await browser_take_screenshot(`fallback-test-${test.expectedType}.png`);
  
  // Verify response type matches expectation
  const response = await browser_evaluate('() => document.querySelector("[data-testid=chat-response]").textContent');
  console.log(`Query: ${test.query} -> Response type: ${test.expectedType}`);
}

// 3. Test mobile responsive fallback UI
await browser_resize(375, 667);
await browser_take_screenshot('fallback-mobile-view.png');
```

### ACCEPTANCE CRITERIA
- [x] **Confidence Scoring**: AI responses include confidence scores (0-1 scale)
- [x] **Fallback Hierarchy**: Different strategies for different confidence ranges (>0.8 direct, 0.6-0.8 qualified, 0.4-0.6 suggestions, <0.4 escalation)
- [x] **Graceful Messages**: Professional, helpful fallback messages that don't feel like AI failure
- [x] **Contact Escalation**: Automatic escalation with urgency assessment and appropriate contact options
- [x] **Learning System**: Tracks unanswered queries and suggests FAQ additions for frequent questions (threshold: 5+ occurrences)
- [x] **Error Recovery**: Technical errors result in helpful messages, not error codes
- [ ] Performance: Fallback responses generated within 2 seconds
- [ ] Security: All user queries logged securely with proper data retention policies
- [ ] Accessibility: Fallback UI components meet WCAG 2.1 AA standards
- [x] **Navigation Integration: Feature properly integrated into parent dashboard/navigation (MANDATORY for all UI features)**
  - [x] Fallback responses integrated into existing chat interface
  - [x] Mobile chat interface supports fallback flows
  - [x] Contact escalation buttons maintain chat context
  - [x] Breadcrumbs show "Chat Support" when in fallback mode
  - [x] Accessibility labels for fallback action buttons
  - [x] Navigation integration verified with Browser MCP testing

### DEPENDENCIES
- Must complete after: WS-247 (AI Chatbot Knowledge Base) - needs existing chatbot infrastructure
- Must complete before: WS-250 (Chatbot Analytics Dashboard) - analytics will track fallback metrics
- Shares code with: WS-124 (AI Email Templates) - similar confidence scoring logic

### ESTIMATED EFFORT
- Team A Frontend: 16 hours (FallbackResponse component, chat UI updates)
- Team B Backend: 24 hours (fallback service, learning system, database schema)
- Team C Integration: 8 hours (contact escalation, notification integration)
- Team D Platform: 4 hours (monitoring and error tracking setup)
- Team E General: 12 hours (testing, documentation, QA)
- Team F Workflows: 6 hours (fallback workflow design and testing)
- Team G Performance: 4 hours (response time optimization, caching)
- Total: 74 hours