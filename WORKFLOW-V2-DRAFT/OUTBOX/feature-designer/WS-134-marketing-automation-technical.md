# TECHNICAL SPECIFICATION: WS-134 - Marketing Automation
## Generated by Feature Development Session - 2025-01-23

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** WedSync marketing manager driving viral growth and user acquisition
**I want to:** Automate the viral loop where couples invite suppliers and suppliers invite couples through intelligent trigger-based campaigns
**So that:** We achieve viral coefficient >1.0, reduce customer acquisition cost by 60%, and increase referral conversion rate to 35%+

**Real Business Scenario:**
A wedding photographer joins WedSync and immediately receives a personalized welcome sequence. When they add their first client couple, the system automatically sends the couple a branded invitation to join their photographer's workspace. The couple's acceptance triggers a sequence that helps them invite other suppliers (DJ, florist, caterer). Each supplier invitation creates new viral loops. Within 60 days, this single photographer acquisition generates 12 new platform users across 4 weddings, reducing our effective customer acquisition cost from $180 to $15 per user.

### SPECIFICATION SOURCE
- **Feature ID:** WS-134
- **Original Spec:** /CORE-SPECIFICATIONS/13-BUSINESS-OPERATIONS/04-marketing-automation md.md
- **Current Implementation:** 0% complete
- **Files to Modify:** None (new feature)
- **New Files to Create:**
  - /src/lib/marketing/viral-engine.ts
  - /src/lib/marketing/campaign-automation.ts
  - /src/lib/marketing/attribution-tracker.ts
  - /src/lib/marketing/referral-incentives.ts
  - /src/app/api/marketing/viral/track/route.ts
  - /src/app/api/marketing/campaigns/trigger/route.ts
  - /src/app/api/marketing/attribution/route.ts
  - /src/components/marketing/ReferralWidget.tsx
  - /src/components/marketing/CampaignDashboard.tsx
  - /src/components/marketing/InvitationFlow.tsx

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Marketing campaigns and automation
CREATE TABLE IF NOT EXISTS marketing_campaigns (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  campaign_type TEXT NOT NULL, -- 'email_sequence', 'in_app_message', 'referral_campaign', 'onboarding_flow'
  target_audience JSONB NOT NULL, -- {"user_type": ["suppliers"], "vendor_types": ["photography"], "signup_source": ["referral"]}
  trigger_conditions JSONB NOT NULL, -- {"event": "user_signup", "delay_hours": 0, "filters": {...}}
  content_templates JSONB NOT NULL, -- {"subject": "...", "body": "...", "cta": "..."}
  personalization_rules JSONB DEFAULT '{}', -- Rules for dynamic content
  a_b_test_variants JSONB DEFAULT '{}', -- A/B testing configurations
  status TEXT DEFAULT 'draft' CHECK (status IN ('draft', 'active', 'paused', 'completed')),
  success_metrics JSONB DEFAULT '{}', -- {"primary": "conversion_rate", "secondary": ["open_rate", "click_rate"]}
  budget_limit DECIMAL(10,2),
  start_date TIMESTAMP,
  end_date TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- User attribution and referral tracking
CREATE TABLE IF NOT EXISTS attribution (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES user_profiles(id),
  user_type TEXT NOT NULL, -- 'supplier', 'couple'
  signup_source TEXT NOT NULL, -- 'organic', 'couple_invite', 'supplier_invite', 'paid_ad', 'content_marketing', 'referral_code'
  referrer_id UUID REFERENCES user_profiles(id),
  referrer_type TEXT, -- 'supplier', 'couple', 'admin'
  invitation_id UUID, -- References specific invitation sent
  campaign_id UUID REFERENCES marketing_campaigns(id),
  landing_page TEXT,
  utm_source TEXT,
  utm_medium TEXT,
  utm_campaign TEXT,
  utm_content TEXT,
  conversion_value DECIMAL(10,2) DEFAULT 0, -- LTV or subscription value
  conversion_date TIMESTAMP,
  attribution_model TEXT DEFAULT 'first_touch', -- 'first_touch', 'last_touch', 'multi_touch'
  created_at TIMESTAMP DEFAULT NOW()
);

-- Viral actions and invitation tracking
CREATE TABLE IF NOT EXISTS viral_actions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  actor_id UUID REFERENCES user_profiles(id),
  actor_type TEXT NOT NULL, -- 'supplier', 'couple'
  action_type TEXT NOT NULL, -- 'sent_invite', 'accepted_invite', 'activated_account', 'made_referral'
  target_email TEXT,
  target_user_id UUID REFERENCES user_profiles(id),
  invitation_type TEXT, -- 'couple_to_supplier', 'supplier_to_couple', 'supplier_to_supplier'
  wedding_context JSONB, -- {"wedding_id": "...", "wedding_date": "...", "venue": "..."}
  invitation_template TEXT,
  personalization_data JSONB DEFAULT '{}',
  status TEXT DEFAULT 'sent' CHECK (status IN ('sent', 'delivered', 'opened', 'clicked', 'accepted', 'expired')),
  tracking_code TEXT UNIQUE,
  sent_at TIMESTAMP DEFAULT NOW(),
  opened_at TIMESTAMP,
  clicked_at TIMESTAMP,
  accepted_at TIMESTAMP,
  conversion_value DECIMAL(8,2) DEFAULT 0,
  viral_coefficient_contribution DECIMAL(4,3) DEFAULT 0, -- This action's contribution to K-factor
  created_at TIMESTAMP DEFAULT NOW()
);

-- Marketing automation sequences and flows
CREATE TABLE IF NOT EXISTS automation_sequences (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  sequence_name TEXT NOT NULL,
  sequence_type TEXT NOT NULL, -- 'onboarding', 'nurture', 'win_back', 'upsell', 'referral_encouragement'
  trigger_event TEXT NOT NULL, -- 'user_signup', 'client_added', 'trial_started', 'subscription_canceled'
  target_user_types TEXT[] DEFAULT '{"supplier"}',
  sequence_steps JSONB NOT NULL, -- [{"step": 1, "delay_hours": 0, "action": "send_email", "template": "welcome", "conditions": {...}}]
  success_criteria JSONB DEFAULT '{}', -- {"completion_rate": 0.8, "conversion_rate": 0.25}
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Sequence execution tracking
CREATE TABLE IF NOT EXISTS sequence_executions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  sequence_id UUID REFERENCES automation_sequences(id),
  user_id UUID REFERENCES user_profiles(id),
  current_step INTEGER DEFAULT 1,
  status TEXT DEFAULT 'active' CHECK (status IN ('active', 'completed', 'paused', 'failed')),
  started_at TIMESTAMP DEFAULT NOW(),
  last_action_at TIMESTAMP,
  completed_at TIMESTAMP,
  conversion_achieved BOOLEAN DEFAULT false,
  conversion_value DECIMAL(10,2) DEFAULT 0,
  steps_completed INTEGER DEFAULT 0,
  total_steps INTEGER,
  personalization_context JSONB DEFAULT '{}', -- User-specific data for personalization
  created_at TIMESTAMP DEFAULT NOW()
);

-- A/B testing for marketing optimization
CREATE TABLE IF NOT EXISTS marketing_experiments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  experiment_name TEXT NOT NULL,
  experiment_type TEXT NOT NULL, -- 'email_subject', 'cta_button', 'invitation_template', 'incentive_structure'
  campaign_id UUID REFERENCES marketing_campaigns(id),
  variants JSONB NOT NULL, -- [{"variant": "A", "content": {...}, "traffic_allocation": 0.5}]
  success_metric TEXT NOT NULL, -- 'conversion_rate', 'click_rate', 'viral_coefficient'
  minimum_sample_size INTEGER DEFAULT 100,
  confidence_level DECIMAL(3,2) DEFAULT 0.95,
  start_date TIMESTAMP DEFAULT NOW(),
  end_date TIMESTAMP,
  status TEXT DEFAULT 'running' CHECK (status IN ('draft', 'running', 'completed', 'paused')),
  winner_variant TEXT,
  statistical_significance DECIMAL(3,2),
  results_summary JSONB DEFAULT '{}',
  created_at TIMESTAMP DEFAULT NOW()
);

-- Referral incentives and rewards
CREATE TABLE IF NOT EXISTS referral_incentives (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  incentive_name TEXT NOT NULL,
  referrer_reward_type TEXT, -- 'account_credit', 'feature_unlock', 'subscription_discount', 'cash_reward'
  referrer_reward_value DECIMAL(8,2),
  referee_reward_type TEXT, -- 'signup_bonus', 'trial_extension', 'subscription_discount'
  referee_reward_value DECIMAL(8,2),
  qualification_criteria JSONB NOT NULL, -- {"min_referrals": 1, "referee_must_subscribe": true, "time_limit_days": 30}
  reward_caps JSONB DEFAULT '{}', -- {"max_per_month": 5, "max_total": 50}
  is_active BOOLEAN DEFAULT true,
  valid_from TIMESTAMP DEFAULT NOW(),
  valid_until TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Viral coefficient and growth metrics
CREATE TABLE IF NOT EXISTS viral_metrics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  calculation_date DATE DEFAULT CURRENT_DATE,
  period_type TEXT DEFAULT 'daily', -- 'daily', 'weekly', 'monthly'
  new_users_count INTEGER DEFAULT 0,
  invitations_sent INTEGER DEFAULT 0,
  invitations_accepted INTEGER DEFAULT 0,
  viral_coefficient DECIMAL(4,3) DEFAULT 0, -- K-factor calculation
  organic_signups INTEGER DEFAULT 0,
  referred_signups INTEGER DEFAULT 0,
  supplier_to_couple_conversions INTEGER DEFAULT 0,
  couple_to_supplier_conversions INTEGER DEFAULT 0,
  average_invitation_per_user DECIMAL(4,2) DEFAULT 0,
  conversion_rate DECIMAL(4,3) DEFAULT 0,
  cycle_time_days DECIMAL(4,1) DEFAULT 0, -- Average time from signup to first referral
  created_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(calculation_date, period_type)
);

-- Campaign performance analytics
CREATE TABLE IF NOT EXISTS campaign_analytics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  campaign_id UUID REFERENCES marketing_campaigns(id),
  metric_date DATE DEFAULT CURRENT_DATE,
  impressions INTEGER DEFAULT 0,
  opens INTEGER DEFAULT 0,
  clicks INTEGER DEFAULT 0,
  conversions INTEGER DEFAULT 0,
  conversion_value DECIMAL(10,2) DEFAULT 0,
  cost DECIMAL(8,2) DEFAULT 0,
  roas DECIMAL(6,2) DEFAULT 0, -- Return on ad spend
  viral_actions_generated INTEGER DEFAULT 0,
  secondary_conversions INTEGER DEFAULT 0, -- Conversions from viral actions
  created_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(campaign_id, metric_date)
);
```

#### API Endpoints Required
```typescript
// POST /api/marketing/viral/track
interface TrackViralActionRequest {
  actorId: string;
  actionType: 'sent_invite' | 'accepted_invite' | 'activated_account';
  targetEmail?: string;
  targetUserId?: string;
  invitationType: 'couple_to_supplier' | 'supplier_to_couple' | 'supplier_to_supplier';
  weddingContext?: WeddingContext;
  metadata?: any;
}

interface TrackViralActionResponse {
  success: boolean;
  actionId: string;
  trackingCode: string;
  viralCoefficientContribution: number;
  incentiveTriggered?: IncentiveDetails;
}

// POST /api/marketing/campaigns/trigger
interface TriggerCampaignRequest {
  userId: string;
  triggerEvent: string;
  eventData?: any;
  forceExecution?: boolean; // Override frequency limits for testing
}

interface CampaignTriggerResponse {
  success: boolean;
  campaignsTriggered: string[];
  sequencesStarted: string[];
  estimatedDeliveryTime: string;
}

// GET /api/marketing/attribution/:userId
interface AttributionResponse {
  success: boolean;
  attribution: {
    source: string;
    referrer?: UserProfile;
    campaign?: CampaignDetails;
    conversionPath: AttributionTouch[];
    ltv: number;
    virality: {
      invitationsSent: number;
      conversionsGenerated: number;
      personalViralCoefficient: number;
    };
  };
}

// GET /api/marketing/viral-metrics
interface ViralMetricsResponse {
  success: boolean;
  current: {
    viralCoefficient: number;
    period: string;
    trend: 'up' | 'down' | 'stable';
  };
  breakdown: {
    invitationsSent: number;
    acceptanceRate: number;
    averageInvitationsPerUser: number;
    cycleTime: number;
  };
  topPerformers: TopReferrer[];
  recommendations: OptimizationRecommendation[];
}
```

#### Frontend Components Required
```typescript
// Component: ReferralWidget
// Location: /src/components/marketing/ReferralWidget.tsx

interface ReferralWidgetProps {
  userId: string;
  userType: 'supplier' | 'couple';
  currentReferrals: number;
  availableIncentives: ReferralIncentive[];
  onInviteSent: (email: string, type: InvitationType) => void;
}

interface InvitationType {
  type: 'couple_to_supplier' | 'supplier_to_couple' | 'supplier_to_supplier';
  description: string;
  expectedConversion: number;
  incentiveValue: number;
}

interface ReferralIncentive {
  id: string;
  name: string;
  description: string;
  referrerReward: string;
  refereeReward: string;
  progress: {
    current: number;
    target: number;
    completed: boolean;
  };
  expiryDate?: string;
}

interface CampaignPerformanceMetrics {
  campaignId: string;
  name: string;
  type: string;
  status: 'active' | 'paused' | 'completed';
  metrics: {
    impressions: number;
    opens: number;
    clicks: number;
    conversions: number;
    conversionRate: number;
    viralActionsGenerated: number;
    roas: number;
  };
  trends: {
    period: string;
    changePercent: number;
    direction: 'up' | 'down' | 'stable';
  };
}

// Key functionality:
- Smart invitation targeting based on user context
- Real-time viral coefficient tracking and optimization
- Personalized referral incentive management
- A/B testing integration for campaign optimization
- Attribution tracking across multi-touch conversion paths
- Automated sequence management with personalization
```

#### Integration Points
```typescript
// Service: ViralMarketingEngine
// Dependencies: Email automation, user analytics, incentive management, A/B testing

class ViralMarketingEngine {
  async trackViralAction(action: ViralActionData): Promise<ViralActionResult> {
    // Record viral action in database
    // Calculate contribution to viral coefficient
    // Trigger follow-up automation sequences
    // Check for incentive qualifications
    // Update attribution models
  }
  
  async calculateViralCoefficient(period: 'daily' | 'weekly' | 'monthly'): Promise<ViralMetrics> {
    // K-factor = (invitations per user) × (conversion rate)
    // Analyze by user segment and invitation type
    // Track viral loops and amplification effects
    // Generate optimization recommendations
  }
  
  async optimizeInvitationFlow(userId: string, context: InvitationContext): Promise<OptimizedInvitation> {
    // AI-powered invitation personalization
    // Optimal timing based on user behavior
    // Dynamic incentive selection
    // A/B testing integration
  }
}
```

### CODE EXAMPLES

#### Example 1: Viral Engine with Attribution Tracking and Campaign Automation
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { addHours, format } from 'date-fns';

interface WeddingContext {
  weddingId?: string;
  weddingDate?: string;
  venue?: string;
  guestCount?: number;
  budget?: number;
}

interface ViralActionData {
  actorId: string;
  actionType: 'sent_invite' | 'accepted_invite' | 'activated_account' | 'made_referral';
  targetEmail?: string;
  targetUserId?: string;
  invitationType: 'couple_to_supplier' | 'supplier_to_couple' | 'supplier_to_supplier';
  weddingContext?: WeddingContext;
  metadata?: any;
}

const VIRAL_ACTION_VALUES = {
  'sent_invite': 0.1, // Base viral coefficient contribution
  'accepted_invite': 0.3,
  'activated_account': 0.5,
  'made_referral': 0.8 // Highest value - creates secondary viral loops
};

export class ViralMarketingEngine {
  private supabase = createClient();

  async trackViralAction(actionData: ViralActionData): Promise<ViralActionResult> {
    try {
      // Generate unique tracking code
      const trackingCode = this.generateTrackingCode(actionData);
      
      // Calculate viral coefficient contribution
      const viralContribution = this.calculateViralContribution(actionData);
      
      // Record viral action
      const { data: viralAction, error } = await this.supabase
        .from('viral_actions')
        .insert({
          actor_id: actionData.actorId,
          actor_type: await this.getUserType(actionData.actorId),
          action_type: actionData.actionType,
          target_email: actionData.targetEmail,
          target_user_id: actionData.targetUserId,
          invitation_type: actionData.invitationType,
          wedding_context: actionData.weddingContext || {},
          tracking_code: trackingCode,
          viral_coefficient_contribution: viralContribution,
          personalization_data: actionData.metadata || {}
        })
        .select('*')
        .single();

      if (error) throw error;

      // Update attribution if target user exists
      if (actionData.targetUserId) {
        await this.updateAttribution(actionData.targetUserId, actionData.actorId, viralAction.id);
      }

      // Check for referral incentive qualifications
      const incentiveDetails = await this.checkReferralIncentives(actionData.actorId, actionData);

      // Trigger follow-up automation sequences
      await this.triggerFollowupSequences(actionData);

      // Update viral metrics
      await this.updateViralMetrics(actionData);

      return {
        success: true,
        actionId: viralAction.id,
        trackingCode,
        viralCoefficientContribution: viralContribution,
        incentiveTriggered: incentiveDetails
      };

    } catch (error) {
      console.error('Viral action tracking failed:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Viral tracking failed'
      };
    }
  }

  private calculateViralContribution(actionData: ViralActionData): number {
    const baseValue = VIRAL_ACTION_VALUES[actionData.actionType] || 0;
    
    // Apply multipliers based on invitation type
    const typeMultipliers = {
      'couple_to_supplier': 1.2, // High value - suppliers are key growth drivers
      'supplier_to_couple': 1.0, // Standard value
      'supplier_to_supplier': 1.5 // Highest value - creates network effects
    };
    
    const typeMultiplier = typeMultipliers[actionData.invitationType] || 1.0;
    
    // Apply context multipliers
    let contextMultiplier = 1.0;
    if (actionData.weddingContext?.guestCount && actionData.weddingContext.guestCount > 100) {
      contextMultiplier = 1.3; // Larger weddings have more viral potential
    }
    
    return baseValue * typeMultiplier * contextMultiplier;
  }

  async calculateViralCoefficient(
    period: 'daily' | 'weekly' | 'monthly' = 'daily'
  ): Promise<ViralMetrics> {
    try {
      const startDate = this.getStartDateForPeriod(period);
      const endDate = new Date();

      // Get viral actions for the period
      const { data: viralActions } = await this.supabase
        .from('viral_actions')
        .select('*')
        .gte('created_at', startDate.toISOString())
        .lte('created_at', endDate.toISOString());

      // Get new user signups for the period
      const { data: newUsers } = await this.supabase
        .from('user_profiles')
        .select('id, created_at')
        .gte('created_at', startDate.toISOString())
        .lte('created_at', endDate.toISOString());

      // Calculate metrics
      const invitationsSent = viralActions?.filter(a => a.action_type === 'sent_invite').length || 0;
      const invitationsAccepted = viralActions?.filter(a => a.action_type === 'accepted_invite').length || 0;
      const newUsersWhoInvited = await this.countNewUsersWhoInvited(newUsers || [], startDate, endDate);
      
      // K-factor = (invitations sent per new user) × (acceptance rate)
      const invitationsPerUser = newUsers && newUsers.length > 0 ? invitationsSent / newUsers.length : 0;
      const acceptanceRate = invitationsSent > 0 ? invitationsAccepted / invitationsSent : 0;
      const viralCoefficient = invitationsPerUser * acceptanceRate;

      // Calculate cycle time (days from signup to first invitation)
      const avgCycleTime = await this.calculateAverageCycleTime(startDate, endDate);

      // Save metrics
      await this.supabase
        .from('viral_metrics')
        .upsert({
          calculation_date: format(endDate, 'yyyy-MM-dd'),
          period_type: period,
          new_users_count: newUsers?.length || 0,
          invitations_sent: invitationsSent,
          invitations_accepted: invitationsAccepted,
          viral_coefficient: viralCoefficient,
          average_invitation_per_user: invitationsPerUser,
          conversion_rate: acceptanceRate,
          cycle_time_days: avgCycleTime
        });

      return {
        viralCoefficient,
        invitationsSent,
        invitationsAccepted,
        acceptanceRate,
        invitationsPerUser,
        avgCycleTime,
        trend: await this.calculateTrend(period, viralCoefficient),
        recommendations: await this.generateOptimizationRecommendations(viralCoefficient, {
          invitationsPerUser,
          acceptanceRate,
          avgCycleTime
        })
      };

    } catch (error) {
      console.error('Viral coefficient calculation failed:', error);
      return {
        viralCoefficient: 0,
        invitationsSent: 0,
        invitationsAccepted: 0,
        acceptanceRate: 0,
        invitationsPerUser: 0,
        avgCycleTime: 0,
        trend: 'stable',
        recommendations: []
      };
    }
  }

  async triggerAutomatedCampaign(
    userId: string,
    triggerEvent: string,
    eventData?: any
  ): Promise<CampaignTriggerResult> {
    try {
      // Find applicable campaigns
      const { data: campaigns } = await this.supabase
        .from('marketing_campaigns')
        .select('*')
        .eq('status', 'active')
        .contains('trigger_conditions', { event: triggerEvent });

      if (!campaigns || campaigns.length === 0) {
        return { success: true, campaignsTriggered: [], message: 'No applicable campaigns found' };
      }

      const triggeredCampaigns: string[] = [];

      for (const campaign of campaigns) {
        // Check if user matches target audience
        if (await this.userMatchesAudience(userId, campaign.target_audience)) {
          
          // Check trigger conditions
          if (await this.evaluateTriggerConditions(userId, campaign.trigger_conditions, eventData)) {
            
            // Check frequency limits
            if (await this.checkFrequencyLimits(userId, campaign.id)) {
              
              // Execute campaign
              await this.executeCampaign(userId, campaign, eventData);
              triggeredCampaigns.push(campaign.id);
            }
          }
        }
      }

      // Also check for automation sequences
      const sequencesStarted = await this.triggerAutomationSequences(userId, triggerEvent, eventData);

      return {
        success: true,
        campaignsTriggered: triggeredCampaigns,
        sequencesStarted,
        message: `${triggeredCampaigns.length} campaigns and ${sequencesStarted.length} sequences triggered`
      };

    } catch (error) {
      console.error('Campaign trigger failed:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Campaign trigger failed'
      };
    }
  }

  private async executeCampaign(
    userId: string,
    campaign: any,
    eventData?: any
  ): Promise<void> {
    // Get user data for personalization
    const { data: user } = await this.supabase
      .from('user_profiles')
      .select('*')
      .eq('id', userId)
      .single();

    if (!user) throw new Error('User not found');

    // Apply personalization rules
    const personalizedContent = await this.personalizeContent(
      campaign.content_templates,
      user,
      eventData
    );

    // Handle A/B testing if configured
    const finalContent = await this.applyAbTesting(
      personalizedContent,
      campaign.a_b_test_variants,
      userId
    );

    // Execute based on campaign type
    switch (campaign.campaign_type) {
      case 'email_sequence':
        await this.sendMarketingEmail(userId, finalContent, campaign.id);
        break;
      
      case 'in_app_message':
        await this.createInAppMessage(userId, finalContent, campaign.id);
        break;
      
      case 'referral_campaign':
        await this.triggerReferralCampaign(userId, finalContent, campaign.id);
        break;
      
      default:
        console.warn(`Unknown campaign type: ${campaign.campaign_type}`);
    }

    // Track campaign execution
    await this.trackCampaignExecution(userId, campaign.id, finalContent);
  }

  private async personalizeContent(
    templates: any,
    user: any,
    eventData?: any
  ): Promise<any> {
    let personalized = { ...templates };

    // Replace placeholder variables
    const personalizations = {
      '{{first_name}}': user.first_name || 'there',
      '{{business_name}}': user.business_name || 'your business',
      '{{vendor_type}}': user.vendor_type || 'wedding vendor',
      '{{days_since_signup}}': this.calculateDaysSinceSignup(user.created_at),
      '{{client_count}}': await this.getClientCount(user.id),
      '{{recent_activity}}': await this.getRecentActivity(user.id)
    };

    // Apply personalizations
    Object.keys(personalizations).forEach(placeholder => {
      if (personalized.subject) {
        personalized.subject = personalized.subject.replace(
          new RegExp(placeholder, 'g'), 
          personalizations[placeholder]
        );
      }
      if (personalized.body) {
        personalized.body = personalized.body.replace(
          new RegExp(placeholder, 'g'), 
          personalizations[placeholder]
        );
      }
    });

    // Add dynamic recommendations based on user behavior
    if (eventData?.event === 'trial_started') {
      personalized.recommendations = await this.generateTrialRecommendations(user);
    }

    return personalized;
  }

  async checkReferralIncentives(
    userId: string,
    viralAction: ViralActionData
  ): Promise<IncentiveDetails | null> {
    try {
      // Get active referral incentives
      const { data: incentives } = await this.supabase
        .from('referral_incentives')
        .select('*')
        .eq('is_active', true)
        .lte('valid_from', new Date().toISOString())
        .or('valid_until.is.null,valid_until.gte.' + new Date().toISOString());

      if (!incentives || incentives.length === 0) return null;

      // Check user's referral history
      const { data: userReferrals } = await this.supabase
        .from('viral_actions')
        .select('*')
        .eq('actor_id', userId)
        .eq('action_type', 'sent_invite');

      for (const incentive of incentives) {
        const qualificationCriteria = incentive.qualification_criteria;
        const currentReferrals = userReferrals?.length || 0;

        // Check qualification criteria
        if (currentReferrals >= (qualificationCriteria.min_referrals || 1)) {
          
          // Check if referee subscribed (if required)
          if (qualificationCriteria.referee_must_subscribe && viralAction.targetUserId) {
            const { data: targetSubscription } = await this.supabase
              .from('user_subscriptions')
              .select('status')
              .eq('user_id', viralAction.targetUserId)
              .single();

            if (!targetSubscription || targetSubscription.status !== 'active') {
              continue; // Skip this incentive
            }
          }

          // Check reward caps
          const rewardCaps = incentive.reward_caps;
          if (rewardCaps.max_per_month || rewardCaps.max_total) {
            const capExceeded = await this.checkRewardCaps(userId, incentive.id, rewardCaps);
            if (capExceeded) continue;
          }

          // Incentive qualified - process reward
          await this.processReferralReward(userId, viralAction.targetUserId, incentive);

          return {
            incentiveId: incentive.id,
            incentiveName: incentive.incentive_name,
            referrerReward: {
              type: incentive.referrer_reward_type,
              value: incentive.referrer_reward_value
            },
            refereeReward: {
              type: incentive.referee_reward_type,
              value: incentive.referee_reward_value
            }
          };
        }
      }

      return null;

    } catch (error) {
      console.error('Referral incentive check failed:', error);
      return null;
    }
  }

  private async generateOptimizationRecommendations(
    viralCoefficient: number,
    metrics: {
      invitationsPerUser: number;
      acceptanceRate: number;
      avgCycleTime: number;
    }
  ): Promise<OptimizationRecommendation[]> {
    const recommendations: OptimizationRecommendation[] = [];

    // K-factor recommendations
    if (viralCoefficient < 1.0) {
      if (metrics.invitationsPerUser < 2.0) {
        recommendations.push({
          type: 'increase_invitation_frequency',
          priority: 'high',
          description: 'Users are not sending enough invitations. Consider stronger incentives or better prompts.',
          expectedImpact: '+15-25% viral coefficient',
          implementation: 'Add invitation reminders and referral rewards'
        });
      }

      if (metrics.acceptanceRate < 0.3) {
        recommendations.push({
          type: 'improve_invitation_quality',
          priority: 'high',
          description: 'Invitation acceptance rate is low. Improve personalization and value proposition.',
          expectedImpact: '+20-35% acceptance rate',
          implementation: 'A/B test invitation templates and incentives'
        });
      }
    }

    // Cycle time recommendations
    if (metrics.avgCycleTime > 7) {
      recommendations.push({
        type: 'reduce_activation_time',
        priority: 'medium',
        description: 'Users take too long to make their first referral. Improve onboarding.',
        expectedImpact: '+10-20% viral coefficient',
        implementation: 'Add referral prompts in onboarding flow'
      });
    }

    // Growth recommendations
    if (viralCoefficient >= 1.0) {
      recommendations.push({
        type: 'scale_successful_channels',
        priority: 'medium',
        description: 'Viral coefficient is healthy. Focus on scaling successful acquisition channels.',
        expectedImpact: '+30-50% user growth',
        implementation: 'Increase marketing spend on high-converting channels'
      });
    }

    return recommendations;
  }
}

// Background job for viral metrics calculation
export async function calculateDailyViralMetrics() {
  const viralEngine = new ViralMarketingEngine();
  
  try {
    await viralEngine.calculateViralCoefficient('daily');
    console.log('Daily viral metrics calculated successfully');
  } catch (error) {
    console.error('Daily viral metrics calculation failed:', error);
  }
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [ ] Context7: Load marketing automation and viral growth patterns
- [ ] Playwright: Test referral flows, campaign triggers, and conversion funnels
- [ ] PostgreSQL: Manage campaign data, viral tracking, and attribution models

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/marketing-automation/viral-loops", "viral coefficient optimization", 3000);
await mcp__context7__get-library-docs("/attribution/multi-touch", "marketing attribution models", 2500);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('ViralMarketingEngine', () => {
  it('should calculate viral coefficient accurately', async () => {
    const mockData = {
      newUsers: 100,
      invitationsSent: 250,
      invitationsAccepted: 75,
      usersWhoInvited: 80
    };
    
    const metrics = await viralEngine.calculateViralCoefficient('daily');
    
    expect(metrics.viralCoefficient).toBeCloseTo(1.875); // (250/100) * (75/250)
    expect(metrics.invitationsPerUser).toBe(2.5);
    expect(metrics.acceptanceRate).toBe(0.3);
  });

  it('should track viral actions and update attribution', async () => {
    const viralAction = {
      actorId: 'supplier-123',
      actionType: 'sent_invite',
      targetEmail: 'couple@example.com',
      invitationType: 'supplier_to_couple',
      weddingContext: { weddingId: 'wedding-456' }
    };
    
    const result = await viralEngine.trackViralAction(viralAction);
    
    expect(result.success).toBe(true);
    expect(result.trackingCode).toBeTruthy();
    expect(result.viralCoefficientContribution).toBeGreaterThan(0);
  });

  it('should trigger relevant campaigns based on user events', async () => {
    const userId = 'test-user-id';
    const triggerEvent = 'client_added';
    
    const result = await viralEngine.triggerAutomatedCampaign(userId, triggerEvent);
    
    expect(result.success).toBe(true);
    expect(result.campaignsTriggered).toHaveLength.greaterThan(0);
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Complete viral referral flow', async () => {
  // Supplier sends invitation to couple
  await mcp__playwright__browser_navigate({url: '/dashboard/clients'});
  
  await mcp__playwright__browser_click({
    element: 'Invite Couple Button',
    ref: 'button.invite-couple'
  });
  
  await mcp__playwright__browser_type({
    element: 'Couple Email Input',
    ref: 'input[name="coupleEmail"]',
    text: 'newcouple@example.com'
  });
  
  await mcp__playwright__browser_type({
    element: 'Personal Message',
    ref: 'textarea[name="personalMessage"]',
    text: 'Hi! I\'d love to help you plan your wedding. Join my WedSync workspace to get started!'
  });
  
  await mcp__playwright__browser_click({
    element: 'Send Invitation',
    ref: 'button[type="submit"]'
  });
  
  // Verify invitation sent
  await mcp__playwright__browser_wait_for({text: 'Invitation sent successfully'});
  
  // Simulate couple clicking invitation link
  const invitationUrl = await fetch('/api/test/get-latest-invitation', {
    method: 'POST',
    body: JSON.stringify({ email: 'newcouple@example.com' })
  }).then(r => r.json()).then(data => data.invitationUrl);
  
  await mcp__playwright__browser_navigate({url: invitationUrl});
  
  // Complete couple signup
  await mcp__playwright__browser_type({
    element: 'First Name Input',
    ref: 'input[name="firstName"]',
    text: 'John'
  });
  
  await mcp__playwright__browser_type({
    element: 'Partner Name Input',
    ref: 'input[name="partnerName"]',
    text: 'Jane'
  });
  
  await mcp__playwright__browser_click({
    element: 'Join Workspace Button',
    ref: 'button.join-workspace'
  });
  
  // Verify viral tracking
  await mcp__playwright__browser_wait_for({text: 'Welcome to WedSync'});
  
  // Check that viral action was tracked
  const viralAction = await fetch('/api/test/get-viral-action', {
    method: 'POST',
    body: JSON.stringify({ email: 'newcouple@example.com' })
  }).then(r => r.json());
  
  expect(viralAction.actionType).toBe('accepted_invite');
  expect(viralAction.invitationType).toBe('supplier_to_couple');
  
  await mcp__playwright__browser_snapshot();
});

test('Marketing campaign automation and personalization', async () => {
  // Set up test user with specific attributes
  await fetch('/api/test/setup-user', {
    method: 'POST',
    body: JSON.stringify({
      userId: 'test-user',
      vendorType: 'photography',
      daysSinceSignup: 7,
      clientCount: 0,
      trialStatus: 'active'
    })
  });
  
  // Trigger campaign automation
  await fetch('/api/marketing/campaigns/trigger', {
    method: 'POST',
    body: JSON.stringify({
      userId: 'test-user',
      triggerEvent: 'trial_day_7_no_clients'
    })
  });
  
  // Verify campaign was triggered
  await mcp__playwright__browser_navigate({url: '/admin/marketing/campaigns'});
  
  await mcp__playwright__browser_wait_for({text: 'Recent Campaign Executions'});
  await mcp__playwright__browser_wait_for({text: 'trial_day_7_no_clients'});
  
  // Check personalized content
  const campaignExecution = await mcp__playwright__browser_evaluate({
    function: `() => {
      const row = document.querySelector('tr[data-trigger="trial_day_7_no_clients"]');
      return {
        subject: row.querySelector('.subject').textContent,
        content: row.querySelector('.content-preview').textContent
      };
    }`
  });
  
  expect(campaignExecution.subject).toContain('photography'); // Personalized by vendor type
  expect(campaignExecution.content).toContain('7 days'); // Personalized by days since signup
  
  await mcp__playwright__browser_snapshot();
});
```

### ACCEPTANCE CRITERIA
- [ ] Achieve viral coefficient >1.0 through automated invitation flows
- [ ] Track 100% of viral actions with accurate attribution
- [ ] Automate 90% of marketing campaigns based on user behavior triggers
- [ ] Support multi-touch attribution across 5+ conversion paths
- [ ] Process referral incentives with 99.9% accuracy
- [ ] A/B testing framework for 10+ campaign elements
- [ ] Reduce customer acquisition cost by 60% through viral growth
- [ ] Generate personalized content for 8+ user segments
- [ ] Real-time viral metrics dashboard with trend analysis
- [ ] Scale to handle 10,000+ viral actions per day

### DEPENDENCIES
- Must complete after: WS-133 (Customer Success System) - Provides user intelligence
- Must complete before: WS-135 (Viral Optimization System)
- Shares code with: Email automation, user analytics, subscription management

### ESTIMATED EFFORT
- Team A Frontend: 22 hours (Referral widgets, campaign dashboard, invitation flows)
- Team B Backend: 42 hours (Viral tracking, attribution modeling, campaign automation)
- Team C Integration: 26 hours (Email integration, A/B testing, analytics pipeline)
- Total: 90 hours