# TECHNICAL SPECIFICATION: WS-224 - Progress Charts System
## Generated by Feature Development Session - January 25, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding professional managing post-wedding deliverables
**I want to:** Create visual progress charts showing delivery milestones with automated client notifications
**So that:** Clients stay informed about progress, reducing anxiety and support requests while building trust

**Real Wedding Scenario:**
"Timeless Memories Photography" creates a progress chart for photo editing with 6 stages: "Images Backed Up" → "Culling Complete" → "Editing in Progress" → "Quality Review" → "Gallery Ready" → "Delivered". As Sarah completes each stage, the progress bar updates automatically, clients receive email notifications, and estimated completion dates adjust based on her historical performance. This transparency reduces "where are my photos?" emails by 80% and increases client satisfaction scores.

### SPECIFICATION SOURCE
- **Feature ID:** WS-224
- **Original Spec:** /CORE-SPECIFICATIONS/02-WEDSYNC-SUPPLIER-PLATFORM/07-Client-Dashboard-Builder/06-progress-charts md.md
- **Current Implementation:** 0% complete (new)
- **Files to Modify:** None (new feature)
- **New Files to Create:** 
  - `/src/app/(dashboard)/progress-charts/page.tsx`
  - `/src/app/(dashboard)/progress-charts/new/page.tsx`
  - `/src/app/(dashboard)/progress-charts/[id]/edit/page.tsx`
  - `/src/components/progress/ProgressChartBuilder.tsx`
  - `/src/components/progress/ProgressVisualizer.tsx`
  - `/src/components/progress/StageEditor.tsx`
  - `/src/components/progress/ClientProgressView.tsx`
  - `/src/components/progress/ProgressAnalytics.tsx`
  - `/src/lib/services/progressService.ts`
  - `/src/lib/utils/progressUtils.ts`
  - `/src/types/progress.ts`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Progress chart templates and configurations
CREATE TABLE IF NOT EXISTS progress_charts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES suppliers(id),
  name VARCHAR(255) NOT NULL,
  description TEXT,
  chart_type VARCHAR(50) DEFAULT 'linear' CHECK (chart_type IN ('linear', 'circular', 'kanban', 'milestone', 'timeline')),
  display_type VARCHAR(50) DEFAULT 'progress_bar' CHECK (display_type IN ('progress_bar', 'checklist', 'timeline', 'kanban_board', 'pie_chart')),
  show_percentage BOOLEAN DEFAULT true,
  show_estimated_completion BOOLEAN DEFAULT true,
  allow_client_input BOOLEAN DEFAULT false,
  client_interaction_type VARCHAR(50) DEFAULT 'view_only' CHECK (client_interaction_type IN ('view_only', 'approve_stages', 'provide_feedback', 'upload_files')),
  auto_advance_stages BOOLEAN DEFAULT false,
  send_stage_notifications BOOLEAN DEFAULT true,
  color_scheme JSONB DEFAULT '{"primary": "#4F46E5", "completed": "#10B981", "pending": "#9CA3AF", "in_progress": "#F59E0B"}',
  is_template BOOLEAN DEFAULT false,
  is_active BOOLEAN DEFAULT true,
  category VARCHAR(100), -- e.g., 'photography', 'catering', 'planning'
  estimated_total_duration_days INTEGER,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Individual stages within progress charts
CREATE TABLE IF NOT EXISTS progress_stages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  chart_id UUID REFERENCES progress_charts(id) ON DELETE CASCADE,
  name VARCHAR(255) NOT NULL,
  description TEXT,
  stage_order INTEGER NOT NULL,
  estimated_duration_hours INTEGER,
  is_required BOOLEAN DEFAULT true,
  requires_client_approval BOOLEAN DEFAULT false,
  requires_file_upload BOOLEAN DEFAULT false,
  stage_icon VARCHAR(50),
  stage_color VARCHAR(7),
  success_criteria TEXT, -- What defines completion of this stage
  client_instructions TEXT, -- Instructions for clients if they need to take action
  supplier_notes TEXT, -- Internal notes for suppliers
  notification_template_id UUID, -- Reference to email template for stage completion
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Progress chart instances for specific clients/projects
CREATE TABLE IF NOT EXISTS progress_instances (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  chart_id UUID REFERENCES progress_charts(id),
  client_id UUID REFERENCES clients(id),
  project_name VARCHAR(255),
  project_type VARCHAR(100), -- 'wedding', 'engagement', 'elopement'
  current_stage_id UUID REFERENCES progress_stages(id),
  overall_progress_percentage DECIMAL(5,2) DEFAULT 0,
  status VARCHAR(20) DEFAULT 'active' CHECK (status IN ('active', 'completed', 'paused', 'cancelled')),
  started_at TIMESTAMPTZ DEFAULT NOW(),
  target_completion_date DATE,
  actual_completion_date DATE,
  client_satisfaction_rating INTEGER CHECK (client_satisfaction_rating >= 1 AND client_satisfaction_rating <= 5),
  client_feedback TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Individual stage completion tracking
CREATE TABLE IF NOT EXISTS stage_completions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  instance_id UUID REFERENCES progress_instances(id) ON DELETE CASCADE,
  stage_id UUID REFERENCES progress_stages(id),
  status VARCHAR(20) DEFAULT 'pending' CHECK (status IN ('pending', 'in_progress', 'completed', 'skipped', 'blocked')),
  started_at TIMESTAMPTZ,
  completed_at TIMESTAMPTZ,
  estimated_completion_date DATE,
  actual_duration_hours DECIMAL(8,2),
  completed_by UUID, -- User who marked it complete
  completion_notes TEXT,
  client_approved_at TIMESTAMPTZ,
  client_feedback TEXT,
  quality_score INTEGER CHECK (quality_score >= 1 AND quality_score <= 10),
  files_uploaded JSONB DEFAULT '[]', -- Array of uploaded file metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Client interactions with progress charts
CREATE TABLE IF NOT EXISTS progress_interactions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  instance_id UUID REFERENCES progress_instances(id) ON DELETE CASCADE,
  stage_id UUID REFERENCES progress_stages(id),
  client_id UUID REFERENCES clients(id),
  interaction_type VARCHAR(50) NOT NULL CHECK (interaction_type IN ('view', 'approve', 'feedback', 'file_upload', 'question')),
  interaction_data JSONB DEFAULT '{}',
  ip_address INET,
  user_agent TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Email notifications for progress updates
CREATE TABLE IF NOT EXISTS progress_notifications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  instance_id UUID REFERENCES progress_instances(id) ON DELETE CASCADE,
  stage_id UUID REFERENCES progress_stages(id),
  notification_type VARCHAR(50) NOT NULL CHECK (notification_type IN ('stage_started', 'stage_completed', 'approval_needed', 'milestone_reached', 'delay_warning')),
  recipient_email VARCHAR(255) NOT NULL,
  subject VARCHAR(255) NOT NULL,
  email_content TEXT NOT NULL,
  scheduled_at TIMESTAMPTZ DEFAULT NOW(),
  sent_at TIMESTAMPTZ,
  delivery_status VARCHAR(20) DEFAULT 'pending' CHECK (delivery_status IN ('pending', 'sent', 'delivered', 'failed', 'bounced')),
  opened_at TIMESTAMPTZ,
  clicked_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Progress analytics and metrics
CREATE TABLE IF NOT EXISTS progress_analytics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  chart_id UUID REFERENCES progress_charts(id),
  supplier_id UUID REFERENCES suppliers(id),
  analytics_date DATE NOT NULL,
  total_instances INTEGER DEFAULT 0,
  completed_instances INTEGER DEFAULT 0,
  average_completion_time_days DECIMAL(8,2),
  client_satisfaction_avg DECIMAL(3,2),
  bottleneck_stage_id UUID REFERENCES progress_stages(id),
  most_delayed_stage_id UUID REFERENCES progress_stages(id),
  on_time_completion_rate DECIMAL(5,2),
  client_approval_avg_time_hours DECIMAL(8,2),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(chart_id, analytics_date)
);

-- Progress chart templates for common workflows
INSERT INTO progress_charts (id, supplier_id, name, description, chart_type, category, is_template) VALUES 
('aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa', '00000000-0000-0000-0000-000000000000', 'Wedding Photography Workflow', 'Standard photo editing and delivery process', 'linear', 'photography', true),
('bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb', '00000000-0000-0000-0000-000000000000', 'Video Production Pipeline', 'Complete video editing and delivery workflow', 'timeline', 'videography', true),
('cccccccc-cccc-cccc-cccc-cccccccccccc', '00000000-0000-0000-0000-000000000000', 'Event Planning Milestones', 'Wedding planning progress tracking', 'milestone', 'planning', true),
('dddddddd-dddd-dddd-dddd-dddddddddddd', '00000000-0000-0000-0000-000000000000', 'Catering Preparation', 'Food preparation and delivery stages', 'kanban', 'catering', true)
ON CONFLICT DO NOTHING;

-- Sample progress stages for photography workflow
INSERT INTO progress_stages (chart_id, name, description, stage_order, estimated_duration_hours, stage_icon) VALUES 
('aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa', 'Images Backed Up', 'All wedding photos safely backed up to cloud storage', 1, 2, 'shield-check'),
('aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa', 'Culling Complete', 'Best images selected from the full collection', 2, 8, 'filter'),
('aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa', 'Editing in Progress', 'Professional editing and color correction underway', 3, 24, 'image'),
('aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa', 'Quality Review', 'Final quality check and corrections', 4, 4, 'eye'),
('aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa', 'Gallery Ready', 'Online gallery prepared with all edited photos', 5, 2, 'layout'),
('aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa', 'Delivered', 'Gallery link sent and physical products shipped', 6, 1, 'check-circle')
ON CONFLICT DO NOTHING;

-- RLS Policies
ALTER TABLE progress_charts ENABLE ROW LEVEL SECURITY;
ALTER TABLE progress_stages ENABLE ROW LEVEL SECURITY;
ALTER TABLE progress_instances ENABLE ROW LEVEL SECURITY;
ALTER TABLE stage_completions ENABLE ROW LEVEL SECURITY;
ALTER TABLE progress_interactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE progress_notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE progress_analytics ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Suppliers manage their progress charts" ON progress_charts
  FOR ALL USING (auth.uid() = supplier_id OR is_template = true OR
                 auth.uid() IN (SELECT user_id FROM team_members WHERE supplier_id = progress_charts.supplier_id));

CREATE POLICY "Progress stages belong to supplier charts" ON progress_stages
  FOR ALL USING (auth.uid() IN (
    SELECT pc.supplier_id FROM progress_charts pc WHERE pc.id = progress_stages.chart_id
  ) OR EXISTS (
    SELECT 1 FROM progress_charts pc WHERE pc.id = progress_stages.chart_id AND pc.is_template = true
  ));

CREATE POLICY "Progress instances belong to supplier" ON progress_instances
  FOR ALL USING (auth.uid() IN (
    SELECT pc.supplier_id FROM progress_charts pc WHERE pc.id = progress_instances.chart_id
  ));

CREATE POLICY "Stage completions belong to supplier instances" ON stage_completions
  FOR ALL USING (auth.uid() IN (
    SELECT pc.supplier_id FROM progress_charts pc 
    JOIN progress_instances pi ON pi.chart_id = pc.id 
    WHERE pi.id = stage_completions.instance_id
  ));

CREATE POLICY "Progress interactions readable by supplier" ON progress_interactions
  FOR SELECT USING (auth.uid() IN (
    SELECT pc.supplier_id FROM progress_charts pc 
    JOIN progress_instances pi ON pi.chart_id = pc.id 
    WHERE pi.id = progress_interactions.instance_id
  ));

CREATE POLICY "Progress notifications belong to supplier" ON progress_notifications
  FOR ALL USING (auth.uid() IN (
    SELECT pc.supplier_id FROM progress_charts pc 
    JOIN progress_instances pi ON pi.chart_id = pc.id 
    WHERE pi.id = progress_notifications.instance_id
  ));

CREATE POLICY "Progress analytics belong to supplier" ON progress_analytics
  FOR ALL USING (auth.uid() = supplier_id);

-- Indexes for performance
CREATE INDEX idx_progress_charts_supplier_id ON progress_charts(supplier_id);
CREATE INDEX idx_progress_charts_category ON progress_charts(category, is_template);
CREATE INDEX idx_progress_stages_chart_id ON progress_stages(chart_id, stage_order);
CREATE INDEX idx_progress_instances_chart_client ON progress_instances(chart_id, client_id);
CREATE INDEX idx_progress_instances_status ON progress_instances(status, target_completion_date);
CREATE INDEX idx_stage_completions_instance_id ON stage_completions(instance_id);
CREATE INDEX idx_stage_completions_status ON stage_completions(status, estimated_completion_date);
CREATE INDEX idx_progress_interactions_instance_id ON progress_interactions(instance_id, created_at);
CREATE INDEX idx_progress_notifications_scheduled ON progress_notifications(scheduled_at) WHERE delivery_status = 'pending';
CREATE INDEX idx_progress_analytics_date ON progress_analytics(chart_id, analytics_date);

-- Functions and triggers
CREATE OR REPLACE FUNCTION update_progress_modified()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_progress_instances_modified
  BEFORE UPDATE ON progress_instances
  FOR EACH ROW EXECUTE FUNCTION update_progress_modified();

CREATE TRIGGER update_stage_completions_modified
  BEFORE UPDATE ON stage_completions
  FOR EACH ROW EXECUTE FUNCTION update_progress_modified();

-- Function to calculate overall progress percentage
CREATE OR REPLACE FUNCTION calculate_progress_percentage(instance_id_param UUID)
RETURNS DECIMAL AS $$
DECLARE
  total_stages INTEGER;
  completed_stages INTEGER;
  progress_percent DECIMAL;
BEGIN
  SELECT COUNT(*) INTO total_stages
  FROM progress_stages ps
  JOIN progress_instances pi ON pi.chart_id = ps.chart_id
  WHERE pi.id = instance_id_param;
  
  SELECT COUNT(*) INTO completed_stages
  FROM stage_completions sc
  WHERE sc.instance_id = instance_id_param
  AND sc.status = 'completed';
  
  IF total_stages > 0 THEN
    progress_percent := (completed_stages::DECIMAL / total_stages::DECIMAL) * 100;
  ELSE
    progress_percent := 0;
  END IF;
  
  RETURN ROUND(progress_percent, 2);
END;
$$ LANGUAGE plpgsql;

-- Function to update progress when stage is completed
CREATE OR REPLACE FUNCTION update_instance_progress()
RETURNS TRIGGER AS $$
DECLARE
  new_progress DECIMAL;
  next_stage_id UUID;
BEGIN
  -- Calculate new overall progress
  new_progress := calculate_progress_percentage(NEW.instance_id);
  
  -- Get next pending stage
  SELECT ps.id INTO next_stage_id
  FROM progress_stages ps
  JOIN progress_instances pi ON pi.chart_id = ps.chart_id
  LEFT JOIN stage_completions sc ON sc.stage_id = ps.id AND sc.instance_id = NEW.instance_id
  WHERE pi.id = NEW.instance_id
  AND (sc.status IS NULL OR sc.status = 'pending')
  ORDER BY ps.stage_order
  LIMIT 1;
  
  -- Update progress instance
  UPDATE progress_instances 
  SET 
    overall_progress_percentage = new_progress,
    current_stage_id = COALESCE(next_stage_id, current_stage_id),
    status = CASE 
      WHEN new_progress >= 100 THEN 'completed'
      ELSE status
    END,
    actual_completion_date = CASE 
      WHEN new_progress >= 100 THEN CURRENT_DATE
      ELSE actual_completion_date
    END,
    updated_at = NOW()
  WHERE id = NEW.instance_id;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_instance_progress_trigger
  AFTER UPDATE ON stage_completions
  FOR EACH ROW
  WHEN (NEW.status = 'completed' AND OLD.status != 'completed')
  EXECUTE FUNCTION update_instance_progress();

-- Function to generate estimated completion dates
CREATE OR REPLACE FUNCTION update_estimated_dates(instance_id_param UUID)
RETURNS VOID AS $$
DECLARE
  stage_record RECORD;
  current_date DATE := CURRENT_DATE;
  working_hours_per_day INTEGER := 8;
BEGIN
  FOR stage_record IN
    SELECT sc.id, ps.estimated_duration_hours, sc.status
    FROM stage_completions sc
    JOIN progress_stages ps ON ps.id = sc.stage_id
    WHERE sc.instance_id = instance_id_param
    AND sc.status IN ('pending', 'in_progress')
    ORDER BY ps.stage_order
  LOOP
    -- Calculate estimated completion date based on working hours
    UPDATE stage_completions
    SET estimated_completion_date = current_date + CEILING(stage_record.estimated_duration_hours::DECIMAL / working_hours_per_day)::INTEGER
    WHERE id = stage_record.id;
    
    -- Move to next stage start date
    current_date := current_date + CEILING(stage_record.estimated_duration_hours::DECIMAL / working_hours_per_day)::INTEGER;
  END LOOP;
END;
$$ LANGUAGE plpgsql;
```

#### TypeScript Interfaces
```typescript
// /src/types/progress.ts
export interface ProgressChart {
  id: string;
  supplier_id: string;
  name: string;
  description: string | null;
  chart_type: 'linear' | 'circular' | 'kanban' | 'milestone' | 'timeline';
  display_type: 'progress_bar' | 'checklist' | 'timeline' | 'kanban_board' | 'pie_chart';
  show_percentage: boolean;
  show_estimated_completion: boolean;
  allow_client_input: boolean;
  client_interaction_type: 'view_only' | 'approve_stages' | 'provide_feedback' | 'upload_files';
  auto_advance_stages: boolean;
  send_stage_notifications: boolean;
  color_scheme: {
    primary: string;
    completed: string;
    pending: string;
    in_progress: string;
  };
  is_template: boolean;
  is_active: boolean;
  category: string | null;
  estimated_total_duration_days: number | null;
  created_at: string;
  updated_at: string;
  // Relations
  stages?: ProgressStage[];
  instances?: ProgressInstance[];
  analytics?: ProgressAnalytics[];
}

export interface ProgressStage {
  id: string;
  chart_id: string;
  name: string;
  description: string | null;
  stage_order: number;
  estimated_duration_hours: number | null;
  is_required: boolean;
  requires_client_approval: boolean;
  requires_file_upload: boolean;
  stage_icon: string | null;
  stage_color: string | null;
  success_criteria: string | null;
  client_instructions: string | null;
  supplier_notes: string | null;
  notification_template_id: string | null;
  created_at: string;
  // Relations
  completions?: StageCompletion[];
}

export interface ProgressInstance {
  id: string;
  chart_id: string;
  client_id: string;
  project_name: string | null;
  project_type: string | null;
  current_stage_id: string | null;
  overall_progress_percentage: number;
  status: 'active' | 'completed' | 'paused' | 'cancelled';
  started_at: string;
  target_completion_date: string | null;
  actual_completion_date: string | null;
  client_satisfaction_rating: number | null;
  client_feedback: string | null;
  created_at: string;
  updated_at: string;
  // Relations
  chart?: ProgressChart;
  client?: any; // Client interface
  current_stage?: ProgressStage;
  stage_completions?: StageCompletion[];
  interactions?: ProgressInteraction[];
  notifications?: ProgressNotification[];
}

export interface StageCompletion {
  id: string;
  instance_id: string;
  stage_id: string;
  status: 'pending' | 'in_progress' | 'completed' | 'skipped' | 'blocked';
  started_at: string | null;
  completed_at: string | null;
  estimated_completion_date: string | null;
  actual_duration_hours: number | null;
  completed_by: string | null;
  completion_notes: string | null;
  client_approved_at: string | null;
  client_feedback: string | null;
  quality_score: number | null;
  files_uploaded: FileUpload[];
  created_at: string;
  updated_at: string;
  // Relations
  stage?: ProgressStage;
  instance?: ProgressInstance;
}

export interface ProgressInteraction {
  id: string;
  instance_id: string;
  stage_id: string | null;
  client_id: string;
  interaction_type: 'view' | 'approve' | 'feedback' | 'file_upload' | 'question';
  interaction_data: any;
  ip_address: string | null;
  user_agent: string | null;
  created_at: string;
}

export interface ProgressNotification {
  id: string;
  instance_id: string;
  stage_id: string | null;
  notification_type: 'stage_started' | 'stage_completed' | 'approval_needed' | 'milestone_reached' | 'delay_warning';
  recipient_email: string;
  subject: string;
  email_content: string;
  scheduled_at: string;
  sent_at: string | null;
  delivery_status: 'pending' | 'sent' | 'delivered' | 'failed' | 'bounced';
  opened_at: string | null;
  clicked_at: string | null;
  created_at: string;
}

export interface ProgressAnalytics {
  id: string;
  chart_id: string;
  supplier_id: string;
  analytics_date: string;
  total_instances: number;
  completed_instances: number;
  average_completion_time_days: number | null;
  client_satisfaction_avg: number | null;
  bottleneck_stage_id: string | null;
  most_delayed_stage_id: string | null;
  on_time_completion_rate: number | null;
  client_approval_avg_time_hours: number | null;
  created_at: string;
  // Relations
  bottleneck_stage?: ProgressStage;
  most_delayed_stage?: ProgressStage;
}

export interface FileUpload {
  id: string;
  file_name: string;
  file_url: string;
  file_size: number;
  mime_type: string;
  uploaded_at: string;
}

export interface ProgressChartTemplate {
  id: string;
  name: string;
  description: string;
  category: string;
  chart_type: string;
  display_type: string;
  stages: Array<{
    name: string;
    description: string;
    estimated_duration_hours: number;
    stage_icon: string;
    requires_client_approval: boolean;
  }>;
}

export interface ProgressMetrics {
  completion_rate: number;
  average_duration_days: number;
  client_satisfaction: number;
  on_time_delivery_rate: number;
  bottlenecks: Array<{
    stage_name: string;
    average_delay_days: number;
  }>;
  trends: Array<{
    date: string;
    completion_rate: number;
    satisfaction: number;
  }>;
}

export interface ClientProgressView {
  instance: ProgressInstance;
  stages: Array<{
    stage: ProgressStage;
    completion: StageCompletion;
    is_current: boolean;
    can_interact: boolean;
  }>;
  overall_progress: number;
  estimated_completion: string | null;
  next_milestone: {
    stage_name: string;
    estimated_date: string;
  } | null;
  recent_updates: Array<{
    stage_name: string;
    status: string;
    updated_at: string;
    notes: string | null;
  }>;
}
```

#### API Endpoints Required

**1. GET /api/progress-charts**
```typescript
// /src/app/api/progress-charts/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { getCurrentSupplier } from '@/lib/auth/server';

export async function GET(request: NextRequest) {
  try {
    const supplier = await getCurrentSupplier();
    const supabase = createClient();
    const { searchParams } = new URL(request.url);
    
    const include_templates = searchParams.get('templates') === 'true';
    const category = searchParams.get('category');

    let query = supabase
      .from('progress_charts')
      .select(`
        *,
        stages:progress_stages(*),
        instances:progress_instances(
          id,
          client_id,
          project_name,
          status,
          overall_progress_percentage,
          created_at
        ),
        _count:progress_instances(count)
      `)
      .eq('is_active', true)
      .order('created_at', { ascending: false });

    if (include_templates) {
      query = query.or(`supplier_id.eq.${supplier.id},is_template.eq.true`);
    } else {
      query = query.eq('supplier_id', supplier.id);
    }

    if (category) {
      query = query.eq('category', category);
    }

    const { data: charts, error } = await query;

    if (error) throw error;

    return NextResponse.json({ charts: charts || [] });

  } catch (error) {
    console.error('Error fetching progress charts:', error);
    return NextResponse.json(
      { error: 'Failed to fetch progress charts' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const supplier = await getCurrentSupplier();
    const supabase = createClient();
    const chartData = await request.json();

    // Create progress chart
    const { data: chart, error: chartError } = await supabase
      .from('progress_charts')
      .insert({
        supplier_id: supplier.id,
        ...chartData,
        is_template: false
      })
      .select()
      .single();

    if (chartError) throw chartError;

    // Create stages if provided
    if (chartData.stages && chartData.stages.length > 0) {
      const stagesData = chartData.stages.map((stage: any, index: number) => ({
        chart_id: chart.id,
        stage_order: index + 1,
        ...stage
      }));

      const { error: stagesError } = await supabase
        .from('progress_stages')
        .insert(stagesData);

      if (stagesError) throw stagesError;
    }

    return NextResponse.json({ 
      chart,
      message: 'Progress chart created successfully' 
    });

  } catch (error) {
    console.error('Error creating progress chart:', error);
    return NextResponse.json(
      { error: 'Failed to create progress chart' },
      { status: 500 }
    );
  }
}
```

**2. POST /api/progress-charts/[id]/instances**
```typescript
// /src/app/api/progress-charts/[id]/instances/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { getCurrentSupplier } from '@/lib/auth/server';

export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const supplier = await getCurrentSupplier();
    const supabase = createClient();
    const chartId = params.id;
    const instanceData = await request.json();

    // Verify chart ownership
    const { data: chart, error: chartError } = await supabase
      .from('progress_charts')
      .select(`
        id,
        stages:progress_stages(*)
      `)
      .eq('id', chartId)
      .or(`supplier_id.eq.${supplier.id},is_template.eq.true`)
      .single();

    if (chartError || !chart) {
      return NextResponse.json(
        { error: 'Progress chart not found' },
        { status: 404 }
      );
    }

    // Create progress instance
    const { data: instance, error: instanceError } = await supabase
      .from('progress_instances')
      .insert({
        chart_id: chartId,
        client_id: instanceData.client_id,
        project_name: instanceData.project_name,
        project_type: instanceData.project_type,
        target_completion_date: instanceData.target_completion_date,
        current_stage_id: chart.stages[0]?.id, // Start with first stage
        overall_progress_percentage: 0,
        status: 'active'
      })
      .select()
      .single();

    if (instanceError) throw instanceError;

    // Create stage completion records for all stages
    const stageCompletions = chart.stages.map((stage: any) => ({
      instance_id: instance.id,
      stage_id: stage.id,
      status: 'pending'
    }));

    const { error: completionsError } = await supabase
      .from('stage_completions')
      .insert(stageCompletions);

    if (completionsError) throw completionsError;

    // Update estimated completion dates
    await supabase.rpc('update_estimated_dates', {
      instance_id_param: instance.id
    });

    // Send initial notification if enabled
    if (chart.send_stage_notifications && chart.stages[0]) {
      await supabase
        .from('progress_notifications')
        .insert({
          instance_id: instance.id,
          stage_id: chart.stages[0].id,
          notification_type: 'stage_started',
          recipient_email: instanceData.client_email || '',
          subject: `${instanceData.project_name || 'Your Project'} - Progress Started`,
          email_content: `We've started working on your project! The first stage "${chart.stages[0].name}" is now underway.`
        });
    }

    return NextResponse.json({ 
      instance,
      message: 'Progress tracking started successfully' 
    });

  } catch (error) {
    console.error('Error creating progress instance:', error);
    return NextResponse.json(
      { error: 'Failed to start progress tracking' },
      { status: 500 }
    );
  }
}
```

**3. PUT /api/progress-instances/[id]/stages/[stageId]/complete**
```typescript
// /src/app/api/progress-instances/[id]/stages/[stageId]/complete/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { getCurrentUser } from '@/lib/auth/server';

export async function PUT(
  request: NextRequest,
  { params }: { params: { id: string; stageId: string } }
) {
  try {
    const user = await getCurrentUser();
    const supabase = createClient();
    const instanceId = params.id;
    const stageId = params.stageId;
    const completionData = await request.json();

    // Verify access to this instance
    const { data: instance, error: instanceError } = await supabase
      .from('progress_instances')
      .select(`
        id,
        chart:progress_charts(
          supplier_id,
          send_stage_notifications
        ),
        client_id,
        project_name
      `)
      .eq('id', instanceId)
      .single();

    if (instanceError || !instance) {
      return NextResponse.json(
        { error: 'Progress instance not found' },
        { status: 404 }
      );
    }

    // Check if user has permission (supplier or team member)
    if (user.role !== 'supplier' && !instance.chart.supplier_id === user.id) {
      // Check if user is team member
      const { data: teamMember } = await supabase
        .from('team_members')
        .select('id')
        .eq('supplier_id', instance.chart.supplier_id)
        .eq('user_id', user.id)
        .single();

      if (!teamMember) {
        return NextResponse.json(
          { error: 'Access denied' },
          { status: 403 }
        );
      }
    }

    // Get stage details
    const { data: stage, error: stageError } = await supabase
      .from('progress_stages')
      .select('*')
      .eq('id', stageId)
      .single();

    if (stageError || !stage) {
      return NextResponse.json(
        { error: 'Stage not found' },
        { status: 404 }
      );
    }

    // Update stage completion
    const completionUpdate = {
      status: 'completed',
      completed_at: new Date().toISOString(),
      completed_by: user.id,
      completion_notes: completionData.notes,
      quality_score: completionData.quality_score,
      files_uploaded: completionData.files_uploaded || []
    };

    // If stage wasn't in progress, mark start time
    const { data: existingCompletion } = await supabase
      .from('stage_completions')
      .select('started_at, status')
      .eq('instance_id', instanceId)
      .eq('stage_id', stageId)
      .single();

    if (!existingCompletion?.started_at) {
      completionUpdate.started_at = new Date().toISOString();
    }

    // Calculate actual duration
    if (existingCompletion?.started_at) {
      const startTime = new Date(existingCompletion.started_at);
      const endTime = new Date();
      const durationHours = (endTime.getTime() - startTime.getTime()) / (1000 * 60 * 60);
      completionUpdate.actual_duration_hours = Math.round(durationHours * 100) / 100;
    }

    const { data: completion, error: completionError } = await supabase
      .from('stage_completions')
      .update(completionUpdate)
      .eq('instance_id', instanceId)
      .eq('stage_id', stageId)
      .select()
      .single();

    if (completionError) throw completionError;

    // Send completion notification if enabled
    if (instance.chart.send_stage_notifications) {
      const { data: client } = await supabase
        .from('clients')
        .select('email, name')
        .eq('id', instance.client_id)
        .single();

      if (client?.email) {
        await supabase
          .from('progress_notifications')
          .insert({
            instance_id: instanceId,
            stage_id: stageId,
            notification_type: 'stage_completed',
            recipient_email: client.email,
            subject: `${instance.project_name || 'Your Project'} - ${stage.name} Complete`,
            email_content: `Great news! We've completed the "${stage.name}" stage of your project. ${completionData.notes ? 'Notes: ' + completionData.notes : ''}`
          });
      }
    }

    // Get updated progress percentage
    const { data: updatedInstance } = await supabase
      .from('progress_instances')
      .select('overall_progress_percentage, status')
      .eq('id', instanceId)
      .single();

    return NextResponse.json({ 
      completion,
      progress: updatedInstance?.overall_progress_percentage || 0,
      instance_status: updatedInstance?.status,
      message: 'Stage completed successfully' 
    });

  } catch (error) {
    console.error('Error completing stage:', error);
    return NextResponse.json(
      { error: 'Failed to complete stage' },
      { status: 500 }
    );
  }
}
```

#### React Components

**1. Progress Chart Builder**
```tsx
// /src/components/progress/ProgressChartBuilder.tsx
'use client';

import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Badge } from '@/components/ui/badge';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { 
  Plus,
  Settings,
  Eye,
  Save,
  BarChart3,
  CheckCircle,
  Clock,
  ArrowRight,
  GripVertical
} from 'lucide-react';
import { ProgressChart, ProgressStage } from '@/types/progress';
import { StageEditor } from './StageEditor';
import { ProgressVisualizer } from './ProgressVisualizer';
import { useToast } from '@/components/ui/use-toast';
import { DragDropContext, Droppable, Draggable } from '@hello-pangea/dnd';

interface ProgressChartBuilderProps {
  chart?: ProgressChart;
  onSave?: (chart: ProgressChart) => void;
}

export function ProgressChartBuilder({ chart, onSave }: ProgressChartBuilderProps) {
  const { toast } = useToast();
  const [formData, setFormData] = useState<Partial<ProgressChart>>({
    name: '',
    description: '',
    chart_type: 'linear',
    display_type: 'progress_bar',
    show_percentage: true,
    show_estimated_completion: true,
    allow_client_input: false,
    client_interaction_type: 'view_only',
    auto_advance_stages: false,
    send_stage_notifications: true,
    color_scheme: {
      primary: '#4F46E5',
      completed: '#10B981',
      pending: '#9CA3AF',
      in_progress: '#F59E0B'
    },
    category: 'general',
    estimated_total_duration_days: null,
    ...chart
  });

  const [stages, setStages] = useState<ProgressStage[]>(chart?.stages || []);
  const [editingStage, setEditingStage] = useState<ProgressStage | null>(null);
  const [previewMode, setPreviewMode] = useState(false);
  const [saving, setSaving] = useState(false);

  const handleAddStage = () => {
    const newStage: Partial<ProgressStage> = {
      chart_id: chart?.id || '',
      name: `Stage ${stages.length + 1}`,
      description: '',
      stage_order: stages.length + 1,
      estimated_duration_hours: 8,
      is_required: true,
      requires_client_approval: false,
      requires_file_upload: false,
      stage_icon: 'circle',
      stage_color: formData.color_scheme?.primary || '#4F46E5'
    };
    
    setStages([...stages, newStage as ProgressStage]);
  };

  const handleStageUpdate = (updatedStage: ProgressStage) => {
    setStages(stages.map(stage => 
      stage.id === updatedStage.id ? updatedStage : stage
    ));
    setEditingStage(null);
  };

  const handleDeleteStage = (stageId: string) => {
    if (confirm('Are you sure you want to delete this stage?')) {
      setStages(stages.filter(stage => stage.id !== stageId));
    }
  };

  const handleDragEnd = (result: any) => {
    if (!result.destination) return;

    const reorderedStages = Array.from(stages);
    const [movedStage] = reorderedStages.splice(result.source.index, 1);
    reorderedStages.splice(result.destination.index, 0, movedStage);

    // Update stage orders
    const updatedStages = reorderedStages.map((stage, index) => ({
      ...stage,
      stage_order: index + 1
    }));

    setStages(updatedStages);
  };

  const handleSave = async () => {
    if (!formData.name?.trim()) {
      toast({
        title: 'Error',
        description: 'Please enter a chart name',
        variant: 'destructive',
      });
      return;
    }

    if (stages.length === 0) {
      toast({
        title: 'Error',
        description: 'Please add at least one stage',
        variant: 'destructive',
      });
      return;
    }

    try {
      setSaving(true);
      
      const chartData = {
        ...formData,
        stages: stages.map((stage, index) => ({
          ...stage,
          stage_order: index + 1
        }))
      };

      const url = chart?.id ? `/api/progress-charts/${chart.id}` : '/api/progress-charts';
      const method = chart?.id ? 'PUT' : 'POST';

      const response = await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(chartData),
      });

      if (!response.ok) {
        throw new Error('Failed to save progress chart');
      }

      const result = await response.json();
      
      toast({
        title: 'Success',
        description: 'Progress chart saved successfully',
      });

      if (onSave) {
        onSave(result.chart);
      }

    } catch (error) {
      console.error('Error saving chart:', error);
      toast({
        title: 'Error',
        description: 'Failed to save progress chart',
        variant: 'destructive',
      });
    } finally {
      setSaving(false);
    }
  };

  return (
    <div className="container mx-auto p-6 max-w-7xl">
      <div className="flex justify-between items-center mb-6">
        <div>
          <h1 className="text-3xl font-bold">
            {chart ? 'Edit Progress Chart' : 'Create Progress Chart'}
          </h1>
          <p className="text-gray-600 mt-2">
            Design a custom progress tracking system for your client projects
          </p>
        </div>
        <div className="flex gap-2">
          <Button
            variant={previewMode ? 'default' : 'outline'}
            onClick={() => setPreviewMode(!previewMode)}
          >
            <Eye className="w-4 h-4 mr-2" />
            {previewMode ? 'Hide Preview' : 'Preview'}
          </Button>
          <Button onClick={handleSave} disabled={saving}>
            <Save className="w-4 h-4 mr-2" />
            {saving ? 'Saving...' : 'Save Chart'}
          </Button>
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Chart Configuration */}
        <div className={`${previewMode ? 'lg:col-span-1' : 'lg:col-span-3'} space-y-6`}>
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Settings className="w-5 h-5" />
                Chart Configuration
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                  <label className="block text-sm font-medium mb-2">
                    Chart Name *
                  </label>
                  <Input
                    placeholder="e.g., Wedding Photography Workflow"
                    value={formData.name}
                    onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium mb-2">
                    Category
                  </label>
                  <select
                    value={formData.category}
                    onChange={(e) => setFormData({ ...formData, category: e.target.value })}
                    className="w-full p-2 border rounded-md"
                  >
                    <option value="photography">Photography</option>
                    <option value="videography">Videography</option>
                    <option value="planning">Event Planning</option>
                    <option value="catering">Catering</option>
                    <option value="general">General</option>
                  </select>
                </div>
              </div>

              <div>
                <label className="block text-sm font-medium mb-2">
                  Description
                </label>
                <textarea
                  className="w-full p-2 border rounded-md"
                  rows={3}
                  placeholder="Describe what this progress chart tracks..."
                  value={formData.description}
                  onChange={(e) => setFormData({ ...formData, description: e.target.value })}
                />
              </div>

              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                  <label className="block text-sm font-medium mb-2">
                    Chart Type
                  </label>
                  <select
                    value={formData.chart_type}
                    onChange={(e) => setFormData({ ...formData, chart_type: e.target.value as any })}
                    className="w-full p-2 border rounded-md"
                  >
                    <option value="linear">Linear Progress</option>
                    <option value="circular">Circular Progress</option>
                    <option value="kanban">Kanban Board</option>
                    <option value="milestone">Milestone Timeline</option>
                    <option value="timeline">Timeline View</option>
                  </select>
                </div>
                <div>
                  <label className="block text-sm font-medium mb-2">
                    Display Type
                  </label>
                  <select
                    value={formData.display_type}
                    onChange={(e) => setFormData({ ...formData, display_type: e.target.value as any })}
                    className="w-full p-2 border rounded-md"
                  >
                    <option value="progress_bar">Progress Bar</option>
                    <option value="checklist">Checklist</option>
                    <option value="timeline">Timeline</option>
                    <option value="kanban_board">Kanban Board</option>
                    <option value="pie_chart">Pie Chart</option>
                  </select>
                </div>
              </div>

              <div className="space-y-3">
                <h4 className="font-medium">Display Options</h4>
                <div className="space-y-2">
                  {[
                    { key: 'show_percentage', label: 'Show percentage completion' },
                    { key: 'show_estimated_completion', label: 'Show estimated completion dates' },
                    { key: 'allow_client_input', label: 'Allow client interactions' },
                    { key: 'auto_advance_stages', label: 'Auto-advance to next stage' },
                    { key: 'send_stage_notifications', label: 'Send email notifications' }
                  ].map((option) => (
                    <label key={option.key} className="flex items-center space-x-2">
                      <input
                        type="checkbox"
                        checked={formData[option.key as keyof typeof formData] as boolean}
                        onChange={(e) => setFormData({ 
                          ...formData, 
                          [option.key]: e.target.checked 
                        })}
                      />
                      <span className="text-sm">{option.label}</span>
                    </label>
                  ))}
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Stages Management */}
          <Card>
            <CardHeader>
              <div className="flex justify-between items-center">
                <CardTitle className="flex items-center gap-2">
                  <BarChart3 className="w-5 h-5" />
                  Progress Stages ({stages.length})
                </CardTitle>
                <Button onClick={handleAddStage}>
                  <Plus className="w-4 h-4 mr-2" />
                  Add Stage
                </Button>
              </div>
            </CardHeader>
            <CardContent>
              {stages.length === 0 ? (
                <div className="text-center py-8">
                  <CheckCircle className="w-16 h-16 mx-auto text-gray-400 mb-4" />
                  <h3 className="text-lg font-semibold mb-2">No stages yet</h3>
                  <p className="text-gray-600 mb-4">
                    Add stages to define your progress workflow
                  </p>
                  <Button onClick={handleAddStage}>
                    <Plus className="w-4 h-4 mr-2" />
                    Add First Stage
                  </Button>
                </div>
              ) : (
                <DragDropContext onDragEnd={handleDragEnd}>
                  <Droppable droppableId="stages">
                    {(provided) => (
                      <div {...provided.droppableProps} ref={provided.innerRef} className="space-y-3">
                        {stages.map((stage, index) => (
                          <Draggable key={stage.id || index} draggableId={stage.id || index.toString()} index={index}>
                            {(provided, snapshot) => (
                              <div
                                ref={provided.innerRef}
                                {...provided.draggableProps}
                                className={`border rounded-lg p-4 ${
                                  snapshot.isDragging ? 'shadow-lg bg-white' : 'bg-gray-50'
                                }`}
                              >
                                <div className="flex items-center justify-between">
                                  <div className="flex items-center gap-3">
                                    <div {...provided.dragHandleProps}>
                                      <GripVertical className="w-4 h-4 text-gray-400" />
                                    </div>
                                    <div className="flex items-center gap-2">
                                      <div className="flex items-center justify-center w-8 h-8 rounded-full bg-primary text-white text-sm font-medium">
                                        {stage.stage_order || index + 1}
                                      </div>
                                      <div>
                                        <h4 className="font-medium">{stage.name}</h4>
                                        <p className="text-sm text-gray-600">{stage.description}</p>
                                      </div>
                                    </div>
                                  </div>
                                  <div className="flex items-center gap-2">
                                    {stage.estimated_duration_hours && (
                                      <Badge variant="outline" className="flex items-center gap-1">
                                        <Clock className="w-3 h-3" />
                                        {stage.estimated_duration_hours}h
                                      </Badge>
                                    )}
                                    {stage.requires_client_approval && (
                                      <Badge variant="outline">Approval Required</Badge>
                                    )}
                                    <Button
                                      size="sm"
                                      variant="outline"
                                      onClick={() => setEditingStage(stage)}
                                    >
                                      Edit
                                    </Button>
                                    <Button
                                      size="sm"
                                      variant="outline"
                                      onClick={() => handleDeleteStage(stage.id)}
                                      className="text-red-600"
                                    >
                                      Delete
                                    </Button>
                                  </div>
                                </div>
                              </div>
                            )}
                          </Draggable>
                        ))}
                        {provided.placeholder}
                      </div>
                    )}
                  </Droppable>
                </DragDropContext>
              )}
            </CardContent>
          </Card>
        </div>

        {/* Preview Panel */}
        {previewMode && (
          <div className="lg:col-span-2">
            <Card className="h-fit">
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Eye className="w-5 h-5" />
                  Preview
                </CardTitle>
              </CardHeader>
              <CardContent>
                <ProgressVisualizer
                  chart={{ ...formData, stages } as ProgressChart}
                  instanceData={{
                    overall_progress_percentage: 25,
                    current_stage_id: stages[1]?.id,
                    stage_completions: stages.map((stage, index) => ({
                      stage_id: stage.id,
                      status: index === 0 ? 'completed' : index === 1 ? 'in_progress' : 'pending',
                      estimated_completion_date: new Date(Date.now() + (index + 1) * 7 * 24 * 60 * 60 * 1000).toISOString()
                    }))
                  }}
                />
              </CardContent>
            </Card>
          </div>
        )}
      </div>

      {/* Stage Editor Modal */}
      {editingStage && (
        <StageEditor
          stage={editingStage}
          onSave={handleStageUpdate}
          onClose={() => setEditingStage(null)}
        />
      )}
    </div>
  );
}
```

### IMPLEMENTATION SUMMARY

This comprehensive progress charts system provides:

1. **Visual Progress Tracking** - Multiple chart types (linear, circular, kanban, timeline, milestone)
2. **Flexible Stage Configuration** - Customizable stages with duration estimates, client approvals, and file uploads
3. **Automated Client Notifications** - Email alerts for stage completions, milestones, and delays
4. **Real-time Progress Updates** - Live progress bars and completion percentages
5. **Client Interaction Features** - Approval workflows, feedback collection, and file uploads
6. **Analytics and Insights** - Performance metrics, bottleneck identification, and completion rates
7. **Template System** - Reusable workflow templates for different service categories
8. **Drag-and-Drop Stage Management** - Easy reordering and customization of workflow stages

The system enables wedding professionals to provide transparent, professional progress tracking that builds client trust, reduces support requests, and demonstrates value through clear milestone communication.

**Key Benefits for Wedding Professionals:**
- Reduced client anxiety and support requests (80% fewer "where are my photos?" emails)
- Enhanced client satisfaction through transparency
- Professional milestone communication and progress tracking  
- Automated notification system saving time
- Performance analytics to optimize delivery processes
- Flexible workflows adaptable to any service type
- Client interaction capabilities for approvals and feedback
- Historical data for accurate future estimates