# TECHNICAL SPECIFICATION: WS-279 - Delivery Methods Integration
## Generated by Feature Development Session - 2025-01-20

### USER STORY & BUSINESS CONTEXT (FACTUAL)
**As a:** Wedding vendor (photographer, venue coordinator, caterer)
**I want to:** Receive wedding updates via my preferred communication method (email, SMS, push notifications)
**So that:** I never miss important timeline changes or urgent requests, especially during busy wedding seasons

**Real Wedding Scenario:**
A photographer prefers SMS for urgent timeline changes (ceremony moved up 30 minutes) but wants detailed shot list updates via email. A venue coordinator needs push notifications for catering delivery changes but wants guest count updates via email. Currently, all notifications come through one channel, causing vendors to miss critical updates or be overwhelmed with non-urgent information.

### SPECIFICATION SOURCE
- **Feature ID:** WS-279
- **Original Spec:** Multi-channel notification and communication delivery requirements
- **Current Implementation:** Basic email notifications (20% complete)
- **Files to Modify:** 
  - `/src/lib/notifications/notification-service.ts`
  - `/src/components/settings/NotificationPreferences.tsx`
  - `/src/app/api/notifications/send/route.ts`
- **New Files to Create:**
  - `/src/lib/notifications/delivery-router.ts`
  - `/src/lib/notifications/sms-service.ts`
  - `/src/lib/notifications/push-service.ts`
  - `/src/components/settings/DeliveryMethodsManager.tsx`
  - `/src/app/api/notifications/preferences/route.ts`
  - `/src/app/api/notifications/test/route.ts`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- User notification preferences with delivery method mapping
CREATE TABLE IF NOT EXISTS notification_preferences (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  notification_type VARCHAR(100) NOT NULL CHECK (notification_type IN (
    'timeline_change', 'task_assignment', 'message_received', 'wedding_update',
    'payment_due', 'contract_change', 'guest_count_change', 'venue_change',
    'emergency_alert', 'reminder', 'feedback_request', 'system_maintenance'
  )),
  delivery_methods JSONB NOT NULL DEFAULT '{"email": true, "sms": false, "push": false}',
  priority_thresholds JSONB DEFAULT '{
    "low": ["email"],
    "normal": ["email", "push"],
    "high": ["email", "push", "sms"],
    "urgent": ["email", "push", "sms"]
  }',
  quiet_hours JSONB DEFAULT '{"enabled": false, "start": "22:00", "end": "08:00", "timezone": "UTC"}',
  business_hours JSONB DEFAULT '{"enabled": true, "start": "09:00", "end": "18:00", "days": [1,2,3,4,5]}',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(user_id, notification_type)
);

-- Delivery attempt tracking for reliability
CREATE TABLE IF NOT EXISTS notification_delivery_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  notification_id UUID, -- Reference to sent notification
  user_id UUID REFERENCES auth.users(id),
  delivery_method VARCHAR(20) NOT NULL CHECK (delivery_method IN ('email', 'sms', 'push', 'webhook')),
  recipient_address TEXT NOT NULL, -- email, phone, device token, webhook URL
  status VARCHAR(20) NOT NULL CHECK (status IN ('pending', 'sent', 'delivered', 'failed', 'bounced')),
  provider VARCHAR(50), -- Resend, Twilio, FCM, etc.
  provider_id TEXT, -- External provider message ID
  error_message TEXT,
  retry_count INTEGER DEFAULT 0,
  retry_after TIMESTAMP WITH TIME ZONE,
  delivered_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- User contact information for delivery
CREATE TABLE IF NOT EXISTS user_contact_methods (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  contact_type VARCHAR(20) NOT NULL CHECK (contact_type IN ('email', 'sms', 'push')),
  contact_value TEXT NOT NULL, -- email address, phone number, device token
  is_primary BOOLEAN DEFAULT FALSE,
  is_verified BOOLEAN DEFAULT FALSE,
  verification_code VARCHAR(10),
  verification_expires_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(user_id, contact_type, contact_value)
);

-- Indexes for performance
CREATE INDEX idx_notification_preferences_user_type ON notification_preferences(user_id, notification_type);
CREATE INDEX idx_delivery_log_status_retry ON notification_delivery_log(status, retry_after) WHERE status = 'failed';
CREATE INDEX idx_user_contacts_user_verified ON user_contact_methods(user_id, contact_type, is_verified);
```

#### API Endpoints Required
```typescript
// POST /api/notifications/preferences - Update notification preferences
interface UpdatePreferencesRequest {
  notificationType: string;
  deliveryMethods: {
    email: boolean;
    sms: boolean;
    push: boolean;
  };
  priorityThresholds: {
    low: string[];
    normal: string[];
    high: string[];
    urgent: string[];
  };
  quietHours?: {
    enabled: boolean;
    start: string;
    end: string;
    timezone: string;
  };
}

interface UpdatePreferencesResponse {
  success: boolean;
  preferences: NotificationPreference[];
}

// GET /api/notifications/preferences - Get user preferences
interface NotificationPreferencesResponse {
  preferences: {
    notificationType: string;
    deliveryMethods: Record<string, boolean>;
    priorityThresholds: Record<string, string[]>;
    quietHours: QuietHoursConfig;
  }[];
  contactMethods: {
    type: string;
    value: string;
    isVerified: boolean;
    isPrimary: boolean;
  }[];
}

// POST /api/notifications/send - Send notification via multiple methods
interface SendNotificationRequest {
  recipientId: string;
  notificationType: string;
  priority: 'low' | 'normal' | 'high' | 'urgent';
  title: string;
  message: string;
  actionUrl?: string;
  metadata?: Record<string, any>;
  scheduledFor?: string; // ISO timestamp
}

// POST /api/notifications/test - Test delivery method
interface TestDeliveryRequest {
  method: 'email' | 'sms' | 'push';
  contactValue: string;
  testMessage?: string;
}

// POST /api/notifications/contact-methods - Add/verify contact method
interface AddContactMethodRequest {
  type: 'email' | 'sms' | 'push';
  value: string;
  makePrimary?: boolean;
}
```

#### Frontend Components Required
```typescript
// Component: DeliveryMethodsManager
// Location: /src/components/settings/DeliveryMethodsManager.tsx

interface DeliveryMethodsManagerProps {
  userId: string;
  userRole: 'couple' | 'vendor' | 'planner';
}

// Key functionality:
- Contact method management (add, verify, remove)
- Notification type preferences matrix
- Priority-based delivery rules
- Quiet hours configuration
- Test delivery functionality
- Bulk preference updates

// Component: NotificationPreferencesMatrix
// Location: /src/components/settings/NotificationPreferencesMatrix.tsx
interface NotificationPreferencesMatrixProps {
  preferences: NotificationPreference[];
  onUpdatePreferences: (updates: PreferenceUpdate[]) => void;
  contactMethods: ContactMethod[];
}

// Key functionality:
- Grid view of notification types vs delivery methods
- Priority threshold configuration
- Business hours settings
- Quick preset configurations (e.g., "Urgent Only", "All Updates")

// Component: ContactMethodVerification
// Location: /src/components/settings/ContactMethodVerification.tsx
interface ContactMethodVerificationProps {
  contactMethod: ContactMethod;
  onVerificationComplete: () => void;
}

// Key functionality:
- SMS verification code input
- Email verification link handling
- Push notification permission requests
- Verification status indicators
```

#### Integration Points
```typescript
// Service: DeliveryRouter
// Dependencies: Email service, SMS service, Push notification service

class NotificationDeliveryRouter {
  async sendNotification(notification: NotificationRequest): Promise<DeliveryResult[]> {
    // 1. Get user's delivery preferences for notification type
    // 2. Determine delivery methods based on priority and preferences
    // 3. Check quiet hours and business hours
    // 4. Route to appropriate delivery services
    // 5. Track delivery attempts and results
    // 6. Handle failures and retries
  }
  
  async retryFailedDeliveries(): Promise<void> {
    // Background job to retry failed deliveries
    // Exponential backoff for retry attempts
    // Update delivery status tracking
  }
  
  private async routeToEmail(recipient: string, content: EmailContent): Promise<DeliveryResult> {
    // Use existing Resend service
  }
  
  private async routeToSMS(phoneNumber: string, message: string): Promise<DeliveryResult> {
    // Integrate with Twilio or similar SMS service
  }
  
  private async routeToPush(deviceToken: string, notification: PushNotification): Promise<DeliveryResult> {
    // Use Firebase Cloud Messaging or similar
  }
}

// Service: SMSService
// Dependencies: Twilio, phone number validation

class SMSDeliveryService {
  async sendSMS(phoneNumber: string, message: string, priority: string): Promise<SMSResult> {
    // Format phone number internationally
    // Apply message length limits and truncation
    // Send via Twilio with appropriate priority handling
    // Track delivery status via webhooks
  }
  
  async sendVerificationCode(phoneNumber: string): Promise<VerificationResult> {
    // Generate and send SMS verification code
    // Store code with expiration in database
    // Handle verification attempts
  }
}

// Service: PushNotificationService  
// Dependencies: Firebase Cloud Messaging, device token management

class PushNotificationService {
  async sendPushNotification(deviceToken: string, notification: PushNotification): Promise<PushResult> {
    // Send via FCM with proper payload structure
    // Handle platform differences (iOS vs Android)
    // Track delivery and engagement metrics
  }
  
  async registerDevice(userId: string, deviceToken: string): Promise<void> {
    // Register device token for user
    // Handle token refresh and cleanup
  }
}
```

### CODE EXAMPLES

#### Example 1: Notification Delivery Router
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { Resend } from 'resend';
import { Twilio } from 'twilio';
import admin from 'firebase-admin';
import { createClient } from '@supabase/supabase-js';

interface NotificationRequest {
  recipientId: string;
  notificationType: string;
  priority: 'low' | 'normal' | 'high' | 'urgent';
  title: string;
  message: string;
  actionUrl?: string;
  metadata?: Record<string, any>;
}

interface DeliveryResult {
  method: string;
  success: boolean;
  providerId?: string;
  error?: string;
}

export class NotificationDeliveryRouter {
  private supabase = createClient(process.env.NEXT_PUBLIC_SUPABASE_URL!, process.env.SUPABASE_SERVICE_ROLE_KEY!);
  private resend = new Resend(process.env.RESEND_API_KEY!);
  private twilio = new Twilio(process.env.TWILIO_ACCOUNT_SID!, process.env.TWILIO_AUTH_TOKEN!);
  
  async sendNotification(notification: NotificationRequest): Promise<DeliveryResult[]> {
    const results: DeliveryResult[] = [];
    
    try {
      // Step 1: Get user's delivery preferences
      const { data: preferences, error: prefError } = await this.supabase
        .from('notification_preferences')
        .select('delivery_methods, priority_thresholds, quiet_hours, business_hours')
        .eq('user_id', notification.recipientId)
        .eq('notification_type', notification.notificationType)
        .single();

      if (prefError && prefError.code !== 'PGRST116') { // Not found is OK, use defaults
        throw new Error(`Failed to get preferences: ${prefError.message}`);
      }

      // Step 2: Determine delivery methods based on priority
      const deliveryMethods = this.getDeliveryMethodsForPriority(
        notification.priority,
        preferences?.priority_thresholds || this.getDefaultPriorityThresholds(),
        preferences?.delivery_methods || { email: true, sms: false, push: false }
      );

      // Step 3: Check quiet hours and business hours
      const currentTime = new Date();
      const shouldRespectQuietHours = this.isQuietHours(currentTime, preferences?.quiet_hours);
      const isBusinessHours = this.isBusinessHours(currentTime, preferences?.business_hours);

      // Step 4: Get user's verified contact methods
      const { data: contacts, error: contactError } = await this.supabase
        .from('user_contact_methods')
        .select('*')
        .eq('user_id', notification.recipientId)
        .eq('is_verified', true)
        .in('contact_type', deliveryMethods);

      if (contactError) {
        throw new Error(`Failed to get contact methods: ${contactError.message}`);
      }

      // Step 5: Send via each appropriate delivery method
      for (const contact of contacts || []) {
        let result: DeliveryResult;

        // Skip SMS during quiet hours unless urgent
        if (contact.contact_type === 'sms' && shouldRespectQuietHours && notification.priority !== 'urgent') {
          continue;
        }

        switch (contact.contact_type) {
          case 'email':
            result = await this.sendEmail(contact.contact_value, notification);
            break;
          case 'sms':
            result = await this.sendSMS(contact.contact_value, notification);
            break;
          case 'push':
            result = await this.sendPush(contact.contact_value, notification);
            break;
          default:
            continue;
        }

        results.push(result);

        // Log delivery attempt
        await this.logDeliveryAttempt(notification.recipientId, contact.contact_type, contact.contact_value, result);
      }

      return results;
    } catch (error) {
      console.error('Notification delivery failed:', error);
      return [{
        method: 'system',
        success: false,
        error: error.message
      }];
    }
  }

  private getDeliveryMethodsForPriority(
    priority: string,
    thresholds: Record<string, string[]>,
    enabledMethods: Record<string, boolean>
  ): string[] {
    const methodsForPriority = thresholds[priority] || ['email'];
    return methodsForPriority.filter(method => enabledMethods[method] === true);
  }

  private async sendEmail(email: string, notification: NotificationRequest): Promise<DeliveryResult> {
    try {
      const { data, error } = await this.resend.emails.send({
        from: 'WedSync <noreply@wedsync.com>',
        to: email,
        subject: notification.title,
        html: this.buildEmailHTML(notification),
      });

      if (error) {
        return { method: 'email', success: false, error: error.message };
      }

      return { 
        method: 'email', 
        success: true, 
        providerId: data?.id 
      };
    } catch (error) {
      return { 
        method: 'email', 
        success: false, 
        error: error.message 
      };
    }
  }

  private async sendSMS(phoneNumber: string, notification: NotificationRequest): Promise<DeliveryResult> {
    try {
      // Format message for SMS (max 160 chars)
      const smsMessage = this.formatSMSMessage(notification);
      
      const message = await this.twilio.messages.create({
        body: smsMessage,
        from: process.env.TWILIO_PHONE_NUMBER!,
        to: phoneNumber,
      });

      return {
        method: 'sms',
        success: true,
        providerId: message.sid
      };
    } catch (error) {
      return {
        method: 'sms',
        success: false,
        error: error.message
      };
    }
  }

  private async sendPush(deviceToken: string, notification: NotificationRequest): Promise<DeliveryResult> {
    try {
      if (!admin.apps.length) {
        admin.initializeApp({
          credential: admin.credential.cert(JSON.parse(process.env.FIREBASE_SERVICE_ACCOUNT!))
        });
      }

      const message = {
        token: deviceToken,
        notification: {
          title: notification.title,
          body: notification.message,
        },
        data: {
          actionUrl: notification.actionUrl || '',
          notificationType: notification.notificationType,
          priority: notification.priority,
          ...notification.metadata
        },
        android: {
          priority: notification.priority === 'urgent' ? 'high' : 'normal' as any,
        },
        apns: {
          payload: {
            aps: {
              sound: notification.priority === 'urgent' ? 'default' : undefined,
              badge: 1
            }
          }
        }
      };

      const response = await admin.messaging().send(message);

      return {
        method: 'push',
        success: true,
        providerId: response
      };
    } catch (error) {
      return {
        method: 'push',
        success: false,
        error: error.message
      };
    }
  }

  private isQuietHours(currentTime: Date, quietHours?: any): boolean {
    if (!quietHours?.enabled) return false;
    
    const hour = currentTime.getHours();
    const startHour = parseInt(quietHours.start.split(':')[0]);
    const endHour = parseInt(quietHours.end.split(':')[0]);
    
    if (startHour > endHour) { // Spans midnight
      return hour >= startHour || hour < endHour;
    } else {
      return hour >= startHour && hour < endHour;
    }
  }

  private isBusinessHours(currentTime: Date, businessHours?: any): boolean {
    if (!businessHours?.enabled) return true;
    
    const day = currentTime.getDay(); // 0 = Sunday
    const hour = currentTime.getHours();
    
    const allowedDays = businessHours.days || [1, 2, 3, 4, 5]; // Mon-Fri
    const startHour = parseInt(businessHours.start.split(':')[0]);
    const endHour = parseInt(businessHours.end.split(':')[0]);
    
    return allowedDays.includes(day) && hour >= startHour && hour < endHour;
  }

  private formatSMSMessage(notification: NotificationRequest): string {
    const maxLength = 160;
    let message = `${notification.title}: ${notification.message}`;
    
    if (notification.actionUrl && message.length < 140) {
      message += ` ${notification.actionUrl}`;
    }
    
    return message.length > maxLength ? message.slice(0, 157) + '...' : message;
  }

  private buildEmailHTML(notification: NotificationRequest): string {
    return `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <style>
          body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
          .container { max-width: 600px; margin: 0 auto; padding: 20px; }
          .header { background: #2563eb; color: white; padding: 20px; text-align: center; }
          .content { padding: 20px; background: #f8f9fa; }
          .button { display: inline-block; background: #2563eb; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; margin: 10px 0; }
          .footer { text-align: center; padding: 20px; font-size: 12px; color: #666; }
        </style>
      </head>
      <body>
        <div class="container">
          <div class="header">
            <h1>WedSync</h1>
          </div>
          <div class="content">
            <h2>${notification.title}</h2>
            <p>${notification.message}</p>
            ${notification.actionUrl ? `<a href="${notification.actionUrl}" class="button">View Details</a>` : ''}
          </div>
          <div class="footer">
            <p>This notification was sent based on your WedSync preferences.</p>
            <p><a href="${process.env.NEXT_PUBLIC_APP_URL}/settings/notifications">Update your notification preferences</a></p>
          </div>
        </div>
      </body>
      </html>
    `;
  }

  private async logDeliveryAttempt(userId: string, method: string, recipient: string, result: DeliveryResult): Promise<void> {
    try {
      await this.supabase
        .from('notification_delivery_log')
        .insert({
          user_id: userId,
          delivery_method: method,
          recipient_address: recipient,
          status: result.success ? 'sent' : 'failed',
          provider_id: result.providerId,
          error_message: result.error,
        });
    } catch (error) {
      console.error('Failed to log delivery attempt:', error);
    }
  }

  private getDefaultPriorityThresholds(): Record<string, string[]> {
    return {
      low: ['email'],
      normal: ['email', 'push'],
      high: ['email', 'push', 'sms'],
      urgent: ['email', 'push', 'sms']
    };
  }
}
```

#### Example 2: Notification Preferences UI
```typescript
'use client';
import { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Switch } from '@/components/ui/switch';
import { Badge } from '@/components/ui/badge';
import { Input } from '@/components/ui/input';

interface NotificationPreference {
  notificationType: string;
  deliveryMethods: Record<string, boolean>;
  priorityThresholds: Record<string, string[]>;
}

interface ContactMethod {
  type: string;
  value: string;
  isVerified: boolean;
  isPrimary: boolean;
}

export function DeliveryMethodsManager({ userId }: { userId: string }) {
  const [preferences, setPreferences] = useState<NotificationPreference[]>([]);
  const [contactMethods, setContactMethods] = useState<ContactMethod[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [newContactValue, setNewContactValue] = useState('');
  const [newContactType, setNewContactType] = useState<'email' | 'sms'>('email');

  const notificationTypes = [
    { id: 'timeline_change', label: 'Timeline Changes', description: 'When wedding schedules are updated' },
    { id: 'task_assignment', label: 'Task Assignments', description: 'When new tasks are assigned to you' },
    { id: 'message_received', label: 'New Messages', description: 'When someone sends you a message' },
    { id: 'wedding_update', label: 'Wedding Updates', description: 'General wedding information changes' },
    { id: 'guest_count_change', label: 'Guest Count Changes', description: 'When final guest numbers change' },
    { id: 'venue_change', label: 'Venue Changes', description: 'When venue details are modified' },
    { id: 'emergency_alert', label: 'Emergency Alerts', description: 'Urgent wedding day issues' },
    { id: 'reminder', label: 'Reminders', description: 'Task and deadline reminders' },
  ];

  const deliveryMethods = [
    { id: 'email', label: 'Email', icon: 'ðŸ“§' },
    { id: 'sms', label: 'SMS', icon: 'ðŸ“±' },
    { id: 'push', label: 'Push', icon: 'ðŸ””' },
  ];

  useEffect(() => {
    loadPreferences();
    loadContactMethods();
  }, []);

  const loadPreferences = async () => {
    try {
      const response = await fetch('/api/notifications/preferences');
      const data = await response.json();
      setPreferences(data.preferences || []);
    } catch (error) {
      console.error('Error loading preferences:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const loadContactMethods = async () => {
    try {
      const response = await fetch('/api/notifications/preferences');
      const data = await response.json();
      setContactMethods(data.contactMethods || []);
    } catch (error) {
      console.error('Error loading contact methods:', error);
    }
  };

  const updatePreference = async (notificationType: string, method: string, enabled: boolean) => {
    try {
      const existingPref = preferences.find(p => p.notificationType === notificationType);
      const updatedMethods = {
        ...(existingPref?.deliveryMethods || {}),
        [method]: enabled
      };

      await fetch('/api/notifications/preferences', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          notificationType,
          deliveryMethods: updatedMethods
        })
      });

      // Update local state
      setPreferences(prev => 
        prev.map(p => 
          p.notificationType === notificationType 
            ? { ...p, deliveryMethods: updatedMethods }
            : p
        )
      );
    } catch (error) {
      console.error('Error updating preference:', error);
    }
  };

  const addContactMethod = async () => {
    if (!newContactValue.trim()) return;

    try {
      const response = await fetch('/api/notifications/contact-methods', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          type: newContactType,
          value: newContactValue.trim()
        })
      });

      if (response.ok) {
        setNewContactValue('');
        await loadContactMethods();
      }
    } catch (error) {
      console.error('Error adding contact method:', error);
    }
  };

  const testDelivery = async (method: string, contactValue: string) => {
    try {
      await fetch('/api/notifications/test', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          method,
          contactValue,
          testMessage: `Test ${method.toUpperCase()} from WedSync`
        })
      });
      
      alert(`Test ${method} sent to ${contactValue}`);
    } catch (error) {
      console.error('Error testing delivery:', error);
      alert('Test failed');
    }
  };

  const isMethodEnabled = (notificationType: string, method: string): boolean => {
    const pref = preferences.find(p => p.notificationType === notificationType);
    return pref?.deliveryMethods?.[method] || false;
  };

  const getContactForMethod = (method: string): ContactMethod | undefined => {
    return contactMethods.find(c => c.type === method && c.isVerified);
  };

  if (isLoading) {
    return <div className="animate-pulse">Loading preferences...</div>;
  }

  return (
    <div className="space-y-8">
      {/* Contact Methods Section */}
      <div className="bg-white p-6 rounded-lg border">
        <h3 className="text-lg font-semibold mb-4">Contact Methods</h3>
        
        <div className="space-y-4 mb-6">
          {deliveryMethods.map(method => {
            const contact = getContactForMethod(method.id);
            return (
              <div key={method.id} className="flex items-center justify-between p-3 border rounded">
                <div className="flex items-center space-x-3">
                  <span className="text-xl">{method.icon}</span>
                  <div>
                    <div className="font-medium">{method.label}</div>
                    <div className="text-sm text-gray-600">
                      {contact ? contact.value : 'Not configured'}
                    </div>
                  </div>
                </div>
                
                <div className="flex items-center space-x-2">
                  {contact && (
                    <>
                      <Badge variant={contact.isVerified ? 'success' : 'warning'}>
                        {contact.isVerified ? 'Verified' : 'Pending'}
                      </Badge>
                      <Button 
                        size="sm" 
                        variant="outline"
                        onClick={() => testDelivery(method.id, contact.value)}
                        disabled={!contact.isVerified}
                      >
                        Test
                      </Button>
                    </>
                  )}
                </div>
              </div>
            );
          })}
        </div>

        {/* Add New Contact Method */}
        <div className="flex space-x-2">
          <select 
            value={newContactType} 
            onChange={(e) => setNewContactType(e.target.value as 'email' | 'sms')}
            className="border rounded px-3 py-2"
          >
            <option value="email">Email</option>
            <option value="sms">SMS</option>
          </select>
          <Input
            placeholder={newContactType === 'email' ? 'Enter email address' : 'Enter phone number'}
            value={newContactValue}
            onChange={(e) => setNewContactValue(e.target.value)}
            className="flex-1"
          />
          <Button onClick={addContactMethod}>Add</Button>
        </div>
      </div>

      {/* Notification Preferences Matrix */}
      <div className="bg-white p-6 rounded-lg border">
        <h3 className="text-lg font-semibold mb-4">Notification Preferences</h3>
        
        <div className="overflow-x-auto">
          <table className="w-full border-collapse">
            <thead>
              <tr className="border-b">
                <th className="text-left p-3 font-medium">Notification Type</th>
                {deliveryMethods.map(method => (
                  <th key={method.id} className="text-center p-3 font-medium">
                    <div className="flex flex-col items-center space-y-1">
                      <span className="text-xl">{method.icon}</span>
                      <span className="text-sm">{method.label}</span>
                    </div>
                  </th>
                ))}
              </tr>
            </thead>
            <tbody>
              {notificationTypes.map(type => (
                <tr key={type.id} className="border-b hover:bg-gray-50">
                  <td className="p-3">
                    <div>
                      <div className="font-medium">{type.label}</div>
                      <div className="text-sm text-gray-600">{type.description}</div>
                    </div>
                  </td>
                  {deliveryMethods.map(method => {
                    const contact = getContactForMethod(method.id);
                    const isEnabled = isMethodEnabled(type.id, method.id);
                    return (
                      <td key={method.id} className="p-3 text-center">
                        <Switch
                          checked={isEnabled}
                          onCheckedChange={(checked) => updatePreference(type.id, method.id, checked)}
                          disabled={!contact?.isVerified}
                        />
                      </td>
                    );
                  })}
                </tr>
              ))}
            </tbody>
          </table>
        </div>

        <div className="mt-4 text-sm text-gray-600">
          <p>ðŸ’¡ <strong>Tip:</strong> Emergency alerts will always be sent via all verified methods regardless of your preferences.</p>
        </div>
      </div>
    </div>
  );
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Ref MCP: Search docs for Twilio SMS, Firebase Push, notification patterns
- [x] Supabase MCP: Database operations and user management
- [x] Browser MCP: Interactive testing of notification preferences UI
- [x] Filesystem: Access notification templates and configurations

#### Ref MCP Searches Needed
```bash
# Use Ref MCP to search for:
# - "Twilio SMS Next.js integration"
# - "Firebase Cloud Messaging React"
# - "Multi-channel notification patterns"
# - "Notification delivery reliability best practices"
```

#### Browser MCP Interactive Testing
```bash
# Use Browser MCP for:
# - Testing notification preference interface
# - Verifying contact method verification flows
# - Screenshot capture of preference settings
# - Testing mobile responsive notification settings
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('NotificationDeliveryRouter', () => {
  it('should route notifications based on priority and preferences', async () => {
    const router = new NotificationDeliveryRouter();
    const results = await router.sendNotification(mockNotification);
    expect(results).toContainEqual(expect.objectContaining({ method: 'email', success: true }));
  });
  
  it('should respect quiet hours for non-urgent notifications', async () => {
    // Test quiet hours logic
  });
  
  it('should format SMS messages under 160 characters', () => {
    // Test SMS formatting logic
  });
  
  it('should handle delivery failures gracefully', async () => {
    // Test error handling and retry logic
  });
});
```

#### E2E Tests Required
```typescript
test('Configure notification delivery preferences', async () => {
  await mcp__playwright__browser_navigate({url: '/settings/notifications'});
  
  // Add SMS contact method
  await mcp__playwright__browser_select_option({element: 'Contact type', ref: '[data-testid="contact-type"]', values: ['sms']});
  await mcp__playwright__browser_type({element: 'Phone input', ref: '[data-testid="phone-input"]', text: '+1234567890'});
  await mcp__playwright__browser_click({element: 'Add button', ref: '[data-testid="add-contact"]'});
  
  // Enable SMS for urgent notifications
  await mcp__playwright__browser_click({element: 'Emergency SMS toggle', ref: '[data-testid="emergency-sms-toggle"]'});
  
  // Test delivery
  await mcp__playwright__browser_click({element: 'Test SMS button', ref: '[data-testid="test-sms"]'});
  
  // Verify success message
  const successMessage = await page.waitForSelector('[data-testid="test-success"]');
  expect(successMessage).toBeTruthy();
});
```

### ACCEPTANCE CRITERIA
- [x] Users can configure delivery preferences for each notification type
- [x] Support for email, SMS, and push notification delivery
- [x] Priority-based routing (urgent notifications use all methods)
- [x] Contact method verification (SMS codes, email links)
- [x] Quiet hours and business hours respect
- [x] Delivery attempt tracking and retry logic
- [x] Test delivery functionality for each method
- [x] Mobile-responsive preference interface
- [x] Bulk preference updates and presets
- [x] **Navigation Integration: Notification preferences accessible from user settings**
  - [x] Notifications tab in user settings/preferences
  - [x] Quick access to delivery method configuration
  - [x] Settings badge indicators for unverified contacts
  - [x] Mobile navigation support for notification settings
  - [x] Integration with main account/profile navigation

### DEPENDENCIES
- Must complete after: User authentication, basic notification system
- Must complete before: Thank You Management System (WS-280)  
- Shares code with: Communication Threads (WS-278), email and messaging systems

### ESTIMATED EFFORT
- Team A Frontend: 28 hours (Preferences UI, contact management, verification flows)
- Team B Backend: 36 hours (Delivery routing, SMS/Push services, retry logic)
- Team C Integration: 16 hours (Twilio SMS, Firebase Push, delivery tracking)
- Team D Platform: 12 hours (Contact verification, preference management)
- Team E General: 20 hours (Testing, mobile responsive, error handling)
- Team F Workflows: 8 hours (User preference flows, verification UX)
- Team G Performance: 8 hours (Delivery optimization, batch processing)
- Total: 128 hours