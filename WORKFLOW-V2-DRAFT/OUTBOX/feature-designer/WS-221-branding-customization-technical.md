# TECHNICAL SPECIFICATION: WS-221 - Branding Customization
## Generated by Feature Development Session - January 25, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding professional building client portals
**I want to:** Completely customize branding, colors, fonts, and layouts to match my business identity
**So that:** My clients see a fully white-labeled experience that builds my brand recognition and trust

**Real Wedding Scenario:**
Elite Wedding Photography by Sarah wants to provide premium client portals that match her luxury brand. She uploads her gold and navy brand colors, custom serif fonts, and high-resolution logo. When her couples visit their portal at clients.eliteweddingsbysarah.com, they see no WedSync branding - only Sarah's professional identity. This reinforces her premium positioning and creates a seamless brand experience worth $2,000+ in perceived value per client.

### SPECIFICATION SOURCE
- **Feature ID:** WS-221
- **Original Spec:** /CORE-SPECIFICATIONS/02-WEDSYNC-SUPPLIER-PLATFORM/07-Client-Dashboard-Builder/03-branding-customization md.md
- **Current Implementation:** 0% complete (new)
- **Files to Modify:** None (new feature)
- **New Files to Create:** 
  - `/src/app/(dashboard)/branding/page.tsx`
  - `/src/components/branding/BrandingCustomizer.tsx`
  - `/src/components/branding/ColorPalette.tsx`
  - `/src/components/branding/TypographySelector.tsx`
  - `/src/components/branding/LogoUploader.tsx`
  - `/src/components/branding/PreviewPanel.tsx`
  - `/src/lib/services/brandingService.ts`
  - `/src/lib/utils/colorUtils.ts`
  - `/src/types/branding.ts`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Branding configuration tables
CREATE TABLE IF NOT EXISTS branding_configs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES suppliers(id),
  name VARCHAR(255) NOT NULL DEFAULT 'Default Brand',
  is_active BOOLEAN DEFAULT true,
  logo_primary_url VARCHAR(500),
  logo_favicon_url VARCHAR(500),
  logo_email_header_url VARCHAR(500),
  logo_dark_mode_url VARCHAR(500),
  primary_color VARCHAR(7) DEFAULT '#4F46E5',
  secondary_color VARCHAR(7) DEFAULT '#10B981',
  accent_color VARCHAR(7) DEFAULT '#F59E0B',
  background_color VARCHAR(7) DEFAULT '#FFFFFF',
  text_color VARCHAR(7) DEFAULT '#1F2937',
  success_color VARCHAR(7) DEFAULT '#10B981',
  warning_color VARCHAR(7) DEFAULT '#F59E0B',
  error_color VARCHAR(7) DEFAULT '#EF4444',
  heading_font VARCHAR(100) DEFAULT 'Inter',
  body_font VARCHAR(100) DEFAULT 'Inter',
  base_font_size INTEGER DEFAULT 16,
  border_radius_preference VARCHAR(20) DEFAULT 'rounded-md',
  custom_css TEXT,
  footer_content TEXT,
  meta_title VARCHAR(255),
  meta_description TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Brand asset storage
CREATE TABLE IF NOT EXISTS brand_assets (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branding_config_id UUID REFERENCES branding_configs(id) ON DELETE CASCADE,
  asset_type VARCHAR(50) NOT NULL, -- 'logo_primary', 'favicon', 'font_file'
  file_name VARCHAR(255) NOT NULL,
  file_url VARCHAR(500) NOT NULL,
  file_size INTEGER,
  mime_type VARCHAR(100),
  alt_text VARCHAR(255),
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Color palette presets
CREATE TABLE IF NOT EXISTS brand_color_presets (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(100) NOT NULL,
  description TEXT,
  color_scheme JSONB NOT NULL, -- Store complete color scheme
  is_system_preset BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Insert default color presets
INSERT INTO brand_color_presets (name, description, color_scheme, is_system_preset) VALUES
('Luxury Gold', 'Elegant gold and navy for premium brands', 
 '{"primary": "#D4AF37", "secondary": "#1E3A8A", "accent": "#FCD34D", "background": "#FFFFFF", "text": "#1F2937"}', true),
('Modern Minimal', 'Clean black and white with subtle accents', 
 '{"primary": "#000000", "secondary": "#6B7280", "accent": "#3B82F6", "background": "#FFFFFF", "text": "#111827"}', true),
('Romantic Pink', 'Soft pinks and roses for romantic brands', 
 '{"primary": "#EC4899", "secondary": "#BE185D", "accent": "#F9A8D4", "background": "#FFF7ED", "text": "#374151"}', true),
('Natural Green', 'Earthy greens for organic/natural brands', 
 '{"primary": "#059669", "secondary": "#064E3B", "accent": "#34D399", "background": "#F0FDF4", "text": "#1F2937"}', true);

-- RLS Policies
ALTER TABLE branding_configs ENABLE ROW LEVEL SECURITY;
ALTER TABLE brand_assets ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Suppliers can manage their own branding" ON branding_configs
  FOR ALL USING (auth.uid() = supplier_id OR 
                 auth.uid() IN (SELECT user_id FROM team_members WHERE supplier_id = branding_configs.supplier_id));

CREATE POLICY "Suppliers can manage their own brand assets" ON brand_assets
  FOR ALL USING (auth.uid() IN (
    SELECT bc.supplier_id FROM branding_configs bc 
    WHERE bc.id = brand_assets.branding_config_id
  ));

-- Indexes for performance
CREATE INDEX idx_branding_configs_supplier_id ON branding_configs(supplier_id);
CREATE INDEX idx_branding_configs_active ON branding_configs(supplier_id, is_active);
CREATE INDEX idx_brand_assets_config_id ON brand_assets(branding_config_id);
```

#### TypeScript Interfaces
```typescript
// /src/types/branding.ts
export interface BrandingConfig {
  id: string;
  supplier_id: string;
  name: string;
  is_active: boolean;
  logo: {
    primary: string | null;
    favicon: string | null;
    emailHeader: string | null;
    darkMode: string | null;
  };
  colors: {
    primary: string;
    secondary: string;
    accent: string;
    background: string;
    text: string;
    success: string;
    warning: string;
    error: string;
  };
  typography: {
    headingFont: string;
    bodyFont: string;
    baseFontSize: number;
  };
  layout: {
    borderRadiusPreference: 'rounded-none' | 'rounded-sm' | 'rounded-md' | 'rounded-lg' | 'rounded-xl';
  };
  customCSS: string | null;
  footerContent: string | null;
  metaTags: {
    title: string | null;
    description: string | null;
  };
  created_at: string;
  updated_at: string;
}

export interface BrandAsset {
  id: string;
  branding_config_id: string;
  asset_type: 'logo_primary' | 'favicon' | 'logo_email' | 'logo_dark' | 'font_file';
  file_name: string;
  file_url: string;
  file_size: number;
  mime_type: string;
  alt_text: string | null;
  created_at: string;
}

export interface ColorPreset {
  id: string;
  name: string;
  description: string;
  color_scheme: {
    primary: string;
    secondary: string;
    accent: string;
    background: string;
    text: string;
    success?: string;
    warning?: string;
    error?: string;
  };
  is_system_preset: boolean;
}

export interface GoogleFont {
  family: string;
  variants: string[];
  subsets: string[];
  category: 'serif' | 'sans-serif' | 'display' | 'handwriting' | 'monospace';
}

export interface BrandingPreview {
  config: BrandingConfig;
  appliedStyles: React.CSSProperties;
  cssVariables: Record<string, string>;
}
```

#### API Endpoints Required

**1. GET /api/branding/config**
```typescript
// /src/app/api/branding/config/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { getCurrentSupplier } from '@/lib/auth/server';

export async function GET() {
  try {
    const supplier = await getCurrentSupplier();
    const supabase = createClient();

    const { data: config, error } = await supabase
      .from('branding_configs')
      .select(`
        *,
        brand_assets (*)
      `)
      .eq('supplier_id', supplier.id)
      .eq('is_active', true)
      .single();

    if (error && error.code !== 'PGRST116') {
      throw error;
    }

    // Return default config if none exists
    if (!config) {
      const defaultConfig = {
        id: null,
        supplier_id: supplier.id,
        name: 'Default Brand',
        is_active: true,
        logo: {
          primary: null,
          favicon: null,
          emailHeader: null,
          darkMode: null
        },
        colors: {
          primary: '#4F46E5',
          secondary: '#10B981',
          accent: '#F59E0B',
          background: '#FFFFFF',
          text: '#1F2937',
          success: '#10B981',
          warning: '#F59E0B',
          error: '#EF4444'
        },
        typography: {
          headingFont: 'Inter',
          bodyFont: 'Inter',
          baseFontSize: 16
        },
        layout: {
          borderRadiusPreference: 'rounded-md'
        },
        customCSS: null,
        footerContent: null,
        metaTags: {
          title: null,
          description: null
        },
        brand_assets: []
      };
      
      return NextResponse.json({ config: defaultConfig });
    }

    // Transform database response to match interface
    const transformedConfig = {
      ...config,
      logo: {
        primary: config.logo_primary_url,
        favicon: config.logo_favicon_url,
        emailHeader: config.logo_email_header_url,
        darkMode: config.logo_dark_mode_url
      },
      colors: {
        primary: config.primary_color,
        secondary: config.secondary_color,
        accent: config.accent_color,
        background: config.background_color,
        text: config.text_color,
        success: config.success_color,
        warning: config.warning_color,
        error: config.error_color
      },
      typography: {
        headingFont: config.heading_font,
        bodyFont: config.body_font,
        baseFontSize: config.base_font_size
      },
      layout: {
        borderRadiusPreference: config.border_radius_preference
      },
      customCSS: config.custom_css,
      footerContent: config.footer_content,
      metaTags: {
        title: config.meta_title,
        description: config.meta_description
      }
    };

    return NextResponse.json({ config: transformedConfig });

  } catch (error) {
    console.error('Error fetching branding config:', error);
    return NextResponse.json(
      { error: 'Failed to fetch branding configuration' },
      { status: 500 }
    );
  }
}

export async function PUT(request: NextRequest) {
  try {
    const supplier = await getCurrentSupplier();
    const supabase = createClient();
    const config = await request.json();

    // Transform interface to database format
    const dbConfig = {
      supplier_id: supplier.id,
      name: config.name || 'Default Brand',
      is_active: true,
      logo_primary_url: config.logo?.primary,
      logo_favicon_url: config.logo?.favicon,
      logo_email_header_url: config.logo?.emailHeader,
      logo_dark_mode_url: config.logo?.darkMode,
      primary_color: config.colors.primary,
      secondary_color: config.colors.secondary,
      accent_color: config.colors.accent,
      background_color: config.colors.background,
      text_color: config.colors.text,
      success_color: config.colors.success,
      warning_color: config.colors.warning,
      error_color: config.colors.error,
      heading_font: config.typography.headingFont,
      body_font: config.typography.bodyFont,
      base_font_size: config.typography.baseFontSize,
      border_radius_preference: config.layout.borderRadiusPreference,
      custom_css: config.customCSS,
      footer_content: config.footerContent,
      meta_title: config.metaTags?.title,
      meta_description: config.metaTags?.description,
      updated_at: new Date().toISOString()
    };

    const { data, error } = await supabase
      .from('branding_configs')
      .upsert(dbConfig, { onConflict: 'supplier_id' })
      .select()
      .single();

    if (error) throw error;

    return NextResponse.json({ 
      success: true, 
      config: data,
      message: 'Branding configuration saved successfully' 
    });

  } catch (error) {
    console.error('Error saving branding config:', error);
    return NextResponse.json(
      { error: 'Failed to save branding configuration' },
      { status: 500 }
    );
  }
}
```

**2. POST /api/branding/upload**
```typescript
// /src/app/api/branding/upload/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { getCurrentSupplier } from '@/lib/auth/server';
import sharp from 'sharp';

export async function POST(request: NextRequest) {
  try {
    const supplier = await getCurrentSupplier();
    const supabase = createClient();
    const formData = await request.formData();
    
    const file = formData.get('file') as File;
    const assetType = formData.get('asset_type') as string;
    const altText = formData.get('alt_text') as string;

    if (!file) {
      return NextResponse.json(
        { error: 'No file provided' },
        { status: 400 }
      );
    }

    // Validate file type
    const allowedTypes = ['image/jpeg', 'image/png', 'image/webp', 'image/svg+xml'];
    if (!allowedTypes.includes(file.type)) {
      return NextResponse.json(
        { error: 'Invalid file type. Only JPEG, PNG, WebP, and SVG files are allowed.' },
        { status: 400 }
      );
    }

    // Validate file size (5MB limit)
    if (file.size > 5 * 1024 * 1024) {
      return NextResponse.json(
        { error: 'File size must be less than 5MB' },
        { status: 400 }
      );
    }

    const arrayBuffer = await file.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);

    // Optimize images based on type
    let optimizedBuffer = buffer;
    let optimizedFileName = file.name;

    if (assetType === 'favicon') {
      // Generate multiple favicon sizes
      const sizes = [16, 32, 48];
      for (const size of sizes) {
        const faviconBuffer = await sharp(buffer)
          .resize(size, size)
          .png()
          .toBuffer();
        
        const fileName = `favicon-${size}x${size}.png`;
        const filePath = `branding/${supplier.id}/${fileName}`;

        const { error: uploadError } = await supabase.storage
          .from('assets')
          .upload(filePath, faviconBuffer, {
            contentType: 'image/png',
            upsert: true
          });

        if (uploadError) throw uploadError;
      }
      
      // Use 32x32 as the primary favicon
      optimizedFileName = 'favicon-32x32.png';
      optimizedBuffer = await sharp(buffer).resize(32, 32).png().toBuffer();
      
    } else if (assetType === 'logo_primary') {
      // Optimize logo for web display
      if (file.type !== 'image/svg+xml') {
        optimizedBuffer = await sharp(buffer)
          .resize(400, 200, { fit: 'inside', withoutEnlargement: true })
          .webp({ quality: 90 })
          .toBuffer();
        optimizedFileName = file.name.replace(/\.(jpg|jpeg|png)$/i, '.webp');
      }
    }

    // Upload to Supabase Storage
    const filePath = `branding/${supplier.id}/${optimizedFileName}`;
    const { data: uploadData, error: uploadError } = await supabase.storage
      .from('assets')
      .upload(filePath, optimizedBuffer, {
        contentType: file.type === 'image/svg+xml' ? 'image/svg+xml' : 'image/webp',
        upsert: true
      });

    if (uploadError) throw uploadError;

    // Get public URL
    const { data: { publicUrl } } = supabase.storage
      .from('assets')
      .getPublicUrl(filePath);

    // Get or create branding config
    let { data: brandingConfig, error: configError } = await supabase
      .from('branding_configs')
      .select('id')
      .eq('supplier_id', supplier.id)
      .single();

    if (configError && configError.code === 'PGRST116') {
      // Create default branding config
      const { data: newConfig, error: createError } = await supabase
        .from('branding_configs')
        .insert({
          supplier_id: supplier.id,
          name: 'Default Brand'
        })
        .select('id')
        .single();

      if (createError) throw createError;
      brandingConfig = newConfig;
    }

    // Save asset record
    const { data: assetData, error: assetError } = await supabase
      .from('brand_assets')
      .insert({
        branding_config_id: brandingConfig.id,
        asset_type: assetType,
        file_name: optimizedFileName,
        file_url: publicUrl,
        file_size: optimizedBuffer.length,
        mime_type: file.type === 'image/svg+xml' ? 'image/svg+xml' : 'image/webp',
        alt_text: altText
      })
      .select()
      .single();

    if (assetError) throw assetError;

    // Update branding config with asset URL
    const updateData: any = {};
    switch (assetType) {
      case 'logo_primary':
        updateData.logo_primary_url = publicUrl;
        break;
      case 'favicon':
        updateData.logo_favicon_url = publicUrl;
        break;
      case 'logo_email':
        updateData.logo_email_header_url = publicUrl;
        break;
      case 'logo_dark':
        updateData.logo_dark_mode_url = publicUrl;
        break;
    }

    await supabase
      .from('branding_configs')
      .update(updateData)
      .eq('id', brandingConfig.id);

    return NextResponse.json({
      success: true,
      asset: assetData,
      url: publicUrl,
      message: 'Asset uploaded successfully'
    });

  } catch (error) {
    console.error('Error uploading brand asset:', error);
    return NextResponse.json(
      { error: 'Failed to upload asset' },
      { status: 500 }
    );
  }
}
```

**3. GET /api/branding/color-presets**
```typescript
// /src/app/api/branding/color-presets/route.ts
import { NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';

export async function GET() {
  try {
    const supabase = createClient();

    const { data: presets, error } = await supabase
      .from('brand_color_presets')
      .select('*')
      .order('is_system_preset', { ascending: false })
      .order('name');

    if (error) throw error;

    return NextResponse.json({ presets });

  } catch (error) {
    console.error('Error fetching color presets:', error);
    return NextResponse.json(
      { error: 'Failed to fetch color presets' },
      { status: 500 }
    );
  }
}
```

#### React Components

**1. Main Branding Customizer Component**
```tsx
// /src/components/branding/BrandingCustomizer.tsx
'use client';

import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Palette, Type, Layout, Code, Eye, Save } from 'lucide-react';
import { BrandingConfig, ColorPreset } from '@/types/branding';
import { ColorPalette } from './ColorPalette';
import { TypographySelector } from './TypographySelector';
import { LogoUploader } from './LogoUploader';
import { PreviewPanel } from './PreviewPanel';
import { useToast } from '@/components/ui/use-toast';
import { useBranding } from '@/hooks/useBranding';

export function BrandingCustomizer() {
  const { toast } = useToast();
  const {
    config,
    loading,
    updateConfig,
    saveConfig,
    uploadAsset,
    generateCSS
  } = useBranding();

  const [activeTab, setActiveTab] = useState('colors');
  const [isPreviewMode, setIsPreviewMode] = useState(false);
  const [isSaving, setIsSaving] = useState(false);

  const handleSave = async () => {
    try {
      setIsSaving(true);
      await saveConfig(config);
      toast({
        title: 'Success',
        description: 'Branding configuration saved successfully',
      });
    } catch (error) {
      toast({
        title: 'Error',
        description: 'Failed to save branding configuration',
        variant: 'destructive',
      });
    } finally {
      setIsSaving(false);
    }
  };

  const handleColorChange = (colorKey: string, value: string) => {
    updateConfig({
      colors: {
        ...config.colors,
        [colorKey]: value
      }
    });
  };

  const handleTypographyChange = (fontType: 'headingFont' | 'bodyFont', value: string) => {
    updateConfig({
      typography: {
        ...config.typography,
        [fontType]: value
      }
    });
  };

  const handleLogoUpload = async (assetType: string, file: File, altText: string) => {
    try {
      const result = await uploadAsset(assetType, file, altText);
      updateConfig({
        logo: {
          ...config.logo,
          [assetType.replace('logo_', '')]: result.url
        }
      });
      toast({
        title: 'Success',
        description: 'Logo uploaded successfully',
      });
    } catch (error) {
      toast({
        title: 'Error',
        description: 'Failed to upload logo',
        variant: 'destructive',
      });
    }
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center h-96">
        <div className="animate-spin rounded-full h-32 w-32 border-b-2 border-primary"></div>
      </div>
    );
  }

  return (
    <div className="container mx-auto p-6 max-w-7xl">
      <div className="flex justify-between items-center mb-6">
        <div>
          <h1 className="text-3xl font-bold">Brand Customization</h1>
          <p className="text-gray-600 mt-2">
            Customize your client portal branding to match your business identity
          </p>
        </div>
        <div className="flex gap-2">
          <Button
            variant={isPreviewMode ? 'default' : 'outline'}
            onClick={() => setIsPreviewMode(!isPreviewMode)}
          >
            <Eye className="w-4 h-4 mr-2" />
            {isPreviewMode ? 'Hide Preview' : 'Show Preview'}
          </Button>
          <Button onClick={handleSave} disabled={isSaving}>
            <Save className="w-4 h-4 mr-2" />
            {isSaving ? 'Saving...' : 'Save Changes'}
          </Button>
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Customization Panel */}
        <div className={`${isPreviewMode ? 'lg:col-span-1' : 'lg:col-span-3'} transition-all duration-300`}>
          <Card>
            <CardHeader>
              <CardTitle>Customization Options</CardTitle>
            </CardHeader>
            <CardContent>
              <Tabs value={activeTab} onValueChange={setActiveTab}>
                <TabsList className="grid w-full grid-cols-4">
                  <TabsTrigger value="logos" className="flex items-center gap-2">
                    <Layout className="w-4 h-4" />
                    <span className="hidden sm:inline">Logos</span>
                  </TabsTrigger>
                  <TabsTrigger value="colors" className="flex items-center gap-2">
                    <Palette className="w-4 h-4" />
                    <span className="hidden sm:inline">Colors</span>
                  </TabsTrigger>
                  <TabsTrigger value="typography" className="flex items-center gap-2">
                    <Type className="w-4 h-4" />
                    <span className="hidden sm:inline">Fonts</span>
                  </TabsTrigger>
                  <TabsTrigger value="advanced" className="flex items-center gap-2">
                    <Code className="w-4 h-4" />
                    <span className="hidden sm:inline">Advanced</span>
                  </TabsTrigger>
                </TabsList>

                <TabsContent value="logos" className="mt-6">
                  <LogoUploader
                    config={config}
                    onUpload={handleLogoUpload}
                  />
                </TabsContent>

                <TabsContent value="colors" className="mt-6">
                  <ColorPalette
                    colors={config.colors}
                    onChange={handleColorChange}
                  />
                </TabsContent>

                <TabsContent value="typography" className="mt-6">
                  <TypographySelector
                    typography={config.typography}
                    onChange={handleTypographyChange}
                  />
                </TabsContent>

                <TabsContent value="advanced" className="mt-6">
                  <div className="space-y-6">
                    <div>
                      <label className="block text-sm font-medium mb-2">
                        Custom CSS
                      </label>
                      <textarea
                        className="w-full h-48 p-3 border rounded-md font-mono text-sm"
                        placeholder="/* Add your custom CSS here */
.client-portal-header {
  background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
}

.dashboard-card {
  border-radius: var(--border-radius);
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}"
                        value={config.customCSS || ''}
                        onChange={(e) => updateConfig({ customCSS: e.target.value })}
                      />
                      <p className="text-xs text-gray-500 mt-1">
                        Use CSS variables like --primary, --secondary, etc. to reference your brand colors
                      </p>
                    </div>

                    <div>
                      <label className="block text-sm font-medium mb-2">
                        Footer Content
                      </label>
                      <textarea
                        className="w-full h-24 p-3 border rounded-md"
                        placeholder="© 2025 Your Business Name. All rights reserved."
                        value={config.footerContent || ''}
                        onChange={(e) => updateConfig({ footerContent: e.target.value })}
                      />
                    </div>

                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                      <div>
                        <label className="block text-sm font-medium mb-2">
                          Page Title
                        </label>
                        <input
                          type="text"
                          className="w-full p-2 border rounded-md"
                          placeholder="Your Business Name - Client Portal"
                          value={config.metaTags?.title || ''}
                          onChange={(e) => updateConfig({
                            metaTags: {
                              ...config.metaTags,
                              title: e.target.value
                            }
                          })}
                        />
                      </div>
                      <div>
                        <label className="block text-sm font-medium mb-2">
                          Page Description
                        </label>
                        <input
                          type="text"
                          className="w-full p-2 border rounded-md"
                          placeholder="Secure client portal for wedding planning"
                          value={config.metaTags?.description || ''}
                          onChange={(e) => updateConfig({
                            metaTags: {
                              ...config.metaTags,
                              description: e.target.value
                            }
                          })}
                        />
                      </div>
                    </div>
                  </div>
                </TabsContent>
              </Tabs>
            </CardContent>
          </Card>
        </div>

        {/* Preview Panel */}
        {isPreviewMode && (
          <div className="lg:col-span-2">
            <PreviewPanel config={config} />
          </div>
        )}
      </div>
    </div>
  );
}
```

**2. Color Palette Component**
```tsx
// /src/components/branding/ColorPalette.tsx
'use client';

import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Palette, RefreshCw } from 'lucide-react';
import { ColorPreset } from '@/types/branding';
import { generateColorVariations, getContrastRatio, isValidHexColor } from '@/lib/utils/colorUtils';

interface ColorPaletteProps {
  colors: {
    primary: string;
    secondary: string;
    accent: string;
    background: string;
    text: string;
    success: string;
    warning: string;
    error: string;
  };
  onChange: (colorKey: string, value: string) => void;
}

export function ColorPalette({ colors, onChange }: ColorPaletteProps) {
  const [presets, setPresets] = useState<ColorPreset[]>([]);
  const [customColors, setCustomColors] = useState(colors);
  const [validationErrors, setValidationErrors] = useState<Record<string, string>>({});

  useEffect(() => {
    fetchColorPresets();
  }, []);

  useEffect(() => {
    setCustomColors(colors);
    validateColors(colors);
  }, [colors]);

  const fetchColorPresets = async () => {
    try {
      const response = await fetch('/api/branding/color-presets');
      const data = await response.json();
      setPresets(data.presets || []);
    } catch (error) {
      console.error('Failed to fetch color presets:', error);
    }
  };

  const validateColors = (colorObj: typeof colors) => {
    const errors: Record<string, string> = {};

    // Validate hex format
    Object.entries(colorObj).forEach(([key, value]) => {
      if (!isValidHexColor(value)) {
        errors[key] = 'Invalid hex color format';
      }
    });

    // Check contrast ratios for accessibility
    const textContrast = getContrastRatio(colorObj.text, colorObj.background);
    if (textContrast < 4.5) {
      errors.text = 'Poor contrast with background (WCAG AA requires 4.5:1)';
    }

    const primaryContrast = getContrastRatio('#FFFFFF', colorObj.primary);
    if (primaryContrast < 3) {
      errors.primary = 'Poor contrast for white text';
    }

    setValidationErrors(errors);
  };

  const handleColorChange = (colorKey: string, value: string) => {
    const newColors = { ...customColors, [colorKey]: value };
    setCustomColors(newColors);
    onChange(colorKey, value);
  };

  const applyPreset = (preset: ColorPreset) => {
    Object.entries(preset.color_scheme).forEach(([key, value]) => {
      onChange(key, value);
    });
  };

  const generateHarmoniousColors = () => {
    const variations = generateColorVariations(colors.primary);
    handleColorChange('secondary', variations.analogous[1]);
    handleColorChange('accent', variations.complementary);
  };

  const colorFields = [
    { key: 'primary', label: 'Primary', description: 'Main brand color for buttons and highlights' },
    { key: 'secondary', label: 'Secondary', description: 'Supporting color for accents and borders' },
    { key: 'accent', label: 'Accent', description: 'Call-to-action and emphasis color' },
    { key: 'background', label: 'Background', description: 'Main page background color' },
    { key: 'text', label: 'Text', description: 'Primary text color' },
    { key: 'success', label: 'Success', description: 'Success messages and positive actions' },
    { key: 'warning', label: 'Warning', description: 'Warning messages and caution states' },
    { key: 'error', label: 'Error', description: 'Error messages and danger states' },
  ];

  return (
    <div className="space-y-6">
      {/* Color Presets */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Palette className="w-5 h-5" />
            Color Presets
          </CardTitle>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
            {presets.map((preset) => (
              <div
                key={preset.id}
                className="p-4 border rounded-lg cursor-pointer hover:shadow-md transition-shadow"
                onClick={() => applyPreset(preset)}
              >
                <div className="flex items-center justify-between mb-2">
                  <h4 className="font-medium">{preset.name}</h4>
                  {preset.is_system_preset && (
                    <Badge variant="secondary" className="text-xs">
                      System
                    </Badge>
                  )}
                </div>
                <p className="text-sm text-gray-600 mb-3">{preset.description}</p>
                <div className="flex gap-1">
                  {Object.values(preset.color_scheme).slice(0, 5).map((color, index) => (
                    <div
                      key={index}
                      className="w-6 h-6 rounded border"
                      style={{ backgroundColor: color }}
                      title={color}
                    />
                  ))}
                </div>
              </div>
            ))}
          </div>
          
          <Button
            variant="outline"
            onClick={generateHarmoniousColors}
            className="w-full"
          >
            <RefreshCw className="w-4 h-4 mr-2" />
            Generate Harmonious Colors
          </Button>
        </CardContent>
      </Card>

      {/* Custom Color Editor */}
      <Card>
        <CardHeader>
          <CardTitle>Custom Colors</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            {colorFields.map(({ key, label, description }) => (
              <div key={key} className="space-y-2">
                <label className="block text-sm font-medium">
                  {label}
                </label>
                <div className="flex gap-3 items-center">
                  <div
                    className="w-12 h-12 rounded-lg border-2 cursor-pointer"
                    style={{ backgroundColor: customColors[key as keyof typeof customColors] }}
                    onClick={() => {
                      const input = document.createElement('input');
                      input.type = 'color';
                      input.value = customColors[key as keyof typeof customColors];
                      input.addEventListener('change', (e) => {
                        handleColorChange(key, (e.target as HTMLInputElement).value);
                      });
                      input.click();
                    }}
                  />
                  <div className="flex-1">
                    <input
                      type="text"
                      value={customColors[key as keyof typeof customColors]}
                      onChange={(e) => handleColorChange(key, e.target.value)}
                      className={`w-full p-2 border rounded-md font-mono text-sm ${
                        validationErrors[key] ? 'border-red-300 bg-red-50' : 'border-gray-300'
                      }`}
                      placeholder="#000000"
                    />
                    {validationErrors[key] && (
                      <p className="text-xs text-red-600 mt-1">{validationErrors[key]}</p>
                    )}
                  </div>
                </div>
                <p className="text-xs text-gray-500">{description}</p>
              </div>
            ))}
          </div>

          {/* Color Preview */}
          <div className="mt-6 p-4 border rounded-lg bg-gray-50">
            <h4 className="font-medium mb-3">Color Preview</h4>
            <div className="flex flex-wrap gap-2">
              {Object.entries(customColors).map(([key, color]) => (
                <div key={key} className="text-center">
                  <div
                    className="w-16 h-16 rounded-lg border shadow-sm"
                    style={{ backgroundColor: color }}
                  />
                  <p className="text-xs mt-1 capitalize">{key}</p>
                  <p className="text-xs text-gray-500 font-mono">{color}</p>
                </div>
              ))}
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
```

**3. Logo Uploader Component**
```tsx
// /src/components/branding/LogoUploader.tsx
'use client';

import React, { useState, useRef } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Upload, X, Image as ImageIcon, Globe } from 'lucide-react';
import { BrandingConfig } from '@/types/branding';

interface LogoUploaderProps {
  config: BrandingConfig;
  onUpload: (assetType: string, file: File, altText: string) => Promise<void>;
}

export function LogoUploader({ config, onUpload }: LogoUploaderProps) {
  const [isUploading, setIsUploading] = useState(false);
  const [dragActive, setDragActive] = useState(false);
  const fileInputRefs = useRef<{ [key: string]: HTMLInputElement | null }>({});

  const logoTypes = [
    {
      key: 'logo_primary',
      label: 'Primary Logo',
      description: 'Main logo displayed in client portals',
      currentUrl: config.logo.primary,
      icon: <ImageIcon className="w-5 h-5" />,
      recommended: '400x200px, PNG or SVG'
    },
    {
      key: 'favicon',
      label: 'Favicon',
      description: 'Small icon shown in browser tabs',
      currentUrl: config.logo.favicon,
      icon: <Globe className="w-5 h-5" />,
      recommended: '32x32px, PNG or ICO'
    },
    {
      key: 'logo_email',
      label: 'Email Header Logo',
      description: 'Logo used in email communications',
      currentUrl: config.logo.emailHeader,
      icon: <ImageIcon className="w-5 h-5" />,
      recommended: '300x100px, PNG'
    },
    {
      key: 'logo_dark',
      label: 'Dark Mode Logo',
      description: 'Alternative logo for dark backgrounds',
      currentUrl: config.logo.darkMode,
      icon: <ImageIcon className="w-5 h-5" />,
      recommended: '400x200px, PNG or SVG'
    }
  ];

  const handleFileSelect = async (assetType: string, file: File) => {
    if (!file) return;

    // Validate file type
    const allowedTypes = ['image/jpeg', 'image/png', 'image/webp', 'image/svg+xml'];
    if (!allowedTypes.includes(file.type)) {
      alert('Please select a valid image file (JPEG, PNG, WebP, or SVG)');
      return;
    }

    // Validate file size (5MB limit)
    if (file.size > 5 * 1024 * 1024) {
      alert('File size must be less than 5MB');
      return;
    }

    try {
      setIsUploading(true);
      const altText = `${config.name || 'Business'} logo`;
      await onUpload(assetType, file, altText);
    } catch (error) {
      console.error('Upload failed:', error);
      alert('Upload failed. Please try again.');
    } finally {
      setIsUploading(false);
    }
  };

  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
    setDragActive(true);
  };

  const handleDragLeave = (e: React.DragEvent) => {
    e.preventDefault();
    setDragActive(false);
  };

  const handleDrop = async (e: React.DragEvent, assetType: string) => {
    e.preventDefault();
    setDragActive(false);

    const files = Array.from(e.dataTransfer.files);
    if (files.length > 0) {
      await handleFileSelect(assetType, files[0]);
    }
  };

  const removeLogo = (assetType: string) => {
    // This would typically call an API to remove the asset
    console.log('Remove logo:', assetType);
  };

  return (
    <div className="space-y-6">
      {logoTypes.map((logoType) => (
        <Card key={logoType.key}>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              {logoType.icon}
              {logoType.label}
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
              {/* Current Logo Display */}
              <div>
                <h4 className="font-medium mb-2">Current Logo</h4>
                {logoType.currentUrl ? (
                  <div className="relative group">
                    <div className="border rounded-lg p-4 bg-gray-50 flex items-center justify-center h-32">
                      <img
                        src={logoType.currentUrl}
                        alt={`${logoType.label} preview`}
                        className="max-h-full max-w-full object-contain"
                      />
                    </div>
                    <Button
                      variant="destructive"
                      size="sm"
                      className="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity"
                      onClick={() => removeLogo(logoType.key)}
                    >
                      <X className="w-4 h-4" />
                    </Button>
                  </div>
                ) : (
                  <div className="border-2 border-dashed border-gray-300 rounded-lg p-8 flex items-center justify-center h-32 bg-gray-50">
                    <p className="text-gray-500 text-center">
                      No logo uploaded
                      <br />
                      <span className="text-sm">Upload one below</span>
                    </p>
                  </div>
                )}
              </div>

              {/* Upload Area */}
              <div>
                <h4 className="font-medium mb-2">Upload New Logo</h4>
                <div
                  className={`border-2 border-dashed rounded-lg p-6 text-center cursor-pointer transition-colors ${
                    dragActive ? 'border-primary bg-primary/5' : 'border-gray-300 hover:border-primary/50'
                  }`}
                  onDragOver={handleDragOver}
                  onDragLeave={handleDragLeave}
                  onDrop={(e) => handleDrop(e, logoType.key)}
                  onClick={() => fileInputRefs.current[logoType.key]?.click()}
                >
                  <Upload className="w-8 h-8 mx-auto mb-2 text-gray-400" />
                  <p className="text-sm font-medium">
                    Drop your logo here, or click to browse
                  </p>
                  <p className="text-xs text-gray-500 mt-1">
                    {logoType.recommended}
                  </p>
                  <p className="text-xs text-gray-500">
                    Supports: PNG, JPEG, WebP, SVG (max 5MB)
                  </p>

                  <input
                    type="file"
                    ref={(el) => (fileInputRefs.current[logoType.key] = el)}
                    className="hidden"
                    accept="image/jpeg,image/png,image/webp,image/svg+xml"
                    onChange={(e) => {
                      const file = e.target.files?.[0];
                      if (file) {
                        handleFileSelect(logoType.key, file);
                      }
                    }}
                  />
                </div>

                <p className="text-sm text-gray-600 mt-2">
                  {logoType.description}
                </p>
              </div>
            </div>
          </CardContent>
        </Card>
      ))}

      {/* Upload Progress */}
      {isUploading && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
          <Card className="w-96">
            <CardContent className="p-6">
              <div className="text-center">
                <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto mb-4"></div>
                <p className="font-medium">Uploading Logo...</p>
                <p className="text-sm text-gray-600 mt-2">
                  Please wait while we optimize and upload your logo
                </p>
              </div>
            </CardContent>
          </Card>
        </div>
      )}
    </div>
  );
}
```

#### Service Layer
```typescript
// /src/lib/services/brandingService.ts
import { createClient } from '@/lib/supabase/client';
import { BrandingConfig, BrandAsset } from '@/types/branding';

export class BrandingService {
  private supabase = createClient();

  async getBrandingConfig(): Promise<BrandingConfig | null> {
    try {
      const { data, error } = await this.supabase
        .from('branding_configs')
        .select(`
          *,
          brand_assets (*)
        `)
        .eq('is_active', true)
        .single();

      if (error && error.code !== 'PGRST116') throw error;
      return data;
    } catch (error) {
      console.error('Error fetching branding config:', error);
      throw error;
    }
  }

  async saveBrandingConfig(config: Partial<BrandingConfig>): Promise<BrandingConfig> {
    try {
      const { data, error } = await this.supabase
        .from('branding_configs')
        .upsert(config)
        .select()
        .single();

      if (error) throw error;
      return data;
    } catch (error) {
      console.error('Error saving branding config:', error);
      throw error;
    }
  }

  async uploadBrandAsset(
    assetType: string,
    file: File,
    altText: string
  ): Promise<{ url: string; asset: BrandAsset }> {
    try {
      const formData = new FormData();
      formData.append('file', file);
      formData.append('asset_type', assetType);
      formData.append('alt_text', altText);

      const response = await fetch('/api/branding/upload', {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        throw new Error('Upload failed');
      }

      const result = await response.json();
      return {
        url: result.url,
        asset: result.asset,
      };
    } catch (error) {
      console.error('Error uploading brand asset:', error);
      throw error;
    }
  }

  generateCSS(config: BrandingConfig): string {
    const cssVariables = Object.entries(config.colors)
      .map(([key, value]) => `--${key.replace(/([A-Z])/g, '-$1').toLowerCase()}: ${value};`)
      .join('\n  ');

    const customCSS = config.customCSS || '';

    return `
:root {
  ${cssVariables}
  --heading-font: ${config.typography.headingFont}, sans-serif;
  --body-font: ${config.typography.bodyFont}, sans-serif;
  --base-font-size: ${config.typography.baseFontSize}px;
  --border-radius: ${config.layout?.borderRadiusPreference || 'rounded-md'};
}

/* Base styling */
body {
  font-family: var(--body-font);
  font-size: var(--base-font-size);
  color: var(--text);
  background-color: var(--background);
}

h1, h2, h3, h4, h5, h6 {
  font-family: var(--heading-font);
}

/* Primary button styling */
.btn-primary {
  background-color: var(--primary);
  color: white;
  border: none;
  padding: 0.75rem 1.5rem;
  border-radius: var(--border-radius);
}

.btn-primary:hover {
  background-color: color-mix(in srgb, var(--primary) 85%, black);
}

/* Custom CSS */
${customCSS}
`.trim();
  }

  async applyBrandingToPortal(customDomain?: string): Promise<void> {
    try {
      const config = await this.getBrandingConfig();
      if (!config) return;

      const css = this.generateCSS(config);
      
      // Apply CSS to the document
      let styleElement = document.getElementById('branding-styles') as HTMLStyleElement;
      if (!styleElement) {
        styleElement = document.createElement('style');
        styleElement.id = 'branding-styles';
        document.head.appendChild(styleElement);
      }
      
      styleElement.textContent = css;

      // Update favicon if available
      if (config.logo.favicon) {
        let faviconLink = document.querySelector("link[rel*='icon']") as HTMLLinkElement;
        if (!faviconLink) {
          faviconLink = document.createElement('link');
          faviconLink.rel = 'icon';
          document.head.appendChild(faviconLink);
        }
        faviconLink.href = config.logo.favicon;
      }

      // Update page title if available
      if (config.metaTags?.title) {
        document.title = config.metaTags.title;
      }

      // Update meta description if available
      if (config.metaTags?.description) {
        let metaDescription = document.querySelector('meta[name="description"]') as HTMLMetaElement;
        if (!metaDescription) {
          metaDescription = document.createElement('meta');
          metaDescription.name = 'description';
          document.head.appendChild(metaDescription);
        }
        metaDescription.content = config.metaTags.description;
      }

    } catch (error) {
      console.error('Error applying branding to portal:', error);
    }
  }
}

export const brandingService = new BrandingService();
```

#### Hook for Branding Management
```typescript
// /src/hooks/useBranding.ts
import { useState, useEffect, useCallback } from 'react';
import { BrandingConfig } from '@/types/branding';
import { brandingService } from '@/lib/services/brandingService';

export function useBranding() {
  const [config, setConfig] = useState<BrandingConfig | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchConfig = useCallback(async () => {
    try {
      setLoading(true);
      const brandingConfig = await brandingService.getBrandingConfig();
      setConfig(brandingConfig);
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to fetch branding config');
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchConfig();
  }, [fetchConfig]);

  const updateConfig = useCallback((updates: Partial<BrandingConfig>) => {
    if (config) {
      setConfig({ ...config, ...updates });
    }
  }, [config]);

  const saveConfig = useCallback(async (configToSave: BrandingConfig) => {
    try {
      const savedConfig = await brandingService.saveBrandingConfig(configToSave);
      setConfig(savedConfig);
      return savedConfig;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to save branding config');
      throw err;
    }
  }, []);

  const uploadAsset = useCallback(async (assetType: string, file: File, altText: string) => {
    try {
      const result = await brandingService.uploadBrandAsset(assetType, file, altText);
      return result;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to upload asset');
      throw err;
    }
  }, []);

  const generateCSS = useCallback((brandingConfig: BrandingConfig) => {
    return brandingService.generateCSS(brandingConfig);
  }, []);

  const applyBranding = useCallback(async (customDomain?: string) => {
    try {
      await brandingService.applyBrandingToPortal(customDomain);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to apply branding');
      throw err;
    }
  }, []);

  return {
    config,
    loading,
    error,
    updateConfig,
    saveConfig,
    uploadAsset,
    generateCSS,
    applyBranding,
    refetch: fetchConfig
  };
}
```

### IMPLEMENTATION SUMMARY

This comprehensive branding customization system provides:

1. **Complete White-Label Experience** - Removes all WedSync branding from client portals
2. **Professional Logo Management** - Multiple logo types with automatic optimization
3. **Advanced Color System** - Color presets, harmony generation, and accessibility validation
4. **Typography Control** - Google Fonts integration with font pairing suggestions
5. **Custom CSS Support** - Advanced customization with CSS variable system
6. **Real-time Preview** - Live preview of changes before applying
7. **Asset Optimization** - Automatic image resizing and format conversion
8. **Accessibility Compliance** - WCAG contrast checking and validation

The system enables wedding professionals to create fully branded client experiences that build trust, reinforce their brand identity, and justify premium pricing through professional presentation.

**Key Benefits for Wedding Professionals:**
- Increased brand recognition and trust
- Professional client portal experience
- Higher perceived value ($2,000+ per client)
- Seamless brand consistency across all touchpoints
- Easy-to-use customization without technical knowledge required