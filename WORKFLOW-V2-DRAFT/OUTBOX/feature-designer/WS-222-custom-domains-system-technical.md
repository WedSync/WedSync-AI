# TECHNICAL SPECIFICATION: WS-222 - Custom Domains System
## Generated by Feature Development Session - January 25, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding professional wanting a premium client experience
**I want to:** Host client portals on my own domain (clients.mybusiness.com)
**So that:** Clients see my professional domain instead of WedSync branding, increasing trust and perceived value

**Real Wedding Scenario:**
"Elegant Affairs by Jessica" wants her couples to access their portal at clients.elegantaffairsbyjessica.com instead of jessica-smith.wedsync.app. This custom domain reinforces her premium brand, eliminates third-party associations, and allows her to charge 15-20% more for her services. Couples perceive this as a more professional, established business, leading to higher trust and referrals.

### SPECIFICATION SOURCE
- **Feature ID:** WS-222
- **Original Spec:** /CORE-SPECIFICATIONS/02-WEDSYNC-SUPPLIER-PLATFORM/07-Client-Dashboard-Builder/04-custom-domains md.md
- **Current Implementation:** 0% complete (new)
- **Files to Modify:** None (new feature)
- **New Files to Create:** 
  - `/src/app/(dashboard)/settings/domains/page.tsx`
  - `/src/components/domains/DomainSetup.tsx`
  - `/src/components/domains/DomainVerification.tsx`
  - `/src/components/domains/DNSInstructions.tsx`
  - `/src/components/domains/SSLStatus.tsx`
  - `/src/lib/services/domainService.ts`
  - `/src/lib/utils/dnsUtils.ts`
  - `/src/types/domains.ts`
  - `/src/middleware/customDomains.ts`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Custom domain management tables
CREATE TABLE IF NOT EXISTS custom_domains (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES suppliers(id),
  domain VARCHAR(255) NOT NULL UNIQUE,
  subdomain VARCHAR(100), -- e.g., 'clients' from clients.mybusiness.com
  full_domain VARCHAR(255) GENERATED ALWAYS AS (
    CASE 
      WHEN subdomain IS NOT NULL THEN subdomain || '.' || domain
      ELSE domain
    END
  ) STORED,
  status VARCHAR(20) DEFAULT 'pending' CHECK (status IN ('pending', 'verifying', 'active', 'failed', 'suspended')),
  verification_method VARCHAR(20) DEFAULT 'dns' CHECK (verification_method IN ('dns', 'file')),
  verification_token VARCHAR(255) UNIQUE DEFAULT gen_random_uuid(),
  verified_at TIMESTAMPTZ,
  ssl_status VARCHAR(20) DEFAULT 'pending' CHECK (ssl_status IN ('pending', 'issuing', 'issued', 'expired', 'failed')),
  ssl_certificate_id VARCHAR(255),
  ssl_issued_at TIMESTAMPTZ,
  ssl_expires_at TIMESTAMPTZ,
  auto_renew_ssl BOOLEAN DEFAULT true,
  redirect_www BOOLEAN DEFAULT true,
  force_https BOOLEAN DEFAULT true,
  last_check_at TIMESTAMPTZ DEFAULT NOW(),
  error_message TEXT,
  cdn_enabled BOOLEAN DEFAULT true,
  dns_instructions JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- DNS record tracking
CREATE TABLE IF NOT EXISTS dns_records (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  custom_domain_id UUID REFERENCES custom_domains(id) ON DELETE CASCADE,
  record_type VARCHAR(10) NOT NULL CHECK (record_type IN ('A', 'AAAA', 'CNAME', 'TXT', 'MX')),
  host VARCHAR(255) NOT NULL,
  value TEXT NOT NULL,
  ttl INTEGER DEFAULT 3600,
  priority INTEGER, -- For MX records
  is_required BOOLEAN DEFAULT true,
  is_verified BOOLEAN DEFAULT false,
  last_verified_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Domain verification history
CREATE TABLE IF NOT EXISTS domain_verifications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  custom_domain_id UUID REFERENCES custom_domains(id) ON DELETE CASCADE,
  verification_type VARCHAR(20) NOT NULL,
  status VARCHAR(20) NOT NULL,
  attempted_at TIMESTAMPTZ DEFAULT NOW(),
  error_details TEXT,
  response_data JSONB,
  verified_by VARCHAR(100) -- system, user, etc.
);

-- SSL certificate management
CREATE TABLE IF NOT EXISTS ssl_certificates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  custom_domain_id UUID REFERENCES custom_domains(id) ON DELETE CASCADE,
  provider VARCHAR(50) DEFAULT 'letsencrypt',
  certificate_data TEXT, -- Base64 encoded certificate
  private_key_data TEXT, -- Encrypted private key
  intermediate_chain TEXT, -- Certificate chain
  issued_at TIMESTAMPTZ NOT NULL,
  expires_at TIMESTAMPTZ NOT NULL,
  auto_renewal_enabled BOOLEAN DEFAULT true,
  last_renewal_attempt TIMESTAMPTZ,
  renewal_status VARCHAR(20) DEFAULT 'active',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Domain analytics and monitoring
CREATE TABLE IF NOT EXISTS domain_analytics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  custom_domain_id UUID REFERENCES custom_domains(id) ON DELETE CASCADE,
  date DATE NOT NULL,
  requests_count BIGINT DEFAULT 0,
  unique_visitors INTEGER DEFAULT 0,
  bandwidth_mb DECIMAL(10,2) DEFAULT 0,
  response_time_avg DECIMAL(8,2), -- Average response time in ms
  uptime_percentage DECIMAL(5,2) DEFAULT 100,
  ssl_errors INTEGER DEFAULT 0,
  dns_errors INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(custom_domain_id, date)
);

-- Insert default DNS instructions template
INSERT INTO custom_domains (id, supplier_id, domain, dns_instructions) VALUES 
('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', 'example.com', 
'{
  "steps": [
    {
      "title": "Add CNAME Record",
      "description": "Add the following CNAME record to your DNS provider",
      "record": {
        "type": "CNAME",
        "host": "@",
        "value": "custom.wedsync.app",
        "ttl": 3600
      }
    }
  ],
  "providers": {
    "cloudflare": {
      "instructions": "Log in to Cloudflare → DNS → Add record → CNAME",
      "support_url": "https://support.cloudflare.com/hc/en-us/articles/360019093151"
    },
    "godaddy": {
      "instructions": "Log in to GoDaddy → DNS Management → Add CNAME record",
      "support_url": "https://www.godaddy.com/help/add-a-cname-record-19236"
    }
  }
}'::jsonb)
ON CONFLICT DO NOTHING;

-- RLS Policies
ALTER TABLE custom_domains ENABLE ROW LEVEL SECURITY;
ALTER TABLE dns_records ENABLE ROW LEVEL SECURITY;
ALTER TABLE domain_verifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE ssl_certificates ENABLE ROW LEVEL SECURITY;
ALTER TABLE domain_analytics ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Suppliers can manage their domains" ON custom_domains
  FOR ALL USING (auth.uid() = supplier_id OR 
                 auth.uid() IN (SELECT user_id FROM team_members WHERE supplier_id = custom_domains.supplier_id));

CREATE POLICY "DNS records belong to supplier domains" ON dns_records
  FOR ALL USING (auth.uid() IN (
    SELECT cd.supplier_id FROM custom_domains cd WHERE cd.id = dns_records.custom_domain_id
  ));

CREATE POLICY "Domain verifications belong to supplier" ON domain_verifications
  FOR ALL USING (auth.uid() IN (
    SELECT cd.supplier_id FROM custom_domains cd WHERE cd.id = domain_verifications.custom_domain_id
  ));

CREATE POLICY "SSL certificates belong to supplier" ON ssl_certificates
  FOR ALL USING (auth.uid() IN (
    SELECT cd.supplier_id FROM custom_domains cd WHERE cd.id = ssl_certificates.custom_domain_id
  ));

CREATE POLICY "Domain analytics belong to supplier" ON domain_analytics
  FOR ALL USING (auth.uid() IN (
    SELECT cd.supplier_id FROM custom_domains cd WHERE cd.id = domain_analytics.custom_domain_id
  ));

-- Indexes for performance
CREATE INDEX idx_custom_domains_supplier_id ON custom_domains(supplier_id);
CREATE INDEX idx_custom_domains_status ON custom_domains(status);
CREATE INDEX idx_custom_domains_full_domain ON custom_domains(full_domain);
CREATE INDEX idx_custom_domains_verification_token ON custom_domains(verification_token);
CREATE INDEX idx_dns_records_domain_id ON dns_records(custom_domain_id);
CREATE INDEX idx_domain_verifications_domain_id ON domain_verifications(custom_domain_id);
CREATE INDEX idx_ssl_certificates_domain_id ON ssl_certificates(custom_domain_id);
CREATE INDEX idx_ssl_certificates_expires_at ON ssl_certificates(expires_at);
CREATE INDEX idx_domain_analytics_date ON domain_analytics(custom_domain_id, date);

-- Functions and triggers
CREATE OR REPLACE FUNCTION update_domain_modified()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_custom_domains_modified
  BEFORE UPDATE ON custom_domains
  FOR EACH ROW EXECUTE FUNCTION update_domain_modified();

-- Function to check domain availability
CREATE OR REPLACE FUNCTION is_domain_available(domain_name TEXT)
RETURNS BOOLEAN AS $$
BEGIN
  RETURN NOT EXISTS (
    SELECT 1 FROM custom_domains 
    WHERE full_domain = domain_name AND status IN ('active', 'pending', 'verifying')
  );
END;
$$ LANGUAGE plpgsql;
```

#### TypeScript Interfaces
```typescript
// /src/types/domains.ts
export interface CustomDomain {
  id: string;
  supplier_id: string;
  domain: string;
  subdomain: string | null;
  full_domain: string;
  status: 'pending' | 'verifying' | 'active' | 'failed' | 'suspended';
  verification_method: 'dns' | 'file';
  verification_token: string;
  verified_at: string | null;
  ssl_status: 'pending' | 'issuing' | 'issued' | 'expired' | 'failed';
  ssl_certificate_id: string | null;
  ssl_issued_at: string | null;
  ssl_expires_at: string | null;
  auto_renew_ssl: boolean;
  redirect_www: boolean;
  force_https: boolean;
  last_check_at: string;
  error_message: string | null;
  cdn_enabled: boolean;
  dns_instructions: DNSInstructions;
  created_at: string;
  updated_at: string;
}

export interface DNSRecord {
  id: string;
  custom_domain_id: string;
  record_type: 'A' | 'AAAA' | 'CNAME' | 'TXT' | 'MX';
  host: string;
  value: string;
  ttl: number;
  priority: number | null;
  is_required: boolean;
  is_verified: boolean;
  last_verified_at: string | null;
  created_at: string;
}

export interface DomainVerification {
  id: string;
  custom_domain_id: string;
  verification_type: string;
  status: string;
  attempted_at: string;
  error_details: string | null;
  response_data: any;
  verified_by: string | null;
}

export interface SSLCertificate {
  id: string;
  custom_domain_id: string;
  provider: string;
  issued_at: string;
  expires_at: string;
  auto_renewal_enabled: boolean;
  last_renewal_attempt: string | null;
  renewal_status: string;
  created_at: string;
}

export interface DNSInstructions {
  steps: DNSStep[];
  providers: Record<string, DNSProviderInstructions>;
}

export interface DNSStep {
  title: string;
  description: string;
  record: {
    type: string;
    host: string;
    value: string;
    ttl: number;
  };
  optional?: boolean;
}

export interface DNSProviderInstructions {
  instructions: string;
  support_url: string;
  video_url?: string;
}

export interface DomainAnalytics {
  id: string;
  custom_domain_id: string;
  date: string;
  requests_count: number;
  unique_visitors: number;
  bandwidth_mb: number;
  response_time_avg: number | null;
  uptime_percentage: number;
  ssl_errors: number;
  dns_errors: number;
}

export interface DomainSetupRequest {
  domain: string;
  subdomain?: string;
  verification_method?: 'dns' | 'file';
  redirect_www?: boolean;
  force_https?: boolean;
  cdn_enabled?: boolean;
}

export interface DomainValidationResult {
  isValid: boolean;
  errors: string[];
  suggestions: string[];
  estimated_setup_time: string;
}
```

#### API Endpoints Required

**1. GET /api/domains**
```typescript
// /src/app/api/domains/route.ts
import { NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { getCurrentSupplier } from '@/lib/auth/server';

export async function GET() {
  try {
    const supplier = await getCurrentSupplier();
    const supabase = createClient();

    const { data: domains, error } = await supabase
      .from('custom_domains')
      .select(`
        *,
        dns_records (*),
        ssl_certificates (*),
        domain_analytics (
          date,
          requests_count,
          unique_visitors,
          uptime_percentage
        )
      `)
      .eq('supplier_id', supplier.id)
      .order('created_at', { ascending: false });

    if (error) throw error;

    return NextResponse.json({ domains });

  } catch (error) {
    console.error('Error fetching domains:', error);
    return NextResponse.json(
      { error: 'Failed to fetch custom domains' },
      { status: 500 }
    );
  }
}

export async function POST(request: Request) {
  try {
    const supplier = await getCurrentSupplier();
    const supabase = createClient();
    const domainRequest = await request.json() as DomainSetupRequest;

    // Validate domain format
    const domainRegex = /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i;
    const fullDomain = domainRequest.subdomain 
      ? `${domainRequest.subdomain}.${domainRequest.domain}`
      : domainRequest.domain;

    if (!domainRegex.test(fullDomain)) {
      return NextResponse.json(
        { error: 'Invalid domain format' },
        { status: 400 }
      );
    }

    // Check if domain is already in use
    const { data: existingDomain } = await supabase
      .from('custom_domains')
      .select('id')
      .eq('full_domain', fullDomain)
      .single();

    if (existingDomain) {
      return NextResponse.json(
        { error: 'Domain is already in use' },
        { status: 409 }
      );
    }

    // Generate verification token
    const verificationToken = crypto.randomUUID();

    // Create DNS instructions based on subdomain/domain setup
    const dnsInstructions = {
      steps: [
        {
          title: 'Add CNAME Record',
          description: `Point your ${domainRequest.subdomain || 'domain'} to our servers`,
          record: {
            type: 'CNAME',
            host: domainRequest.subdomain || '@',
            value: 'custom.wedsync.app',
            ttl: 3600
          }
        },
        {
          title: 'Add TXT Record for Verification',
          description: 'Add this TXT record to verify domain ownership',
          record: {
            type: 'TXT',
            host: `_wedsync-verify.${domainRequest.subdomain || '@'}`,
            value: `wedsync-domain-verification=${verificationToken}`,
            ttl: 3600
          }
        }
      ],
      providers: {
        cloudflare: {
          instructions: 'Log in to Cloudflare Dashboard → DNS → Add records as shown above',
          support_url: 'https://support.cloudflare.com/hc/en-us/articles/360019093151'
        },
        godaddy: {
          instructions: 'Log in to GoDaddy → My Products → DNS → Manage → Add records',
          support_url: 'https://www.godaddy.com/help/add-a-cname-record-19236'
        },
        namecheap: {
          instructions: 'Log in to Namecheap → Domain List → Manage → Advanced DNS → Add records',
          support_url: 'https://www.namecheap.com/support/knowledgebase/article.aspx/9646/2237/how-to-create-a-cname-record-for-your-domain'
        },
        route53: {
          instructions: 'AWS Console → Route 53 → Hosted zones → Select domain → Create records',
          support_url: 'https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/rrsets-working-with.html'
        }
      }
    };

    // Insert domain record
    const { data: domain, error } = await supabase
      .from('custom_domains')
      .insert({
        supplier_id: supplier.id,
        domain: domainRequest.domain,
        subdomain: domainRequest.subdomain,
        verification_method: domainRequest.verification_method || 'dns',
        verification_token: verificationToken,
        redirect_www: domainRequest.redirect_www ?? true,
        force_https: domainRequest.force_https ?? true,
        cdn_enabled: domainRequest.cdn_enabled ?? true,
        dns_instructions: dnsInstructions,
        status: 'pending'
      })
      .select()
      .single();

    if (error) throw error;

    // Create required DNS records
    const dnsRecords = [
      {
        custom_domain_id: domain.id,
        record_type: 'CNAME',
        host: domainRequest.subdomain || '@',
        value: 'custom.wedsync.app',
        ttl: 3600,
        is_required: true
      },
      {
        custom_domain_id: domain.id,
        record_type: 'TXT',
        host: `_wedsync-verify.${domainRequest.subdomain || '@'}`,
        value: `wedsync-domain-verification=${verificationToken}`,
        ttl: 3600,
        is_required: true
      }
    ];

    await supabase
      .from('dns_records')
      .insert(dnsRecords);

    // Start verification process asynchronously
    fetch('/api/domains/verify', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ domain_id: domain.id })
    }).catch(() => {}); // Fire and forget

    return NextResponse.json({ 
      domain,
      message: 'Domain setup initiated. Please configure your DNS records as instructed.'
    });

  } catch (error) {
    console.error('Error setting up domain:', error);
    return NextResponse.json(
      { error: 'Failed to setup custom domain' },
      { status: 500 }
    );
  }
}
```

**2. POST /api/domains/verify**
```typescript
// /src/app/api/domains/verify/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { verifyDNSRecords, checkSSLCertificate } from '@/lib/utils/dnsUtils';
import { issueLetsEncryptCertificate } from '@/lib/utils/sslUtils';

export async function POST(request: NextRequest) {
  try {
    const { domain_id } = await request.json();
    const supabase = createClient();

    // Get domain details
    const { data: domain, error } = await supabase
      .from('custom_domains')
      .select(`
        *,
        dns_records (*)
      `)
      .eq('id', domain_id)
      .single();

    if (error || !domain) {
      return NextResponse.json(
        { error: 'Domain not found' },
        { status: 404 }
      );
    }

    // Update status to verifying
    await supabase
      .from('custom_domains')
      .update({ 
        status: 'verifying',
        last_check_at: new Date().toISOString()
      })
      .eq('id', domain_id);

    try {
      // Verify DNS records
      const dnsVerificationResult = await verifyDNSRecords(domain);
      
      if (!dnsVerificationResult.success) {
        // Update domain status to failed
        await supabase
          .from('custom_domains')
          .update({ 
            status: 'failed',
            error_message: dnsVerificationResult.error,
            last_check_at: new Date().toISOString()
          })
          .eq('id', domain_id);

        // Log verification attempt
        await supabase
          .from('domain_verifications')
          .insert({
            custom_domain_id: domain_id,
            verification_type: 'dns',
            status: 'failed',
            error_details: dnsVerificationResult.error,
            response_data: dnsVerificationResult.details
          });

        return NextResponse.json({
          success: false,
          error: dnsVerificationResult.error,
          details: dnsVerificationResult.details
        });
      }

      // Update DNS records as verified
      for (const record of dnsVerificationResult.verified_records) {
        await supabase
          .from('dns_records')
          .update({
            is_verified: true,
            last_verified_at: new Date().toISOString()
          })
          .eq('custom_domain_id', domain_id)
          .eq('record_type', record.type)
          .eq('host', record.host);
      }

      // Domain verification successful - update status
      await supabase
        .from('custom_domains')
        .update({ 
          status: 'active',
          verified_at: new Date().toISOString(),
          error_message: null,
          last_check_at: new Date().toISOString()
        })
        .eq('id', domain_id);

      // Log successful verification
      await supabase
        .from('domain_verifications')
        .insert({
          custom_domain_id: domain_id,
          verification_type: 'dns',
          status: 'success',
          response_data: dnsVerificationResult.details,
          verified_by: 'system'
        });

      // Initiate SSL certificate issuance
      if (domain.ssl_status === 'pending') {
        await supabase
          .from('custom_domains')
          .update({ ssl_status: 'issuing' })
          .eq('id', domain_id);

        try {
          const sslResult = await issueLetsEncryptCertificate(domain.full_domain);
          
          if (sslResult.success) {
            // Store SSL certificate
            const { data: sslCert } = await supabase
              .from('ssl_certificates')
              .insert({
                custom_domain_id: domain_id,
                provider: 'letsencrypt',
                certificate_data: sslResult.certificate,
                private_key_data: sslResult.privateKey, // Should be encrypted
                intermediate_chain: sslResult.chain,
                issued_at: new Date().toISOString(),
                expires_at: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString(), // 90 days
                auto_renewal_enabled: true,
                renewal_status: 'active'
              })
              .select()
              .single();

            await supabase
              .from('custom_domains')
              .update({ 
                ssl_status: 'issued',
                ssl_certificate_id: sslCert.id,
                ssl_issued_at: sslCert.issued_at,
                ssl_expires_at: sslCert.expires_at
              })
              .eq('id', domain_id);
          } else {
            await supabase
              .from('custom_domains')
              .update({ 
                ssl_status: 'failed',
                error_message: `SSL issuance failed: ${sslResult.error}`
              })
              .eq('id', domain_id);
          }
        } catch (sslError) {
          console.error('SSL certificate issuance error:', sslError);
          await supabase
            .from('custom_domains')
            .update({ 
              ssl_status: 'failed',
              error_message: `SSL issuance error: ${sslError.message}`
            })
            .eq('id', domain_id);
        }
      }

      return NextResponse.json({
        success: true,
        message: 'Domain verified successfully',
        domain_status: 'active',
        ssl_status: domain.ssl_status
      });

    } catch (verificationError) {
      console.error('Domain verification error:', verificationError);
      
      await supabase
        .from('custom_domains')
        .update({ 
          status: 'failed',
          error_message: verificationError.message,
          last_check_at: new Date().toISOString()
        })
        .eq('id', domain_id);

      return NextResponse.json({
        success: false,
        error: verificationError.message
      }, { status: 500 });
    }

  } catch (error) {
    console.error('Error in domain verification:', error);
    return NextResponse.json(
      { error: 'Verification process failed' },
      { status: 500 }
    );
  }
}
```

**3. DELETE /api/domains/[id]**
```typescript
// /src/app/api/domains/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { getCurrentSupplier } from '@/lib/auth/server';

export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const supplier = await getCurrentSupplier();
    const supabase = createClient();
    const domainId = params.id;

    // Verify domain ownership
    const { data: domain, error } = await supabase
      .from('custom_domains')
      .select('id, full_domain, status')
      .eq('id', domainId)
      .eq('supplier_id', supplier.id)
      .single();

    if (error || !domain) {
      return NextResponse.json(
        { error: 'Domain not found or access denied' },
        { status: 404 }
      );
    }

    // Check if domain is actively serving traffic
    if (domain.status === 'active') {
      // Get recent analytics to warn about traffic
      const { data: analytics } = await supabase
        .from('domain_analytics')
        .select('requests_count')
        .eq('custom_domain_id', domainId)
        .gte('date', new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0])
        .order('date', { ascending: false })
        .limit(1);

      if (analytics && analytics[0]?.requests_count > 0) {
        return NextResponse.json(
          { 
            error: 'Cannot delete active domain with recent traffic',
            suggestion: 'Consider suspending the domain first to avoid breaking client access'
          },
          { status: 409 }
        );
      }
    }

    // Soft delete approach - mark as suspended instead of hard delete
    const { error: updateError } = await supabase
      .from('custom_domains')
      .update({ 
        status: 'suspended',
        error_message: 'Domain removed by user',
        updated_at: new Date().toISOString()
      })
      .eq('id', domainId);

    if (updateError) throw updateError;

    return NextResponse.json({
      success: true,
      message: 'Domain has been removed successfully'
    });

  } catch (error) {
    console.error('Error deleting domain:', error);
    return NextResponse.json(
      { error: 'Failed to delete custom domain' },
      { status: 500 }
    );
  }
}
```

#### React Components

**1. Domain Setup Component**
```tsx
// /src/components/domains/DomainSetup.tsx
'use client';

import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Badge } from '@/components/ui/badge';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { 
  Globe, 
  Shield, 
  CheckCircle, 
  AlertCircle, 
  Clock,
  ExternalLink,
  Trash2,
  RotateCcw
} from 'lucide-react';
import { CustomDomain, DomainSetupRequest } from '@/types/domains';
import { DomainVerification } from './DomainVerification';
import { DNSInstructions } from './DNSInstructions';
import { SSLStatus } from './SSLStatus';
import { useToast } from '@/components/ui/use-toast';

export function DomainSetup() {
  const { toast } = useToast();
  const [domains, setDomains] = useState<CustomDomain[]>([]);
  const [loading, setLoading] = useState(true);
  const [isAddingDomain, setIsAddingDomain] = useState(false);
  const [newDomain, setNewDomain] = useState<DomainSetupRequest>({
    domain: '',
    subdomain: 'clients',
    verification_method: 'dns',
    redirect_www: true,
    force_https: true,
    cdn_enabled: true
  });

  useEffect(() => {
    fetchDomains();
  }, []);

  const fetchDomains = async () => {
    try {
      const response = await fetch('/api/domains');
      const data = await response.json();
      setDomains(data.domains || []);
    } catch (error) {
      toast({
        title: 'Error',
        description: 'Failed to load custom domains',
        variant: 'destructive',
      });
    } finally {
      setLoading(false);
    }
  };

  const handleAddDomain = async () => {
    if (!newDomain.domain) {
      toast({
        title: 'Error',
        description: 'Please enter a domain name',
        variant: 'destructive',
      });
      return;
    }

    try {
      setIsAddingDomain(true);
      const response = await fetch('/api/domains', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newDomain),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Failed to add domain');
      }

      toast({
        title: 'Success',
        description: 'Domain added successfully. Please configure your DNS records.',
      });

      setNewDomain({
        domain: '',
        subdomain: 'clients',
        verification_method: 'dns',
        redirect_www: true,
        force_https: true,
        cdn_enabled: true
      });

      fetchDomains();

    } catch (error) {
      toast({
        title: 'Error',
        description: error.message || 'Failed to add domain',
        variant: 'destructive',
      });
    } finally {
      setIsAddingDomain(false);
    }
  };

  const handleDeleteDomain = async (domainId: string) => {
    if (!confirm('Are you sure you want to remove this domain? This action cannot be undone.')) {
      return;
    }

    try {
      const response = await fetch(`/api/domains/${domainId}`, {
        method: 'DELETE',
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Failed to delete domain');
      }

      toast({
        title: 'Success',
        description: 'Domain removed successfully',
      });

      fetchDomains();

    } catch (error) {
      toast({
        title: 'Error',
        description: error.message || 'Failed to remove domain',
        variant: 'destructive',
      });
    }
  };

  const handleRetryVerification = async (domainId: string) => {
    try {
      const response = await fetch('/api/domains/verify', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ domain_id: domainId }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Verification failed');
      }

      toast({
        title: 'Success',
        description: 'Domain verification started',
      });

      fetchDomains();

    } catch (error) {
      toast({
        title: 'Error',
        description: error.message || 'Failed to retry verification',
        variant: 'destructive',
      });
    }
  };

  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'active':
        return <CheckCircle className="w-5 h-5 text-green-500" />;
      case 'pending':
      case 'verifying':
        return <Clock className="w-5 h-5 text-yellow-500" />;
      case 'failed':
      case 'suspended':
        return <AlertCircle className="w-5 h-5 text-red-500" />;
      default:
        return <Globe className="w-5 h-5 text-gray-500" />;
    }
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'active':
        return 'bg-green-100 text-green-800';
      case 'pending':
      case 'verifying':
        return 'bg-yellow-100 text-yellow-800';
      case 'failed':
      case 'suspended':
        return 'bg-red-100 text-red-800';
      default:
        return 'bg-gray-100 text-gray-800';
    }
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center h-96">
        <div className="animate-spin rounded-full h-32 w-32 border-b-2 border-primary"></div>
      </div>
    );
  }

  return (
    <div className="container mx-auto p-6 max-w-6xl">
      <div className="mb-6">
        <h1 className="text-3xl font-bold">Custom Domains</h1>
        <p className="text-gray-600 mt-2">
          Set up custom domains for your client portals to enhance your brand presence
        </p>
      </div>

      {/* Add New Domain */}
      <Card className="mb-8">
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Globe className="w-5 h-5" />
            Add Custom Domain
          </CardTitle>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
            <div>
              <label className="block text-sm font-medium mb-2">
                Subdomain (optional)
              </label>
              <Input
                placeholder="clients"
                value={newDomain.subdomain || ''}
                onChange={(e) => setNewDomain({ ...newDomain, subdomain: e.target.value || undefined })}
              />
              <p className="text-xs text-gray-500 mt-1">
                Leave empty to use your root domain
              </p>
            </div>
            <div>
              <label className="block text-sm font-medium mb-2">
                Your Domain
              </label>
              <Input
                placeholder="yourbusiness.com"
                value={newDomain.domain}
                onChange={(e) => setNewDomain({ ...newDomain, domain: e.target.value })}
              />
            </div>
            <div className="flex items-end">
              <Button 
                onClick={handleAddDomain} 
                disabled={isAddingDomain || !newDomain.domain}
                className="w-full"
              >
                {isAddingDomain ? 'Adding...' : 'Add Domain'}
              </Button>
            </div>
          </div>

          {newDomain.domain && (
            <Alert className="mb-4">
              <Globe className="h-4 w-4" />
              <AlertDescription>
                Your client portal will be available at: <strong>
                  {newDomain.subdomain ? `${newDomain.subdomain}.${newDomain.domain}` : newDomain.domain}
                </strong>
              </AlertDescription>
            </Alert>
          )}

          <div className="flex flex-wrap gap-2">
            <label className="flex items-center space-x-2">
              <input
                type="checkbox"
                checked={newDomain.redirect_www}
                onChange={(e) => setNewDomain({ ...newDomain, redirect_www: e.target.checked })}
              />
              <span className="text-sm">Redirect www to non-www</span>
            </label>
            <label className="flex items-center space-x-2">
              <input
                type="checkbox"
                checked={newDomain.force_https}
                onChange={(e) => setNewDomain({ ...newDomain, force_https: e.target.checked })}
              />
              <span className="text-sm">Force HTTPS</span>
            </label>
            <label className="flex items-center space-x-2">
              <input
                type="checkbox"
                checked={newDomain.cdn_enabled}
                onChange={(e) => setNewDomain({ ...newDomain, cdn_enabled: e.target.checked })}
              />
              <span className="text-sm">Enable CDN</span>
            </label>
          </div>
        </CardContent>
      </Card>

      {/* Existing Domains */}
      <div className="space-y-6">
        {domains.length === 0 ? (
          <Card>
            <CardContent className="p-8 text-center">
              <Globe className="w-16 h-16 mx-auto text-gray-400 mb-4" />
              <h3 className="text-xl font-semibold mb-2">No Custom Domains Yet</h3>
              <p className="text-gray-600">
                Add your first custom domain to start providing branded client portals
              </p>
            </CardContent>
          </Card>
        ) : (
          domains.map((domain) => (
            <Card key={domain.id}>
              <CardHeader>
                <div className="flex justify-between items-start">
                  <div className="flex items-center gap-3">
                    {getStatusIcon(domain.status)}
                    <div>
                      <CardTitle className="text-xl">{domain.full_domain}</CardTitle>
                      <div className="flex items-center gap-2 mt-1">
                        <Badge className={getStatusColor(domain.status)}>
                          {domain.status.charAt(0).toUpperCase() + domain.status.slice(1)}
                        </Badge>
                        {domain.ssl_status === 'issued' && (
                          <Badge className="bg-green-100 text-green-800">
                            <Shield className="w-3 h-3 mr-1" />
                            SSL Active
                          </Badge>
                        )}
                        {domain.cdn_enabled && (
                          <Badge variant="outline">
                            CDN Enabled
                          </Badge>
                        )}
                      </div>
                    </div>
                  </div>
                  <div className="flex gap-2">
                    {domain.status === 'failed' && (
                      <Button
                        size="sm"
                        variant="outline"
                        onClick={() => handleRetryVerification(domain.id)}
                      >
                        <RotateCcw className="w-4 h-4 mr-1" />
                        Retry
                      </Button>
                    )}
                    {domain.status === 'active' && (
                      <Button
                        size="sm"
                        variant="outline"
                        onClick={() => window.open(`https://${domain.full_domain}`, '_blank')}
                      >
                        <ExternalLink className="w-4 h-4 mr-1" />
                        Visit
                      </Button>
                    )}
                    <Button
                      size="sm"
                      variant="outline"
                      onClick={() => handleDeleteDomain(domain.id)}
                      className="text-red-600 hover:text-red-800"
                    >
                      <Trash2 className="w-4 h-4" />
                    </Button>
                  </div>
                </div>
              </CardHeader>
              <CardContent>
                {domain.error_message && (
                  <Alert className="mb-4" variant="destructive">
                    <AlertCircle className="h-4 w-4" />
                    <AlertDescription>{domain.error_message}</AlertDescription>
                  </Alert>
                )}

                <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                  {/* DNS Instructions */}
                  {(domain.status === 'pending' || domain.status === 'failed') && (
                    <DNSInstructions domain={domain} />
                  )}

                  {/* Verification Status */}
                  {domain.status === 'verifying' && (
                    <DomainVerification domain={domain} onVerified={fetchDomains} />
                  )}

                  {/* SSL Status */}
                  {domain.status === 'active' && (
                    <SSLStatus domain={domain} />
                  )}

                  {/* Domain Analytics */}
                  {domain.status === 'active' && domain.domain_analytics && (
                    <div>
                      <h4 className="font-semibold mb-3">Recent Activity</h4>
                      <div className="grid grid-cols-2 gap-4">
                        <div className="text-center p-3 bg-gray-50 rounded">
                          <div className="text-2xl font-bold">
                            {domain.domain_analytics[0]?.requests_count.toLocaleString() || '0'}
                          </div>
                          <div className="text-sm text-gray-600">Requests Today</div>
                        </div>
                        <div className="text-center p-3 bg-gray-50 rounded">
                          <div className="text-2xl font-bold">
                            {domain.domain_analytics[0]?.uptime_percentage || '100'}%
                          </div>
                          <div className="text-sm text-gray-600">Uptime</div>
                        </div>
                      </div>
                    </div>
                  )}
                </div>

                <div className="mt-4 text-sm text-gray-500">
                  Created: {new Date(domain.created_at).toLocaleDateString()}
                  {domain.verified_at && (
                    <> • Verified: {new Date(domain.verified_at).toLocaleDateString()}</>
                  )}
                </div>
              </CardContent>
            </Card>
          ))
        )}
      </div>
    </div>
  );
}
```

**2. DNS Instructions Component**
```tsx
// /src/components/domains/DNSInstructions.tsx
'use client';

import React, { useState } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Copy, ExternalLink, CheckCircle } from 'lucide-react';
import { CustomDomain } from '@/types/domains';
import { useToast } from '@/components/ui/use-toast';

interface DNSInstructionsProps {
  domain: CustomDomain;
}

export function DNSInstructions({ domain }: DNSInstructionsProps) {
  const { toast } = useToast();
  const [copiedText, setCopiedText] = useState<string | null>(null);

  const copyToClipboard = async (text: string, label: string) => {
    try {
      await navigator.clipboard.writeText(text);
      setCopiedText(label);
      toast({
        title: 'Copied',
        description: `${label} copied to clipboard`,
      });
      setTimeout(() => setCopiedText(null), 2000);
    } catch (error) {
      toast({
        title: 'Error',
        description: 'Failed to copy to clipboard',
        variant: 'destructive',
      });
    }
  };

  const instructions = domain.dns_instructions;
  const providers = Object.keys(instructions.providers || {});

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          DNS Configuration Required
          <Badge variant="outline">Step {domain.status === 'pending' ? '1' : '2'} of 3</Badge>
        </CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-6">
          {/* DNS Records to Add */}
          <div>
            <h4 className="font-semibold mb-3">Add These DNS Records:</h4>
            <div className="space-y-4">
              {instructions.steps.map((step, index) => (
                <div key={index} className="border rounded-lg p-4 bg-gray-50">
                  <div className="flex justify-between items-start mb-2">
                    <h5 className="font-medium">{step.title}</h5>
                    {step.optional && (
                      <Badge variant="secondary" className="text-xs">
                        Optional
                      </Badge>
                    )}
                  </div>
                  <p className="text-sm text-gray-600 mb-3">{step.description}</p>
                  
                  <div className="grid grid-cols-4 gap-2 text-sm font-mono bg-white border rounded p-3">
                    <div>
                      <strong>Type:</strong>
                      <div className="flex items-center gap-2 mt-1">
                        <code className="bg-gray-100 px-2 py-1 rounded">
                          {step.record.type}
                        </code>
                        <Button
                          size="sm"
                          variant="ghost"
                          onClick={() => copyToClipboard(step.record.type, 'Record Type')}
                        >
                          {copiedText === 'Record Type' ? (
                            <CheckCircle className="w-3 h-3 text-green-500" />
                          ) : (
                            <Copy className="w-3 h-3" />
                          )}
                        </Button>
                      </div>
                    </div>
                    <div>
                      <strong>Host:</strong>
                      <div className="flex items-center gap-2 mt-1">
                        <code className="bg-gray-100 px-2 py-1 rounded">
                          {step.record.host}
                        </code>
                        <Button
                          size="sm"
                          variant="ghost"
                          onClick={() => copyToClipboard(step.record.host, 'Host')}
                        >
                          {copiedText === 'Host' ? (
                            <CheckCircle className="w-3 h-3 text-green-500" />
                          ) : (
                            <Copy className="w-3 h-3" />
                          )}
                        </Button>
                      </div>
                    </div>
                    <div>
                      <strong>Value:</strong>
                      <div className="flex items-center gap-2 mt-1">
                        <code className="bg-gray-100 px-2 py-1 rounded text-xs break-all">
                          {step.record.value}
                        </code>
                        <Button
                          size="sm"
                          variant="ghost"
                          onClick={() => copyToClipboard(step.record.value, 'Value')}
                        >
                          {copiedText === 'Value' ? (
                            <CheckCircle className="w-3 h-3 text-green-500" />
                          ) : (
                            <Copy className="w-3 h-3" />
                          )}
                        </Button>
                      </div>
                    </div>
                    <div>
                      <strong>TTL:</strong>
                      <div className="flex items-center gap-2 mt-1">
                        <code className="bg-gray-100 px-2 py-1 rounded">
                          {step.record.ttl}
                        </code>
                        <Button
                          size="sm"
                          variant="ghost"
                          onClick={() => copyToClipboard(step.record.ttl.toString(), 'TTL')}
                        >
                          {copiedText === 'TTL' ? (
                            <CheckCircle className="w-3 h-3 text-green-500" />
                          ) : (
                            <Copy className="w-3 h-3" />
                          )}
                        </Button>
                      </div>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </div>

          {/* Provider-Specific Instructions */}
          {providers.length > 0 && (
            <div>
              <h4 className="font-semibold mb-3">Provider Instructions:</h4>
              <Tabs defaultValue={providers[0]} className="w-full">
                <TabsList className="grid w-full grid-cols-4">
                  {providers.slice(0, 4).map((provider) => (
                    <TabsTrigger key={provider} value={provider} className="capitalize">
                      {provider}
                    </TabsTrigger>
                  ))}
                </TabsList>
                
                {providers.map((provider) => (
                  <TabsContent key={provider} value={provider}>
                    <Card>
                      <CardContent className="pt-6">
                        <p className="mb-4">{instructions.providers[provider].instructions}</p>
                        <Button
                          variant="outline"
                          onClick={() => window.open(instructions.providers[provider].support_url, '_blank')}
                        >
                          <ExternalLink className="w-4 h-4 mr-2" />
                          View {provider.charAt(0).toUpperCase() + provider.slice(1)} Guide
                        </Button>
                      </CardContent>
                    </Card>
                  </TabsContent>
                ))}
              </Tabs>
            </div>
          )}

          {/* Important Notes */}
          <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
            <h5 className="font-semibold text-blue-900 mb-2">Important Notes:</h5>
            <ul className="text-sm text-blue-800 space-y-1">
              <li>• DNS changes can take 24-48 hours to propagate globally</li>
              <li>• We'll automatically verify your domain once DNS is configured</li>
              <li>• SSL certificate will be issued automatically after verification</li>
              <li>• Your client portal will go live once all steps are complete</li>
            </ul>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
```

#### Service Layer and Utilities
```typescript
// /src/lib/services/domainService.ts
import { createClient } from '@/lib/supabase/client';
import { CustomDomain, DomainSetupRequest } from '@/types/domains';

export class DomainService {
  private supabase = createClient();

  async getDomains(): Promise<CustomDomain[]> {
    try {
      const { data, error } = await this.supabase
        .from('custom_domains')
        .select(`
          *,
          dns_records (*),
          ssl_certificates (*),
          domain_analytics (
            date,
            requests_count,
            unique_visitors,
            uptime_percentage
          )
        `)
        .order('created_at', { ascending: false });

      if (error) throw error;
      return data || [];
    } catch (error) {
      console.error('Error fetching domains:', error);
      throw error;
    }
  }

  async addDomain(domainRequest: DomainSetupRequest): Promise<CustomDomain> {
    try {
      const response = await fetch('/api/domains', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(domainRequest),
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Failed to add domain');
      }

      const data = await response.json();
      return data.domain;
    } catch (error) {
      console.error('Error adding domain:', error);
      throw error;
    }
  }

  async verifyDomain(domainId: string): Promise<void> {
    try {
      const response = await fetch('/api/domains/verify', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ domain_id: domainId }),
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Verification failed');
      }
    } catch (error) {
      console.error('Error verifying domain:', error);
      throw error;
    }
  }

  async deleteDomain(domainId: string): Promise<void> {
    try {
      const response = await fetch(`/api/domains/${domainId}`, {
        method: 'DELETE',
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Failed to delete domain');
      }
    } catch (error) {
      console.error('Error deleting domain:', error);
      throw error;
    }
  }

  validateDomain(domain: string): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];
    
    // Basic domain format validation
    const domainRegex = /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i;
    if (!domainRegex.test(domain)) {
      errors.push('Invalid domain format');
    }

    // Check for reserved domains
    const reservedDomains = ['localhost', 'example.com', 'test.com', 'wedsync.app'];
    if (reservedDomains.some(reserved => domain.includes(reserved))) {
      errors.push('Cannot use reserved domains');
    }

    // Length validation
    if (domain.length > 253) {
      errors.push('Domain name too long (max 253 characters)');
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }
}

export const domainService = new DomainService();
```

### IMPLEMENTATION SUMMARY

This comprehensive custom domains system provides:

1. **Professional Domain Setup** - Allows suppliers to host client portals on their own domains
2. **Automated DNS Verification** - Checks DNS records and provides clear setup instructions
3. **SSL Certificate Management** - Automatic Let's Encrypt certificate issuance and renewal
4. **Multi-Provider Support** - Instructions for Cloudflare, GoDaddy, Namecheap, Route 53
5. **Real-time Monitoring** - Tracks domain health, uptime, and traffic analytics
6. **Error Handling** - Comprehensive error reporting and retry mechanisms
7. **Security Features** - HTTPS enforcement, CDN support, domain validation
8. **Analytics Integration** - Traffic monitoring and performance metrics

The system enables wedding professionals to create premium client experiences with their own branded domains, significantly increasing perceived value and professional credibility.

**Key Benefits for Wedding Professionals:**
- Enhanced brand credibility and trust
- Professional domain presence (clients.yourbusiness.com)
- Increased perceived value (15-20% premium pricing)
- Seamless client experience without third-party branding
- Comprehensive monitoring and analytics
- Automated SSL security
- Easy setup with clear DNS instructions