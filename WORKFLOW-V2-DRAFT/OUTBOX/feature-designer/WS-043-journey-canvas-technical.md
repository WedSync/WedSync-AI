# TECHNICAL SPECIFICATION: WS-043 - Journey Canvas
## Generated by Feature Development Session - 2025-08-21

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding photographer who sends the same 15 emails to every couple at predictable times
**I want to:** Create a visual workflow that automatically sends timeline reminders, form requests, and photo delivery updates
**So that:** I can focus on creative work instead of manually tracking when to send "2 weeks before wedding: confirm timeline" emails to 50 different couples

**Real Wedding Scenario:**
A photographer currently uses calendar reminders and sticky notes to remember: "Send engagement session details 8 weeks before wedding", "Request timeline 3 weeks before", "Deliver sneak peeks 2 days after wedding", "Send full gallery 3 weeks after". With the journey canvas, they create one visual workflow and every new couple automatically gets these touchpoints at the right time.

### SPECIFICATION SOURCE
- **Feature ID:** WS-043
- **Original Spec:** /CORE-SPECIFICATIONS/02-WEDSYNC-SUPPLIER-PLATFORM/05-Customer-Journey/01-journey-canvas md.md
- **Current Implementation:** 0% complete (visual 75% done, needs backend)
- **Files to Modify:**
  - `/src/app/(dashboard)/journeys/[id]/canvas/page.tsx` (new)
  - `/src/components/journey/JourneyCanvas.tsx` (enhance existing)
- **New Files to Create:**
  - `/src/components/journey/canvas/CanvasGrid.tsx`
  - `/src/components/journey/canvas/NodeLibrary.tsx`
  - `/src/components/journey/canvas/TimelineAnchor.tsx`
  - `/src/components/journey/canvas/NodeConnector.tsx`
  - `/src/lib/journey/scheduler.ts`
  - `/src/lib/journey/validator.ts`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Journey definitions
CREATE TABLE IF NOT EXISTS journeys (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES suppliers(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  description TEXT,
  status TEXT CHECK (status IN ('draft', 'active', 'paused', 'archived')) DEFAULT 'draft',
  canvas_data JSONB NOT NULL DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Journey nodes (individual steps)
CREATE TABLE IF NOT EXISTS journey_nodes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  journey_id UUID REFERENCES journeys(id) ON DELETE CASCADE,
  node_type TEXT NOT NULL, -- 'timeline', 'module', 'condition', 'split'
  position JSONB NOT NULL, -- {x: number, y: number}
  config JSONB NOT NULL DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Journey connections between nodes
CREATE TABLE IF NOT EXISTS journey_connections (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  journey_id UUID REFERENCES journeys(id) ON DELETE CASCADE,
  source_node_id UUID REFERENCES journey_nodes(id) ON DELETE CASCADE,
  target_node_id UUID REFERENCES journey_nodes(id) ON DELETE CASCADE,
  connection_type TEXT DEFAULT 'default',
  condition_config JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Journey executions for tracking
CREATE TABLE IF NOT EXISTS journey_executions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  journey_id UUID REFERENCES journeys(id) ON DELETE CASCADE,
  client_id UUID REFERENCES clients(id) ON DELETE CASCADE,
  current_node_id UUID REFERENCES journey_nodes(id),
  status TEXT CHECK (status IN ('active', 'completed', 'paused', 'failed')) DEFAULT 'active',
  started_at TIMESTAMPTZ DEFAULT NOW(),
  completed_at TIMESTAMPTZ,
  metadata JSONB DEFAULT '{}'
);

-- Scheduled actions
CREATE TABLE IF NOT EXISTS journey_scheduled_actions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  execution_id UUID REFERENCES journey_executions(id) ON DELETE CASCADE,
  node_id UUID REFERENCES journey_nodes(id) ON DELETE CASCADE,
  action_type TEXT NOT NULL, -- 'email', 'sms', 'form', 'reminder'
  scheduled_for TIMESTAMPTZ NOT NULL,
  status TEXT CHECK (status IN ('pending', 'executed', 'failed', 'cancelled')) DEFAULT 'pending',
  attempt_count INTEGER DEFAULT 0,
  result JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_journeys_supplier_id ON journeys(supplier_id);
CREATE INDEX IF NOT EXISTS idx_journey_nodes_journey_id ON journey_nodes(journey_id);
CREATE INDEX IF NOT EXISTS idx_journey_connections_journey_id ON journey_connections(journey_id);
CREATE INDEX IF NOT EXISTS idx_journey_executions_journey_id ON journey_executions(journey_id);
CREATE INDEX IF NOT EXISTS idx_journey_executions_client_id ON journey_executions(client_id);
CREATE INDEX IF NOT EXISTS idx_journey_scheduled_actions_scheduled_for ON journey_scheduled_actions(scheduled_for);
CREATE INDEX IF NOT EXISTS idx_journey_scheduled_actions_status ON journey_scheduled_actions(status);
```

#### API Endpoints Required
```typescript
// GET /api/journeys/[id]/canvas
interface GetJourneyCanvasResponse {
  journey: Journey;
  nodes: JourneyNode[];
  connections: JourneyConnection[];
  executions: {
    active: number;
    completed: number;
    paused: number;
  };
}

// PUT /api/journeys/[id]/canvas
interface UpdateJourneyCanvasRequest {
  nodes: JourneyNode[];
  connections: JourneyConnection[];
  canvas_data: {
    zoom: number;
    position: { x: number; y: number };
  };
}

// POST /api/journeys/[id]/validate
interface ValidateJourneyRequest {
  nodes: JourneyNode[];
  connections: JourneyConnection[];
}

interface ValidateJourneyResponse {
  isValid: boolean;
  errors: ValidationError[];
  warnings: ValidationWarning[];
}

// POST /api/journeys/[id]/test
interface TestJourneyRequest {
  testData: {
    wedding_date: string;
    couple_name: string;
    email: string;
  };
}
```

#### Frontend Components Required
```typescript
// Component: JourneyCanvas
// Location: /src/components/journey/JourneyCanvas.tsx

interface JourneyCanvasProps {
  journey: Journey;
  nodes: JourneyNode[];
  connections: JourneyConnection[];
  onNodesChange: (nodes: JourneyNode[]) => void;
  onConnectionsChange: (connections: JourneyConnection[]) => void;
}

// Key functionality:
- Infinite canvas with pan and zoom (25% to 200%)
- Node drag-and-drop from library
- Connection drawing between nodes
- Real-time collaboration indicators
- Keyboard shortcuts (Delete, Ctrl+Z, Ctrl+Y)
- Auto-save every 30 seconds

// Component: CanvasGrid
// Location: /src/components/journey/canvas/CanvasGrid.tsx
interface CanvasGridProps {
  zoom: number;
  position: { x: number; y: number };
}

// Key functionality:
- Snap-to-grid positioning
- Visual grid lines that scale with zoom
- Timeline ruler at top
- Coordinate system for node placement

// Component: NodeLibrary
// Location: /src/components/journey/canvas/NodeLibrary.tsx
interface NodeLibraryProps {
  onNodeDrag: (nodeType: string, config: any) => void;
}

// Key functionality:
- Categorized node types (Communication, Data Collection, Scheduling)
- Drag sources for canvas placement
- Node configuration previews
- Tier-based restrictions (Basic/Pro features)

// Component: TimelineAnchor
// Location: /src/components/journey/canvas/TimelineAnchor.tsx
interface TimelineAnchorProps {
  position: { x: number; y: number };
  anchorType: 'booking_date' | 'wedding_date' | 'fixed_date' | 'relative_date';
  config: TimelineAnchorConfig;
  onConfigChange: (config: TimelineAnchorConfig) => void;
}

// Key functionality:
- Visual timeline representation
- Date calculation preview
- Business hours and weekend handling
- Timezone-aware scheduling
```

#### Integration Points
```typescript
// Service: JourneyScheduler
// Dependencies: Node.js cron, date-fns

class JourneyScheduler {
  async scheduleJourneyForClient(journeyId: string, clientId: string): Promise<void> {
    const journey = await this.getJourney(journeyId);
    const client = await this.getClient(clientId);
    
    // Create execution record
    const execution = await supabase
      .from('journey_executions')
      .insert({
        journey_id: journeyId,
        client_id: clientId,
        status: 'active'
      })
      .select()
      .single();
    
    // Schedule all timeline-based actions
    const timelineNodes = journey.nodes.filter(n => n.node_type === 'timeline');
    
    for (const node of timelineNodes) {
      const scheduledDate = this.calculateScheduleDate(
        node.config.anchor_type,
        node.config.offset,
        client.wedding_date,
        client.booking_date
      );
      
      await this.scheduleAction(execution.data.id, node.id, scheduledDate);
    }
  }
  
  private calculateScheduleDate(
    anchorType: string,
    offset: { value: number; unit: 'days' | 'weeks' | 'months' },
    weddingDate: string,
    bookingDate: string
  ): Date {
    const anchor = anchorType === 'wedding_date' ? new Date(weddingDate) : new Date(bookingDate);
    
    let scheduledDate: Date;
    
    switch (offset.unit) {
      case 'days':
        scheduledDate = addDays(anchor, offset.value);
        break;
      case 'weeks':
        scheduledDate = addWeeks(anchor, offset.value);
        break;
      case 'months':
        scheduledDate = addMonths(anchor, offset.value);
        break;
    }
    
    // Handle business hours and weekend skipping
    if (this.shouldSkipWeekends(anchorType)) {
      scheduledDate = this.adjustForBusinessDays(scheduledDate);
    }
    
    return scheduledDate;
  }
  
  async executeScheduledAction(actionId: string): Promise<void> {
    const action = await this.getScheduledAction(actionId);
    
    try {
      switch (action.action_type) {
        case 'email':
          await this.sendEmail(action);
          break;
        case 'sms':
          await this.sendSMS(action);
          break;
        case 'form':
          await this.sendForm(action);
          break;
        case 'reminder':
          await this.createReminder(action);
          break;
      }
      
      await this.markActionCompleted(actionId);
    } catch (error) {
      await this.markActionFailed(actionId, error.message);
    }
  }
}
```

### CODE EXAMPLES

#### Example 1: Canvas Drag and Drop Implementation
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { useState, useCallback, useRef } from 'react';
import { DndProvider, useDrag, useDrop } from 'react-dnd';
import { HTML5Backend } from 'react-dnd-html5-backend';

interface JourneyCanvasProps {
  nodes: JourneyNode[];
  onNodesChange: (nodes: JourneyNode[]) => void;
}

export function JourneyCanvas({ nodes, onNodesChange }: JourneyCanvasProps) {
  const [canvasOffset, setCanvasOffset] = useState({ x: 0, y: 0 });
  const [zoom, setZoom] = useState(1);
  const canvasRef = useRef<HTMLDivElement>(null);
  
  const [, drop] = useDrop({
    accept: ['node', 'existing-node'],
    drop: (item: any, monitor) => {
      const offset = monitor.getSourceClientOffset();
      if (!offset || !canvasRef.current) return;
      
      const canvasRect = canvasRef.current.getBoundingClientRect();
      const position = {
        x: (offset.x - canvasRect.left - canvasOffset.x) / zoom,
        y: (offset.y - canvasRect.top - canvasOffset.y) / zoom
      };
      
      if (item.type === 'new-node') {
        // Create new node
        const newNode: JourneyNode = {
          id: generateId(),
          journey_id: '',
          node_type: item.nodeType,
          position,
          config: item.defaultConfig || {}
        };
        
        onNodesChange([...nodes, newNode]);
      } else {
        // Move existing node
        const updatedNodes = nodes.map(node =>
          node.id === item.id ? { ...node, position } : node
        );
        onNodesChange(updatedNodes);
      }
    }
  });
  
  const handleCanvasPan = useCallback((deltaX: number, deltaY: number) => {
    setCanvasOffset(prev => ({
      x: prev.x + deltaX,
      y: prev.y + deltaY
    }));
  }, []);
  
  const handleZoom = useCallback((zoomDelta: number, centerPoint: { x: number; y: number }) => {
    setZoom(prevZoom => {
      const newZoom = Math.max(0.25, Math.min(2, prevZoom + zoomDelta));
      
      // Adjust offset to zoom towards center point
      const zoomFactor = newZoom / prevZoom;
      setCanvasOffset(prev => ({
        x: centerPoint.x - (centerPoint.x - prev.x) * zoomFactor,
        y: centerPoint.y - (centerPoint.y - prev.y) * zoomFactor
      }));
      
      return newZoom;
    });
  }, []);
  
  return (
    <DndProvider backend={HTML5Backend}>
      <div
        ref={(node) => drop(canvasRef.current = node)}
        className="relative w-full h-full overflow-hidden bg-gray-50"
        onWheel={(e) => {
          e.preventDefault();
          const zoomDelta = e.deltaY > 0 ? -0.1 : 0.1;
          handleZoom(zoomDelta, { x: e.clientX, y: e.clientY });
        }}
      >
        {/* Grid Background */}
        <CanvasGrid zoom={zoom} offset={canvasOffset} />
        
        {/* Nodes */}
        <div
          className="relative"
          style={{
            transform: `translate(${canvasOffset.x}px, ${canvasOffset.y}px) scale(${zoom})`
          }}
        >
          {nodes.map(node => (
            <DraggableNode
              key={node.id}
              node={node}
              onMove={(position) => {
                const updatedNodes = nodes.map(n =>
                  n.id === node.id ? { ...n, position } : n
                );
                onNodesChange(updatedNodes);
              }}
            />
          ))}
        </div>
        
        {/* Zoom Controls */}
        <div className="absolute bottom-4 right-4 flex flex-col gap-2">
          <button
            onClick={() => handleZoom(0.1, { x: window.innerWidth / 2, y: window.innerHeight / 2 })}
            className="p-2 bg-white rounded shadow border"
          >
            +
          </button>
          <button
            onClick={() => handleZoom(-0.1, { x: window.innerWidth / 2, y: window.innerHeight / 2 })}
            className="p-2 bg-white rounded shadow border"
          >
            -
          </button>
        </div>
      </div>
    </DndProvider>
  );
}
```

#### Example 2: Timeline Anchor Logic
```typescript
import { addDays, addWeeks, addMonths, isWeekend, nextMonday } from 'date-fns';

interface TimelineAnchorConfig {
  anchor_type: 'booking_date' | 'wedding_date' | 'fixed_date' | 'relative_date';
  offset: {
    value: number;
    unit: 'days' | 'weeks' | 'months';
    direction: 'before' | 'after';
  };
  business_hours?: {
    start: string; // "09:00"
    end: string;   // "17:00"
  };
  skip_weekends: boolean;
  timezone: string;
}

export class TimelineCalculator {
  static calculateExecutionDate(
    config: TimelineAnchorConfig,
    weddingDate: Date,
    bookingDate: Date,
    fixedDate?: Date
  ): Date {
    let anchor: Date;
    
    switch (config.anchor_type) {
      case 'wedding_date':
        anchor = weddingDate;
        break;
      case 'booking_date':
        anchor = bookingDate;
        break;
      case 'fixed_date':
        anchor = fixedDate || new Date();
        break;
      default:
        throw new Error(`Unsupported anchor type: ${config.anchor_type}`);
    }
    
    // Calculate offset
    let targetDate = anchor;
    const offsetValue = config.offset.direction === 'before' 
      ? -Math.abs(config.offset.value)
      : Math.abs(config.offset.value);
    
    switch (config.offset.unit) {
      case 'days':
        targetDate = addDays(anchor, offsetValue);
        break;
      case 'weeks':
        targetDate = addWeeks(anchor, offsetValue);
        break;
      case 'months':
        targetDate = addMonths(anchor, offsetValue);
        break;
    }
    
    // Apply business day constraints
    if (config.skip_weekends && isWeekend(targetDate)) {
      targetDate = nextMonday(targetDate);
    }
    
    // Apply business hours
    if (config.business_hours) {
      const [startHour, startMinute] = config.business_hours.start.split(':').map(Number);
      targetDate.setHours(startHour, startMinute, 0, 0);
    }
    
    return targetDate;
  }
  
  static validateTimelineNode(config: TimelineAnchorConfig): ValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];
    
    // Validate offset values
    if (config.offset.value < 0) {
      errors.push('Offset value must be positive');
    }
    
    if (config.offset.value > 365 && config.offset.unit === 'days') {
      warnings.push('Offset of more than 365 days may be excessive');
    }
    
    // Validate business hours
    if (config.business_hours) {
      const startTime = config.business_hours.start;
      const endTime = config.business_hours.end;
      
      if (!startTime.match(/^\d{2}:\d{2}$/)) {
        errors.push('Invalid start time format. Use HH:MM');
      }
      
      if (!endTime.match(/^\d{2}:\d{2}$/)) {
        errors.push('Invalid end time format. Use HH:MM');
      }
      
      if (startTime >= endTime) {
        errors.push('Start time must be before end time');
      }
    }
    
    return {
      isValid: errors.length === 0,
      errors,
      warnings
    };
  }
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for React DnD, date-fns, canvas libraries
- [x] Playwright: Test drag-and-drop interactions, timeline calculations
- [x] Filesystem: Access existing journey components

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/react-dnd/react-dnd", "drag and drop canvas", 3000);
await mcp__context7__get-library-docs("/date-fns/date-fns", "date calculations", 2000);
await mcp__context7__get-library-docs("/supabase/supabase", "real-time canvas collaboration", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('TimelineCalculator', () => {
  it('should calculate wedding date anchors correctly', () => {
    const weddingDate = new Date('2024-06-15');
    const config: TimelineAnchorConfig = {
      anchor_type: 'wedding_date',
      offset: { value: 2, unit: 'weeks', direction: 'before' },
      skip_weekends: false,
      timezone: 'UTC'
    };
    
    const result = TimelineCalculator.calculateExecutionDate(config, weddingDate, new Date());
    expect(result).toEqual(new Date('2024-06-01'));
  });
  
  it('should skip weekends when configured', () => {
    const weddingDate = new Date('2024-06-16'); // Sunday
    const config: TimelineAnchorConfig = {
      anchor_type: 'wedding_date',
      offset: { value: 1, unit: 'days', direction: 'before' },
      skip_weekends: true,
      timezone: 'UTC'
    };
    
    const result = TimelineCalculator.calculateExecutionDate(config, weddingDate, new Date());
    expect(result.getDay()).not.toBe(0); // Not Sunday
    expect(result.getDay()).not.toBe(6); // Not Saturday
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Journey canvas workflow', async () => {
  await mcp__playwright__browser_navigate({url: '/journeys/test-journey/canvas'});
  await mcp__playwright__browser_snapshot();
  
  // Test node drag from library
  await mcp__playwright__browser_drag({
    startElement: 'Email node from library',
    startRef: '[data-testid="node-library-email"]',
    endElement: 'Canvas drop zone',
    endRef: '[data-testid="canvas-drop-zone"]'
  });
  
  // Test node configuration
  await mcp__playwright__browser_click({
    element: 'Dropped email node',
    ref: '[data-testid="canvas-node-email"]'
  });
  
  // Test timeline anchor configuration
  await mcp__playwright__browser_select_option({
    element: 'Anchor type dropdown',
    ref: '[data-testid="anchor-type-select"]',
    values: ['wedding_date']
  });
  
  // Test canvas zoom
  await mcp__playwright__browser_click({
    element: 'Zoom in button',
    ref: '[data-testid="zoom-in"]'
  });
  
  await mcp__playwright__browser_snapshot();
});
```

### ACCEPTANCE CRITERIA
- [x] Drag-and-drop nodes from library to canvas works smoothly
- [x] Timeline anchor calculations are accurate for all date types
- [x] Canvas supports zoom (25% to 200%) and pan operations
- [x] Auto-save preserves canvas state every 30 seconds
- [x] Performance: Handles 50+ nodes without lag
- [x] Security: Journey data isolated by supplier via RLS
- [x] Accessibility: Keyboard navigation, screen reader announcements

### DEPENDENCIES
- Must complete after: Basic journey infrastructure
- Must complete before: WS-044 (Timeline Nodes), WS-045 (Conditional Branching)
- Shares code with: Date utilities, drag-and-drop components

### ESTIMATED EFFORT
- Team A Frontend: 24 hours
- Team B Backend: 16 hours
- Team C Integration: 8 hours
- Total: 48 hours