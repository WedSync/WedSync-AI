# TECHNICAL SPECIFICATION: WS-143 - Marketing Automation Engine
## Generated by Feature Development Session - 2025-01-24

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding supplier who wants to grow my client base
**I want to:** Automatically market to my existing clients to generate referrals and reviews
**So that:** I can leverage the viral loop where my clients invite other vendors, who then invite more couples

**Real Wedding Scenario:**
Emma, a wedding photographer, just completed a wedding. The marketing automation system automatically sends a review request to the couple 3 days later, then follows up with a referral request offering Â£50 off their next session for each vendor they successfully refer. When Sarah (florist) gets invited by Emma's couple, she receives a personalized email showing the couple's wedding date and venue, making her 5x more likely to join than a cold outreach.

### SPECIFICATION SOURCE
- **Feature ID:** WS-143
- **Original Spec:** /CORE-SPECIFICATIONS/13-BUSINESS-OPERATIONS/04-marketing-automation md.md
- **Current Implementation:** 0% complete
- **Files to Modify:** None (new feature)
- **New Files to Create:** 
  - /src/lib/services/marketing-automation-service.ts
  - /src/lib/services/email-personalization-engine.ts
  - /src/lib/services/engagement-trigger-system.ts
  - /src/components/marketing/CampaignBuilder.tsx
  - /src/components/marketing/ViralTracker.tsx
  - /src/app/api/marketing/track-invite/route.ts
  - /src/app/api/marketing/attribution/[userId]/route.ts
  - /src/app/api/marketing/viral-coefficient/route.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Marketing campaign tracking
CREATE TABLE IF NOT EXISTS marketing_campaigns (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  campaign_type TEXT NOT NULL, -- 'email', 'in_app', 'referral', 'review_request'
  target_audience TEXT NOT NULL, -- 'suppliers', 'couples', 'prospects'
  status TEXT DEFAULT 'draft', -- 'draft', 'active', 'paused', 'completed'
  trigger_event TEXT, -- 'wedding_completed', 'form_submitted', 'signup_anniversary'
  delay_hours INTEGER DEFAULT 0,
  
  -- Campaign content
  subject_line TEXT,
  email_template TEXT,
  personalization_fields JSONB DEFAULT '[]',
  
  -- Targeting
  filters JSONB DEFAULT '{}', -- Audience filters
  exclude_conditions JSONB DEFAULT '{}',
  
  -- Performance tracking
  sent_count INTEGER DEFAULT 0,
  delivered_count INTEGER DEFAULT 0,
  opened_count INTEGER DEFAULT 0,
  clicked_count INTEGER DEFAULT 0,
  converted_count INTEGER DEFAULT 0,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  created_by UUID REFERENCES auth.users(id)
);

-- Attribution tracking for viral growth
CREATE TABLE IF NOT EXISTS attribution (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL,
  user_type TEXT NOT NULL, -- 'supplier', 'couple'
  source TEXT NOT NULL, -- 'couple_invite', 'supplier_invite', 'organic', 'paid', 'referral'
  referrer_id UUID,
  referrer_type TEXT, -- 'supplier', 'couple'
  campaign_id UUID REFERENCES marketing_campaigns(id),
  
  -- Context
  ip_address INET,
  user_agent TEXT,
  utm_source TEXT,
  utm_medium TEXT,
  utm_campaign TEXT,
  
  -- Conversion tracking
  converted BOOLEAN DEFAULT FALSE,
  conversion_type TEXT, -- 'signup', 'trial_start', 'paid_plan', 'first_booking'
  conversion_value_cents INTEGER,
  lifetime_value_cents INTEGER,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Viral invitation tracking
CREATE TABLE IF NOT EXISTS viral_actions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  actor_id UUID NOT NULL, -- Who performed the action
  actor_type TEXT NOT NULL, -- 'supplier', 'couple'
  action_type TEXT NOT NULL, -- 'sent_invite', 'accepted_invite', 'activated_account'
  
  -- Recipient details
  recipient_email TEXT,
  recipient_id UUID, -- Set when they sign up
  recipient_type TEXT,
  
  -- Invitation context
  wedding_id UUID, -- If invite is wedding-specific
  invitation_code TEXT UNIQUE,
  personalized_message TEXT,
  
  -- Status tracking
  status TEXT DEFAULT 'pending', -- 'pending', 'accepted', 'expired', 'bounced'
  sent_at TIMESTAMPTZ DEFAULT NOW(),
  opened_at TIMESTAMPTZ,
  accepted_at TIMESTAMPTZ,
  expired_at TIMESTAMPTZ,
  
  -- Viral metrics
  generation INTEGER DEFAULT 1, -- How many degrees from original referrer
  viral_chain_id UUID, -- Track entire referral chain
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Email campaign sends tracking
CREATE TABLE IF NOT EXISTS campaign_sends (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  campaign_id UUID REFERENCES marketing_campaigns(id) ON DELETE CASCADE,
  recipient_id UUID NOT NULL,
  recipient_type TEXT NOT NULL,
  recipient_email TEXT NOT NULL,
  
  -- Personalization
  personalized_subject TEXT,
  personalized_content TEXT,
  merge_data JSONB DEFAULT '{}',
  
  -- Delivery tracking
  sent_at TIMESTAMPTZ DEFAULT NOW(),
  delivered_at TIMESTAMPTZ,
  bounced_at TIMESTAMPTZ,
  bounce_reason TEXT,
  
  -- Engagement tracking
  opened_at TIMESTAMPTZ,
  clicked_at TIMESTAMPTZ,
  clicked_links TEXT[],
  unsubscribed_at TIMESTAMPTZ,
  
  -- Conversion tracking
  converted BOOLEAN DEFAULT FALSE,
  conversion_action TEXT,
  converted_at TIMESTAMPTZ,
  
  -- A/B testing
  variant TEXT DEFAULT 'control',
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Referral rewards tracking
CREATE TABLE IF NOT EXISTS referral_rewards (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  referrer_id UUID NOT NULL,
  referee_id UUID NOT NULL,
  reward_type TEXT NOT NULL, -- 'discount', 'credit', 'feature_unlock', 'cash'
  reward_amount_cents INTEGER,
  reward_description TEXT,
  
  -- Requirements
  required_action TEXT, -- 'signup', 'paid_plan', 'first_booking'
  requirement_met BOOLEAN DEFAULT FALSE,
  requirement_met_at TIMESTAMPTZ,
  
  -- Fulfillment
  fulfilled BOOLEAN DEFAULT FALSE,
  fulfilled_at TIMESTAMPTZ,
  fulfillment_method TEXT,
  
  -- Tracking
  viral_action_id UUID REFERENCES viral_actions(id),
  campaign_id UUID REFERENCES marketing_campaigns(id),
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create indexes for performance
CREATE INDEX idx_attribution_user ON attribution(user_id, user_type);
CREATE INDEX idx_attribution_referrer ON attribution(referrer_id);
CREATE INDEX idx_viral_actions_actor ON viral_actions(actor_id);
CREATE INDEX idx_viral_actions_recipient_email ON viral_actions(recipient_email);
CREATE INDEX idx_viral_actions_status ON viral_actions(status);
CREATE INDEX idx_campaign_sends_campaign ON campaign_sends(campaign_id);
CREATE INDEX idx_campaign_sends_recipient ON campaign_sends(recipient_id, recipient_type);
```

#### API Endpoints Required
```typescript
// POST /api/marketing/track-invite
interface TrackInviteRequest {
  actorId: string;
  actorType: 'supplier' | 'couple';
  recipientEmail: string;
  invitationType: 'supplier_invite' | 'couple_invite';
  weddingContext?: {
    weddingId: string;
    weddingDate: string;
    venue: string;
  };
  personalizedMessage?: string;
}

interface TrackInviteResponse {
  success: boolean;
  invitationId: string;
  inviteLink: string;
  trackingCode: string;
}

// GET /api/marketing/attribution/:userId
interface AttributionResponse {
  attribution: {
    source: string;
    referrerId?: string;
    campaignId?: string;
    conversionPath: Array<{
      touchpoint: string;
      timestamp: string;
      campaign?: string;
    }>;
  };
  viralChain: Array<{
    generation: number;
    referrerId: string;
    referrerName: string;
    referralDate: string;
  }>;
}

// POST /api/marketing/conversion
interface ConversionRequest {
  userId: string;
  conversionType: 'trial_start' | 'paid_conversion' | 'referral_signup';
  conversionValue?: number;
  metadata?: Record<string, any>;
}

// GET /api/marketing/viral-coefficient
interface ViralCoefficientResponse {
  coefficient: number; // Target: >1.0
  timeRange: string;
  breakdown: {
    invitesSent: number;
    invitesAccepted: number;
    acceptanceRate: number;
    averageInvitesPerUser: number;
    generationAnalysis: Array<{
      generation: number;
      users: number;
      invitesSent: number;
    }>;
  };
}

// POST /api/marketing/campaign/send
interface CampaignSendRequest {
  campaignId: string;
  recipients: Array<{
    id: string;
    type: 'supplier' | 'couple';
    email: string;
    personalizations: Record<string, any>;
  }>;
  schedule?: string; // ISO timestamp for delayed send
}
```

#### Frontend Components Required
```typescript
// Component: CampaignBuilder
// Location: /src/components/marketing/CampaignBuilder.tsx

interface CampaignBuilderProps {
  campaignType: 'email' | 'referral' | 'review_request';
  onSave: (campaign: Campaign) => void;
}

// Key functionality:
- Drag-and-drop email template builder
- Audience targeting with filters
- Personalization field insertion
- A/B test configuration
- Send timing and trigger setup
- Preview with sample data

// Component: ViralTracker
// Location: /src/components/marketing/ViralTracker.tsx

interface ViralTrackerProps {
  timeRange: '7d' | '30d' | '90d';
}

// Key functionality:
- Real-time viral coefficient display
- Referral chain visualizations
- Top referrers leaderboard  
- Invitation success rates
- Conversion funnel analytics
```

#### Integration Points
```typescript
// Service: MarketingAutomationService
// Dependencies: Email service, Analytics, Customer Success

export class MarketingAutomationService {
  async processViralInvite(
    actorId: string,
    recipientEmail: string,
    context: WeddingContext
  ): Promise<string> {
    // Generate personalized invitation
    const inviteCode = await this.generateInviteCode();
    const personalizedContent = await this.personalizeInvitation(context);
    
    // Track the viral action
    await this.trackViralAction(actorId, recipientEmail, inviteCode);
    
    // Send invitation email
    await this.sendInvitationEmail(recipientEmail, personalizedContent, inviteCode);
    
    return inviteCode;
  }
  
  async triggerAutomatedSequence(
    event: 'wedding_completed' | 'form_submitted' | 'client_inactive',
    userId: string,
    metadata: Record<string, any>
  ) {
    // Find matching campaigns for this trigger
    const campaigns = await this.getActiveCampaigns(event);
    
    for (const campaign of campaigns) {
      if (await this.userMatchesFilters(userId, campaign.filters)) {
        await this.scheduleCampaignSend(campaign.id, userId, metadata);
      }
    }
  }
  
  async calculateViralCoefficient(timeRange: string): Promise<number> {
    const metrics = await this.getViralMetrics(timeRange);
    return metrics.invitesAccepted / metrics.totalUsers;
  }
}
```

### CODE EXAMPLES

#### Example 1: Viral Invitation Engine
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { addDays, format } from 'date-fns';

interface WeddingContext {
  weddingId: string;
  weddingDate: Date;
  venue: string;
  coupleNames: string;
  guestCount?: number;
}

export class ViralEngine {
  // When couple invites a supplier
  async onCoupleInvitesSupplier(
    coupleId: string,
    supplierEmail: string,
    weddingContext: WeddingContext
  ): Promise<string> {
    const inviteCode = crypto.randomUUID();
    
    // Generate personalized invite content
    const emailData = {
      coupleName: weddingContext.coupleNames,
      weddingDate: format(weddingContext.weddingDate, 'MMMM do, yyyy'),
      venue: weddingContext.venue,
      daysUntilWedding: Math.ceil((weddingContext.weddingDate.getTime() - Date.now()) / (1000 * 60 * 60 * 24)),
      inviteLink: `${process.env.NEXT_PUBLIC_APP_URL}/supplier/invite/${inviteCode}`,
      
      // Value propositions based on real wedding context
      valueProps: [
        `${weddingContext.coupleNames} chose you for their special day`,
        'Auto-fill forms with their wedding details already provided',
        'Join 2,847 other suppliers saving 10+ hours per wedding'
      ]
    };
    
    // Track viral action
    await supabase.from('viral_actions').insert({
      actor_id: coupleId,
      actor_type: 'couple',
      action_type: 'sent_invite',
      recipient_email: supplierEmail,
      wedding_id: weddingContext.weddingId,
      invitation_code: inviteCode,
      status: 'pending'
    });
    
    // Send personalized email
    await this.sendSupplierInvite(supplierEmail, emailData);
    
    return inviteCode;
  }
  
  // When supplier invites their existing clients
  async onSupplierInvitesClient(
    supplierId: string,
    clientEmail: string,
    clientContext?: any
  ): Promise<string> {
    const supplier = await this.getSupplierDetails(supplierId);
    const inviteCode = crypto.randomUUID();
    
    const emailData = {
      supplierName: supplier.business_name || `${supplier.first_name} ${supplier.last_name}`,
      supplierType: this.getSupplierTypeLabel(supplier.vendor_type),
      personalizedMessage: this.generateSupplierToClientMessage(supplier),
      inviteLink: `${process.env.NEXT_PUBLIC_APP_URL}/couple/invite/${inviteCode}`,
      
      // Benefits for couples
      benefits: [
        'Free wedding planning dashboard',
        'Coordinate all your vendors in one place',
        'Never lose track of wedding details again',
        'Trusted by 15,000+ couples'
      ]
    };
    
    // Track viral action with attribution
    await supabase.from('viral_actions').insert({
      actor_id: supplierId,
      actor_type: 'supplier',
      action_type: 'sent_invite',
      recipient_email: clientEmail,
      invitation_code: inviteCode,
      personalized_message: emailData.personalizedMessage,
      status: 'pending'
    });
    
    await this.sendCoupleInvite(clientEmail, emailData);
    
    return inviteCode;
  }
  
  private getSupplierTypeLabel(vendorType: string): string {
    const labels: Record<string, string> = {
      'photographer': 'Photography',
      'videographer': 'Videography',
      'dj': 'DJ Services',
      'band': 'Live Music',
      'florist': 'Floral Design',
      'caterer': 'Catering',
      'venue': 'Venue',
      'planner': 'Wedding Planning'
    };
    
    return labels[vendorType] || 'Wedding Services';
  }
  
  private generateSupplierToClientMessage(supplier: any): string {
    const templates = [
      `Hi! It's ${supplier.first_name} from ${supplier.business_name}. I've been using WedSync to make wedding planning smoother for my clients. Thought you might find it helpful for coordinating all your wedding vendors!`,
      `${supplier.first_name} here! I wanted to share this amazing tool that's been helping my couples stay organized. It's called WedSync and it's completely free for couples to use.`,
      `Hope your wedding planning is going well! I've been using WedSync to collaborate better with my clients and I think you'd love how it keeps everything organized in one place.`
    ];
    
    return templates[Math.floor(Math.random() * templates.length)];
  }
}
```

#### Example 2: Automated Email Campaign System
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
interface EmailSequence {
  trigger: string;
  delay: number; // Hours after trigger
  template: string;
  personalization: string[];
  conditions?: Record<string, any>;
}

const SUPPLIER_NURTURE_SEQUENCES: EmailSequence[] = [
  {
    trigger: 'supplier_signup',
    delay: 0,
    template: 'welcome_supplier',
    personalization: ['first_name', 'vendor_type', 'business_name']
  },
  {
    trigger: 'supplier_signup',
    delay: 72, // 3 days
    template: 'import_clients_guide',
    personalization: ['first_name'],
    conditions: { clients_imported: 0 } // Only if no clients imported yet
  },
  {
    trigger: 'first_client_connected',
    delay: 0,
    template: 'celebrate_first_connection',
    personalization: ['first_name', 'client_name']
  },
  {
    trigger: 'client_completed_form',
    delay: 4, // 4 hours after form completion
    template: 'form_completion_notification',
    personalization: ['first_name', 'client_name', 'form_name']
  },
  {
    trigger: '5_clients_connected',
    delay: 0,
    template: 'power_user_tips',
    personalization: ['first_name', 'client_count']
  }
];

const COUPLE_ACTIVATION_SEQUENCES: EmailSequence[] = [
  {
    trigger: 'couple_signup',
    delay: 0,
    template: 'welcome_to_wedme',
    personalization: ['couple_names', 'wedding_date']
  },
  {
    trigger: 'couple_signup',
    delay: 48, // 2 days
    template: 'find_your_suppliers',
    personalization: ['couple_names'],
    conditions: { suppliers_connected: 0 }
  },
  {
    trigger: 'wedding_6_months_away',
    delay: 0,
    template: 'planning_timeline',
    personalization: ['couple_names', 'wedding_date', 'days_until_wedding']
  }
];

export class AutomatedEmailEngine {
  async processEventTrigger(
    event: string,
    userId: string,
    userType: 'supplier' | 'couple',
    metadata: Record<string, any>
  ) {
    const sequences = userType === 'supplier' 
      ? SUPPLIER_NURTURE_SEQUENCES 
      : COUPLE_ACTIVATION_SEQUENCES;
      
    const matchingSequences = sequences.filter(seq => seq.trigger === event);
    
    for (const sequence of matchingSequences) {
      // Check conditions if they exist
      if (sequence.conditions && !await this.checkConditions(userId, sequence.conditions)) {
        continue;
      }
      
      // Schedule email send
      const sendAt = new Date(Date.now() + sequence.delay * 60 * 60 * 1000);
      
      await this.scheduleEmail({
        userId,
        userType,
        template: sequence.template,
        personalizationFields: sequence.personalization,
        scheduledFor: sendAt,
        metadata: { event, ...metadata }
      });
    }
  }
  
  private async checkConditions(
    userId: string,
    conditions: Record<string, any>
  ): Promise<boolean> {
    for (const [key, expectedValue] of Object.entries(conditions)) {
      const actualValue = await this.getUserMetric(userId, key);
      
      if (typeof expectedValue === 'number') {
        if (actualValue !== expectedValue) return false;
      } else if (Array.isArray(expectedValue)) {
        if (!expectedValue.includes(actualValue)) return false;
      } else {
        if (actualValue !== expectedValue) return false;
      }
    }
    
    return true;
  }
  
  async sendScheduledEmails() {
    const now = new Date();
    
    // Get emails ready to send
    const { data: scheduledEmails } = await supabase
      .from('campaign_sends')
      .select(`
        *,
        campaigns:campaign_id (*)
      `)
      .is('sent_at', null)
      .lte('scheduled_for', now.toISOString())
      .limit(100);
    
    for (const email of scheduledEmails || []) {
      try {
        // Personalize content
        const personalizedContent = await this.personalizeEmail(
          email.campaigns.email_template,
          email.merge_data,
          email.recipient_id
        );
        
        // Send email
        await this.deliverEmail({
          to: email.recipient_email,
          subject: await this.personalizeText(email.campaigns.subject_line, email.merge_data),
          html: personalizedContent,
          trackingId: email.id
        });
        
        // Mark as sent
        await supabase
          .from('campaign_sends')
          .update({ sent_at: new Date().toISOString() })
          .eq('id', email.id);
          
      } catch (error) {
        console.error(`Failed to send email ${email.id}:`, error);
        
        // Mark as bounced
        await supabase
          .from('campaign_sends')
          .update({ 
            bounced_at: new Date().toISOString(),
            bounce_reason: error.message
          })
          .eq('id', email.id);
      }
    }
  }
  
  private async personalizeEmail(
    template: string,
    mergeData: Record<string, any>,
    userId: string
  ): Promise<string> {
    // Get additional personalization data
    const userData = await this.getUserData(userId);
    const allData = { ...mergeData, ...userData };
    
    // Replace merge tags
    let personalized = template;
    
    for (const [key, value] of Object.entries(allData)) {
      const regex = new RegExp(`{{${key}}}`, 'g');
      personalized = personalized.replace(regex, String(value));
    }
    
    return personalized;
  }
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [ ] Context7: Load docs for viral marketing strategies, email automation best practices
- [ ] PostgreSQL: Execute viral coefficient calculations and campaign analytics
- [ ] Supabase: Configure real-time subscriptions for marketing events

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/sendgrid/sendgrid-node", "marketing campaigns", 3000);
await mcp__context7__get-library-docs("/mixpanel/mixpanel-node", "viral tracking", 2000);
await mcp__context7__get-library-docs("/react/react", "email templates", 1500);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('ViralEngine', () => {
  it('should generate personalized supplier invitations', async () => {
    const context = {
      weddingId: 'wedding-123',
      weddingDate: new Date('2024-06-15'),
      venue: 'The Grand Ballroom',
      coupleNames: 'Emma & James'
    };
    
    const inviteCode = await ViralEngine.onCoupleInvitesSupplier(
      'couple-id',
      'photographer@example.com',
      context
    );
    
    expect(inviteCode).toBeDefined();
    // Verify viral action was tracked
    // Verify email was sent with correct personalization
  });
  
  it('should calculate viral coefficient correctly', async () => {
    const coefficient = await MarketingAutomationService.calculateViralCoefficient('30d');
    expect(coefficient).toBeGreaterThan(0);
  });
  
  it('should track attribution through referral chains', async () => {
    // Test multi-generation referral tracking
    const attribution = await getAttribution('user-id-3rd-gen');
    expect(attribution.viralChain).toHaveLength(3);
  });
});

describe('AutomatedEmailEngine', () => {
  it('should trigger correct email sequences', async () => {
    await AutomatedEmailEngine.processEventTrigger(
      'supplier_signup',
      'supplier-id',
      'supplier',
      { vendor_type: 'photographer' }
    );
    
    // Verify welcome email scheduled immediately
    // Verify follow-up email scheduled for 72 hours
  });
  
  it('should respect email frequency limits', async () => {
    // Test that users don't receive too many emails
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Viral invitation flow', async () => {
  await mcp__playwright__browser_navigate({url: '/clients/invite-suppliers'});
  
  // Fill out supplier invitation form
  await mcp__playwright__browser_fill_form({
    fields: [
      { name: 'Supplier Email', type: 'textbox', ref: '[data-testid="supplier-email"]', value: 'dj@example.com' }
    ]
  });
  
  await mcp__playwright__browser_click({
    element: 'Send Invitation button',
    ref: '[data-testid="send-invite-btn"]'
  });
  
  // Verify success message
  await mcp__playwright__browser_wait_for({
    text: 'Invitation sent successfully'
  });
});

test('Marketing dashboard shows viral metrics', async () => {
  await mcp__playwright__browser_navigate({url: '/admin/marketing'});
  
  // Check viral coefficient display
  await mcp__playwright__browser_wait_for({
    text: 'Viral Coefficient'
  });
  
  await mcp__playwright__browser_snapshot();
});
```

### ACCEPTANCE CRITERIA
- [ ] Viral coefficient tracking shows accurate invitation/conversion rates
- [ ] Supplier invitations include personalized wedding context (date, venue, couple names)
- [ ] Couple invitations highlight value proposition from their specific supplier
- [ ] Email sequences trigger correctly based on user actions and timing
- [ ] Attribution tracking works through multi-generation referral chains
- [ ] A/B testing framework allows testing different invitation templates
- [ ] Marketing dashboard shows real-time viral growth metrics
- [ ] Referral rewards system tracks and fulfills incentives correctly
- [ ] Unsubscribe links work and are honored immediately
- [ ] GDPR compliant - all marketing emails include opt-out options
- [ ] Rate limiting prevents email spam (max 3 marketing emails per week)
- [ ] Viral coefficient target: achieve >1.2 (20% viral growth)

### DEPENDENCIES
- Must complete after: WS-142 (Customer Success System) - Uses health scores for targeting
- Must complete before: WS-168 (Customer Success Dashboard) - Feeds performance data
- Shares code with: WS-132 (Trial Management System), WS-166 (Pricing Strategy System)

### ESTIMATED EFFORT
- Team A Frontend: 24 hours (campaign builder, viral tracker, marketing UI)
- Team B Backend: 32 hours (viral engine, email automation, attribution tracking)
- Team C Integration: 16 hours (email templates, analytics integration, webhook setup)
- Total: 72 hours