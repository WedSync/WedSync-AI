# TECHNICAL SPECIFICATION: WS-209 - AI Content Personalization Engine
## Generated by Feature Development Session - 2025-08-25

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding supplier sending automated communications
**I want to:** Personalize all email and SMS content based on couple details, wedding style, venue, and timeline
**So that:** My response rates increase by 40% and clients feel I understand their specific wedding needs, reducing booking anxiety and building trust

**Real Wedding Scenario:**
Maria runs a catering company and has three weddings this month: an intimate beach ceremony for 25 guests, a luxury hotel reception for 200, and a rustic barn wedding for 80. Her current email templates are generic and mention "your special day" without context. Personalized content would reference specific venue challenges, appropriate menu styles, and timeline considerations.

### SPECIFICATION SOURCE
- **Feature ID:** WS-209
- **Original Spec:** /Users/skyphotography/CODE/WedSync-2.0/WedSync2/CORE-SPECIFICATIONS/04-AI-INTEGRATION/03-Content-Generation/04-personalization md.md
- **Current Implementation:** 0% complete
- **Files to Modify:**
  - `/wedsync/src/components/messaging/MessageComposer.tsx` (add AI personalization)
  - `/wedsync/src/lib/services/email-automation.ts` (integrate personalization)
- **New Files to Create:**
  - `/wedsync/src/lib/ai/personalization-engine.ts`
  - `/wedsync/src/lib/ai/dynamic-variable-processor.ts`
  - `/wedsync/src/lib/ai/vendor-personalization-specialist.ts`
  - `/wedsync/src/lib/ai/emotional-personalization.ts`
  - `/wedsync/src/components/ai/PersonalizationPreview.tsx`
  - `/wedsync/src/app/api/ai/personalize/route.ts`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Store personalized content and performance data
CREATE TABLE personalizations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  content_type TEXT NOT NULL CHECK (content_type IN ('email', 'sms', 'article', 'form_intro')),
  original_content TEXT NOT NULL,
  personalized_content TEXT NOT NULL,
  context_data JSONB NOT NULL,
  personalizations_applied TEXT[],
  confidence_score DECIMAL(3,2) CHECK (confidence_score BETWEEN 0.00 AND 1.00),
  supplier_id UUID REFERENCES suppliers(id),
  client_id UUID REFERENCES clients(id),
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Track personalization effectiveness for ML improvement
CREATE TABLE personalization_performance (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  personalization_id UUID REFERENCES personalizations(id),
  engagement_improvement DECIMAL(5,2), -- % increase vs generic content
  response_rate DECIMAL(3,2),
  client_satisfaction_score INTEGER CHECK (client_satisfaction_score BETWEEN 1 AND 5),
  time_to_completion INTEGER, -- seconds for forms/tasks
  vendor_feedback_score INTEGER CHECK (vendor_feedback_score BETWEEN 1 AND 5),
  tracked_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_personalization_supplier ON personalizations(supplier_id);
CREATE INDEX idx_personalization_type ON personalizations(content_type);
CREATE INDEX idx_personalization_performance ON personalization_performance(personalization_id);
```

#### API Endpoints Required
```typescript
// Core personalization context interface
interface PersonalizationContext {
  couple: {
    names: string[];
    pronouns?: string[];
    communication_style: 'formal' | 'casual' | 'friendly';
    response_patterns: 'quick' | 'detailed' | 'mixed';
    previous_interactions: InteractionHistory[];
  };
  wedding: {
    date: Date;
    venue: {
      type: 'church' | 'barn' | 'hotel' | 'outdoor' | 'beach' | 'mansion';
      name: string;
      indoor: boolean;
      previous_experience?: boolean;
    };
    style: 'traditional' | 'modern' | 'bohemian' | 'luxury' | 'rustic' | 'destination';
    size: 'intimate' | 'small' | 'medium' | 'large'; // <30, 30-80, 80-150, 150+
    season: 'spring' | 'summer' | 'fall' | 'winter';
    time_of_day: 'morning' | 'afternoon' | 'evening';
    timeline_stress_level: 'relaxed' | 'moderate' | 'rushed';
  };
  supplier: {
    type: 'photographer' | 'dj' | 'caterer' | 'venue' | 'planner';
    brand_voice: 'professional' | 'warm' | 'creative' | 'luxury' | 'down_to_earth';
    experience_level: 'new' | 'experienced' | 'expert';
    specialties: string[];
  };
}

interface PersonalizedContent {
  original: string;
  personalized: string;
  confidence: number;
  personalizations_applied: string[];
  variables_used: string[];
}

// POST /api/ai/personalize
// POST /api/ai/personalize/journey (bulk personalize)
// POST /api/ai/personalization/:id/metrics (track effectiveness)
```

#### Frontend Components Required
- **PersonalizationPreview**: Show before/after content comparison
- **PersonalizationControls**: Configure personalization settings and preferences  
- **PersonalizationMetrics**: Display performance improvements and analytics
- **VariableManager**: Manage dynamic variables and custom fields
- **BrandVoiceConfiguration**: Set supplier brand voice and communication style

#### Integration Points
- **PersonalizationEngine**: Core AI personalization using OpenAI GPT-4
- **DynamicVariableProcessor**: Process template variables and context data
- **VendorPersonalizationSpecialist**: Vendor-specific enhancement rules
- **EmotionalPersonalization**: Tone matching and emotional intelligence
- **Journey Engine**: Personalize all journey touchpoints automatically
- **Email/SMS Services**: Apply personalization to all outbound communications

### CODE EXAMPLES

#### Core Personalization Engine
```typescript
class PersonalizationEngine {
  async personalizeContent(
    content: string, 
    context: PersonalizationContext,
    contentType: 'email' | 'sms' | 'article' | 'form_intro'
  ): Promise<PersonalizedContent> {
    
    const systemPrompt = this.buildPersonalizationPrompt(context, contentType);
    
    const response = await openai.chat.completions.create({
      model: 'gpt-4',
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: `Personalize this content: ${content}` }
      ],
      temperature: 0.4, // Balanced creativity with consistency
      max_tokens: 800
    });
    
    const personalized = response.choices[0].message.content;
    
    return {
      original: content,
      personalized: this.processVariables(personalized, context),
      confidence: this.calculatePersonalizationConfidence(personalized, context),
      personalizations_applied: this.detectAppliedPersonalizations(content, personalized)
    };
  }
  
  private buildPersonalizationPrompt(context: PersonalizationContext, type: string): string {
    return `You are personalizing wedding communication for a ${context.supplier.type}.
    
    Context:
    - Couple: ${context.couple.names.join(' & ')}
    - Wedding: ${context.wedding.style} ${context.wedding.size} wedding at ${context.wedding.venue.name}
    - Season: ${context.wedding.season} ${context.wedding.time_of_day}
    - Supplier brand: ${context.supplier.brand_voice}
    - Communication style: ${context.couple.communication_style}
    
    Personalization rules:
    1. Use couple's names naturally (not excessively)
    2. Reference venue/style appropriately
    3. Match brand voice: ${this.getBrandVoiceDescription(context.supplier.brand_voice)}
    4. Include relevant expertise mentions
    5. Acknowledge timeline pressure: ${context.wedding.timeline_stress_level}
    6. Never change dates, prices, or critical details
    
    ${this.getContentTypeGuidelines(type)}`;
  }
}
```

#### Dynamic Variable Processing
```typescript
class DynamicVariableProcessor {
  private variables = {
    // Time-based variables
    '{{days_until_wedding}}': (context: PersonalizationContext) => {
      return Math.ceil((context.wedding.date.getTime() - Date.now()) / (1000 * 60 * 60 * 24));
    },
    
    // Couple variables
    '{{couple_names}}': (context: PersonalizationContext) => {
      return context.couple.names.join(' & ');
    },
    
    // Wedding variables
    '{{wedding_date_formatted}}': (context: PersonalizationContext) => {
      return context.wedding.date.toLocaleDateString('en-US', {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });
    },
    
    // Dynamic context variables
    '{{appropriate_greeting}}': (context: PersonalizationContext) => {
      const timeUntil = this.variables['{{days_until_wedding}}'](context);
      if (timeUntil > 180) return 'Hope your planning is going well!';
      if (timeUntil > 90) return 'Getting excited for your big day!';
      if (timeUntil > 30) return 'Your wedding is getting close!';
      if (timeUntil > 7) return 'Almost time for your big day!';
      return 'Your wedding is this week!';
    },
    
    '{{season_appropriate_comment}}': (context: PersonalizationContext) => {
      const seasonComments = {
        spring: 'Perfect timing for blooming flowers and mild weather!',
        summer: 'Great choice for outdoor celebrations and golden hour photos!',
        fall: 'Beautiful autumn colors will make stunning photos!',
        winter: 'Winter weddings have such a magical, cozy atmosphere!'
      };
      return seasonComments[context.wedding.season] || '';
    }
  };
  
  processVariables(content: string, context: PersonalizationContext): string {
    let processed = content;
    
    for (const [variable, processor] of Object.entries(this.variables)) {
      if (processed.includes(variable)) {
        const value = processor(context);
        processed = processed.replace(new RegExp(variable.replace(/[{}]/g, '\\$&'), 'g'), value);
      }
    }
    
    return processed;
  }
}
```

### MCP SERVER USAGE
- **Context7 MCP**: Fetch OpenAI API documentation and personalization best practices
- **GitHub MCP**: Create feature branch and track development progress
- **PostgreSQL MCP**: Execute database migrations and test personalization storage
- **Supabase MCP**: Apply schema changes and verify performance tracking

Required Context7 queries:
```graphql
query {
  searchDocs(query: "OpenAI chat completions personalization") {
    nodes {
      title
      content  
      href
    }
  }
}
```

### TEST REQUIREMENTS

#### Unit Tests
- **PersonalizationEngine.personalizeContent()**: Test personalization accuracy with various contexts
- **DynamicVariableProcessor.processVariables()**: Test variable replacement and edge cases
- **VendorPersonalizationSpecialist**: Test vendor-specific enhancement logic
- **Validation system**: Test critical information preservation
- **Performance tracking**: Test metrics calculation and storage

#### Integration Tests
- **Full personalization flow**: Content → Context → AI → Variables → Validation → Storage
- **Database operations**: Test personalization storage and performance tracking
- **API endpoints**: Test request/response formats and error handling
- **Email integration**: Test personalized content in actual email templates

#### E2E Tests
```typescript
test('Photographer personalizes engagement session email', async ({ page }) => {
  await page.goto('/dashboard/communications/compose');
  await page.selectOption('[data-testid="template"]', 'engagement_session_reminder');
  await page.click('[data-testid="enable-personalization"]');
  
  // AI should personalize based on context
  await expect(page.locator('[data-testid="personalized-preview"]'))
    .toContainText('Sarah & Michael'); // Couple names
  await expect(page.locator('[data-testid="personalized-preview"]'))
    .toContainText('Central Park'); // Venue name
  await expect(page.locator('[data-testid="personalized-preview"]'))
    .toContainText('spring'); // Season reference
});
```

### ACCEPTANCE CRITERIA
- [ ] AI personalizes content based on couple names, wedding details, and supplier brand voice
- [ ] Dynamic variables process correctly with proper date/time formatting
- [ ] Vendor-specific enhancements apply appropriate expertise mentions
- [ ] Personalization preserves all critical information (dates, prices, contact details)
- [ ] Content validation ensures appropriate tone and personalization level
- [ ] Performance tracking shows engagement improvements vs generic content
- [ ] API handles errors gracefully with fallback to original content
- [ ] Integration with journey engine personalizes all touchpoints automatically

### DEPENDENCIES
- **Before:** Journey Canvas (WS-013) and Email Templates System (WS-012) must be complete
- **After:** AI Knowledge Base (WS-210) will provide additional context for personalization
- **Parallel:** Journey Suggestions AI (WS-208) will use personalization for generated content

### ESTIMATED EFFORT
- **Backend Development:** 28 hours (AI engine, variable processing, vendor specialists)
- **Frontend Development:** 20 hours (preview components, configuration interfaces)
- **API Development:** 12 hours (endpoints, validation, performance tracking)
- **Database Work:** 8 hours (schema, migrations, analytics tracking)
- **Integration Work:** 16 hours (journey engine, email/SMS services)
- **Testing:** 20 hours (unit, integration, E2E, performance validation)
- **Total:** 104 hours across teams