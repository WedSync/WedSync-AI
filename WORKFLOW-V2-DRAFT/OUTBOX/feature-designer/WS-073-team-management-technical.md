# TECHNICAL SPECIFICATION: WS-073 - Team Management
## Generated by Feature Development Session - August 22, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding photography studio owner with 3 photographers and 2 coordinators
**I want to:** Give my team members different levels of access to our WedSync account
**So that:** Photographers can manage their assigned clients, coordinators can view analytics, but only I can change billing or delete data

**Real Wedding Scenario:**
A photography studio has the owner (who handles billing and team management), senior photographers (who manage clients and forms), junior photographers (who only manage assigned clients), and a coordinator (who views analytics but can't modify client data). The owner invites team members by email, assigns appropriate roles, and team members receive access based on their responsibilities without compromising sensitive business data.

### SPECIFICATION SOURCE
- **Feature ID:** WS-073
- **Original Spec:** /CORE-SPECIFICATIONS/02-WEDSYNC-SUPPLIER-PLATFORM/11-Billing-Settings/03-team-management md.md
- **Current Implementation:** 0% complete
- **Files to Modify:**
  - /wedsync/src/app/(dashboard)/settings/page.tsx (add team management tab)
  - /wedsync/src/middleware.ts (add role-based access control)
- **New Files to Create:**
  - /wedsync/src/app/(dashboard)/team/page.tsx
  - /wedsync/src/app/(dashboard)/team/invite/page.tsx
  - /wedsync/src/app/api/team/route.ts
  - /wedsync/src/app/api/team/invite/route.ts
  - /wedsync/src/app/api/team/[memberId]/route.ts
  - /wedsync/src/app/api/team/accept/[token]/route.ts
  - /wedsync/src/components/team/TeamManager.tsx
  - /wedsync/src/components/team/InviteMemberDialog.tsx
  - /wedsync/src/components/team/MemberList.tsx
  - /wedsync/src/components/team/RoleSelector.tsx
  - /wedsync/src/lib/services/teamService.ts
  - /wedsync/src/lib/auth/rbac.ts
  - /wedsync/src/lib/email/teamInvitations.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Team members table
CREATE TABLE IF NOT EXISTS team_members (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID NOT NULL REFERENCES suppliers(id),
  user_id UUID REFERENCES auth.users(id), -- NULL until invitation accepted
  email VARCHAR(255) NOT NULL,
  role VARCHAR(50) NOT NULL DEFAULT 'member', -- 'owner', 'admin', 'member', 'viewer'
  permissions JSONB, -- Custom permissions override
  invited_by UUID NOT NULL REFERENCES auth.users(id),
  invited_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  accepted_at TIMESTAMP WITH TIME ZONE,
  last_active_at TIMESTAMP WITH TIME ZONE,
  removed_at TIMESTAMP WITH TIME ZONE,
  
  UNIQUE(supplier_id, email) -- One invitation per email per supplier
);

-- Team invitation tokens
CREATE TABLE IF NOT EXISTS team_invitations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  team_member_id UUID NOT NULL REFERENCES team_members(id),
  token VARCHAR(255) NOT NULL UNIQUE,
  expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
  used_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Permission audit log
CREATE TABLE IF NOT EXISTS permission_audit_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID NOT NULL REFERENCES suppliers(id),
  user_id UUID NOT NULL REFERENCES auth.users(id),
  action VARCHAR(100) NOT NULL,
  resource_type VARCHAR(50), -- 'client', 'form', 'analytics', etc.
  resource_id UUID,
  allowed BOOLEAN NOT NULL,
  role VARCHAR(50),
  timestamp TIMESTAMP WITH TIME ZONE DEFAULT now(),
  ip_address INET,
  user_agent TEXT
);

-- Create indexes
CREATE INDEX idx_team_members_supplier_id ON team_members(supplier_id);
CREATE INDEX idx_team_members_user_id ON team_members(user_id);
CREATE INDEX idx_team_invitations_token ON team_invitations(token);
CREATE INDEX idx_permission_audit_supplier_id ON permission_audit_log(supplier_id);
```

#### API Endpoints Required
```typescript
// GET /api/team - Get team members for supplier
interface GetTeamResponse {
  members: {
    id: string;
    email: string;
    name?: string;
    role: 'owner' | 'admin' | 'member' | 'viewer';
    customPermissions?: string[];
    invitedBy: string;
    invitedAt: string;
    acceptedAt?: string;
    lastActiveAt?: string;
    status: 'pending' | 'active' | 'inactive';
  }[];
  maxSeats: number;
  currentSeats: number;
}

// POST /api/team/invite - Invite new team member
interface InviteTeamMemberRequest {
  email: string;
  role: 'admin' | 'member' | 'viewer';
  customPermissions?: string[];
  personalMessage?: string;
}

interface InviteTeamMemberResponse {
  success: boolean;
  invitation: {
    id: string;
    email: string;
    role: string;
    invitationUrl: string;
    expiresAt: string;
  };
}

// PUT /api/team/[memberId] - Update team member role/permissions
interface UpdateTeamMemberRequest {
  role?: 'admin' | 'member' | 'viewer';
  customPermissions?: string[];
}

// POST /api/team/accept/[token] - Accept team invitation
interface AcceptInvitationRequest {
  name: string;
  password?: string; // If user doesn't exist yet
}

// DELETE /api/team/[memberId] - Remove team member
interface RemoveTeamMemberResponse {
  success: boolean;
  removedAt: string;
}
```

#### Frontend Components Required
```typescript
// Component: TeamManager
// Location: /src/components/team/TeamManager.tsx

interface TeamManagerProps {
  supplierId: string;
  currentUserRole: string;
}

// Key functionality:
- Display team members with roles and status
- Invite new members with role selection
- Edit member roles and permissions
- Remove team members with confirmation
- View team activity and audit logs

// Component: InviteMemberDialog
// Location: /src/components/team/InviteMemberDialog.tsx

interface InviteMemberDialogProps {
  onInvite: (invitation: InviteTeamMemberRequest) => Promise<void>;
  availableRoles: Role[];
  maxSeats: number;
  currentSeats: number;
}

// Key functionality:
- Email input with validation
- Role selection with permission preview
- Custom permissions override
- Personal message input
- Seat limit validation

// Component: MemberList
// Location: /src/components/team/MemberList.tsx

interface MemberListProps {
  members: TeamMember[];
  onUpdateMember: (memberId: string, updates: UpdateTeamMemberRequest) => Promise<void>;
  onRemoveMember: (memberId: string) => Promise<void>;
  currentUserRole: string;
}

// Key functionality:
- Member cards with role badges
- Quick role change dropdown
- Activity status indicators
- Remove member confirmation
- Permission details tooltip

// Component: RoleSelector
// Location: /src/components/team/RoleSelector.tsx

interface RoleSelectorProps {
  currentRole: string;
  onRoleChange: (role: string) => void;
  permissions: Permission[];
  canEdit: boolean;
}

// Key functionality:
- Role dropdown with descriptions
- Permission matrix display
- Custom permission checkboxes
- Role change confirmation
- Permission preview
```

#### Integration Points
```typescript
// Service: TeamService
// Dependencies: Supabase, email service, RBAC

class TeamService {
  async inviteTeamMember(supplierId: string, inviterId: string, invitation: InviteTeamMemberRequest) {
    // Step 1: Check subscription seat limits
    const subscription = await subscriptionService.getCurrentSubscription(supplierId);
    const currentSeats = await this.getTeamMemberCount(supplierId);
    const maxSeats = this.getMaxSeatsForTier(subscription.tier.id);
    
    if (currentSeats >= maxSeats) {
      throw new Error('Team member limit reached for current plan');
    }
    
    // Step 2: Check if user already invited/exists
    const existingMember = await supabase
      .from('team_members')
      .select('*')
      .eq('supplier_id', supplierId)
      .eq('email', invitation.email)
      .is('removed_at', null)
      .single();
    
    if (existingMember) {
      throw new Error('User already invited or is team member');
    }
    
    // Step 3: Create team member record
    const { data: teamMember } = await supabase
      .from('team_members')
      .insert({
        supplier_id: supplierId,
        email: invitation.email,
        role: invitation.role,
        permissions: invitation.customPermissions,
        invited_by: inviterId
      })
      .select()
      .single();
    
    // Step 4: Generate invitation token
    const token = crypto.randomBytes(32).toString('hex');
    const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 days
    
    await supabase
      .from('team_invitations')
      .insert({
        team_member_id: teamMember.id,
        token,
        expires_at: expiresAt.toISOString()
      });
    
    // Step 5: Send invitation email
    const invitationUrl = `${process.env.NEXT_PUBLIC_APP_URL}/team/accept/${token}`;
    await emailService.sendTeamInvitation({
      to: invitation.email,
      inviterName: await this.getInviterName(inviterId),
      supplierName: await this.getSupplierName(supplierId),
      role: invitation.role,
      invitationUrl,
      personalMessage: invitation.personalMessage
    });
    
    return { teamMember, invitationUrl, expiresAt };
  }
  
  async checkPermission(userId: string, supplierId: string, action: string, resourceType?: string) {
    const { data: member } = await supabase
      .from('team_members')
      .select('role, permissions')
      .eq('user_id', userId)
      .eq('supplier_id', supplierId)
      .is('removed_at', null)
      .single();
    
    if (!member) return false;
    
    // Check role-based permissions
    const rolePermissions = this.getRolePermissions(member.role);
    let hasPermission = rolePermissions.includes(action) || rolePermissions.includes('*');
    
    // Check custom permissions override
    if (member.permissions) {
      const customPerms = member.permissions as string[];
      hasPermission = customPerms.includes(action) || customPerms.includes('*');
    }
    
    // Log permission check for audit
    await this.logPermissionCheck(userId, supplierId, action, resourceType, hasPermission, member.role);
    
    return hasPermission;
  }
  
  getRolePermissions(role: string): string[] {
    const ROLE_PERMISSIONS = {
      owner: ['*'], // All permissions
      admin: [
        'manage_team',
        'manage_clients',
        'manage_forms',
        'view_analytics',
        'manage_billing'
      ],
      member: [
        'manage_clients',
        'manage_forms',
        'view_analytics'
      ],
      viewer: [
        'view_clients',
        'view_analytics'
      ]
    };
    
    return ROLE_PERMISSIONS[role as keyof typeof ROLE_PERMISSIONS] || [];
  }
}
```

### CODE EXAMPLES

#### Example 1: Role-Based Access Control Middleware
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { TeamService } from '@/lib/services/teamService';

export async function rbacMiddleware(request: NextRequest) {
  const supabase = createClient();
  const teamService = new TeamService();
  
  // Step 1: Get current user session
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) {
    return NextResponse.redirect(new URL('/login', request.url));
  }
  
  // Step 2: Extract supplier ID from URL or headers
  const supplierId = request.headers.get('x-supplier-id') || 
                    request.nextUrl.searchParams.get('supplierId');
  
  if (!supplierId) {
    return NextResponse.json({ error: 'Supplier ID required' }, { status: 400 });
  }
  
  // Step 3: Determine required permission for this route
  const routePermissions: Record<string, Record<string, string>> = {
    '/api/clients': {
      'GET': 'view_clients',
      'POST': 'manage_clients',
      'PUT': 'manage_clients',
      'DELETE': 'manage_clients'
    },
    '/api/team': {
      'GET': 'manage_team',
      'POST': 'manage_team',
      'PUT': 'manage_team',
      'DELETE': 'manage_team'
    },
    '/api/analytics': {
      'GET': 'view_analytics'
    }
  };
  
  const requiredPermission = routePermissions[request.nextUrl.pathname]?.[request.method];
  
  // Step 4: Check user permission
  if (requiredPermission) {
    const hasPermission = await teamService.checkPermission(
      session.user.id,
      supplierId,
      requiredPermission
    );
    
    if (!hasPermission) {
      return NextResponse.json(
        { error: 'Insufficient permissions' },
        { status: 403 }
      );
    }
  }
  
  // Step 5: Add user context to headers
  const response = NextResponse.next();
  response.headers.set('x-user-id', session.user.id);
  response.headers.set('x-supplier-id', supplierId);
  
  return response;
}

// Permission check hook for frontend
export function usePermission(action: string, resourceType?: string) {
  const { user } = useAuth();
  const { supplierId } = useSupplier();
  
  return useSWR(
    user && supplierId ? ['permission', user.id, supplierId, action, resourceType] : null,
    () => teamService.checkPermission(user.id, supplierId, action, resourceType),
    { 
      revalidateOnFocus: false,
      revalidateOnReconnect: false 
    }
  );
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [ ] Context7: Load docs for RBAC patterns, email templates
- [ ] Playwright: Test team invitation flow and permission enforcement
- [ ] Filesystem: Access team management templates

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/casl/ability", "role based access control", 2500);
await mcp__context7__get-library-docs("/nodemailer/nodemailer", "email sending", 2000);
await mcp__context7__get-library-docs("/react-hook-form/react-hook-form", "form validation", 1500);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('Team Service', () => {
  it('should enforce seat limits based on subscription tier', async () => {
    // Mock free tier (2 seats)
    mockSubscription({ tier: 'free', maxSeats: 2 });
    mockTeamMemberCount(2);
    
    await expect(
      teamService.inviteTeamMember('supplier-123', 'owner-123', {
        email: 'new@example.com',
        role: 'member'
      })
    ).rejects.toThrow('Team member limit reached');
  });
  
  it('should check permissions correctly for each role', async () => {
    const adminAccess = await teamService.checkPermission('admin-123', 'supplier-123', 'manage_clients');
    expect(adminAccess).toBe(true);
    
    const viewerAccess = await teamService.checkPermission('viewer-123', 'supplier-123', 'manage_clients');
    expect(viewerAccess).toBe(false);
    
    const viewerView = await teamService.checkPermission('viewer-123', 'supplier-123', 'view_clients');
    expect(viewerView).toBe(true);
  });
  
  it('should handle invitation expiration correctly', async () => {
    const expiredToken = 'expired-token-123';
    mockExpiredInvitation(expiredToken);
    
    await expect(
      teamService.acceptInvitation(expiredToken, { name: 'John Doe' })
    ).rejects.toThrow('Invitation expired or invalid');
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Team invitation and acceptance workflow', async () => {
  await mcp__playwright__browser_navigate({url: '/team'});
  await mcp__playwright__browser_snapshot();
  
  // Test inviting new team member
  await mcp__playwright__browser_click({
    element: "Invite Member button",
    ref: "button[data-testid='invite-member']"
  });
  
  await mcp__playwright__browser_type({
    element: "Email input",
    ref: "input[name='email']",
    text: "newmember@example.com"
  });
  
  // Test role selection
  await mcp__playwright__browser_click({
    element: "Role selector",
    ref: "select[name='role']"
  });
  
  await mcp__playwright__browser_select_option({
    element: "Role selector",
    ref: "select[name='role']",
    values: ["admin"]
  });
  
  // Test permission enforcement
  await mcp__playwright__browser_navigate({url: '/team/settings'});
  
  // Should see permission denied for non-owner
  await mcp__playwright__browser_wait_for({text: "Access denied"});
  
  // Test member list display
  await mcp__playwright__browser_navigate({url: '/team'});
  await mcp__playwright__browser_wait_for({text: "newmember@example.com"});
});
```

### ACCEPTANCE CRITERIA
- [ ] Owners can invite team members via email with role-based permissions
- [ ] Four role levels (Owner, Admin, Member, Viewer) with appropriate permissions
- [ ] Invitation emails sent with secure tokens that expire in 7 days
- [ ] Permission checks enforce access control across all features
- [ ] Team member activity tracked with audit logs
- [ ] Seat limits enforced based on subscription tier
- [ ] Performance: Permission checks complete within 100ms (cached)
- [ ] Security: Invitation tokens are cryptographically secure and single-use
- [ ] Accessibility: Team management interface supports keyboard navigation

### DEPENDENCIES
- Must complete after: WS-072 (API Key Management) - team members need API key permissions
- Must complete before: All team-collaborative features
- Shares code with: Authentication system, subscription enforcement

### ESTIMATED EFFORT
- Team E Full-stack: 28 hours (Complete team management system, RBAC, invitation flow)
- Team B Backend: 8 hours (Permission middleware, audit logging)
- Team C Integration: 4 hours (Email templates, notification system)
- Total: 40 hours