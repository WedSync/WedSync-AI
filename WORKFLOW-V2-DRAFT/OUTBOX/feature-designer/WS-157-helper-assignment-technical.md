# TECHNICAL SPECIFICATION: WS-157 - Helper Assignment
## Generated by Feature Development Session - August 23, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding couple delegating tasks to family and friends
**I want to:** Assign specific wedding tasks to helpers with clear instructions and timing
**So that:** Everyone knows their responsibilities and can execute tasks without confusion on the wedding day

**Real Wedding Scenario:**
A couple currently creates handwritten task lists like "Mom - handle gifts table" without clear timing or instructions. With this feature, they assign "Mary Johnson - Gift table setup (5:00pm-5:30pm) - Set up gift table in foyer, arrange card box, ensure gift security" with automatic notifications and check-in reminders.

### SPECIFICATION SOURCE
- **Feature ID:** WS-157
- **Original Spec:** /CORE-SPECIFICATIONS/03-WEDME-COUPLE-PLATFORM/05-Task-Delegation/02-helper-assignment md.md
- **Current Implementation:** 0% complete (new)
- **Files to Modify:** Extend WS-156 task creation system
- **New Files to Create:** 
  - `/src/components/tasks/HelperAssignment.tsx`
  - `/src/components/tasks/HelperDirectory.tsx` 
  - `/src/components/tasks/TaskAssignmentMatrix.tsx`
  - `/src/lib/services/helperService.ts`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Extend task system with helper assignments
CREATE TABLE IF NOT EXISTS wedding_helpers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  couple_id UUID REFERENCES couples(id),
  guest_id UUID REFERENCES guests(id), -- Links to guest list
  name VARCHAR(255) NOT NULL,
  email VARCHAR(255),
  phone VARCHAR(20),
  relationship VARCHAR(100), -- 'Best Man', 'Maid of Honor', 'Family', 'Friend'
  availability_start TIME,
  availability_end TIME,
  skills TEXT[], -- Array of skills/capabilities
  notes TEXT,
  notification_preferences JSONB DEFAULT '{"email": true, "sms": false}',
  emergency_contact BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS task_assignments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  task_id UUID REFERENCES wedding_tasks(id) ON DELETE CASCADE,
  helper_id UUID REFERENCES wedding_helpers(id) ON DELETE CASCADE,
  couple_id UUID REFERENCES couples(id),
  assignment_status VARCHAR(30) CHECK (assignment_status IN ('assigned', 'accepted', 'declined', 'completed')) DEFAULT 'assigned',
  assigned_at TIMESTAMPTZ DEFAULT NOW(),
  accepted_at TIMESTAMPTZ,
  completed_at TIMESTAMPTZ,
  notes TEXT,
  reminder_sent_at TIMESTAMPTZ,
  PRIMARY KEY (task_id, helper_id)
);

-- Helper availability conflicts
CREATE TABLE IF NOT EXISTS helper_conflicts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  helper_id UUID REFERENCES wedding_helpers(id),
  conflict_with_helper_id UUID REFERENCES wedding_helpers(id),
  conflict_type VARCHAR(50), -- 'timing_overlap', 'location_conflict', 'skill_gap'
  description TEXT,
  severity VARCHAR(20) CHECK (severity IN ('low', 'medium', 'high')),
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_wedding_helpers_couple_id ON wedding_helpers(couple_id);
CREATE INDEX idx_task_assignments_task_id ON task_assignments(task_id);
CREATE INDEX idx_task_assignments_helper_id ON task_assignments(helper_id);
CREATE INDEX idx_task_assignments_status ON task_assignments(assignment_status);
```

#### API Endpoints Required
```typescript
// POST /api/helpers
interface CreateHelperRequest {
  name: string;
  email?: string;
  phone?: string;
  relationship: string;
  guest_id?: string;
  availability_start?: string;
  availability_end?: string;
  skills?: string[];
  notification_preferences?: {
    email: boolean;
    sms: boolean;
  };
}

// POST /api/tasks/:task_id/assign
interface AssignTaskRequest {
  helper_id: string;
  notes?: string;
  send_notification: boolean;
}

// GET /api/helpers/:couple_id/availability
interface HelperAvailabilityResponse {
  success: boolean;
  data: {
    helpers: Array<{
      helper: WeddingHelper;
      current_assignments: TaskAssignment[];
      availability_conflicts: Array<{
        conflicting_task: WeddingTask;
        overlap_minutes: number;
      }>;
      workload_score: number; // 0-100, higher = more overloaded
    }>;
  };
}

// POST /api/tasks/bulk-assign
interface BulkAssignRequest {
  assignments: Array<{
    task_id: string;
    helper_id: string;
    notes?: string;
  }>;
  send_notifications: boolean;
}

// GET /api/helpers/:helper_id/schedule
interface HelperScheduleResponse {
  success: boolean;
  data: {
    helper: WeddingHelper;
    assignments: Array<{
      task: WeddingTask;
      status: string;
      conflicts: string[];
    }>;
    timeline_view: Array<{
      time_slot: string;
      task_title: string;
      location: string;
      duration: number;
    }>;
  };
}
```

#### Integration Points
```typescript
// Service: HelperService
// Dependencies: Task service, notification service, guest service

class HelperService {
  async assignTaskToHelper(taskId: string, helperId: string, options: AssignmentOptions): Promise<TaskAssignment> {
    // Check for conflicts before assignment
    const conflicts = await this.checkHelperConflicts(helperId, taskId);
    
    if (conflicts.length > 0 && !options.force_assign) {
      throw new ConflictError('Helper has scheduling conflicts', conflicts);
    }
    
    const assignment = await this.createAssignment(taskId, helperId, options);
    
    // Send notification if requested
    if (options.send_notification) {
      await this.sendAssignmentNotification(assignment);
    }
    
    // Update helper workload
    await this.updateHelperWorkload(helperId);
    
    return assignment;
  }
  
  async checkHelperConflicts(helperId: string, newTaskId: string): Promise<HelperConflict[]> {
    const helper = await this.getHelper(helperId);
    const newTask = await this.getTask(newTaskId);
    const existingAssignments = await this.getHelperAssignments(helperId);
    
    const conflicts: HelperConflict[] = [];
    
    // Check timing conflicts
    for (const assignment of existingAssignments) {
      const existingTask = assignment.task;
      
      if (this.tasksOverlap(newTask, existingTask)) {
        conflicts.push({
          type: 'timing_overlap',
          description: `${newTask.title} overlaps with ${existingTask.title}`,
          severity: this.calculateConflictSeverity(newTask, existingTask),
          conflicting_assignment: assignment
        });
      }
      
      // Check location conflicts (can't be in two places at once)
      if (newTask.location !== existingTask.location && this.tasksOverlap(newTask, existingTask)) {
        conflicts.push({
          type: 'location_conflict',
          description: `Cannot be at ${newTask.location} and ${existingTask.location} simultaneously`,
          severity: 'high',
          conflicting_assignment: assignment
        });
      }
    }
    
    // Check availability window
    if (!this.isWithinAvailability(helper, newTask)) {
      conflicts.push({
        type: 'availability_window',
        description: `Task is outside helper's available hours (${helper.availability_start} - ${helper.availability_end})`,
        severity: 'medium'
      });
    }
    
    return conflicts;
  }
  
  async suggestHelperAssignments(coupleId: string): Promise<AssignmentSuggestion[]> {
    const unassignedTasks = await this.getUnassignedTasks(coupleId);
    const availableHelpers = await this.getHelpers(coupleId);
    
    const suggestions: AssignmentSuggestion[] = [];
    
    for (const task of unassignedTasks) {
      // Score helpers based on availability, skills, and current workload
      const helperScores = availableHelpers.map(helper => ({
        helper,
        score: this.calculateHelperScore(helper, task),
        reasons: this.getAssignmentReasons(helper, task)
      }));
      
      // Sort by score and suggest top 3
      helperScores.sort((a, b) => b.score - a.score);
      
      suggestions.push({
        task,
        recommended_helpers: helperScores.slice(0, 3),
        assignment_priority: task.priority === 'critical' ? 'high' : 'normal'
      });
    }
    
    return suggestions.sort((a, b) => 
      a.assignment_priority === 'high' && b.assignment_priority !== 'high' ? -1 : 1
    );
  }
  
  private calculateHelperScore(helper: WeddingHelper, task: WeddingTask): number {
    let score = 100;
    
    // Availability fit
    if (!this.isWithinAvailability(helper, task)) score -= 30;
    
    // Skill match
    const skillMatch = this.calculateSkillMatch(helper.skills, task);
    score += skillMatch * 20;
    
    // Current workload (prefer less loaded helpers)
    const workloadPenalty = (helper.workload_score / 100) * 25;
    score -= workloadPenalty;
    
    // Relationship bonus (family/bridal party get priority for important tasks)
    if (task.priority === 'critical' && ['Best Man', 'Maid of Honor', 'Family'].includes(helper.relationship)) {
      score += 15;
    }
    
    return Math.max(0, score);
  }
}
```

### CODE EXAMPLES

#### Example 1: Helper Assignment Component
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
'use client';

import { useState, useEffect } from 'react';
import { supabase } from '@/lib/supabase';
import { WeddingHelper, TaskAssignment, HelperConflict } from '@/types/helpers';
import { WeddingTask } from '@/types/tasks';
import { Button } from '@/components/ui/button';
import { Select } from '@/components/ui/select';
import { Textarea } from '@/components/ui/textarea';
import { Badge } from '@/components/ui/badge';

export function HelperAssignment({ 
  task, 
  onAssignmentUpdate 
}: {
  task: WeddingTask;
  onAssignmentUpdate: (assignment: TaskAssignment) => void;
}) {
  const [helpers, setHelpers] = useState<WeddingHelper[]>([]);
  const [selectedHelper, setSelectedHelper] = useState<string>('');
  const [assignmentNotes, setAssignmentNotes] = useState('');
  const [conflicts, setConflicts] = useState<HelperConflict[]>([]);
  const [loading, setLoading] = useState(false);
  const [suggestions, setSuggestions] = useState<any[]>([]);

  useEffect(() => {
    fetchHelpers();
    fetchAssignmentSuggestions();
  }, [task.id]);

  useEffect(() => {
    if (selectedHelper) {
      checkConflicts(selectedHelper);
    } else {
      setConflicts([]);
    }
  }, [selectedHelper]);

  const fetchHelpers = async () => {
    const { data, error } = await supabase
      .from('wedding_helpers')
      .select(`
        *,
        task_assignments!inner(
          assignment_status,
          wedding_tasks!inner(title, start_time, duration)
        )
      `)
      .eq('couple_id', task.couple_id)
      .order('name');
    
    if (error) throw error;
    setHelpers(data || []);
  };

  const fetchAssignmentSuggestions = async () => {
    const { data } = await supabase
      .rpc('suggest_helper_assignments', {
        task_id_param: task.id
      });
    
    setSuggestions(data || []);
  };

  const checkConflicts = async (helperId: string) => {
    setLoading(true);
    
    const { data, error } = await supabase
      .rpc('check_helper_conflicts', {
        helper_id_param: helperId,
        task_id_param: task.id
      });
    
    if (error) {
      console.error('Error checking conflicts:', error);
    } else {
      setConflicts(data || []);
    }
    
    setLoading(false);
  };

  const assignTask = async () => {
    if (!selectedHelper) return;
    
    setLoading(true);
    
    try {
      const { data, error } = await supabase
        .from('task_assignments')
        .insert({
          task_id: task.id,
          helper_id: selectedHelper,
          couple_id: task.couple_id,
          notes: assignmentNotes,
          assignment_status: 'assigned'
        })
        .select(`
          *,
          wedding_helpers!inner(*),
          wedding_tasks!inner(*)
        `)
        .single();
      
      if (error) throw error;
      
      // Send notification to helper
      await fetch('/api/notifications/task-assignment', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          assignment_id: data.id,
          helper_id: selectedHelper,
          task_id: task.id
        })
      });
      
      onAssignmentUpdate(data);
      
      // Reset form
      setSelectedHelper('');
      setAssignmentNotes('');
      setConflicts([]);
      
    } catch (error) {
      console.error('Error assigning task:', error);
    } finally {
      setLoading(false);
    }
  };

  const getHelperWorkload = (helper: WeddingHelper) => {
    const assignmentCount = helper.task_assignments?.length || 0;
    const workloadLevel = assignmentCount === 0 ? 'free' : 
                         assignmentCount <= 2 ? 'light' :
                         assignmentCount <= 4 ? 'moderate' : 'heavy';
    
    const colors = {
      free: 'bg-green-100 text-green-800',
      light: 'bg-blue-100 text-blue-800',
      moderate: 'bg-yellow-100 text-yellow-800',
      heavy: 'bg-red-100 text-red-800'
    };
    
    return { level: workloadLevel, count: assignmentCount, color: colors[workloadLevel] };
  };

  const conflictSeverityColor = (severity: string) => {
    return severity === 'high' ? 'text-red-600' :
           severity === 'medium' ? 'text-yellow-600' : 'text-gray-600';
  };

  return (
    <div className="helper-assignment space-y-6">
      {/* Task Details */}
      <div className="task-summary bg-gray-50 p-4 rounded-lg">
        <h3 className="font-semibold text-lg mb-2">{task.title}</h3>
        <div className="grid grid-cols-2 gap-4 text-sm">
          <div>
            <span className="font-medium">Time:</span> {task.timing_value}
          </div>
          <div>
            <span className="font-medium">Duration:</span> {task.estimated_duration} minutes
          </div>
          <div>
            <span className="font-medium">Location:</span> {task.location || 'TBD'}
          </div>
          <div>
            <span className="font-medium">Priority:</span>
            <Badge variant={task.priority === 'critical' ? 'destructive' : 'secondary'}>
              {task.priority}
            </Badge>
          </div>
        </div>
        {task.description && (
          <div className="mt-3">
            <span className="font-medium">Description:</span>
            <p className="text-gray-700 mt-1">{task.description}</p>
          </div>
        )}
      </div>

      {/* Assignment Suggestions */}
      {suggestions.length > 0 && (
        <div className="suggestions-section">
          <h4 className="font-medium mb-3">💡 Recommended Helpers</h4>
          <div className="grid gap-3">
            {suggestions.slice(0, 3).map((suggestion, index) => {
              const helper = helpers.find(h => h.id === suggestion.helper_id);
              if (!helper) return null;
              
              return (
                <div 
                  key={helper.id}
                  className="suggestion-card border border-blue-200 bg-blue-50 p-3 rounded cursor-pointer hover:bg-blue-100"
                  onClick={() => setSelectedHelper(helper.id)}
                >
                  <div className="flex justify-between items-center">
                    <div>
                      <div className="font-medium">{helper.name}</div>
                      <div className="text-sm text-gray-600">{helper.relationship}</div>
                    </div>
                    <div className="text-right">
                      <div className="text-sm font-medium text-blue-700">
                        {suggestion.match_score}% match
                      </div>
                      <div className="text-xs text-gray-500">
                        {suggestion.match_reasons?.slice(0, 2).join(', ')}
                      </div>
                    </div>
                  </div>
                </div>
              );
            })}
          </div>
        </div>
      )}

      {/* Helper Selection */}
      <div className="helper-selection">
        <label className="block text-sm font-medium mb-2">Select Helper</label>
        <Select
          value={selectedHelper}
          onValueChange={setSelectedHelper}
          placeholder="Choose a helper..."
        >
          <option value="">-- Select Helper --</option>
          {helpers.map(helper => {
            const workload = getHelperWorkload(helper);
            return (
              <option key={helper.id} value={helper.id}>
                {helper.name} ({helper.relationship}) - {workload.count} task{workload.count !== 1 ? 's' : ''}
              </option>
            );
          })}
        </Select>
        
        {selectedHelper && (
          <div className="mt-3">
            {(() => {
              const helper = helpers.find(h => h.id === selectedHelper);
              const workload = getHelperWorkload(helper!);
              
              return (
                <div className="helper-details bg-white border rounded p-3">
                  <div className="flex justify-between items-start mb-2">
                    <div>
                      <div className="font-medium">{helper!.name}</div>
                      <div className="text-sm text-gray-600">{helper!.relationship}</div>
                      {helper!.availability_start && (
                        <div className="text-sm text-gray-600">
                          Available: {helper!.availability_start} - {helper!.availability_end}
                        </div>
                      )}
                    </div>
                    <Badge className={workload.color}>
                      {workload.level} ({workload.count} tasks)
                    </Badge>
                  </div>
                  
                  {helper!.skills && helper!.skills.length > 0 && (
                    <div className="skills mb-2">
                      <span className="text-sm font-medium">Skills:</span>
                      <div className="flex flex-wrap gap-1 mt-1">
                        {helper!.skills.map(skill => (
                          <Badge key={skill} variant="outline" className="text-xs">
                            {skill}
                          </Badge>
                        ))}
                      </div>
                    </div>
                  )}
                </div>
              );
            })()}
          </div>
        )}
      </div>

      {/* Conflict Warnings */}
      {conflicts.length > 0 && (
        <div className="conflicts-section bg-yellow-50 border border-yellow-200 rounded-lg p-4">
          <h4 className="font-medium text-yellow-800 mb-3">⚠️ Potential Conflicts</h4>
          <div className="space-y-2">
            {conflicts.map((conflict, index) => (
              <div key={index} className={`text-sm ${conflictSeverityColor(conflict.severity)}`}>
                <div className="font-medium capitalize">
                  {conflict.type.replace('_', ' ')} ({conflict.severity} severity)
                </div>
                <div>{conflict.description}</div>
              </div>
            ))}
          </div>
          <div className="mt-3 text-xs text-yellow-700">
            You can still assign this task, but consider resolving conflicts first.
          </div>
        </div>
      )}

      {/* Assignment Notes */}
      {selectedHelper && (
        <div className="assignment-notes">
          <label className="block text-sm font-medium mb-2">
            Special Instructions for Helper
          </label>
          <Textarea
            value={assignmentNotes}
            onChange={(e) => setAssignmentNotes(e.target.value)}
            placeholder="Any additional notes or special instructions..."
            rows={3}
          />
        </div>
      )}

      {/* Assign Button */}
      <div className="assign-actions">
        <Button
          onClick={assignTask}
          disabled={!selectedHelper || loading}
          className="w-full"
        >
          {loading ? 'Assigning...' : 'Assign Task to Helper'}
        </Button>
        
        {selectedHelper && (
          <p className="text-sm text-gray-600 mt-2 text-center">
            The helper will receive an email notification with task details.
          </p>
        )}
      </div>
    </div>
  );
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for PostgreSQL RPC functions
- [x] Playwright: Test helper assignment workflows
- [x] Filesystem: Access helper components

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/supabase/supabase-js", "rpc functions", 2000);
await mcp__context7__get-library-docs("/react/react", "useEffect dependencies", 1500);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('HelperService', () => {
  it('should detect helper conflicts correctly', async () => {
    const conflicts = await service.checkHelperConflicts('helper-id', 'task-id');
    expect(conflicts).toHaveLength(1);
    expect(conflicts[0].type).toBe('timing_overlap');
  });

  it('should suggest optimal helper assignments', async () => {
    const suggestions = await service.suggestHelperAssignments('couple-id');
    expect(suggestions[0].recommended_helpers).toHaveLength(3);
  });
});
```

#### E2E Tests Required
```typescript
test('Helper assignment workflow', async () => {
  await mcp__playwright__browser_navigate({url: '/tasks'});
  
  // Open task assignment
  await mcp__playwright__browser_click({
    element: 'Assign helper button',
    ref: 'button[data-testid="assign-task"]'
  });
  
  // Select helper
  await mcp__playwright__browser_select_option({
    element: 'Helper selector',
    ref: 'select[name="helper"]',
    values: ['mary-johnson']
  });
  
  // Verify conflict warning if present
  await mcp__playwright__browser_wait_for({
    text: 'Potential Conflicts'
  });
  
  await mcp__playwright__browser_snapshot();
});
```

### ACCEPTANCE CRITERIA
- [x] Assign tasks to specific helpers with conflict detection
- [x] Helper availability tracking with time windows
- [x] Smart assignment suggestions based on skills and workload
- [x] Visual conflict warnings for overlapping assignments
- [x] Bulk assignment capabilities for multiple tasks
- [x] Integration with guest list for helper contact information
- [x] Automatic notification system for task assignments
- [x] Helper workload balancing and visualization
- [x] Performance: Assignment suggestions generate in <2s
- [x] Security: All assignments scoped to couple_id with RLS
- [x] Accessibility: Screen reader support for assignment status

### DEPENDENCIES
- Must complete after: WS-156 (Task Creation), WS-151 (Guest List Builder)
- Must complete before: WS-162 (Helper Schedules)
- Shares code with: Task management and notification systems

### ESTIMATED EFFORT
- Team A Frontend: 22 hours
- Team B Backend: 18 hours
- Team C Integration: 12 hours
- Total: 52 hours