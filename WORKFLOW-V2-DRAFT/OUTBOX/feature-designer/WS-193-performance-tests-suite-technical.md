# TECHNICAL SPECIFICATION: WS-193 - Performance Tests Suite
## Generated by Feature Development Session - August 25, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** WedSync DevOps engineer responsible for platform performance during peak wedding season
**I want to:** Implement comprehensive performance testing that validates load capacity, response times, and resource usage
**So that:** I can ensure the platform handles traffic spikes during peak booking periods, maintains fast response times when couples are planning time-sensitive wedding details, and prevents performance degradation that could cause suppliers to lose bookings

**Real Wedding Scenario:**
During peak wedding season (May-September), WedSync experiences 10x traffic spikes when couples are finalizing vendor selections 3-6 months before their weddings. A venue booking form that normally handles 10 submissions per hour suddenly receives 200 submissions during a bridal show weekend. Performance tests validate that form submission APIs respond under 500ms at 95th percentile with 1,000 concurrent users, database queries for supplier searches complete under 200ms with complex filtering, and the platform maintains 99.9% uptime even during traffic surges.

### SPECIFICATION SOURCE
- **Feature ID:** WS-193
- **Original Spec:** /CORE-SPECIFICATIONS/11-TESTING-DEPLOYMENT/01-Testing/04-performance-tests md.md
- **Current Implementation:** 0% complete (new)
- **Files to Modify:** None (new feature)
- **New Files to Create:** 
  - `/wedsync/tests/performance/load-test.js`
  - `/wedsync/tests/performance/api-performance.js`
  - `/wedsync/tests/performance/lighthouse-audit.ts`
  - `/wedsync/tests/performance/db-performance.test.ts`
  - `/wedsync/scripts/performance-monitor.sh`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Performance test execution tracking
CREATE TABLE performance_tests (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  test_suite TEXT NOT NULL,
  test_scenario TEXT NOT NULL,
  
  -- Test configuration
  virtual_users INTEGER,
  duration_minutes INTEGER,
  target_environment TEXT,
  
  -- Performance metrics
  avg_response_time_ms INTEGER,
  p95_response_time_ms INTEGER,
  p99_response_time_ms INTEGER,
  requests_per_second DECIMAL(8,2),
  error_rate DECIMAL(5,4),
  
  -- Resource utilization
  cpu_usage_percent DECIMAL(5,2),
  memory_usage_mb INTEGER,
  database_connections INTEGER,
  
  -- Test results
  status TEXT CHECK (status IN ('running', 'completed', 'failed')),
  passed_thresholds JSONB, -- {response_time: true, error_rate: false}
  performance_score INTEGER, -- 0-100
  
  started_at TIMESTAMPTZ DEFAULT NOW(),
  completed_at TIMESTAMPTZ
);

-- Frontend performance metrics (Lighthouse)
CREATE TABLE frontend_performance (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  page_url TEXT NOT NULL,
  test_date TIMESTAMPTZ DEFAULT NOW(),
  
  -- Core Web Vitals
  first_contentful_paint_ms INTEGER,
  largest_contentful_paint_ms INTEGER,
  cumulative_layout_shift DECIMAL(4,3),
  first_input_delay_ms INTEGER,
  time_to_interactive_ms INTEGER,
  
  -- Lighthouse scores (0-100)
  performance_score INTEGER,
  accessibility_score INTEGER,
  best_practices_score INTEGER,
  seo_score INTEGER,
  
  -- Bundle analysis
  bundle_size_kb INTEGER,
  main_thread_time_ms INTEGER,
  network_requests INTEGER,
  
  passed_thresholds BOOLEAN DEFAULT TRUE
);

-- Database performance benchmarks
CREATE TABLE db_performance_benchmarks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  query_type TEXT NOT NULL, -- 'supplier_dashboard', 'client_search', 'form_submission'
  query_description TEXT,
  
  -- Performance metrics
  execution_time_ms INTEGER,
  rows_examined INTEGER,
  rows_returned INTEGER,
  index_usage JSONB,
  
  -- Query optimization
  explain_plan JSONB,
  optimization_suggestions TEXT[],
  
  tested_at TIMESTAMPTZ DEFAULT NOW(),
  within_sla BOOLEAN -- Meets performance SLA
);

-- Load test scenarios configuration
CREATE TABLE load_test_scenarios (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  scenario_name TEXT UNIQUE NOT NULL,
  description TEXT,
  
  -- Load pattern
  ramp_up_users INTEGER,
  steady_state_users INTEGER,
  peak_users INTEGER,
  test_duration_minutes INTEGER,
  
  -- Endpoints tested
  endpoints_config JSONB,
  
  -- Success criteria
  max_response_time_ms INTEGER,
  max_error_rate DECIMAL(5,4),
  min_throughput_rps DECIMAL(8,2),
  
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

#### API Endpoints Required
```typescript
// POST /api/testing/performance/run
interface RunPerformanceTestRequest {
  testSuite: 'load' | 'lighthouse' | 'database' | 'stress';
  scenario: string;
  environment: 'staging' | 'production';
  configuration?: Record<string, any>;
}

interface RunPerformanceTestResponse {
  success: boolean;
  data: {
    testId: string;
    estimatedDuration: number;
    monitoringUrls: string[];
    thresholds: PerformanceThreshold[];
  };
}
```

#### Frontend Components Required
```typescript
// Component: PerformanceDashboard
// Location: /src/components/admin/PerformanceDashboard.tsx

interface Props {
  recentTests: PerformanceTest[];
  currentMetrics: SystemMetrics;
  performanceTrends: PerformanceTrend[];
}

// Key functionality:
- Real-time performance test execution monitoring with progress indicators
- Core Web Vitals tracking with historical trends and threshold alerts
- Load test scenario configuration with custom user patterns
- Database performance monitoring with query optimization recommendations
```

#### Integration Points
```typescript
// Service: PerformanceTestOrchestrator
// Dependencies: k6 load testing, Lighthouse auditing, database monitoring

class PerformanceTestOrchestrator {
  async executeLoadTest(scenario: LoadTestScenario): Promise<LoadTestResult> {
    // Comprehensive load testing with k6 and real-time monitoring
  }
  
  async auditFrontendPerformance(pages: string[]): Promise<LighthouseResult[]> {
    // Lighthouse auditing with Core Web Vitals tracking
  }
}
```

### CODE EXAMPLES

#### Example 1: Comprehensive Load Testing with k6
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate, Trend, Counter } from 'k6/metrics';

// Custom metrics for wedding-specific scenarios
const formSubmissionDuration = new Trend('form_submission_duration');
const supplierSearchDuration = new Trend('supplier_search_duration');
const errorRate = new Rate('errors');
const formSubmissions = new Counter('form_submissions_total');

export const options = {
  scenarios: {
    // Peak wedding season traffic pattern
    peak_season_load: {
      executor: 'ramping-vus',
      startVUs: 10,
      stages: [
        { duration: '2m', target: 100 },  // Normal traffic
        { duration: '5m', target: 100 },  // Sustained normal load
        { duration: '1m', target: 300 },  // Bridal show spike
        { duration: '3m', target: 300 },  // Peak bridal show traffic
        { duration: '2m', target: 100 },  // Return to normal
        { duration: '2m', target: 0 },    // Wind down
      ],
    },
    
    // Supplier dashboard concurrent access
    supplier_dashboard: {
      executor: 'constant-vus',
      vus: 50,
      duration: '10m',
      exec: 'supplierDashboardScenario',
    },
    
    // Form submission stress test
    form_submission_stress: {
      executor: 'ramping-arrival-rate',
      startRate: 5,
      timeUnit: '1s',
      preAllocatedVUs: 100,
      maxVUs: 200,
      stages: [
        { target: 50, duration: '3m' },  // 50 submissions/sec
        { target: 50, duration: '5m' },  // Sustained load
        { target: 0, duration: '2m' },   // Wind down
      ],
      exec: 'formSubmissionScenario',
    },
  },
  
  thresholds: {
    // Wedding industry performance requirements
    'form_submission_duration': ['p(95)<500', 'p(99)<1000'],
    'supplier_search_duration': ['p(95)<300', 'p(99)<800'],
    'http_req_duration': ['p(95)<500'],
    'errors': ['rate<0.01'],
    'http_req_failed': ['rate<0.05'],
    'form_submissions_total': ['rate>10'], // Minimum 10 submissions/sec
  },
};

const BASE_URL = __ENV.TARGET_URL || 'https://staging.wedsync.app';

export default function() {
  // Main traffic simulation: couple browsing suppliers
  const supplierSearchResponse = http.get(`${BASE_URL}/api/suppliers/search`, {
    params: {
      location: 'Yorkshire',
      vendor_type: 'photographer',
      budget_min: '1000',
      budget_max: '3000',
    },
    headers: {
      'Authorization': `Bearer ${__ENV.TEST_TOKEN}`,
    },
  });
  
  check(supplierSearchResponse, {
    'supplier search status 200': (r) => r.status === 200,
    'supplier search under 300ms': (r) => r.timings.duration < 300,
    'supplier search returns results': (r) => JSON.parse(r.body).data.length > 0,
  });
  
  supplierSearchDuration.add(supplierSearchResponse.timings.duration);
  errorRate.add(supplierSearchResponse.status !== 200);
  
  sleep(1);
  
  // Simulate form access and submission
  if (Math.random() < 0.3) { // 30% of users submit forms
    const formSubmissionPayload = JSON.stringify({
      form_id: 'photographer-consultation-form',
      data: {
        wedding_date: '2025-07-15',
        venue_name: 'The Manor House',
        guest_count: 120,
        photo_style: 'Traditional',
        budget: '2500',
        additional_requirements: 'Engagement photos included'
      },
    });
    
    const submissionResponse = http.post(
      `${BASE_URL}/api/forms/submit`,
      formSubmissionPayload,
      {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${__ENV.TEST_TOKEN}`,
        },
      }
    );
    
    check(submissionResponse, {
      'form submission status 200': (r) => r.status === 200,
      'form submission under 500ms': (r) => r.timings.duration < 500,
      'form submission successful': (r) => JSON.parse(r.body).success === true,
    });
    
    formSubmissionDuration.add(submissionResponse.timings.duration);
    formSubmissions.add(1);
    errorRate.add(submissionResponse.status !== 200);
  }
  
  sleep(2);
}

// Dedicated scenario for supplier dashboard performance
export function supplierDashboardScenario() {
  const dashboardResponse = http.get(`${BASE_URL}/api/supplier/dashboard`, {
    headers: {
      'Authorization': `Bearer ${__ENV.SUPPLIER_TEST_TOKEN}`,
    },
  });
  
  check(dashboardResponse, {
    'dashboard loads under 200ms': (r) => r.timings.duration < 200,
    'dashboard has required data': (r) => {
      const data = JSON.parse(r.body);
      return data.clients && data.forms && data.analytics;
    },
  });
  
  sleep(3);
}

// Dedicated scenario for form submission load
export function formSubmissionScenario() {
  const formPayload = JSON.stringify({
    form_id: `test-form-${Math.floor(Math.random() * 100)}`,
    data: {
      wedding_date: '2025-06-20',
      venue_name: 'Test Venue',
      notes: `Load test submission ${Date.now()}`
    },
  });
  
  const response = http.post(`${BASE_URL}/api/forms/submit`, formPayload, {
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${__ENV.TEST_TOKEN}`,
    },
  });
  
  formSubmissionDuration.add(response.timings.duration);
  formSubmissions.add(1);
  errorRate.add(response.status !== 200);
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for k6 load testing, Lighthouse performance auditing
- [x] Filesystem: Manage performance test scripts and results
- [x] PostgreSQL: Database performance benchmarking and optimization

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/k6/k6", "load testing", 4000);
await mcp__context7__get-library-docs("/lighthouse/lighthouse", "performance auditing", 3000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('PerformanceTestOrchestrator', () => {
  it('should execute k6 load tests with proper configuration', () => {
    // Test load test configuration and execution
  });
  
  it('should generate Lighthouse reports with Core Web Vitals', () => {
    // Test frontend performance auditing
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Performance test suite executes and reports results', async () => {
  await mcp__playwright__browser_navigate({url: '/admin/performance'});
  
  await mcp__playwright__browser_click({
    element: 'run load test button',
    ref: '[data-testid="run-load-test"]'
  });
  
  // Verify test execution and results
  await mcp__playwright__browser_wait_for({text: 'Load test completed'});
  
  // Verify performance metrics are displayed
  await expect(page.locator('[data-testid="p95-response-time"]')).toBeVisible();
});
```

### ACCEPTANCE CRITERIA
- [x] Load tests validate platform handles 300 concurrent users with <500ms p95 response time
- [x] Frontend performance scores >85 on Lighthouse with Core Web Vitals passing
- [x] Database queries for supplier searches complete under 200ms at 95th percentile
- [x] Performance: Full performance test suite completes within 30 minutes
- [x] Security: Performance tests use isolated test data and don't affect production
- [x] Accessibility: Performance results dashboard works with screen readers

### DEPENDENCIES
- Must complete after: WS-192 (Integration Tests Suite) - provides test infrastructure foundation
- Must complete before: Production deployment and performance monitoring setup
- Shares code with: Test infrastructure, monitoring systems, CI/CD pipeline

### ESTIMATED EFFORT
- Team C Integration: 72 hours (k6 load testing setup, Lighthouse integration, performance monitoring)
- Team A Backend: 32 hours (Database performance testing, API benchmarking)
- Team B Frontend: 24 hours (Performance dashboard, Core Web Vitals tracking)
- Total: 128 hours