# TECHNICAL SPECIFICATION: WS-288 - Solution Architecture
## Generated by Feature Development Session - 2025-08-25

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Technical Lead / Senior Developer / System Architect
**I want to:** Understand the complete system architecture including Core Fields System, database design, and integration patterns
**So that:** I can implement features that align with the architectural vision and maintain system consistency

**Real Wedding Scenario:**
"A couple enters their wedding date, venue, and guest count once in WedMe. This data instantly becomes available to their photographer, caterer, and florist through WedSync's Core Fields System. When the couple updates their guest count from 100 to 120, all three vendors receive real-time notifications with the updated information, eliminating the need for 3 separate phone calls and ensuring everyone has accurate data."

### SPECIFICATION SOURCE
- **Feature ID:** WS-288
- **Original Spec:** /CORE-SPECIFICATIONS/00-PROJECT-OVERVIEW/03-solution-architecture.md
- **Current Implementation:** 30% complete (basic Next.js setup, Supabase connection)
- **Files to Modify:** 
  - /src/lib/database/core-fields.ts
  - /src/lib/auth/providers.ts
  - /src/lib/realtime/subscriptions.ts
- **New Files to Create:**
  - /docs/architecture-overview.md
  - /src/lib/core-fields/types.ts
  - /src/lib/core-fields/service.ts
  - /src/lib/api/endpoints.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Core Fields System (Revolutionary Innovation)
CREATE TABLE IF NOT EXISTS core_fields (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  couple_id UUID REFERENCES couples(id) ON DELETE CASCADE,
  
  -- Couple Information
  partner1_name VARCHAR(100),
  partner1_email VARCHAR(255),
  partner1_phone VARCHAR(20),
  partner2_name VARCHAR(100),
  partner2_email VARCHAR(255),
  partner2_phone VARCHAR(20),
  couple_address JSONB,
  
  -- Wedding Details
  wedding_date DATE,
  ceremony_venue JSONB,
  reception_venue JSONB,
  guest_count JSONB, -- {adults: number, children: number, total: number}
  wedding_style TEXT[],
  wedding_colors TEXT[],
  
  -- Timeline
  ceremony_time TIME,
  reception_time TIME,
  key_moments JSONB, -- [{name: string, time: string, description: string}]
  
  -- Key People
  wedding_party JSONB,
  family_vips JSONB,
  connected_vendors JSONB,
  
  -- Metadata
  last_updated_by UUID,
  updated_at TIMESTAMP DEFAULT NOW(),
  created_at TIMESTAMP DEFAULT NOW(),
  
  UNIQUE(couple_id)
);

-- Enable Row Level Security
ALTER TABLE core_fields ENABLE ROW LEVEL SECURITY;

-- RLS Policies for Core Fields
CREATE POLICY "Couples can access their own core fields" ON core_fields
  FOR ALL USING (couple_id = auth.uid()::UUID);

CREATE POLICY "Connected suppliers can read core fields" ON core_fields
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM supplier_couple_connections scc
      WHERE scc.couple_id = core_fields.couple_id
      AND scc.supplier_id = auth.uid()::UUID
      AND scc.status = 'active'
    )
  );

-- Audit table for all changes
CREATE TABLE IF NOT EXISTS core_fields_audit (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  core_field_id UUID REFERENCES core_fields(id),
  changed_field VARCHAR(100),
  old_value JSONB,
  new_value JSONB,
  changed_by UUID,
  changed_at TIMESTAMP DEFAULT NOW()
);
```

#### API Endpoints Required
```typescript
// Core Fields API Structure
interface CoreFieldsAPI {
  // GET /api/v1/core-fields
  getCoreFields(): Promise<CoreFields>;
  
  // PUT /api/v1/core-fields
  updateCoreFields(data: Partial<CoreFields>): Promise<CoreFields>;
  
  // GET /api/v1/core-fields/audit
  getAuditHistory(): Promise<CoreFieldsAudit[]>;
  
  // POST /api/v1/core-fields/share
  shareWithSupplier(supplierId: string, fields: string[]): Promise<void>;
}

interface CoreFields {
  couple: {
    partner1_name: string;
    partner1_email: string;
    partner1_phone: string;
    partner2_name: string;
    partner2_email: string;
    partner2_phone: string;
    address: Address;
  };
  wedding: {
    date: Date;
    ceremony_venue: Venue;
    reception_venue: Venue;
    guest_count: GuestCount;
    style: string[];
    colors: string[];
  };
  timeline: {
    ceremony_time: string;
    reception_time: string;
    key_moments: Moment[];
  };
  people: {
    wedding_party: Person[];
    family_vips: Person[];
    vendors: Vendor[];
  };
}

interface Venue {
  name: string;
  address: string;
  contact_person?: string;
  contact_phone?: string;
  notes?: string;
}

interface GuestCount {
  adults: number;
  children: number;
  total: number;
  confirmed: number;
  pending: number;
}
```

#### Frontend Components Required
```typescript
// Component: CoreFieldsManager
// Location: /src/components/core-fields/CoreFieldsManager.tsx

interface Props {
  userType: 'couple' | 'supplier';
  editableFields?: string[];
  onFieldChange?: (field: string, value: any) => void;
}

// Key functionality:
- Unified interface for core fields management
- Real-time synchronization across platforms
- Field-level permission controls
- Auto-save with optimistic updates
- Audit trail visualization

// Component: RealTimeUpdates
// Location: /src/components/realtime/RealTimeUpdates.tsx

interface Props {
  subscriptionChannel: string;
  onUpdate: (payload: any) => void;
  userId: string;
}

// Key functionality:
- WebSocket connection management
- Real-time data synchronization
- Connection state monitoring
- Automatic reconnection logic
```

#### Integration Points
```typescript
// Service: CoreFieldsService
// Dependencies: Supabase client, real-time subscriptions

class CoreFieldsService {
  private supabase = createClient();
  
  async getCoreFields(coupleId: string): Promise<CoreFields> {
    const { data, error } = await this.supabase
      .from('core_fields')
      .select('*')
      .eq('couple_id', coupleId)
      .single();
      
    if (error) throw error;
    return this.transformToInterface(data);
  }
  
  async updateCoreFields(coupleId: string, updates: Partial<CoreFields>): Promise<void> {
    // Create audit entry first
    await this.createAuditEntry(coupleId, updates);
    
    const { error } = await this.supabase
      .from('core_fields')
      .update({
        ...updates,
        updated_at: new Date().toISOString()
      })
      .eq('couple_id', coupleId);
      
    if (error) throw error;
    
    // Trigger real-time updates
    await this.notifyConnectedSuppliers(coupleId, updates);
  }
  
  async subscribeToUpdates(coupleId: string, callback: (data: any) => void) {
    return this.supabase
      .channel(`core_fields_${coupleId}`)
      .on('postgres_changes', {
        event: 'UPDATE',
        schema: 'public',
        table: 'core_fields',
        filter: `couple_id=eq.${coupleId}`
      }, callback)
      .subscribe();
  }
}

// Service: RealTimeArchitecture
// Dependencies: Supabase realtime, state management

class RealTimeArchitecture {
  private subscriptions = new Map();
  
  async setupCoupleSubscriptions(coupleId: string) {
    // Subscribe to core fields changes
    // Subscribe to supplier connections
    // Subscribe to form responses
    // Subscribe to journey updates
  }
  
  async setupSupplierSubscriptions(supplierId: string) {
    // Subscribe to client core fields (filtered by permissions)
    // Subscribe to form submissions
    // Subscribe to journey executions
  }
}
```

### CODE EXAMPLES

#### Example 1: Core Fields Auto-Population
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { createClient } from '@/lib/supabase/client';
import { CoreFields } from '@/types/core-fields';

export class CoreFieldsAutoPopulation {
  private supabase = createClient();
  
  async populateForm(formId: string, coupleId: string) {
    // Get couple's core fields
    const { data: coreFields } = await this.supabase
      .from('core_fields')
      .select('*')
      .eq('couple_id', coupleId)
      .single();
    
    if (!coreFields) return;
    
    // Get form structure with field mappings
    const { data: form } = await this.supabase
      .from('forms')
      .select('structure_jsonb, core_field_mappings')
      .eq('id', formId)
      .single();
    
    if (!form) return;
    
    // Auto-populate mapped fields
    const populatedData = {};
    Object.entries(form.core_field_mappings).forEach(([formField, coreField]) => {
      const value = this.getNestedValue(coreFields, coreField as string);
      if (value !== undefined) {
        populatedData[formField] = value;
      }
    });
    
    return populatedData;
  }
  
  private getNestedValue(obj: any, path: string) {
    return path.split('.').reduce((current, key) => current?.[key], obj);
  }
}

// Usage in form component
const formData = await coreFieldsService.populateForm(formId, coupleId);
// Form instantly populated with venue, date, guest count, etc.
```

#### Example 2: Real-Time Synchronization
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { useEffect, useState } from 'react';
import { createClient } from '@/lib/supabase/client';

export function useCoreFieldsSync(coupleId: string) {
  const [coreFields, setCoreFields] = useState<CoreFields | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const supabase = createClient();
  
  useEffect(() => {
    // Initial load
    loadCoreFields();
    
    // Set up real-time subscription
    const subscription = supabase
      .channel(`core_fields_${coupleId}`)
      .on('postgres_changes', {
        event: 'UPDATE',
        schema: 'public',
        table: 'core_fields',
        filter: `couple_id=eq.${coupleId}`
      }, (payload) => {
        setCoreFields(prev => ({
          ...prev,
          ...payload.new
        }));
      })
      .subscribe();
    
    return () => {
      subscription.unsubscribe();
    };
  }, [coupleId]);
  
  const loadCoreFields = async () => {
    setIsLoading(true);
    const { data, error } = await supabase
      .from('core_fields')
      .select('*')
      .eq('couple_id', coupleId)
      .single();
    
    if (!error && data) {
      setCoreFields(data);
    }
    setIsLoading(false);
  };
  
  const updateField = async (field: string, value: any) => {
    // Optimistic update
    setCoreFields(prev => ({
      ...prev,
      [field]: value
    }));
    
    // Persist to database
    const { error } = await supabase
      .from('core_fields')
      .update({ [field]: value })
      .eq('couple_id', coupleId);
    
    if (error) {
      // Revert optimistic update on error
      loadCoreFields();
    }
  };
  
  return { coreFields, isLoading, updateField };
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [ ] Context7: Load docs for Next.js App Router, Supabase realtime
- [ ] Supabase: Database operations, real-time subscriptions
- [ ] Filesystem: Create architecture documentation

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/vercel/next.js", "app router server components", 3000);
await mcp__context7__get-library-docs("/supabase/supabase", "realtime subscriptions", 2500);
await mcp__context7__get-library-docs("/supabase/supabase", "row level security", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('Core Fields Architecture', () => {
  it('should auto-populate forms from core fields', () => {
    const service = new CoreFieldsAutoPopulation();
    // Test field mapping and auto-population
  });
  
  it('should maintain real-time sync across platforms', () => {
    // Test WebSocket connections and data synchronization
  });
  
  it('should enforce RLS policies correctly', () => {
    // Test data access permissions
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Core Fields system works end-to-end', async () => {
  await mcp__playwright__browser_navigate({url: '/wedme/core-fields'});
  
  // Couple updates wedding date
  await mcp__playwright__browser_type({
    element: 'wedding date input',
    ref: 'input[name="wedding_date"]',
    text: '2025-06-15'
  });
  
  // Navigate to supplier view
  await mcp__playwright__browser_navigate({url: '/wedsync/client/123'});
  
  // Verify date appears automatically
  await mcp__playwright__browser_snapshot();
  // Test real-time propagation of core fields data
});
```

### ACCEPTANCE CRITERIA
- [ ] Core Fields System implemented with auto-population capability
- [ ] Real-time synchronization working between WedSync and WedMe
- [ ] Row Level Security policies enforced for data access
- [ ] API endpoints support versioning and rate limiting
- [ ] Audit trail captures all core fields changes
- [ ] Performance targets met (<2 second load times)
- [ ] Security implemented (bank-level encryption)
- [ ] Scalability tested (handles 10,000+ concurrent users)
- [ ] Integration points documented and tested

### DEPENDENCIES
- Must complete after: Problem statement (WS-287)
- Must complete before: Tech stack decisions (WS-289)
- Shares code with: Database architecture, API architecture, real-time systems

### ESTIMATED EFFORT
- Team A Frontend: 24 hours (Core Fields UI, real-time components)
- Team B Backend: 32 hours (Core Fields API, RLS policies, audit system)
- Team C Integration: 16 hours (real-time subscriptions, webhook setup)
- Team D Platform: 8 hours (performance optimization)
- Team E General: 12 hours (architecture documentation)
- Team F Workflows: 6 hours (integration testing)
- Team G Performance: 8 hours (scalability testing)
- Total: 106 hours