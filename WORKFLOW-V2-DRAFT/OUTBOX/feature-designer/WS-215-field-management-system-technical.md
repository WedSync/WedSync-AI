# TECHNICAL SPECIFICATION: WS-215 - Field Management System
## Generated by Feature Development Session - 2025-01-25

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Couple planning our wedding
**I want to:** Enter wedding details once in a centralized system that automatically shares information with all our vendors
**So that:** I never have to repeatedly fill out the same information (names, date, venue, guest count) across multiple vendor forms, saving hours of data entry and preventing inconsistent information

**Real Wedding Scenario:**
A couple has 6 vendors (photographer, caterer, florist, venue coordinator, DJ, planner) who each need the couple's names, wedding date, venue details, guest count, timeline, and contact information. Currently, they spend 2-3 hours filling out separate intake forms, often with slightly different information leading to confusion. With Field Management, they enter core details once, and when the photographer's form asks for "Guest Count" it automatically shows "145" from their core fields. When they update the guest count to 150, all vendors see the change instantly - eliminating 15+ hours of form filling and ensuring all vendors have consistent, up-to-date information.

### SPECIFICATION SOURCE
- **Feature ID:** WS-215
- **Original Spec:** /CORE-SPECIFICATIONS/03-WEDME-COUPLE-PLATFORM/03-Core-Fields/01-field-management md.md
- **Current Implementation:** 25% complete (basic core_fields table exists)
- **Files to Modify:** 
  - /src/lib/validations/core-fields.ts (extend existing validation)
  - /src/types/core-fields.ts (extend existing types)
- **New Files to Create:** 
  - /src/app/(dashboard)/profile/fields/page.tsx
  - /src/components/fields/CoreFieldsManager.tsx
  - /src/components/fields/FieldEditor.tsx
  - /src/components/fields/FieldStatusIndicator.tsx
  - /src/components/fields/FieldSyncTracker.tsx
  - /src/lib/stores/coreFieldsStore.ts
  - /src/lib/services/field-propagation-service.ts
  - /src/app/api/core-fields/route.ts
  - /src/app/api/core-fields/[key]/route.ts
  - /src/app/api/core-fields/sync/route.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Extend existing core_fields table with comprehensive field management
ALTER TABLE core_fields ADD COLUMN IF NOT EXISTS field_metadata JSONB DEFAULT '{}';
ALTER TABLE core_fields ADD COLUMN IF NOT EXISTS validation_rules JSONB DEFAULT '{}';
ALTER TABLE core_fields ADD COLUMN IF NOT EXISTS last_validated_at TIMESTAMP;
ALTER TABLE core_fields ADD COLUMN IF NOT EXISTS updated_by_user_id UUID REFERENCES auth.users(id);
ALTER TABLE core_fields ADD COLUMN IF NOT EXISTS is_locked BOOLEAN DEFAULT false;
ALTER TABLE core_fields ADD COLUMN IF NOT EXISTS lock_reason TEXT;

-- Core field definitions and schemas
CREATE TABLE IF NOT EXISTS core_field_definitions (
  field_key VARCHAR(50) PRIMARY KEY,
  field_name TEXT NOT NULL,
  field_description TEXT,
  field_type TEXT NOT NULL CHECK (field_type IN ('text', 'email', 'phone', 'date', 'number', 'address', 'enum', 'array')),
  validation_schema JSONB NOT NULL,
  default_value JSONB,
  is_required BOOLEAN DEFAULT false,
  is_sensitive BOOLEAN DEFAULT false, -- PII data
  category TEXT NOT NULL CHECK (category IN ('essential', 'couple', 'venue', 'timeline', 'preferences', 'contact')),
  display_order INTEGER DEFAULT 0,
  auto_populate_from TEXT[], -- Fields that can auto-populate this field
  propagates_to TEXT[], -- Services/vendors that receive this field
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Insert comprehensive core field definitions
INSERT INTO core_field_definitions (field_key, field_name, field_description, field_type, validation_schema, is_required, category, display_order, propagates_to) VALUES
-- Essential Wedding Info
('wedding_date', 'Wedding Date', 'The date of your wedding ceremony', 'date', '{"min": "today+30", "max": "today+1095"}', true, 'essential', 1, ARRAY['all_vendors']),
('ceremony_time', 'Ceremony Time', 'Start time of the wedding ceremony', 'text', '{"pattern": "^([0-9]{1,2}):([0-9]{2})\\s?(AM|PM)$"}', true, 'essential', 2, ARRAY['all_vendors']),
('guest_count', 'Guest Count', 'Total number of wedding guests', 'number', '{"min": 2, "max": 500}', true, 'essential', 3, ARRAY['caterer', 'venue', 'photographer', 'planner']),

-- Couple Details
('partner1_name', 'Partner 1 Full Name', 'Full legal name of first partner', 'text', '{"minLength": 2, "maxLength": 100}', true, 'couple', 10, ARRAY['all_vendors']),
('partner1_email', 'Partner 1 Email', 'Primary email address for first partner', 'email', '{}', true, 'couple', 11, ARRAY['all_vendors']),
('partner1_phone', 'Partner 1 Phone', 'Primary phone number for first partner', 'phone', '{}', true, 'couple', 12, ARRAY['all_vendors']),
('partner2_name', 'Partner 2 Full Name', 'Full legal name of second partner', 'text', '{"minLength": 2, "maxLength": 100}', true, 'couple', 13, ARRAY['all_vendors']),
('partner2_email', 'Partner 2 Email', 'Primary email address for second partner', 'email', '{}', false, 'couple', 14, ARRAY['all_vendors']),
('partner2_phone', 'Partner 2 Phone', 'Primary phone number for second partner', 'phone', '{}', false, 'couple', 15, ARRAY['all_vendors']),

-- Venue Information
('ceremony_venue_name', 'Ceremony Venue Name', 'Name of ceremony location', 'text', '{"minLength": 2, "maxLength": 200}', true, 'venue', 20, ARRAY['photographer', 'florist', 'transportation', 'planner']),
('ceremony_venue_address', 'Ceremony Venue Address', 'Full address of ceremony location', 'address', '{}', true, 'venue', 21, ARRAY['all_vendors']),
('reception_venue_name', 'Reception Venue Name', 'Name of reception location', 'text', '{"minLength": 2, "maxLength": 200}', false, 'venue', 22, ARRAY['caterer', 'photographer', 'dj', 'florist']),
('reception_venue_address', 'Reception Venue Address', 'Full address of reception location', 'address', '{}', false, 'venue', 23, ARRAY['all_vendors']),

-- Timeline Details
('getting_ready_time', 'Getting Ready Start Time', 'When bride/groom start getting ready', 'text', '{"pattern": "^([0-9]{1,2}):([0-9]{2})\\s?(AM|PM)$"}', false, 'timeline', 30, ARRAY['photographer', 'hair_makeup']),
('reception_start_time', 'Reception Start Time', 'When reception festivities begin', 'text', '{"pattern": "^([0-9]{1,2}):([0-9]{2})\\s?(AM|PM)$"}', false, 'timeline', 31, ARRAY['caterer', 'dj', 'photographer']),
('reception_end_time', 'Reception End Time', 'When reception is scheduled to end', 'text', '{"pattern": "^([0-9]{1,2}):([0-9]{2})\\s?(AM|PM)$"}', false, 'timeline', 32, ARRAY['venue', 'transportation']),

-- Contact & Emergency
('emergency_contact_name', 'Emergency Contact Name', 'Name of emergency contact person', 'text', '{"minLength": 2, "maxLength": 100}', false, 'contact', 40, ARRAY['venue', 'planner']),
('emergency_contact_phone', 'Emergency Contact Phone', 'Phone number of emergency contact', 'phone', '{}', false, 'contact', 41, ARRAY['venue', 'planner']);

-- Field change history for audit trail
CREATE TABLE IF NOT EXISTS core_field_changes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  couple_id UUID REFERENCES couples(id) ON DELETE CASCADE,
  field_key VARCHAR(50) REFERENCES core_field_definitions(field_key),
  old_value JSONB,
  new_value JSONB,
  changed_by_user_id UUID REFERENCES auth.users(id),
  change_reason TEXT,
  changed_at TIMESTAMP DEFAULT NOW(),
  propagated_at TIMESTAMP,
  propagation_status TEXT DEFAULT 'pending' CHECK (propagation_status IN ('pending', 'in_progress', 'completed', 'failed'))
);

-- Field propagation tracking
CREATE TABLE IF NOT EXISTS field_propagation_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  change_id UUID REFERENCES core_field_changes(id) ON DELETE CASCADE,
  target_service TEXT NOT NULL, -- Which vendor/service received the update
  target_supplier_id UUID REFERENCES auth.users(id),
  propagation_method TEXT NOT NULL CHECK (propagation_method IN ('realtime', 'webhook', 'api', 'manual')),
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'sent', 'delivered', 'failed')),
  error_message TEXT,
  attempted_at TIMESTAMP DEFAULT NOW(),
  completed_at TIMESTAMP
);

-- Indexes for performance
CREATE INDEX idx_core_fields_couple_field ON core_fields(couple_id, field_key);
CREATE INDEX idx_core_field_changes_couple ON core_field_changes(couple_id);
CREATE INDEX idx_core_field_changes_field ON core_field_changes(field_key);
CREATE INDEX idx_field_propagation_log_change ON field_propagation_log(change_id);
CREATE INDEX idx_field_propagation_log_supplier ON field_propagation_log(target_supplier_id);
```

#### API Endpoints Required

**1. Core Fields Management**
```typescript
// GET /api/core-fields
// Get all core fields for authenticated couple
interface CoreFieldsResponse {
  fields: CoreField[];
  completionStats: {
    totalFields: number;
    completedFields: number;
    requiredFields: number;
    completedRequiredFields: number;
    completionPercentage: number;
  };
  lastUpdated: string;
}

interface CoreField {
  key: string;
  value: any;
  status: 'completed' | 'partial' | 'pending' | 'not_applicable';
  lastUpdated: string;
  updatedBy: 'couple' | 'supplier';
  isLocked: boolean;
  lockReason?: string;
  definition: CoreFieldDefinition;
  validationErrors?: ValidationError[];
  propagationStatus: PropagationStatus;
}

interface CoreFieldDefinition {
  fieldName: string;
  fieldDescription: string;
  fieldType: 'text' | 'email' | 'phone' | 'date' | 'number' | 'address' | 'enum' | 'array';
  validationSchema: any;
  isRequired: boolean;
  category: string;
  propagatesTo: string[];
}

interface PropagationStatus {
  lastPropagated: string;
  pendingTargets: string[];
  failedTargets: string[];
  successfulTargets: string[];
}

// PUT /api/core-fields/[key]
// Update a specific core field
interface UpdateCoreFieldRequest {
  value: any;
  changeReason?: string;
  propagateImmediately?: boolean;
}

interface UpdateCoreFieldResponse {
  success: boolean;
  field: CoreField;
  validationErrors?: ValidationError[];
  propagationTriggered: boolean;
  affectedVendors: string[];
}

// POST /api/core-fields/bulk-update
// Update multiple fields at once
interface BulkUpdateRequest {
  updates: Record<string, any>;
  changeReason?: string;
  propagateImmediately?: boolean;
}
```

**2. Field Validation & Status**
```typescript
// POST /api/core-fields/validate
// Validate field values before saving
interface ValidateFieldsRequest {
  fields: Record<string, any>;
}

interface ValidateFieldsResponse {
  isValid: boolean;
  fieldErrors: Record<string, ValidationError[]>;
  warnings: Record<string, ValidationWarning[]>;
}

interface ValidationError {
  code: string;
  message: string;
  field: string;
  value: any;
}

interface ValidationWarning {
  code: string;
  message: string;
  suggestion?: string;
}

// GET /api/core-fields/status
// Get field completion and sync status
interface FieldStatusResponse {
  completionStatus: Record<string, boolean>;
  syncStatus: Record<string, {
    lastSynced: string;
    syncedVendors: string[];
    pendingSyncs: string[];
    failedSyncs: string[];
  }>;
  requiresAttention: string[]; // Fields needing user attention
}
```

**3. Field Propagation & Sync**
```typescript
// POST /api/core-fields/sync
// Manually trigger field synchronization to vendors
interface SyncFieldsRequest {
  fieldKeys?: string[]; // If not provided, sync all changed fields
  targetVendors?: string[]; // If not provided, sync to all connected vendors
  forceSync?: boolean; // Sync even if no changes detected
}

interface SyncFieldsResponse {
  syncJobId: string;
  fieldsToSync: string[];
  targetVendors: string[];
  estimatedCompletionTime: string;
}

// GET /api/core-fields/sync/status/{jobId}
// Check sync job status
interface SyncStatusResponse {
  jobId: string;
  status: 'pending' | 'in_progress' | 'completed' | 'failed';
  progress: {
    total: number;
    completed: number;
    failed: number;
  };
  results: SyncResult[];
  completedAt?: string;
}

interface SyncResult {
  fieldKey: string;
  vendor: string;
  status: 'success' | 'failed';
  error?: string;
  syncedAt: string;
}

// GET /api/core-fields/changes
// Get field change history
interface FieldChangesResponse {
  changes: FieldChange[];
  pagination: {
    page: number;
    totalPages: number;
    totalChanges: number;
  };
}

interface FieldChange {
  id: string;
  fieldKey: string;
  fieldName: string;
  oldValue: any;
  newValue: any;
  changedBy: 'couple' | 'supplier';
  changeReason?: string;
  changedAt: string;
  propagationStatus: 'pending' | 'completed' | 'failed';
  affectedVendors: string[];
}
```

#### Frontend Components Required

**1. Core Fields Manager**
```typescript
// src/components/fields/CoreFieldsManager.tsx
import React, { useState, useEffect } from 'react';
import { FieldEditor } from './FieldEditor';
import { FieldStatusIndicator } from './FieldStatusIndicator';
import { FieldSyncTracker } from './FieldSyncTracker';
import { useCoreFieldsStore } from '@/lib/stores/coreFieldsStore';

interface CoreFieldsManagerProps {
  category?: string; // Filter by field category
  showCompletionStats?: boolean;
  allowBulkEdit?: boolean;
}

export function CoreFieldsManager({
  category,
  showCompletionStats = true,
  allowBulkEdit = false
}: CoreFieldsManagerProps) {
  const {
    fields,
    completionStats,
    isLoading,
    loadFields,
    updateField,
    bulkUpdateFields,
    validateFields,
    triggerSync
  } = useCoreFieldsStore();

  const [editMode, setEditMode] = useState(false);
  const [selectedFields, setSelectedFields] = useState<string[]>([]);
  const [validationErrors, setValidationErrors] = useState<Record<string, ValidationError[]>>({});

  useEffect(() => {
    loadFields(category);
  }, [category, loadFields]);

  const handleFieldUpdate = async (fieldKey: string, value: any, reason?: string) => {
    try {
      // Validate before saving
      const validation = await validateFields({ [fieldKey]: value });
      if (!validation.isValid) {
        setValidationErrors({ [fieldKey]: validation.fieldErrors[fieldKey] || [] });
        return;
      }

      await updateField(fieldKey, value, reason, true); // Propagate immediately
      setValidationErrors(prev => ({ ...prev, [fieldKey]: [] }));
    } catch (error) {
      console.error('Failed to update field:', error);
    }
  };

  const handleBulkUpdate = async (updates: Record<string, any>) => {
    try {
      const validation = await validateFields(updates);
      if (!validation.isValid) {
        setValidationErrors(validation.fieldErrors);
        return;
      }

      await bulkUpdateFields(updates, 'Bulk update from field manager', true);
      setValidationErrors({});
      setSelectedFields([]);
      setEditMode(false);
    } catch (error) {
      console.error('Failed to bulk update fields:', error);
    }
  };

  const filteredFields = category 
    ? fields.filter(field => field.definition.category === category)
    : fields;

  const groupedFields = filteredFields.reduce((groups, field) => {
    const category = field.definition.category;
    if (!groups[category]) {
      groups[category] = [];
    }
    groups[category].push(field);
    return groups;
  }, {} as Record<string, CoreField[]>);

  if (isLoading) {
    return <div className="animate-pulse">Loading your wedding details...</div>;
  }

  return (
    <div className="space-y-6">
      {/* Completion Stats */}
      {showCompletionStats && (
        <div className="bg-gradient-to-r from-blue-50 to-indigo-50 p-6 rounded-lg">
          <div className="flex items-center justify-between mb-4">
            <h3 className="text-lg font-semibold text-gray-900">
              Profile Completion
            </h3>
            <span className="text-2xl font-bold text-blue-600">
              {completionStats.completionPercentage}%
            </span>
          </div>
          
          <div className="bg-blue-200 rounded-full h-3 mb-3">
            <div 
              className="bg-blue-600 h-3 rounded-full transition-all duration-500"
              style={{ width: `${completionStats.completionPercentage}%` }}
            />
          </div>
          
          <div className="flex justify-between text-sm text-gray-600">
            <span>
              {completionStats.completedFields} of {completionStats.totalFields} fields completed
            </span>
            <span>
              {completionStats.completedRequiredFields} of {completionStats.requiredFields} required
            </span>
          </div>
        </div>
      )}

      {/* Bulk Edit Controls */}
      {allowBulkEdit && (
        <div className="flex items-center justify-between p-4 bg-gray-50 rounded-lg">
          <div className="flex items-center space-x-4">
            <button
              onClick={() => setEditMode(!editMode)}
              className={`px-4 py-2 rounded-md ${
                editMode 
                  ? 'bg-blue-600 text-white' 
                  : 'bg-white text-gray-700 border border-gray-300'
              }`}
            >
              {editMode ? 'Exit Edit Mode' : 'Edit Multiple Fields'}
            </button>
            
            {editMode && (
              <span className="text-sm text-gray-600">
                Select fields to edit in bulk
              </span>
            )}
          </div>
          
          {editMode && selectedFields.length > 0 && (
            <button
              onClick={() => {
                // Open bulk edit modal or form
              }}
              className="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700"
            >
              Edit {selectedFields.length} Fields
            </button>
          )}
        </div>
      )}

      {/* Sync Status */}
      <FieldSyncTracker />

      {/* Field Groups */}
      {Object.entries(groupedFields).map(([categoryName, categoryFields]) => (
        <div key={categoryName} className="bg-white border border-gray-200 rounded-lg p-6">
          <div className="flex items-center justify-between mb-4">
            <h4 className="text-lg font-semibold text-gray-900 capitalize">
              {categoryName.replace('_', ' ')} Information
            </h4>
            <FieldStatusIndicator 
              fields={categoryFields}
              showDetails={false}
            />
          </div>
          
          <div className="grid gap-4 md:grid-cols-2">
            {categoryFields.map((field) => (
              <div key={field.key} className="relative">
                {editMode && (
                  <input
                    type="checkbox"
                    checked={selectedFields.includes(field.key)}
                    onChange={(e) => {
                      if (e.target.checked) {
                        setSelectedFields(prev => [...prev, field.key]);
                      } else {
                        setSelectedFields(prev => prev.filter(key => key !== field.key));
                      }
                    }}
                    className="absolute top-2 left-2 z-10"
                  />
                )}
                
                <FieldEditor
                  field={field}
                  onUpdate={(value, reason) => handleFieldUpdate(field.key, value, reason)}
                  validationErrors={validationErrors[field.key]}
                  disabled={field.isLocked}
                />
              </div>
            ))}
          </div>
        </div>
      ))}
    </div>
  );
}
```

**2. Field Editor Component**
```typescript
// src/components/fields/FieldEditor.tsx
import React, { useState, useEffect } from 'react';
import { useDebounce } from '@/hooks/useDebounce';

interface FieldEditorProps {
  field: CoreField;
  onUpdate: (value: any, reason?: string) => void;
  validationErrors?: ValidationError[];
  disabled?: boolean;
}

export function FieldEditor({
  field,
  onUpdate,
  validationErrors = [],
  disabled = false
}: FieldEditorProps) {
  const [localValue, setLocalValue] = useState(field.value || '');
  const [hasChanged, setHasChanged] = useState(false);
  const [changeReason, setChangeReason] = useState('');
  const [showReasonInput, setShowReasonInput] = useState(false);
  
  const debouncedValue = useDebounce(localValue, 2000);

  // Auto-save when value changes
  useEffect(() => {
    if (hasChanged && debouncedValue !== field.value) {
      onUpdate(debouncedValue, changeReason);
      setHasChanged(false);
      setChangeReason('');
      setShowReasonInput(false);
    }
  }, [debouncedValue, hasChanged, field.value, onUpdate, changeReason]);

  const handleValueChange = (newValue: any) => {
    setLocalValue(newValue);
    setHasChanged(true);
    
    // Show reason input for significant changes
    if (field.propagatesTo.includes('all_vendors') && newValue !== field.value) {
      setShowReasonInput(true);
    }
  };

  const renderFieldInput = () => {
    const { fieldType, validationSchema } = field.definition;
    const baseClasses = `w-full px-3 py-2 border rounded-md focus:ring-2 focus:ring-blue-500 ${
      disabled ? 'bg-gray-100 cursor-not-allowed' : 'bg-white'
    } ${validationErrors.length > 0 ? 'border-red-300' : 'border-gray-300'}`;

    switch (fieldType) {
      case 'email':
        return (
          <input
            type="email"
            value={localValue}
            onChange={(e) => handleValueChange(e.target.value)}
            className={baseClasses}
            disabled={disabled}
            placeholder={`Enter ${field.definition.fieldName.toLowerCase()}`}
          />
        );
      
      case 'phone':
        return (
          <input
            type="tel"
            value={localValue}
            onChange={(e) => handleValueChange(e.target.value)}
            className={baseClasses}
            disabled={disabled}
            placeholder="(555) 123-4567"
          />
        );
      
      case 'date':
        return (
          <input
            type="date"
            value={localValue}
            onChange={(e) => handleValueChange(e.target.value)}
            className={baseClasses}
            disabled={disabled}
            min={validationSchema.min === 'today+30' ? 
              new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0] : 
              validationSchema.min
            }
          />
        );
      
      case 'number':
        return (
          <input
            type="number"
            value={localValue}
            onChange={(e) => handleValueChange(parseInt(e.target.value) || 0)}
            className={baseClasses}
            disabled={disabled}
            min={validationSchema.min}
            max={validationSchema.max}
          />
        );
      
      case 'address':
        return (
          <textarea
            value={localValue}
            onChange={(e) => handleValueChange(e.target.value)}
            className={`${baseClasses} min-h-[80px]`}
            disabled={disabled}
            rows={3}
            placeholder="Enter full address"
          />
        );
      
      default:
        return (
          <input
            type="text"
            value={localValue}
            onChange={(e) => handleValueChange(e.target.value)}
            className={baseClasses}
            disabled={disabled}
            placeholder={`Enter ${field.definition.fieldName.toLowerCase()}`}
          />
        );
    }
  };

  return (
    <div className="space-y-2">
      {/* Field Header */}
      <div className="flex items-center justify-between">
        <label className="block text-sm font-medium text-gray-700">
          {field.definition.fieldName}
          {field.definition.isRequired && (
            <span className="text-red-500 ml-1">*</span>
          )}
        </label>
        
        <div className="flex items-center space-x-2">
          {/* Status Indicator */}
          <div className={`w-2 h-2 rounded-full ${
            field.status === 'completed' ? 'bg-green-500' :
            field.status === 'partial' ? 'bg-yellow-500' :
            field.status === 'pending' ? 'bg-gray-400' :
            'bg-gray-300'
          }`} />
          
          {/* Lock Indicator */}
          {field.isLocked && (
            <span className="text-xs text-gray-500" title={field.lockReason}>
              🔒
            </span>
          )}
          
          {/* Propagation Indicator */}
          {field.propagationStatus.pendingTargets.length > 0 && (
            <span className="text-xs text-orange-500" title="Syncing to vendors...">
              ⏳
            </span>
          )}
        </div>
      </div>

      {/* Field Description */}
      {field.definition.fieldDescription && (
        <p className="text-xs text-gray-500 mb-2">
          {field.definition.fieldDescription}
        </p>
      )}

      {/* Field Input */}
      {renderFieldInput()}

      {/* Change Reason (if needed) */}
      {showReasonInput && (
        <input
          type="text"
          value={changeReason}
          onChange={(e) => setChangeReason(e.target.value)}
          placeholder="Reason for change (optional)"
          className="w-full px-3 py-2 text-sm border border-gray-300 rounded-md"
        />
      )}

      {/* Validation Errors */}
      {validationErrors.map((error, index) => (
        <p key={index} className="text-xs text-red-600">
          {error.message}
        </p>
      ))}

      {/* Field Info */}
      <div className="flex items-center justify-between text-xs text-gray-500">
        <span>
          {field.lastUpdated && (
            <>Updated {new Date(field.lastUpdated).toLocaleDateString()}</>
          )}
        </span>
        
        {field.definition.propagatesTo.length > 0 && (
          <span title={`Syncs to: ${field.definition.propagatesTo.join(', ')}`}>
            📤 Syncs to {field.definition.propagatesTo.length} vendor{field.definition.propagatesTo.length !== 1 ? 's' : ''}
          </span>
        )}
      </div>

      {/* Auto-save Indicator */}
      {hasChanged && (
        <div className="flex items-center text-xs text-blue-600">
          <div className="animate-spin h-3 w-3 border border-blue-600 border-t-transparent rounded-full mr-2"></div>
          Auto-saving...
        </div>
      )}
    </div>
  );
}
```

#### State Management Required

**Core Fields Store**
```typescript
// src/lib/stores/coreFieldsStore.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface CoreFieldsState {
  fields: CoreField[];
  completionStats: any;
  syncStatus: Record<string, any>;
  isLoading: boolean;
  error: string | null;
  lastSyncJob: string | null;
  
  // Actions
  loadFields: (category?: string) => Promise<void>;
  updateField: (key: string, value: any, reason?: string, propagateImmediately?: boolean) => Promise<void>;
  bulkUpdateFields: (updates: Record<string, any>, reason?: string, propagateImmediately?: boolean) => Promise<void>;
  validateFields: (fields: Record<string, any>) => Promise<ValidationResult>;
  triggerSync: (fieldKeys?: string[], targetVendors?: string[]) => Promise<string>;
  getSyncStatus: (jobId: string) => Promise<SyncStatusResponse>;
  getFieldChanges: (page?: number) => Promise<FieldChangesResponse>;
  
  // Field locking
  lockField: (key: string, reason: string) => Promise<void>;
  unlockField: (key: string) => Promise<void>;
}

export const useCoreFieldsStore = create<CoreFieldsState>()(
  persist(
    (set, get) => ({
      fields: [],
      completionStats: null,
      syncStatus: {},
      isLoading: false,
      error: null,
      lastSyncJob: null,

      loadFields: async (category?: string) => {
        set({ isLoading: true, error: null });
        try {
          const params = category ? `?category=${category}` : '';
          const response = await fetch(`/api/core-fields${params}`);
          const data = await response.json();
          
          set({ 
            fields: data.fields, 
            completionStats: data.completionStats,
            isLoading: false 
          });
        } catch (error) {
          set({ error: error.message, isLoading: false });
        }
      },

      updateField: async (key: string, value: any, reason?: string, propagateImmediately = true) => {
        try {
          const response = await fetch(`/api/core-fields/${key}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              value,
              changeReason: reason,
              propagateImmediately
            })
          });

          if (!response.ok) {
            throw new Error('Failed to update field');
          }

          const result = await response.json();
          
          // Update local state
          set(state => ({
            fields: state.fields.map(field => 
              field.key === key ? result.field : field
            )
          }));

          // Track sync job if propagation was triggered
          if (result.propagationTriggered) {
            // Could track sync job ID here
          }

          return result;
        } catch (error) {
          set({ error: error.message });
          throw error;
        }
      },

      bulkUpdateFields: async (updates: Record<string, any>, reason?: string, propagateImmediately = true) => {
        try {
          const response = await fetch('/api/core-fields/bulk-update', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              updates,
              changeReason: reason,
              propagateImmediately
            })
          });

          if (!response.ok) {
            throw new Error('Failed to bulk update fields');
          }

          const result = await response.json();
          
          // Reload fields to get updated state
          get().loadFields();

          return result;
        } catch (error) {
          set({ error: error.message });
          throw error;
        }
      },

      validateFields: async (fields: Record<string, any>) => {
        const response = await fetch('/api/core-fields/validate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ fields })
        });

        return response.json();
      },

      triggerSync: async (fieldKeys?: string[], targetVendors?: string[]) => {
        try {
          const response = await fetch('/api/core-fields/sync', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ fieldKeys, targetVendors })
          });

          if (!response.ok) {
            throw new Error('Failed to trigger sync');
          }

          const result = await response.json();
          set({ lastSyncJob: result.syncJobId });
          
          return result.syncJobId;
        } catch (error) {
          set({ error: error.message });
          throw error;
        }
      },

      getSyncStatus: async (jobId: string) => {
        const response = await fetch(`/api/core-fields/sync/status/${jobId}`);
        return response.json();
      },

      getFieldChanges: async (page = 1) => {
        const response = await fetch(`/api/core-fields/changes?page=${page}`);
        return response.json();
      },

      lockField: async (key: string, reason: string) => {
        const response = await fetch(`/api/core-fields/${key}/lock`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ reason })
        });

        if (response.ok) {
          get().loadFields();
        }
      },

      unlockField: async (key: string) => {
        const response = await fetch(`/api/core-fields/${key}/unlock`, {
          method: 'POST'
        });

        if (response.ok) {
          get().loadFields();
        }
      }
    }),
    {
      name: 'core-fields-storage',
      partialize: (state) => ({ 
        fields: state.fields,
        completionStats: state.completionStats 
      }),
    }
  )
);
```

### TESTING REQUIREMENTS

#### Unit Tests
- Field validation logic for all field types
- Auto-save functionality with proper debouncing
- Field propagation service logic
- Bulk update operations
- Field locking/unlocking mechanisms

#### Integration Tests
- Database operations for field updates
- Field change history tracking
- Propagation to connected vendors
- Field sync job processing
- Validation across different field types

#### E2E Tests
- Complete field management workflow
- Auto-save and real-time updates
- Bulk field editing
- Field validation error handling
- Vendor sync status tracking

### DEPENDENCIES & EFFORT ESTIMATE

#### Dependencies
- Core Fields table (existing) - Needs extension
- Vendor Connection System - For field propagation
- Real-time Updates System - For live field sync
- Authentication System - For user tracking

#### Effort Estimate: 25 development days
- **Database Design & Migration**: 4 days
- **Field Validation System**: 4 days  
- **Core Fields Manager**: 6 days
- **Field Propagation Service**: 5 days
- **Auto-save & Sync Tracking**: 3 days
- **Bulk Operations**: 3 days

#### Risk Factors
- **High:** Field propagation complexity and reliability
- **Medium:** Auto-save performance with frequent updates
- **Medium:** Data consistency during bulk operations
- **Low:** Field validation edge cases

### SUCCESS CRITERIA
1. Couples can update any core field and see changes in <2 seconds
2. Field auto-save works reliably with 2-second debounce
3. Field validation prevents invalid data entry
4. Field changes propagate to connected vendors within 30 seconds
5. Bulk field editing supports updating 10+ fields at once
6. Field completion tracking shows accurate progress
7. Field change history maintains complete audit trail
8. Vendor sync status provides clear feedback on propagation success/failure