# TECHNICAL SPECIFICATION: WS-135 - Viral Optimization System
## Generated by Feature Development Session - 2025-01-23

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** WedSync growth team focused on achieving sustainable viral coefficient >1.0
**I want to:** Continuously optimize viral loops, identify super-connectors, and maximize network effects through data-driven improvements
**So that:** We achieve organic growth velocity that reduces customer acquisition cost by 80% and creates self-sustaining user acquisition

**Real Business Scenario:**
Our viral coefficient has plateaued at 0.85. Through the optimization system, we identify that venue coordinators have 3x higher invitation success rates than photographers, but only represent 15% of our user base. We optimize invitation flow targeting, implement venue-specific incentive structures, and create network density clustering around high-performing venues. Within 90 days, viral coefficient increases to 1.3, organic acquisition increases 250%, and customer acquisition cost drops from $180 to $35 per user.

### SPECIFICATION SOURCE
- **Feature ID:** WS-135
- **Original Spec:** /CORE-SPECIFICATIONS/13-BUSINESS-OPERATIONS/05-viral-optimization md.md
- **Current Implementation:** 0% complete
- **Files to Modify:** None (new feature)
- **New Files to Create:**
  - /src/lib/viral/optimization-engine.ts
  - /src/lib/viral/network-analyzer.ts
  - /src/lib/viral/super-connector-detector.ts
  - /src/lib/viral/viral-loop-optimizer.ts
  - /src/app/api/viral/optimize/route.ts
  - /src/app/api/viral/network-analysis/route.ts
  - /src/app/api/viral/super-connectors/route.ts
  - /src/components/viral/OptimizationDashboard.tsx
  - /src/components/viral/NetworkVisualization.tsx
  - /src/components/viral/ViralExperimentPanel.tsx

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Viral coefficient optimization tracking
CREATE TABLE IF NOT EXISTS viral_optimization_experiments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  experiment_name TEXT NOT NULL,
  experiment_type TEXT NOT NULL, -- 'invitation_flow', 'incentive_structure', 'timing_optimization', 'network_clustering'
  hypothesis TEXT NOT NULL,
  target_metric TEXT NOT NULL, -- 'viral_coefficient', 'invitation_acceptance_rate', 'time_to_invite'
  baseline_value DECIMAL(6,3) NOT NULL,
  target_improvement DECIMAL(6,3) NOT NULL, -- Expected improvement (e.g., 0.15 for +15%)
  control_group_size INTEGER NOT NULL,
  treatment_group_size INTEGER NOT NULL,
  control_group_users UUID[] DEFAULT '{}',
  treatment_group_users UUID[] DEFAULT '{}',
  experiment_config JSONB NOT NULL, -- Specific changes being tested
  start_date TIMESTAMP DEFAULT NOW(),
  end_date TIMESTAMP,
  status TEXT DEFAULT 'running' CHECK (status IN ('draft', 'running', 'completed', 'paused', 'failed')),
  results JSONB DEFAULT '{}', -- Statistical results and significance
  winner_variant TEXT,
  implementation_date TIMESTAMP,
  estimated_annual_impact DECIMAL(12,2), -- Projected revenue/cost impact
  created_at TIMESTAMP DEFAULT NOW()
);

-- Network effects and connection strength analysis
CREATE TABLE IF NOT EXISTS network_connections (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES user_profiles(id),
  couple_id UUID REFERENCES user_profiles(id),
  wedding_id UUID,
  connection_type TEXT NOT NULL, -- 'direct_invite', 'mutual_referral', 'venue_clustering', 'supplier_recommendation'
  connection_strength INTEGER DEFAULT 1 CHECK (connection_strength >= 1 AND connection_strength <= 10),
  connection_quality_score DECIMAL(3,2) DEFAULT 0.5, -- 0.0 to 1.0 based on engagement
  first_interaction_date TIMESTAMP DEFAULT NOW(),
  last_interaction_date TIMESTAMP DEFAULT NOW(),
  total_interactions INTEGER DEFAULT 1,
  referrals_generated INTEGER DEFAULT 0,
  conversion_success BOOLEAN DEFAULT false,
  network_cluster_id UUID,
  viral_amplification_factor DECIMAL(4,2) DEFAULT 1.0, -- How much this connection amplifies virality
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(supplier_id, couple_id, wedding_id)
);

-- Super-connector identification and management
CREATE TABLE IF NOT EXISTS super_connectors (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES user_profiles(id),
  user_type TEXT NOT NULL, -- 'supplier', 'couple', 'venue'
  connector_score DECIMAL(6,2) NOT NULL, -- Composite score based on multiple factors
  network_reach INTEGER DEFAULT 0, -- Total unique connections
  invitation_success_rate DECIMAL(3,2) DEFAULT 0, -- Success rate of their invitations
  viral_coefficient_contribution DECIMAL(4,3) DEFAULT 0, -- Their personal K-factor contribution
  referral_conversion_rate DECIMAL(3,2) DEFAULT 0, -- % of their referrals that convert
  network_influence_score DECIMAL(3,2) DEFAULT 0, -- How much they influence others to invite
  geographic_reach INTEGER DEFAULT 1, -- Number of distinct markets they influence
  vendor_type_diversity INTEGER DEFAULT 1, -- Number of different vendor types they connect
  special_program_eligible BOOLEAN DEFAULT false,
  last_calculated TIMESTAMP DEFAULT NOW(),
  tier_level TEXT GENERATED ALWAYS AS (
    CASE 
      WHEN connector_score >= 90 THEN 'diamond'
      WHEN connector_score >= 75 THEN 'platinum'
      WHEN connector_score >= 60 THEN 'gold'
      WHEN connector_score >= 40 THEN 'silver'
      ELSE 'bronze'
    END
  ) STORED,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(user_id)
);

-- Viral loop performance optimization
CREATE TABLE IF NOT EXISTS viral_loop_performance (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  loop_type TEXT NOT NULL, -- 'couple_supplier_loop', 'supplier_supplier_loop', 'venue_cluster_loop'
  loop_stage TEXT NOT NULL, -- 'initiation', 'propagation', 'conversion', 'amplification'
  metric_date DATE DEFAULT CURRENT_DATE,
  entry_count INTEGER DEFAULT 0, -- Users entering this loop stage
  conversion_count INTEGER DEFAULT 0, -- Users converting to next stage
  drop_off_count INTEGER DEFAULT 0, -- Users dropping out
  average_time_in_stage_hours DECIMAL(8,2) DEFAULT 0,
  conversion_rate DECIMAL(4,3) GENERATED ALWAYS AS (
    CASE WHEN entry_count > 0 THEN conversion_count::decimal / entry_count ELSE 0 END
  ) STORED,
  optimization_opportunities JSONB DEFAULT '[]', -- Identified improvement areas
  a_b_test_results JSONB DEFAULT '{}',
  performance_trend TEXT, -- 'improving', 'stable', 'declining'
  created_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(loop_type, loop_stage, metric_date)
);

-- Network clustering and geographic analysis
CREATE TABLE IF NOT EXISTS network_clusters (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  cluster_name TEXT,
  cluster_type TEXT NOT NULL, -- 'geographic', 'venue_based', 'vendor_type', 'event_size'
  geographic_center JSONB, -- {"lat": 40.7128, "lng": -74.0060, "radius_km": 50}
  anchor_venue_id UUID,
  primary_vendor_type TEXT,
  member_count INTEGER DEFAULT 0,
  active_member_count INTEGER DEFAULT 0, -- Members active in last 30 days
  cluster_density DECIMAL(3,2) DEFAULT 0, -- How interconnected cluster members are
  viral_coefficient DECIMAL(4,3) DEFAULT 0, -- K-factor within this cluster
  average_invitation_success_rate DECIMAL(3,2) DEFAULT 0,
  dominant_wedding_style TEXT, -- 'traditional', 'modern', 'rustic', 'luxury'
  average_budget_range TEXT,
  growth_rate DECIMAL(4,2) DEFAULT 0, -- Monthly growth rate
  health_score INTEGER DEFAULT 50, -- Overall cluster performance (0-100)
  optimization_priority INTEGER DEFAULT 3, -- 1-5 scale
  last_analyzed TIMESTAMP DEFAULT NOW(),
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Invitation flow optimization experiments
CREATE TABLE IF NOT EXISTS invitation_flow_experiments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  flow_name TEXT NOT NULL,
  flow_version TEXT NOT NULL, -- 'v1.0', 'v1.1', 'experimental_a'
  flow_configuration JSONB NOT NULL, -- Complete flow definition
  target_segments JSONB NOT NULL, -- User segments this flow targets
  optimization_focus TEXT[], -- ['acceptance_rate', 'time_to_accept', 'secondary_invitations']
  baseline_metrics JSONB NOT NULL,
  current_metrics JSONB DEFAULT '{}',
  a_b_test_allocation DECIMAL(3,2) DEFAULT 0.5, -- % of traffic getting this flow
  performance_score DECIMAL(5,2) DEFAULT 0,
  statistical_significance DECIMAL(3,2),
  recommendation TEXT, -- 'implement', 'iterate', 'abandon'
  implementation_effort TEXT, -- 'low', 'medium', 'high'
  estimated_impact JSONB DEFAULT '{}', -- Projected improvements
  is_active BOOLEAN DEFAULT false,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Viral amplification tracking
CREATE TABLE IF NOT EXISTS viral_amplification (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  original_user_id UUID REFERENCES user_profiles(id), -- Who started the viral chain
  amplification_level INTEGER DEFAULT 1, -- How many degrees of separation
  current_user_id UUID REFERENCES user_profiles(id), -- Current person in the chain
  viral_chain_id UUID, -- Groups related viral actions
  amplification_factor DECIMAL(4,2) DEFAULT 1.0, -- How much this amplifies the original
  decay_factor DECIMAL(3,2) DEFAULT 1.0, -- How much viral power decays at this level
  conversion_probability DECIMAL(3,2) DEFAULT 0, -- Likelihood of conversion
  time_to_propagate_hours DECIMAL(6,2), -- Time from previous level
  geographic_spread_km DECIMAL(8,2) DEFAULT 0, -- Geographic distance from origin
  vendor_type_diversity INTEGER DEFAULT 0, -- Types of vendors reached
  total_potential_reach INTEGER DEFAULT 0, -- Maximum possible further propagation
  actual_conversions INTEGER DEFAULT 0, -- Actual people who converted
  chain_termination_reason TEXT, -- Why the viral chain ended
  created_at TIMESTAMP DEFAULT NOW()
);

-- Optimization recommendation engine
CREATE TABLE IF NOT EXISTS viral_optimization_recommendations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  recommendation_type TEXT NOT NULL, -- 'invitation_timing', 'incentive_structure', 'network_targeting', 'content_optimization'
  priority_level INTEGER NOT NULL CHECK (priority_level >= 1 AND priority_level <= 5),
  target_metric TEXT NOT NULL,
  current_performance DECIMAL(6,3) NOT NULL,
  projected_improvement DECIMAL(6,3) NOT NULL,
  confidence_score DECIMAL(3,2) NOT NULL, -- AI confidence in this recommendation
  recommendation_title TEXT NOT NULL,
  recommendation_description TEXT NOT NULL,
  implementation_steps JSONB NOT NULL, -- Actionable steps to implement
  estimated_effort_hours INTEGER,
  estimated_cost DECIMAL(10,2),
  projected_annual_impact DECIMAL(12,2),
  data_sources TEXT[], -- What data informed this recommendation
  supporting_analysis JSONB DEFAULT '{}',
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'in_progress', 'implemented', 'rejected')),
  implementation_date TIMESTAMP,
  actual_results JSONB DEFAULT '{}',
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);
```

#### API Endpoints Required
```typescript
// GET /api/viral/optimization/recommendations
interface OptimizationRecommendationsResponse {
  success: boolean;
  recommendations: {
    id: string;
    type: 'invitation_timing' | 'incentive_structure' | 'network_targeting' | 'content_optimization';
    priority: number;
    title: string;
    description: string;
    currentPerformance: number;
    projectedImprovement: number;
    confidence: number;
    estimatedEffort: string;
    projectedImpact: number;
    implementationSteps: string[];
  }[];
  overallHealthScore: number;
  criticalIssues: CriticalIssue[];
}

// POST /api/viral/network-analysis/run
interface NetworkAnalysisRequest {
  analysisType: 'full_network' | 'cluster_analysis' | 'super_connector_detection' | 'viral_path_analysis';
  timeframe: 'last_30_days' | 'last_90_days' | 'last_year';
  filters?: {
    geographic?: string;
    vendorTypes?: string[];
    minConnections?: number;
  };
}

interface NetworkAnalysisResponse {
  success: boolean;
  analysis: {
    networkDensity: number;
    clusterCount: number;
    averageClusterSize: number;
    superConnectors: SuperConnector[];
    viralPaths: ViralPath[];
    optimizationOpportunities: OptimizationOpportunity[];
  };
  insights: NetworkInsight[];
}

// POST /api/viral/experiments/create
interface CreateViralExperimentRequest {
  experimentName: string;
  experimentType: 'invitation_flow' | 'incentive_structure' | 'timing_optimization';
  hypothesis: string;
  targetMetric: string;
  baselineValue: number;
  targetImprovement: number;
  experimentConfig: any;
  duration: number; // days
  trafficAllocation: number; // 0.0 to 1.0
}

// GET /api/viral/super-connectors
interface SuperConnectorsResponse {
  success: boolean;
  connectors: {
    userId: string;
    userType: 'supplier' | 'couple' | 'venue';
    connectorScore: number;
    tierLevel: 'diamond' | 'platinum' | 'gold' | 'silver' | 'bronze';
    networkReach: number;
    invitationSuccessRate: number;
    viralContribution: number;
    specialPrograms: string[];
    optimizationRecommendations: string[];
  }[];
  programEligible: number;
  totalNetworkReach: number;
}
```

#### Frontend Components Required
```typescript
// Component: OptimizationDashboard
// Location: /src/components/viral/OptimizationDashboard.tsx

interface OptimizationDashboardProps {
  timeframe: '7d' | '30d' | '90d' | '1y';
  onExperimentCreate: (experiment: ExperimentConfig) => void;
  onRecommendationImplement: (recommendationId: string) => void;
}

interface ViralHealthMetrics {
  currentViralCoefficient: number;
  targetViralCoefficient: number;
  trend: 'up' | 'down' | 'stable';
  healthScore: number;
  criticalIssues: number;
  activeExperiments: number;
  implementedOptimizations: number;
  projectedAnnualImpact: number;
}

interface NetworkCluster {
  id: string;
  name: string;
  type: 'geographic' | 'venue_based' | 'vendor_type';
  memberCount: number;
  viralCoefficient: number;
  healthScore: number;
  optimizationPriority: number;
  growthRate: number;
  averageBudget: string;
  dominantStyle: string;
}

interface SuperConnector {
  userId: string;
  name: string;
  businessName: string;
  vendorType: string;
  connectorScore: number;
  tierLevel: string;
  networkReach: number;
  invitationSuccessRate: number;
  specialPrograms: string[];
  potentialImpact: number;
}

// Key functionality:
- Real-time viral coefficient monitoring with optimization targets
- Network visualization with cluster analysis
- Super-connector identification and special program management
- A/B testing framework for viral loop optimization
- Automated recommendation engine with ROI projections
- Geographic viral spread analysis and targeting
```

#### Integration Points
```typescript
// Service: ViralOptimizationEngine
// Dependencies: Network analysis, machine learning, A/B testing, viral tracking

class ViralOptimizationEngine {
  async analyzeNetworkEffects(): Promise<NetworkAnalysis> {
    // Graph theory analysis of user connections
    // Cluster detection and density calculation
    // Viral path mapping and amplification tracking
    // Geographic spread and market penetration analysis
  }
  
  async identifySuperConnectors(): Promise<SuperConnector[]> {
    // Multi-factor scoring algorithm
    // Network reach and influence calculation
    // Invitation success rate and conversion tracking
    // Special program eligibility assessment
  }
  
  async optimizeViralLoops(): Promise<OptimizationRecommendations> {
    // Loop performance analysis and bottleneck identification
    // A/B testing recommendations for improvement
    // Timing and incentive optimization strategies
    // Personalization opportunities by user segment
  }
}
```

### CODE EXAMPLES

#### Example 1: Comprehensive Viral Optimization Engine with Network Analysis
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { subDays, format, differenceInHours } from 'date-fns';

interface NetworkNode {
  id: string;
  type: 'supplier' | 'couple';
  connections: string[];
  invitationsSent: number;
  invitationsAccepted: number;
  viralCoefficient: number;
  clusterMembership?: string;
}

interface ViralPath {
  originUserId: string;
  pathLength: number;
  totalConversions: number;
  amplificationFactor: number;
  geographicSpread: number;
  timeToComplete: number;
}

export class ViralOptimizationEngine {
  private supabase = createClient();

  async generateOptimizationRecommendations(): Promise<OptimizationRecommendations> {
    try {
      // Analyze current viral performance
      const currentMetrics = await this.analyzeCurrentViralPerformance();
      
      // Identify bottlenecks and opportunities
      const bottlenecks = await this.identifyViralBottlenecks();
      
      // Analyze network structure for optimization opportunities
      const networkInsights = await this.analyzeNetworkStructure();
      
      // Generate ML-powered recommendations
      const recommendations = await this.generateMLRecommendations(
        currentMetrics,
        bottlenecks,
        networkInsights
      );

      // Prioritize recommendations by impact and effort
      const prioritizedRecommendations = this.prioritizeRecommendations(recommendations);

      // Save recommendations for tracking
      await this.saveRecommendations(prioritizedRecommendations);

      return {
        success: true,
        overallHealthScore: this.calculateViralHealthScore(currentMetrics),
        currentViralCoefficient: currentMetrics.viralCoefficient,
        recommendations: prioritizedRecommendations,
        criticalIssues: bottlenecks.filter(b => b.severity === 'critical'),
        projectedImpact: this.calculateTotalProjectedImpact(prioritizedRecommendations)
      };

    } catch (error) {
      console.error('Optimization recommendations failed:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Optimization analysis failed'
      };
    }
  }

  private async analyzeCurrentViralPerformance(): Promise<ViralPerformanceMetrics> {
    const thirtyDaysAgo = subDays(new Date(), 30);
    
    // Get viral actions from last 30 days
    const { data: viralActions } = await this.supabase
      .from('viral_actions')
      .select('*')
      .gte('created_at', thirtyDaysAgo.toISOString());

    // Get new user signups
    const { data: newUsers } = await this.supabase
      .from('user_profiles')
      .select('*')
      .gte('created_at', thirtyDaysAgo.toISOString());

    // Calculate viral coefficient components
    const invitationsSent = viralActions?.filter(a => a.action_type === 'sent_invite').length || 0;
    const invitationsAccepted = viralActions?.filter(a => a.action_type === 'accepted_invite').length || 0;
    const newUserCount = newUsers?.length || 0;
    
    const invitationsPerUser = newUserCount > 0 ? invitationsSent / newUserCount : 0;
    const acceptanceRate = invitationsSent > 0 ? invitationsAccepted / invitationsSent : 0;
    const viralCoefficient = invitationsPerUser * acceptanceRate;

    // Analyze conversion funnel
    const conversionFunnel = await this.analyzeConversionFunnel(viralActions || []);
    
    // Calculate cycle time (time from signup to first invitation)
    const avgCycleTime = await this.calculateAverageCycleTime(newUsers || []);

    return {
      viralCoefficient,
      invitationsPerUser,
      acceptanceRate,
      avgCycleTime,
      conversionFunnel,
      totalViralActions: viralActions?.length || 0,
      newUserCount
    };
  }

  private async identifyViralBottlenecks(): Promise<ViralBottleneck[]> {
    const bottlenecks: ViralBottleneck[] = [];
    
    // Analyze invitation flow performance
    const invitationBottlenecks = await this.analyzeInvitationBottlenecks();
    bottlenecks.push(...invitationBottlenecks);
    
    // Analyze user activation bottlenecks
    const activationBottlenecks = await this.analyzeActivationBottlenecks();
    bottlenecks.push(...activationBottlenecks);
    
    // Analyze network density issues
    const networkBottlenecks = await this.analyzeNetworkBottlenecks();
    bottlenecks.push(...networkBottlenecks);

    return bottlenecks.sort((a, b) => b.impact - a.impact);
  }

  private async analyzeInvitationBottlenecks(): Promise<ViralBottleneck[]> {
    const bottlenecks: ViralBottleneck[] = [];
    
    // Get invitation performance by type
    const { data: invitationPerformance } = await this.supabase
      .from('viral_actions')
      .select('invitation_type, status, created_at')
      .eq('action_type', 'sent_invite')
      .gte('created_at', subDays(new Date(), 30).toISOString());

    if (!invitationPerformance) return bottlenecks;

    // Group by invitation type
    const performanceByType = invitationPerformance.reduce((acc, invitation) => {
      const type = invitation.invitation_type;
      if (!acc[type]) {
        acc[type] = { sent: 0, opened: 0, clicked: 0, accepted: 0 };
      }
      
      acc[type].sent++;
      if (invitation.status === 'opened') acc[type].opened++;
      if (invitation.status === 'clicked') acc[type].clicked++;
      if (invitation.status === 'accepted') acc[type].accepted++;
      
      return acc;
    }, {} as any);

    // Identify low-performing invitation types
    Object.entries(performanceByType).forEach(([type, performance]: [string, any]) => {
      const acceptanceRate = performance.sent > 0 ? performance.accepted / performance.sent : 0;
      
      if (acceptanceRate < 0.15) { // Less than 15% acceptance rate
        bottlenecks.push({
          type: 'low_invitation_acceptance',
          severity: acceptanceRate < 0.05 ? 'critical' : 'high',
          description: `${type} invitations have ${(acceptanceRate * 100).toFixed(1)}% acceptance rate`,
          impact: performance.sent * (0.25 - acceptanceRate), // Potential additional conversions
          recommendation: `Optimize ${type} invitation templates and timing`,
          metrics: performance
        });
      }
    });

    return bottlenecks;
  }

  async identifySuperConnectors(): Promise<SuperConnector[]> {
    try {
      // Get users with their viral performance data
      const { data: users } = await this.supabase
        .from('user_profiles')
        .select(`
          id,
          first_name,
          business_name,
          vendor_type,
          created_at,
          last_login
        `);

      if (!users) return [];

      const superConnectors: SuperConnector[] = [];

      for (const user of users) {
        const connectorScore = await this.calculateConnectorScore(user.id);
        
        if (connectorScore.totalScore >= 40) { // Minimum threshold for super-connector
          const networkAnalysis = await this.analyzeUserNetwork(user.id);
          
          superConnectors.push({
            userId: user.id,
            userType: await this.getUserType(user.id),
            name: `${user.first_name} - ${user.business_name}`,
            vendorType: user.vendor_type,
            connectorScore: connectorScore.totalScore,
            tierLevel: this.determineTierLevel(connectorScore.totalScore),
            networkReach: networkAnalysis.totalConnections,
            invitationSuccessRate: connectorScore.invitationSuccessRate,
            viralCoefficient: connectorScore.personalViralCoefficient,
            referralConversionRate: connectorScore.referralConversionRate,
            geographicReach: networkAnalysis.geographicReach,
            vendorTypeDiversity: networkAnalysis.vendorTypeDiversity,
            specialProgramEligible: connectorScore.totalScore >= 75,
            lastActivity: user.last_login,
            potentialImpact: this.calculatePotentialImpact(connectorScore, networkAnalysis)
          });
        }
      }

      // Sort by connector score descending
      const sortedConnectors = superConnectors.sort((a, b) => b.connectorScore - a.connectorScore);

      // Save super-connector data
      await this.saveSuperConnectors(sortedConnectors);

      return sortedConnectors;

    } catch (error) {
      console.error('Super-connector identification failed:', error);
      return [];
    }
  }

  private async calculateConnectorScore(userId: string): Promise<ConnectorScoreBreakdown> {
    // Get user's viral actions
    const { data: viralActions } = await this.supabase
      .from('viral_actions')
      .select('*')
      .eq('actor_id', userId);

    const invitationsSent = viralActions?.filter(a => a.action_type === 'sent_invite').length || 0;
    const invitationsAccepted = viralActions?.filter(a => a.action_type === 'accepted_invite').length || 0;
    
    // Calculate invitation success rate (0-30 points)
    const invitationSuccessRate = invitationsSent > 0 ? invitationsAccepted / invitationsSent : 0;
    const invitationScore = Math.min(30, invitationSuccessRate * 100);

    // Calculate network reach (0-25 points)
    const { data: connections } = await this.supabase
      .from('network_connections')
      .select('*')
      .or(`supplier_id.eq.${userId},couple_id.eq.${userId}`);
    
    const networkReach = connections?.length || 0;
    const reachScore = Math.min(25, networkReach * 2); // 2 points per connection, max 25

    // Calculate referral conversion rate (0-20 points)
    const referralConversions = await this.countReferralConversions(userId);
    const referralConversionRate = invitationsSent > 0 ? referralConversions / invitationsSent : 0;
    const conversionScore = Math.min(20, referralConversionRate * 100);

    // Calculate viral coefficient contribution (0-15 points)
    const personalViralCoefficient = await this.calculatePersonalViralCoefficient(userId);
    const viralScore = Math.min(15, personalViralCoefficient * 10);

    // Calculate influence score (0-10 points)
    const influenceScore = await this.calculateInfluenceScore(userId);

    const totalScore = invitationScore + reachScore + conversionScore + viralScore + influenceScore;

    return {
      totalScore,
      invitationSuccessRate,
      networkReach,
      referralConversionRate,
      personalViralCoefficient,
      influenceScore,
      breakdown: {
        invitation: invitationScore,
        reach: reachScore,
        conversion: conversionScore,
        viral: viralScore,
        influence: influenceScore
      }
    };
  }

  async optimizeViralLoops(): Promise<ViralLoopOptimizations> {
    try {
      // Analyze each viral loop type
      const loopTypes = ['couple_supplier_loop', 'supplier_supplier_loop', 'venue_cluster_loop'];
      const optimizations: LoopOptimization[] = [];

      for (const loopType of loopTypes) {
        const loopAnalysis = await this.analyzeViralLoop(loopType);
        const bottlenecks = this.identifyLoopBottlenecks(loopAnalysis);
        const recommendations = this.generateLoopOptimizations(loopType, bottlenecks);
        
        optimizations.push({
          loopType,
          currentPerformance: loopAnalysis.overallConversionRate,
          bottlenecks,
          recommendations,
          projectedImprovement: this.calculateProjectedImprovement(recommendations)
        });
      }

      // Create A/B testing experiments for top optimizations
      const experiments = await this.createOptimizationExperiments(optimizations);

      return {
        success: true,
        optimizations,
        experiments,
        overallViralCoefficient: await this.getCurrentViralCoefficient(),
        targetViralCoefficient: 1.2,
        estimatedTimeToTarget: this.estimateTimeToTarget(optimizations)
      };

    } catch (error) {
      console.error('Viral loop optimization failed:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Loop optimization failed'
      };
    }
  }

  private async analyzeViralLoop(loopType: string): Promise<ViralLoopAnalysis> {
    const thirtyDaysAgo = subDays(new Date(), 30);
    
    // Get loop performance data
    const { data: loopData } = await this.supabase
      .from('viral_loop_performance')
      .select('*')
      .eq('loop_type', loopType)
      .gte('metric_date', format(thirtyDaysAgo, 'yyyy-MM-dd'));

    if (!loopData || loopData.length === 0) {
      return {
        loopType,
        stages: [],
        overallConversionRate: 0,
        averageTimeToComplete: 0,
        dropOffPoints: [],
        trend: 'stable'
      };
    }

    // Analyze by stage
    const stageAnalysis = loopData.reduce((acc, record) => {
      const stage = record.loop_stage;
      if (!acc[stage]) {
        acc[stage] = {
          totalEntries: 0,
          totalConversions: 0,
          totalDropOffs: 0,
          avgTime: 0,
          trend: 'stable'
        };
      }

      acc[stage].totalEntries += record.entry_count;
      acc[stage].totalConversions += record.conversion_count;
      acc[stage].totalDropOffs += record.drop_off_count;
      acc[stage].avgTime += record.average_time_in_stage_hours;

      return acc;
    }, {} as any);

    // Calculate overall metrics
    const totalEntries = Object.values(stageAnalysis).reduce((sum: number, stage: any) => sum + stage.totalEntries, 0);
    const totalConversions = Object.values(stageAnalysis).reduce((sum: number, stage: any) => sum + stage.totalConversions, 0);
    const overallConversionRate = totalEntries > 0 ? totalConversions / totalEntries : 0;

    // Identify drop-off points
    const dropOffPoints = Object.entries(stageAnalysis)
      .map(([stage, data]: [string, any]) => ({
        stage,
        dropOffRate: data.totalEntries > 0 ? data.totalDropOffs / data.totalEntries : 0,
        volume: data.totalDropOffs
      }))
      .filter(point => point.dropOffRate > 0.3) // High drop-off stages
      .sort((a, b) => b.dropOffRate - a.dropOffRate);

    return {
      loopType,
      stages: Object.entries(stageAnalysis).map(([stage, data]: [string, any]) => ({
        stage,
        conversionRate: data.totalEntries > 0 ? data.totalConversions / data.totalEntries : 0,
        averageTime: data.avgTime / loopData.length,
        volume: data.totalEntries
      })),
      overallConversionRate,
      averageTimeToComplete: Object.values(stageAnalysis).reduce((sum: number, stage: any) => sum + stage.avgTime, 0),
      dropOffPoints,
      trend: this.calculateLoopTrend(loopData)
    };
  }

  private generateMLRecommendations(
    metrics: ViralPerformanceMetrics,
    bottlenecks: ViralBottleneck[],
    networkInsights: NetworkInsights
  ): OptimizationRecommendation[] {
    const recommendations: OptimizationRecommendation[] = [];

    // Invitation timing optimization
    if (metrics.avgCycleTime > 7) {
      recommendations.push({
        type: 'invitation_timing',
        priority: 4,
        title: 'Optimize invitation timing to reduce cycle time',
        description: `Users take ${metrics.avgCycleTime.toFixed(1)} days on average to send their first invitation. Implement smart timing prompts.`,
        currentPerformance: metrics.avgCycleTime,
        projectedImprovement: -3.5, // Reduce by 3.5 days
        confidence: 0.82,
        estimatedEffort: 'medium',
        projectedAnnualImpact: 125000,
        implementationSteps: [
          'Implement ML model to predict optimal invitation timing',
          'Add smart notification system based on user behavior',
          'Create urgency-based prompts for high-potential inviters',
          'A/B test different timing strategies'
        ]
      });
    }

    // Network clustering optimization
    if (networkInsights.clusterDensity < 0.3) {
      recommendations.push({
        type: 'network_targeting',
        priority: 5,
        title: 'Improve network clustering and density',
        description: `Network clusters have low density (${(networkInsights.clusterDensity * 100).toFixed(1)}%). Focus on venue-based clustering.`,
        currentPerformance: networkInsights.clusterDensity,
        projectedImprovement: 0.25,
        confidence: 0.75,
        estimatedEffort: 'high',
        projectedAnnualImpact: 350000,
        implementationSteps: [
          'Implement venue-based invitation targeting',
          'Create geographic cluster identification system',
          'Develop supplier cross-referral incentives',
          'Build network density optimization algorithms'
        ]
      });
    }

    // Super-connector activation
    if (networkInsights.superConnectorUtilization < 0.4) {
      recommendations.push({
        type: 'super_connector_activation',
        priority: 3,
        title: 'Activate underutilized super-connectors',
        description: `Only ${(networkInsights.superConnectorUtilization * 100).toFixed(1)}% of identified super-connectors are actively referring. Implement activation campaign.`,
        currentPerformance: networkInsights.superConnectorUtilization,
        projectedImprovement: 0.35,
        confidence: 0.88,
        estimatedEffort: 'low',
        projectedAnnualImpact: 200000,
        implementationSteps: [
          'Create super-connector identification dashboard',
          'Implement special incentive programs',
          'Develop personalized outreach campaigns',
          'Add gamification elements for top referrers'
        ]
      });
    }

    return recommendations.sort((a, b) => b.priority - a.priority);
  }
}

// Background job for continuous optimization
export async function runViralOptimizationAnalysis() {
  const optimizationEngine = new ViralOptimizationEngine();
  
  try {
    // Run full optimization analysis
    const recommendations = await optimizationEngine.generateOptimizationRecommendations();
    
    // Identify super-connectors
    const superConnectors = await optimizationEngine.identifySuperConnectors();
    
    // Analyze network structure
    const networkAnalysis = await optimizationEngine.analyzeNetworkStructure();
    
    // Optimize viral loops
    const loopOptimizations = await optimizationEngine.optimizeViralLoops();
    
    console.log('Viral optimization analysis completed successfully');
    console.log(`Generated ${recommendations.recommendations?.length || 0} recommendations`);
    console.log(`Identified ${superConnectors.length} super-connectors`);
    console.log(`Current viral coefficient: ${loopOptimizations.overallViralCoefficient}`);
    
  } catch (error) {
    console.error('Viral optimization analysis failed:', error);
  }
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [ ] Context7: Load network analysis and viral optimization algorithms
- [ ] Playwright: Test optimization interfaces, A/B testing flows, and network visualizations
- [ ] PostgreSQL: Manage viral optimization data, network analysis, and experiment tracking

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/network-analysis/graph-theory", "viral network optimization", 3500);
await mcp__context7__get-library-docs("/machine-learning/optimization", "viral coefficient optimization", 3000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('ViralOptimizationEngine', () => {
  it('should identify viral bottlenecks accurately', async () => {
    const mockMetrics = {
      viralCoefficient: 0.65,
      invitationsPerUser: 1.8,
      acceptanceRate: 0.36,
      avgCycleTime: 9.2
    };
    
    const bottlenecks = await optimizationEngine.identifyViralBottlenecks();
    
    expect(bottlenecks).toHaveLength.greaterThan(0);
    expect(bottlenecks[0].type).toBe('low_invitation_frequency');
    expect(bottlenecks.some(b => b.severity === 'critical')).toBe(true);
  });

  it('should calculate accurate super-connector scores', async () => {
    const userId = 'super-connector-user';
    const mockConnectorData = {
      invitationsSent: 25,
      invitationsAccepted: 18,
      networkConnections: 35,
      referralConversions: 12
    };
    
    const score = await optimizationEngine.calculateConnectorScore(userId);
    
    expect(score.totalScore).toBeGreaterThan(75); // Should qualify as super-connector
    expect(score.invitationSuccessRate).toBeCloseTo(0.72);
    expect(score.networkReach).toBe(35);
  });

  it('should generate actionable optimization recommendations', async () => {
    const recommendations = await optimizationEngine.generateOptimizationRecommendations();
    
    expect(recommendations.success).toBe(true);
    expect(recommendations.recommendations).toHaveLength.greaterThan(0);
    expect(recommendations.recommendations[0]).toHaveProperty('implementationSteps');
    expect(recommendations.recommendations[0]).toHaveProperty('projectedImpact');
    expect(recommendations.overallHealthScore).toBeGreaterThan(0);
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Viral optimization dashboard and experiment creation', async () => {
  await mcp__playwright__browser_navigate({url: '/admin/viral/optimization'});
  
  // View viral health overview
  await mcp__playwright__browser_wait_for({text: 'Viral Health Score'});
  await mcp__playwright__browser_wait_for({text: 'Current K-Factor'});
  
  // Check optimization recommendations
  await mcp__playwright__browser_click({
    element: 'Recommendations Tab',
    ref: 'button[data-tab="recommendations"]'
  });
  
  await mcp__playwright__browser_wait_for({text: 'Priority Recommendations'});
  
  // Create A/B test experiment
  await mcp__playwright__browser_click({
    element: 'Create Experiment Button',
    ref: 'button.create-experiment'
  });
  
  await mcp__playwright__browser_type({
    element: 'Experiment Name',
    ref: 'input[name="experimentName"]',
    text: 'Invitation Timing Optimization'
  });
  
  await mcp__playwright__browser_select_option({
    element: 'Experiment Type',
    ref: 'select[name="experimentType"]',
    values: ['timing_optimization']
  });
  
  await mcp__playwright__browser_type({
    element: 'Hypothesis',
    ref: 'textarea[name="hypothesis"]',
    text: 'Sending invitations 48 hours after user signup will increase acceptance rate by 25%'
  });
  
  await mcp__playwright__browser_click({
    element: 'Create Experiment',
    ref: 'button[type="submit"]'
  });
  
  // Verify experiment creation
  await mcp__playwright__browser_wait_for({text: 'Experiment Created Successfully'});
  
  await mcp__playwright__browser_snapshot();
});

test('Super-connector identification and activation', async () => {
  await mcp__playwright__browser_navigate({url: '/admin/viral/super-connectors'});
  
  // View super-connector dashboard
  await mcp__playwright__browser_wait_for({text: 'Super-Connector Network'});
  
  // Filter by tier level
  await mcp__playwright__browser_select_option({
    element: 'Tier Filter',
    ref: 'select[name="tierFilter"]',
    values: ['diamond']
  });
  
  // View diamond tier super-connectors
  await mcp__playwright__browser_wait_for({text: 'Diamond Tier'});
  
  // Activate special program for top connector
  await mcp__playwright__browser_click({
    element: 'Top Connector Actions',
    ref: 'tr[data-tier="diamond"]:first-child button.actions'
  });
  
  await mcp__playwright__browser_click({
    element: 'Activate Special Program',
    ref: 'button[data-action="activate_program"]'
  });
  
  // Select program type
  await mcp__playwright__browser_select_option({
    element: 'Program Type',
    ref: 'select[name="programType"]',
    values: ['ambassador_program']
  });
  
  await mcp__playwright__browser_type({
    element: 'Special Incentive',
    ref: 'input[name="specialIncentive"]',
    text: '50% commission increase'
  });
  
  await mcp__playwright__browser_click({
    element: 'Activate Program',
    ref: 'button[type="submit"]'
  });
  
  // Verify activation
  await mcp__playwright__browser_wait_for({text: 'Special Program Activated'});
  
  await mcp__playwright__browser_snapshot();
});
```

### ACCEPTANCE CRITERIA
- [ ] Achieve viral coefficient >1.0 through systematic optimization
- [ ] Identify and activate 100+ super-connectors with 90%+ accuracy
- [ ] Reduce viral cycle time by 40% through timing optimization
- [ ] Increase invitation acceptance rate by 35% through personalization
- [ ] Generate 20+ actionable optimization recommendations monthly
- [ ] Support A/B testing for 15+ viral loop optimization experiments
- [ ] Analyze network clusters with 95%+ geographic accuracy
- [ ] Provide real-time viral health monitoring dashboard
- [ ] Process network analysis for 10,000+ user connections
- [ ] Predict viral performance with 80%+ confidence

### DEPENDENCIES
- Must complete after: WS-134 (Marketing Automation) - Requires viral tracking infrastructure
- Must complete before: None - Final feature in the series
- Shares code with: Viral tracking, network analysis, A/B testing, user analytics

### ESTIMATED EFFORT
- Team A Frontend: 32 hours (Optimization dashboard, network visualization, experiment management)
- Team B Backend: 48 hours (Network analysis, ML optimization, super-connector detection)
- Team C Integration: 28 hours (A/B testing framework, analytics integration, performance monitoring)
- Total: 108 hours