# TECHNICAL SPECIFICATION: WS-212 - Section Configuration System
## Generated by Feature Development Session - 2025-01-25

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding photographer or planner
**I want to:** Configure individual dashboard sections for each client with custom content, styling, and behavior options
**So that:** I can create personalized client dashboards that show only relevant information based on wedding timeline, package tier, and client preferences

**Real Wedding Scenario:**
A photographer managing 25 active clients spends 30 minutes per client customizing their dashboard, switching sections on/off based on wedding timeline (e.g., showing final touches checklist only in last month, hiding completed tasks after wedding). With configurable sections, they create template configurations once and apply automatically based on client status and timeline - saving 10+ hours per week on dashboard management and ensuring clients see exactly what they need when they need it.

### SPECIFICATION SOURCE
- **Feature ID:** WS-212
- **Original Spec:** /CORE-SPECIFICATIONS/02-WEDSYNC-SUPPLIER-PLATFORM/07-Client-Dashboard-Builder/02-section-configuration md.md
- **Current Implementation:** 0% complete
- **Files to Modify:** None - new feature
- **New Files to Create:** 
  - /src/app/(dashboard)/dashboard-templates/[id]/sections/page.tsx
  - /src/components/dashboard/SectionConfigurationPanel.tsx
  - /src/components/dashboard/SectionPreview.tsx
  - /src/components/dashboard/VisibilityRulesEditor.tsx
  - /src/components/dashboard/ContentConfigurationEditor.tsx
  - /src/lib/stores/sectionConfigStore.ts
  - /src/app/api/dashboard/sections/route.ts
  - /src/app/api/dashboard/sections/[id]/route.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Dashboard section configurations
CREATE TABLE IF NOT EXISTS dashboard_section_configs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  template_id UUID REFERENCES dashboard_templates(id) ON DELETE CASCADE,
  section_type TEXT NOT NULL CHECK (section_type IN ('forms', 'documents', 'faq', 'timeline', 'photos', 'communications', 'budget', 'tasks')),
  section_title TEXT NOT NULL,
  section_description TEXT,
  display_order INTEGER DEFAULT 0,
  content_config JSONB DEFAULT '{}',
  style_config JSONB DEFAULT '{}',
  visibility_rules JSONB DEFAULT '{}',
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Section visibility conditions
CREATE TABLE IF NOT EXISTS section_visibility_conditions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  section_config_id UUID REFERENCES dashboard_section_configs(id) ON DELETE CASCADE,
  condition_type TEXT NOT NULL CHECK (condition_type IN ('timeline', 'status', 'package', 'custom')),
  condition_operator TEXT NOT NULL CHECK (condition_operator IN ('equals', 'not_equals', 'greater_than', 'less_than', 'contains', 'in_range')),
  condition_value JSONB NOT NULL,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Section content templates
CREATE TABLE IF NOT EXISTS section_content_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  section_type TEXT NOT NULL,
  template_name TEXT NOT NULL,
  content_structure JSONB NOT NULL,
  default_config JSONB DEFAULT '{}',
  created_at TIMESTAMP DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_dashboard_section_configs_supplier ON dashboard_section_configs(supplier_id);
CREATE INDEX idx_dashboard_section_configs_template ON dashboard_section_configs(template_id);
CREATE INDEX idx_section_visibility_conditions_section ON section_visibility_conditions(section_config_id);
CREATE INDEX idx_section_content_templates_type ON section_content_templates(section_type);
```

#### API Endpoints Required

**1. Section Configuration Management**
```typescript
// GET /api/dashboard/sections?template_id=123
// Response: List of section configurations for template
interface SectionConfig {
  id: string;
  sectionType: 'forms' | 'documents' | 'faq' | 'timeline' | 'photos' | 'communications' | 'budget' | 'tasks';
  title: string;
  description?: string;
  displayOrder: number;
  contentConfig: {
    displayMode?: 'list' | 'cards' | 'timeline' | 'grid';
    showStatus?: boolean;
    showDueDate?: boolean;
    groupBy?: 'status' | 'dueDate' | 'supplier' | 'category';
    includeCompleted?: boolean;
    maxItems?: number;
    sortOrder?: 'asc' | 'desc';
    sortField?: string;
    customFields?: string[];
  };
  styleConfig: {
    backgroundColor?: string;
    textColor?: string;
    borderColor?: string;
    fontSize?: 'sm' | 'md' | 'lg';
    spacing?: 'tight' | 'normal' | 'loose';
    showHeader?: boolean;
    showIcon?: boolean;
    iconName?: string;
    isCollapsible?: boolean;
    defaultExpanded?: boolean;
  };
  visibilityRules: {
    conditions: VisibilityCondition[];
    logicalOperator: 'AND' | 'OR';
    timelineVisibility?: {
      showAfter?: string; // e.g., 'booking_confirmed', '6_months_before'
      hideAfter?: string; // e.g., 'wedding_complete', '1_month_after'
    };
    deviceVisibility?: ('desktop' | 'mobile' | 'tablet')[];
  };
  isActive: boolean;
}

interface VisibilityCondition {
  type: 'timeline' | 'status' | 'package' | 'custom';
  operator: 'equals' | 'not_equals' | 'greater_than' | 'less_than' | 'contains' | 'in_range';
  value: any;
  field?: string; // for custom conditions
}

// POST /api/dashboard/sections
// Create new section configuration
// Request: Partial<SectionConfig>

// PUT /api/dashboard/sections/[id]
// Update section configuration
// Request: Partial<SectionConfig>

// DELETE /api/dashboard/sections/[id]
// Delete section configuration

// POST /api/dashboard/sections/[id]/duplicate
// Duplicate section configuration
```

**2. Section Content Templates**
```typescript
// GET /api/dashboard/section-templates?type=forms
// Get available content templates for section type

interface SectionContentTemplate {
  id: string;
  sectionType: string;
  templateName: string;
  contentStructure: {
    fields: ContentField[];
    layout: LayoutConfig;
    interactions: InteractionConfig[];
  };
  defaultConfig: Record<string, any>;
}

interface ContentField {
  name: string;
  type: 'text' | 'date' | 'status' | 'progress' | 'image' | 'link' | 'custom';
  label: string;
  required: boolean;
  sortable: boolean;
  filterable: boolean;
  searchable: boolean;
}

interface LayoutConfig {
  columns: number;
  responsive: {
    mobile: number;
    tablet: number;
    desktop: number;
  };
  spacing: 'tight' | 'normal' | 'loose';
  alignment: 'left' | 'center' | 'right';
}

interface InteractionConfig {
  type: 'click' | 'hover' | 'expand';
  action: 'navigate' | 'modal' | 'inline_edit' | 'quick_action';
  target?: string;
  parameters?: Record<string, any>;
}
```

**3. Section Preview & Validation**
```typescript
// POST /api/dashboard/sections/preview
// Preview section configuration without saving
// Request: SectionConfig

// POST /api/dashboard/sections/validate
// Validate section configuration
// Request: SectionConfig
// Response: ValidationResult

interface ValidationResult {
  isValid: boolean;
  errors: ValidationError[];
  warnings: ValidationWarning[];
}

interface ValidationError {
  field: string;
  message: string;
  code: string;
}

interface ValidationWarning {
  field: string;
  message: string;
  suggestion?: string;
}
```

#### Frontend Components Required

**1. Section Configuration Panel**
```typescript
// src/components/dashboard/SectionConfigurationPanel.tsx
interface SectionConfigurationPanelProps {
  templateId: string;
  sections: SectionConfig[];
  onSectionUpdate: (sectionId: string, config: Partial<SectionConfig>) => void;
  onSectionAdd: (config: SectionConfig) => void;
  onSectionDelete: (sectionId: string) => void;
  onSectionReorder: (sectionIds: string[]) => void;
}

export function SectionConfigurationPanel({
  templateId,
  sections,
  onSectionUpdate,
  onSectionAdd,
  onSectionDelete,
  onSectionReorder
}: SectionConfigurationPanelProps) {
  // Drag-and-drop section reordering
  // Section type selector
  // Content configuration editor
  // Style configuration editor
  // Visibility rules editor
  // Live preview
}
```

**2. Content Configuration Editor**
```typescript
// src/components/dashboard/ContentConfigurationEditor.tsx
interface ContentConfigurationEditorProps {
  sectionType: string;
  currentConfig: Record<string, any>;
  availableFields: ContentField[];
  onChange: (config: Record<string, any>) => void;
}

export function ContentConfigurationEditor({
  sectionType,
  currentConfig,
  availableFields,
  onChange
}: ContentConfigurationEditorProps) {
  // Field selection and configuration
  // Display mode selector
  // Sorting and grouping options
  // Filtering configuration
  // Custom field mapping
}
```

**3. Visibility Rules Editor**
```typescript
// src/components/dashboard/VisibilityRulesEditor.tsx
interface VisibilityRulesEditorProps {
  rules: VisibilityCondition[];
  logicalOperator: 'AND' | 'OR';
  timelineVisibility?: TimelineVisibility;
  deviceVisibility?: ('desktop' | 'mobile' | 'tablet')[];
  onChange: (rules: VisibilityCondition[], operator: 'AND' | 'OR') => void;
  onTimelineChange: (timeline: TimelineVisibility) => void;
  onDeviceChange: (devices: ('desktop' | 'mobile' | 'tablet')[]) => void;
}

export function VisibilityRulesEditor({
  rules,
  logicalOperator,
  timelineVisibility,
  deviceVisibility,
  onChange,
  onTimelineChange,
  onDeviceChange
}: VisibilityRulesEditorProps) {
  // Condition builder interface
  // Timeline visibility selector
  // Device visibility checkboxes
  // Rule logic operator selector
  // Preview of visibility conditions
}
```

**4. Section Preview Component**
```typescript
// src/components/dashboard/SectionPreview.tsx
interface SectionPreviewProps {
  config: SectionConfig;
  sampleData?: any[];
  clientContext?: {
    weddingDate: Date;
    status: string;
    packageType: string;
    customFields: Record<string, any>;
  };
  devicePreview?: 'desktop' | 'mobile' | 'tablet';
}

export function SectionPreview({
  config,
  sampleData,
  clientContext,
  devicePreview = 'desktop'
}: SectionPreviewProps) {
  // Live preview of section configuration
  // Sample data rendering
  // Responsive preview toggle
  // Visibility condition evaluation
}
```

#### State Management Required

**Section Configuration Store**
```typescript
// src/lib/stores/sectionConfigStore.ts
import { create } from 'zustand';

interface SectionConfigState {
  sections: SectionConfig[];
  activeSection: string | null;
  isLoading: boolean;
  error: string | null;
  
  // Actions
  loadSections: (templateId: string) => Promise<void>;
  updateSection: (sectionId: string, config: Partial<SectionConfig>) => Promise<void>;
  addSection: (config: SectionConfig) => Promise<void>;
  deleteSection: (sectionId: string) => Promise<void>;
  reorderSections: (sectionIds: string[]) => Promise<void>;
  setActiveSection: (sectionId: string | null) => void;
  
  // Preview and validation
  previewSection: (config: SectionConfig) => Promise<any>;
  validateSection: (config: SectionConfig) => Promise<ValidationResult>;
  
  // Templates
  loadContentTemplates: (sectionType: string) => Promise<SectionContentTemplate[]>;
  applyTemplate: (sectionId: string, templateId: string) => Promise<void>;
}

export const useSectionConfigStore = create<SectionConfigState>((set, get) => ({
  sections: [],
  activeSection: null,
  isLoading: false,
  error: null,

  loadSections: async (templateId: string) => {
    set({ isLoading: true, error: null });
    try {
      const response = await fetch(`/api/dashboard/sections?template_id=${templateId}`);
      const sections = await response.json();
      set({ sections, isLoading: false });
    } catch (error) {
      set({ error: error.message, isLoading: false });
    }
  },

  updateSection: async (sectionId: string, config: Partial<SectionConfig>) => {
    try {
      const response = await fetch(`/api/dashboard/sections/${sectionId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(config)
      });
      const updatedSection = await response.json();
      
      set(state => ({
        sections: state.sections.map(section => 
          section.id === sectionId ? { ...section, ...updatedSection } : section
        )
      }));
    } catch (error) {
      set({ error: error.message });
    }
  },

  addSection: async (config: SectionConfig) => {
    try {
      const response = await fetch('/api/dashboard/sections', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(config)
      });
      const newSection = await response.json();
      
      set(state => ({
        sections: [...state.sections, newSection]
      }));
    } catch (error) {
      set({ error: error.message });
    }
  },

  deleteSection: async (sectionId: string) => {
    try {
      await fetch(`/api/dashboard/sections/${sectionId}`, {
        method: 'DELETE'
      });
      
      set(state => ({
        sections: state.sections.filter(section => section.id !== sectionId),
        activeSection: state.activeSection === sectionId ? null : state.activeSection
      }));
    } catch (error) {
      set({ error: error.message });
    }
  },

  reorderSections: async (sectionIds: string[]) => {
    try {
      await fetch('/api/dashboard/sections/reorder', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ sectionIds })
      });
      
      set(state => ({
        sections: sectionIds.map((id, index) => {
          const section = state.sections.find(s => s.id === id);
          return section ? { ...section, displayOrder: index } : null;
        }).filter(Boolean) as SectionConfig[]
      }));
    } catch (error) {
      set({ error: error.message });
    }
  },

  setActiveSection: (sectionId: string | null) => {
    set({ activeSection: sectionId });
  },

  previewSection: async (config: SectionConfig) => {
    const response = await fetch('/api/dashboard/sections/preview', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(config)
    });
    return response.json();
  },

  validateSection: async (config: SectionConfig) => {
    const response = await fetch('/api/dashboard/sections/validate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(config)
    });
    return response.json();
  },

  loadContentTemplates: async (sectionType: string) => {
    const response = await fetch(`/api/dashboard/section-templates?type=${sectionType}`);
    return response.json();
  },

  applyTemplate: async (sectionId: string, templateId: string) => {
    const response = await fetch(`/api/dashboard/sections/${sectionId}/apply-template`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ templateId })
    });
    const updatedSection = await response.json();
    
    set(state => ({
      sections: state.sections.map(section => 
        section.id === sectionId ? { ...section, ...updatedSection } : section
      )
    }));
  }
}));
```

#### Code Examples

**Section Configuration Management**
```typescript
// src/app/api/dashboard/sections/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';
import { cookies } from 'next/headers';

export async function GET(request: NextRequest) {
  const supabase = createRouteHandlerClient({ cookies });
  const { searchParams } = new URL(request.url);
  const templateId = searchParams.get('template_id');

  if (!templateId) {
    return NextResponse.json({ error: 'Template ID required' }, { status: 400 });
  }

  try {
    const { data: sections, error } = await supabase
      .from('dashboard_section_configs')
      .select(`
        *,
        section_visibility_conditions(*)
      `)
      .eq('template_id', templateId)
      .order('display_order');

    if (error) throw error;

    // Transform data to include visibility rules
    const sectionsWithRules = sections.map(section => ({
      ...section,
      visibilityRules: {
        conditions: section.section_visibility_conditions || [],
        logicalOperator: section.visibility_rules?.logicalOperator || 'AND',
        timelineVisibility: section.visibility_rules?.timelineVisibility,
        deviceVisibility: section.visibility_rules?.deviceVisibility || ['desktop', 'mobile']
      }
    }));

    return NextResponse.json(sectionsWithRules);
  } catch (error) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  const supabase = createRouteHandlerClient({ cookies });
  const config = await request.json();

  try {
    const { data: session } = await supabase.auth.getSession();
    if (!session?.session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { data: section, error } = await supabase
      .from('dashboard_section_configs')
      .insert({
        supplier_id: session.session.user.id,
        template_id: config.templateId,
        section_type: config.sectionType,
        section_title: config.title,
        section_description: config.description,
        display_order: config.displayOrder,
        content_config: config.contentConfig,
        style_config: config.styleConfig,
        visibility_rules: {
          logicalOperator: config.visibilityRules.logicalOperator,
          timelineVisibility: config.visibilityRules.timelineVisibility,
          deviceVisibility: config.visibilityRules.deviceVisibility
        },
        is_active: config.isActive
      })
      .select()
      .single();

    if (error) throw error;

    // Insert visibility conditions
    if (config.visibilityRules.conditions?.length > 0) {
      const { error: conditionsError } = await supabase
        .from('section_visibility_conditions')
        .insert(
          config.visibilityRules.conditions.map(condition => ({
            section_config_id: section.id,
            condition_type: condition.type,
            condition_operator: condition.operator,
            condition_value: condition.value
          }))
        );

      if (conditionsError) throw conditionsError;
    }

    return NextResponse.json(section);
  } catch (error) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}
```

**Dynamic Section Rendering**
```typescript
// src/components/dashboard/DynamicSectionRenderer.tsx
import React from 'react';

interface DynamicSectionRendererProps {
  config: SectionConfig;
  clientData: any;
  clientContext: {
    weddingDate: Date;
    status: string;
    packageType: string;
    customFields: Record<string, any>;
  };
}

export function DynamicSectionRenderer({
  config,
  clientData,
  clientContext
}: DynamicSectionRendererProps) {
  // Check visibility rules
  const isVisible = evaluateVisibilityRules(config.visibilityRules, clientContext);
  
  if (!isVisible) {
    return null;
  }

  // Apply style configuration
  const sectionStyles = {
    backgroundColor: config.styleConfig.backgroundColor,
    color: config.styleConfig.textColor,
    borderColor: config.styleConfig.borderColor,
    fontSize: config.styleConfig.fontSize,
    padding: config.styleConfig.spacing === 'tight' ? '8px' : 
             config.styleConfig.spacing === 'loose' ? '24px' : '16px'
  };

  // Render section based on type
  const renderSectionContent = () => {
    switch (config.sectionType) {
      case 'forms':
        return (
          <FormsSection 
            data={clientData.forms}
            config={config.contentConfig}
          />
        );
      case 'documents':
        return (
          <DocumentsSection 
            data={clientData.documents}
            config={config.contentConfig}
          />
        );
      case 'faq':
        return (
          <FAQSection 
            data={clientData.faq}
            config={config.contentConfig}
          />
        );
      case 'timeline':
        return (
          <TimelineSection 
            data={clientData.timeline}
            config={config.contentConfig}
          />
        );
      default:
        return <div>Unsupported section type: {config.sectionType}</div>;
    }
  };

  return (
    <div style={sectionStyles} className={`section-${config.sectionType}`}>
      {config.styleConfig.showHeader && (
        <div className="section-header">
          {config.styleConfig.showIcon && config.styleConfig.iconName && (
            <span className={`icon-${config.styleConfig.iconName}`} />
          )}
          <h3>{config.title}</h3>
          {config.description && <p>{config.description}</p>}
        </div>
      )}
      
      {config.styleConfig.isCollapsible ? (
        <CollapsibleContent defaultExpanded={config.styleConfig.defaultExpanded}>
          {renderSectionContent()}
        </CollapsibleContent>
      ) : (
        renderSectionContent()
      )}
    </div>
  );
}

function evaluateVisibilityRules(
  rules: VisibilityRules, 
  context: ClientContext
): boolean {
  // Evaluate timeline visibility
  if (rules.timelineVisibility) {
    const now = new Date();
    const weddingDate = new Date(context.weddingDate);
    
    if (rules.timelineVisibility.showAfter) {
      const showAfterDate = calculateTimelineDate(rules.timelineVisibility.showAfter, weddingDate);
      if (now < showAfterDate) return false;
    }
    
    if (rules.timelineVisibility.hideAfter) {
      const hideAfterDate = calculateTimelineDate(rules.timelineVisibility.hideAfter, weddingDate);
      if (now > hideAfterDate) return false;
    }
  }

  // Evaluate visibility conditions
  if (rules.conditions.length > 0) {
    const results = rules.conditions.map(condition => 
      evaluateCondition(condition, context)
    );
    
    return rules.logicalOperator === 'AND' 
      ? results.every(Boolean)
      : results.some(Boolean);
  }

  return true;
}

function calculateTimelineDate(timelineRef: string, weddingDate: Date): Date {
  const refDate = new Date(weddingDate);
  
  switch (timelineRef) {
    case 'booking_confirmed':
      // Implementation depends on when booking was confirmed
      return new Date(); // Placeholder
    case '6_months_before':
      refDate.setMonth(refDate.getMonth() - 6);
      return refDate;
    case '1_month_after':
      refDate.setMonth(refDate.getMonth() + 1);
      return refDate;
    case 'wedding_complete':
      refDate.setDate(refDate.getDate() + 1);
      return refDate;
    default:
      return refDate;
  }
}

function evaluateCondition(condition: VisibilityCondition, context: ClientContext): boolean {
  const contextValue = context[condition.field as keyof ClientContext] || 
                       context.customFields[condition.field];
  
  switch (condition.operator) {
    case 'equals':
      return contextValue === condition.value;
    case 'not_equals':
      return contextValue !== condition.value;
    case 'greater_than':
      return contextValue > condition.value;
    case 'less_than':
      return contextValue < condition.value;
    case 'contains':
      return String(contextValue).includes(String(condition.value));
    case 'in_range':
      return contextValue >= condition.value.min && contextValue <= condition.value.max;
    default:
      return true;
  }
}
```

### TESTING REQUIREMENTS

#### Unit Tests
- Section configuration validation
- Visibility rule evaluation
- Content configuration parsing
- Style configuration application
- Template loading and application

#### Integration Tests
- Section CRUD operations
- Visibility condition database queries
- Template inheritance and customization
- Real-time section updates
- Multi-device section rendering

#### E2E Tests
- Complete section configuration workflow
- Section reordering via drag-and-drop
- Visibility rule testing across different client contexts
- Template application and customization
- Cross-browser section rendering

### DEPENDENCIES & EFFORT ESTIMATE

#### Dependencies
- Dashboard Templates System (WS-211) - Must be completed first
- Client Management System - For client context data
- Authentication System - For supplier permissions
- Real-time Updates System - For live preview functionality

#### Effort Estimate: 21 development days
- **Database Design & Migration**: 2 days
- **API Endpoints**: 4 days  
- **Section Configuration Panel**: 5 days
- **Visibility Rules Engine**: 4 days
- **Content Configuration Editor**: 3 days
- **Dynamic Section Renderer**: 3 days

#### Risk Factors
- **High:** Complex visibility rule evaluation logic
- **Medium:** Performance with large numbers of sections
- **Medium:** Cross-browser styling consistency
- **Low:** Template inheritance conflicts

### SUCCESS CRITERIA
1. Suppliers can configure 8+ section types with custom content and styling
2. Visibility rules work accurately across different client contexts
3. Section configurations save and load in <500ms
4. Live preview updates in real-time without page refresh
5. Sections render consistently across desktop and mobile devices
6. Section reordering works smoothly via drag-and-drop
7. Template application preserves existing customizations where possible