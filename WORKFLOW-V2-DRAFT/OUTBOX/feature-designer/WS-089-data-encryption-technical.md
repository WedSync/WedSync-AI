# TECHNICAL SPECIFICATION: WS-089 - Data Encryption
## Generated by Feature Development Session - 2025-08-22

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding planner handling high-profile celebrity clients
**I want to:** Ensure all client personal details and guest information is encrypted at rest and in transit
**So that:** I can protect VIP wedding details from potential data breaches that could damage my reputation and violate NDAs

**Real Wedding Scenario:**
A celebrity wedding planner stores guest lists containing home addresses of A-list celebrities, their dietary restrictions, and security requirements. If this data is compromised, it could pose physical safety risks to the celebrities and result in massive lawsuits. End-to-end encryption ensures that even if the database is breached, the sensitive data remains unreadable.

### SPECIFICATION SOURCE
- **Feature ID:** WS-089
- **Original Spec:** /CORE-SPECIFICATIONS/10-SECURITY-COMPLIANCE/02-data-encryption md.md
- **Current Implementation:** 0% complete
- **Files to Modify:** 
  - /wedsync/src/lib/database/supabase.ts
  - /wedsync/src/lib/security/encryption.ts
  - /wedsync/src/middleware.ts
- **New Files to Create:** 
  - /wedsync/src/lib/security/field-encryption.ts
  - /wedsync/src/lib/security/key-management.ts
  - /wedsync/src/lib/security/backup-encryption.ts
  - /wedsync/src/lib/security/file-encryption.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Enable PostgreSQL crypto extension
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- Encrypted sensitive supplier data
CREATE TABLE supplier_sensitive_data (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES suppliers(id) ON DELETE CASCADE,
  tax_id_encrypted BYTEA,
  bank_account_encrypted BYTEA,
  ssn_encrypted BYTEA,
  api_keys_encrypted JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Encryption key management
CREATE TABLE encryption_keys (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  key_type TEXT NOT NULL, -- master, data, session
  key_version INTEGER NOT NULL,
  key_hash TEXT NOT NULL,
  active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  rotated_at TIMESTAMPTZ,
  expires_at TIMESTAMPTZ,
  UNIQUE(key_type, key_version)
);

-- User-specific encryption keys for zero-knowledge
CREATE TABLE user_encryption_keys (
  user_id UUID PRIMARY KEY REFERENCES auth.users(id),
  key_encrypted BYTEA NOT NULL,
  salt BYTEA NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Encryption helper functions
CREATE OR REPLACE FUNCTION encrypt_sensitive(
  data TEXT,
  key TEXT
) RETURNS BYTEA AS $$
BEGIN
  RETURN pgp_sym_encrypt(data, key, 'cipher-algo=aes256');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION decrypt_sensitive(
  encrypted_data BYTEA,
  key TEXT
) RETURNS TEXT AS $$
BEGIN
  RETURN pgp_sym_decrypt(encrypted_data, key);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

#### API Endpoints Required
```typescript
// POST /api/encryption/rotate-keys
interface KeyRotationRequest {
  keyType: 'master' | 'data' | 'session';
  force?: boolean;
}

interface KeyRotationResponse {
  success: boolean;
  newVersion: number;
  affectedRecords: number;
}

// POST /api/encryption/backup-data
interface BackupEncryptionRequest {
  tables: string[];
  encryptionLevel: 'standard' | 'high';
}
```

#### Frontend Components Required
```typescript
// Component: EncryptionStatus
// Location: /src/components/security/EncryptionStatus.tsx

interface EncryptionStatusProps {
  showDetails?: boolean;
  userRole: 'admin' | 'user';
}

// Key functionality:
- Display current encryption status
- Show key rotation schedule
- Alert on encryption issues
- Allow key rotation for admins
```

#### Integration Points
```typescript
// Service: EncryptionService
// Dependencies: Key Management, Supabase, File Storage

class EncryptionService {
  async encryptSensitiveField(data: string, userId: string) {
    // Encrypt field using user-specific key
  }
  
  async decryptSensitiveField(encryptedData: Buffer, userId: string) {
    // Decrypt field using user-specific key
  }
  
  async rotateEncryptionKeys() {
    // Rotate all encryption keys and re-encrypt data
  }
}
```

### CODE EXAMPLES

#### Example 1: Field-Level Encryption
```typescript
// field-encryption.ts
import crypto from 'crypto';
import { createClient } from '@/lib/supabase/server';

export class FieldEncryption {
  private algorithm = 'aes-256-gcm';
  private keyDerivation = 'pbkdf2';

  async encryptPII(data: any, userId: string): Promise<any> {
    const encrypted = { ...data };
    const sensitiveFields = ['ssn', 'tax_id', 'passport_number', 'bank_account'];

    for (const field of sensitiveFields) {
      if (data[field]) {
        encrypted[field] = await this.encryptField(data[field], userId);
        encrypted[`${field}_encrypted`] = true;
        encrypted[`${field}_last4`] = this.getLast4(data[field]);
      }
    }

    return encrypted;
  }

  private async encryptField(value: string, userId: string): Promise<string> {
    // Get user's encryption key
    const userKey = await this.getUserEncryptionKey(userId);
    
    // Generate salt and IV
    const salt = crypto.randomBytes(32);
    const iv = crypto.randomBytes(16);
    
    // Derive key from user key + salt
    const key = crypto.pbkdf2Sync(userKey, salt, 100000, 32, 'sha256');
    
    // Encrypt data
    const cipher = crypto.createCipheriv(this.algorithm, key, iv);
    const encrypted = Buffer.concat([
      cipher.update(value, 'utf8'),
      cipher.final()
    ]);
    
    const authTag = cipher.getAuthTag();

    // Return encoded result
    return JSON.stringify({
      salt: salt.toString('base64'),
      iv: iv.toString('base64'),
      data: encrypted.toString('base64'),
      tag: authTag.toString('base64')
    });
  }

  async decryptField(encryptedValue: string, userId: string): Promise<string> {
    const userKey = await this.getUserEncryptionKey(userId);
    const { salt, iv, data, tag } = JSON.parse(encryptedValue);
    
    // Derive same key
    const key = crypto.pbkdf2Sync(
      userKey, 
      Buffer.from(salt, 'base64'), 
      100000, 
      32, 
      'sha256'
    );
    
    // Decrypt data
    const decipher = crypto.createDecipheriv(
      this.algorithm, 
      key, 
      Buffer.from(iv, 'base64')
    );
    
    decipher.setAuthTag(Buffer.from(tag, 'base64'));
    
    const decrypted = Buffer.concat([
      decipher.update(Buffer.from(data, 'base64')),
      decipher.final()
    ]);
    
    return decrypted.toString('utf8');
  }
}
```

#### Example 2: File Encryption
```typescript
// file-encryption.ts
export class FileEncryption {
  private algorithm = 'aes-256-gcm';

  async encryptFile(file: Buffer, userKey: string): Promise<EncryptedFile> {
    // Generate salt for this file
    const salt = crypto.randomBytes(32);
    
    // Derive encryption key from user key
    const key = crypto.pbkdf2Sync(userKey, salt, 100000, 32, 'sha256');
    
    // Generate IV
    const iv = crypto.randomBytes(16);
    
    // Create cipher
    const cipher = crypto.createCipheriv(this.algorithm, key, iv);
    
    // Encrypt file
    const encrypted = Buffer.concat([
      cipher.update(file),
      cipher.final()
    ]);
    
    // Get auth tag for verification
    const authTag = cipher.getAuthTag();

    return {
      encrypted,
      salt,
      iv,
      authTag,
      algorithm: this.algorithm
    };
  }

  async decryptFile(
    encryptedData: EncryptedFile, 
    userKey: string
  ): Promise<Buffer> {
    // Derive key using same salt
    const key = crypto.pbkdf2Sync(
      userKey,
      encryptedData.salt,
      100000,
      32,
      'sha256'
    );

    // Create decipher
    const decipher = crypto.createDecipheriv(
      this.algorithm,
      key,
      encryptedData.iv
    );

    // Set auth tag for verification
    decipher.setAuthTag(encryptedData.authTag);

    // Decrypt file
    return Buffer.concat([
      decipher.update(encryptedData.encrypted),
      decipher.final()
    ]);
  }
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for Node.js crypto, encryption best practices
- [x] Playwright: Test encryption/decryption flows
- [x] Filesystem: Access encryption-related files

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/nodejs/docs", "crypto module", 3000);
await mcp__context7__get-library-docs("/postgresql/docs", "pgcrypto extension", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('Data Encryption', () => {
  it('should encrypt and decrypt sensitive fields correctly', async () => {
    const encryption = new FieldEncryption();
    const originalData = { ssn: '123-45-6789', name: 'John Doe' };
    
    const encrypted = await encryption.encryptPII(originalData, 'user-id');
    expect(encrypted.ssn).not.toBe(originalData.ssn);
    expect(encrypted.ssn_encrypted).toBe(true);
    
    const decrypted = await encryption.decryptField(encrypted.ssn, 'user-id');
    expect(decrypted).toBe(originalData.ssn);
  });
  
  it('should rotate encryption keys without data loss', async () => {
    const keyService = new KeyManagement();
    const testData = 'sensitive information';
    
    // Encrypt with current key
    const encrypted = await keyService.encrypt(testData);
    
    // Rotate key
    await keyService.rotateKeys();
    
    // Should still be able to decrypt
    const decrypted = await keyService.decrypt(encrypted);
    expect(decrypted).toBe(testData);
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Encryption in User Flow', async () => {
  await mcp__playwright__browser_navigate({url: '/clients/new'});
  
  // Fill form with sensitive data
  await mcp__playwright__browser_type({
    element: 'SSN input',
    ref: '#ssn-input',
    text: '123-45-6789'
  });
  
  await mcp__playwright__browser_click({element: 'Save button', ref: '#save-client'});
  
  // Verify data is encrypted in database
  // This would be checked in the backend test
  await mcp__playwright__browser_snapshot();
});
```

### ACCEPTANCE CRITERIA
- [x] All PII fields are encrypted at rest using AES-256-GCM
- [x] All API communications use TLS 1.3 encryption
- [x] User-specific encryption keys enable zero-knowledge architecture
- [x] Key rotation occurs quarterly without service interruption
- [x] File uploads are encrypted before storage
- [x] Performance: Encryption/decryption adds <50ms overhead
- [x] Security: Keys are never logged or stored in plaintext
- [x] Accessibility: Encryption is transparent to users

### DEPENDENCIES
- Must complete after: WS-088 (Authentication Security)
- Must complete before: WS-090 (GDPR Compliance)
- Shares code with: Database layer, File storage, User management

### ESTIMATED EFFORT
- Team A Frontend: 8 hours
- Team B Backend: 24 hours
- Team C Integration: 10 hours
- Total: 42 hours