# TECHNICAL SPECIFICATION: WS-195 - Business Metrics Dashboard
## Generated by Feature Development Session - August 25, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** WedSync executive monitoring business performance and investor reporting requirements
**I want to:** Track comprehensive business metrics including MRR, churn rate, viral coefficient, and customer acquisition costs in real-time dashboards
**So that:** I can make data-driven decisions about product development, identify growth opportunities during peak wedding seasons, track the success of supplier acquisition campaigns, and provide accurate financial reporting to investors and stakeholders

**Real Wedding Scenario:**
During Q2 (peak wedding planning season), WedSync needs to track business health as supplier signups increase 300% and couple engagement rises 250%. The business metrics dashboard shows MRR grew from £45K to £67K month-over-month, churn decreased to 3.2% as suppliers see value during busy season, viral coefficient increased to 1.8 as satisfied suppliers refer colleagues, and customer acquisition costs decreased 40% due to word-of-mouth referrals, providing clear ROI data for continued investment in the platform.

### SPECIFICATION SOURCE
- **Feature ID:** WS-195
- **Original Spec:** /CORE-SPECIFICATIONS/11-TESTING-DEPLOYMENT/03-Monitoring/04-business-metrics md.md
- **Current Implementation:** 0% complete (new)
- **Files to Modify:** None (new feature)
- **New Files to Create:** 
  - `/wedsync/src/lib/metrics/mrr-calculator.ts`
  - `/wedsync/src/lib/metrics/viral-coefficient-tracker.ts`
  - `/wedsync/src/components/admin/BusinessMetricsDashboard.tsx`
  - `/wedsync/src/app/api/metrics/business/route.ts`
  - `/wedsync/supabase/migrations/business-metrics-system.sql`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Core business metrics tracking
CREATE TABLE business_metrics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  metric_date DATE NOT NULL,
  metric_type TEXT NOT NULL, -- 'mrr', 'churn_rate', 'viral_coefficient', 'cac', 'ltv'
  metric_value DECIMAL(15,4) NOT NULL,
  
  -- Breakdown data for detailed analysis
  metric_breakdown JSONB, -- {'new': 1200, 'expansion': 300, 'contraction': -100, 'churn': -200}
  
  -- Context and metadata
  calculation_method TEXT,
  data_sources TEXT[],
  confidence_level DECIMAL(3,2) DEFAULT 1.0, -- 0.0 to 1.0
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(metric_date, metric_type)
);

-- MRR movement tracking for detailed analysis
CREATE TABLE mrr_movements (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  movement_date DATE NOT NULL,
  supplier_id UUID REFERENCES users(id),
  
  -- Movement categorization
  movement_type TEXT CHECK (movement_type IN ('new', 'expansion', 'contraction', 'churn', 'reactivation')),
  
  -- Financial details
  previous_mrr DECIMAL(10,2) DEFAULT 0,
  new_mrr DECIMAL(10,2) NOT NULL,
  delta DECIMAL(10,2) GENERATED ALWAYS AS (new_mrr - previous_mrr) STORED,
  
  -- Context
  reason TEXT,
  tier_change TEXT, -- 'starter_to_professional', etc.
  addon_changes JSONB,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Viral growth tracking
CREATE TABLE viral_metrics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  cohort_start_date DATE NOT NULL,
  cohort_end_date DATE NOT NULL,
  
  -- Cohort details
  cohort_size INTEGER NOT NULL,
  cohort_type TEXT, -- 'supplier', 'couple', 'mixed'
  
  -- Viral metrics
  total_invitations_sent INTEGER,
  successful_conversions INTEGER,
  viral_coefficient DECIMAL(6,4),
  
  -- Timing analysis
  avg_cycle_time_days DECIMAL(6,2),
  median_cycle_time_days INTEGER,
  
  -- Growth projections
  projected_growth_30d DECIMAL(8,2),
  projected_growth_90d DECIMAL(8,2),
  
  calculated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Customer acquisition cost tracking
CREATE TABLE cac_metrics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  period_start DATE NOT NULL,
  period_end DATE NOT NULL,
  
  -- Acquisition channel breakdown
  channel TEXT, -- 'organic', 'paid_social', 'referral', 'content', 'direct'
  
  -- Cost data
  total_spend DECIMAL(10,2),
  customers_acquired INTEGER,
  cac DECIMAL(8,2) GENERATED ALWAYS AS (
    CASE 
      WHEN customers_acquired > 0 THEN total_spend / customers_acquired
      ELSE 0 
    END
  ) STORED,
  
  -- Quality metrics
  avg_ltv DECIMAL(10,2),
  ltv_cac_ratio DECIMAL(6,2),
  payback_period_months DECIMAL(4,1),
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Business health indicators
CREATE TABLE business_health_indicators (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  indicator_date DATE NOT NULL,
  
  -- Growth health
  mrr_growth_rate DECIMAL(6,4),
  user_growth_rate DECIMAL(6,4),
  revenue_growth_rate DECIMAL(6,4),
  
  -- Retention health
  gross_churn_rate DECIMAL(5,4),
  net_churn_rate DECIMAL(5,4),
  revenue_retention_rate DECIMAL(5,4),
  
  -- Efficiency health
  cac_payback_months DECIMAL(4,1),
  ltv_cac_ratio DECIMAL(6,2),
  gross_margin_percent DECIMAL(5,2),
  
  -- Overall health score (0-100)
  health_score INTEGER CHECK (health_score >= 0 AND health_score <= 100),
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

#### API Endpoints Required
```typescript
// GET /api/metrics/business/dashboard
interface BusinessMetricsDashboardRequest {
  dateRange: {
    startDate: string;
    endDate: string;
  };
  metrics: ('mrr' | 'churn' | 'viral' | 'cac' | 'ltv')[];
  granularity: 'daily' | 'weekly' | 'monthly';
}

interface BusinessMetricsDashboardResponse {
  success: boolean;
  data: {
    currentMetrics: CurrentMetrics;
    historicalTrends: HistoricalTrend[];
    businessHealth: BusinessHealthScore;
    insights: BusinessInsight[];
  };
}
```

#### Frontend Components Required
```typescript
// Component: BusinessMetricsDashboard
// Location: /src/components/admin/BusinessMetricsDashboard.tsx

interface Props {
  timeRange: DateRange;
  userRole: 'admin' | 'executive' | 'finance';
  realTimeUpdates: boolean;
}

// Key functionality:
- Real-time MRR tracking with movement categorization and trend analysis
- Churn rate monitoring with cohort analysis and retention curves
- Viral coefficient calculation with invitation tracking and conversion funnels
- CAC analysis by acquisition channel with LTV:CAC ratio monitoring
```

#### Integration Points
```typescript
// Service: BusinessMetricsCalculator
// Dependencies: Subscription data, user analytics, financial data

class BusinessMetricsCalculator {
  async calculateComprehensiveMetrics(date: Date): Promise<BusinessMetricsSnapshot> {
    // Multi-dimensional business metrics calculation with real-time updates
  }
  
  async generateInvestorReport(period: DateRange): Promise<InvestorReport> {
    // Automated investor reporting with key business metrics
  }
}
```

### CODE EXAMPLES

#### Example 1: Comprehensive MRR Calculation System
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { supabase } from '@/lib/supabase';

export class BusinessMetricsCalculator {
  async calculateDailyBusinessMetrics(targetDate: Date): Promise<BusinessMetricsSnapshot> {
    // Step 1: Calculate MRR with detailed breakdown
    const mrrMetrics = await this.calculateMRRMetrics(targetDate);
    
    // Step 2: Calculate churn rates
    const churnMetrics = await this.calculateChurnMetrics(targetDate);
    
    // Step 3: Calculate viral coefficient
    const viralMetrics = await this.calculateViralCoefficient(targetDate);
    
    // Step 4: Calculate customer acquisition cost
    const cacMetrics = await this.calculateCAC(targetDate);
    
    // Step 5: Calculate overall business health score
    const healthScore = await this.calculateBusinessHealthScore({
      mrr: mrrMetrics,
      churn: churnMetrics,
      viral: viralMetrics,
      cac: cacMetrics
    });

    // Step 6: Store metrics in database for historical tracking
    await this.storeBusinessMetrics(targetDate, {
      mrr: mrrMetrics,
      churn: churnMetrics,
      viral: viralMetrics,
      cac: cacMetrics,
      health: healthScore
    });

    return {
      date: targetDate,
      mrr: mrrMetrics,
      churn: churnMetrics,
      viral: viralMetrics,
      cac: cacMetrics,
      healthScore,
      insights: await this.generateBusinessInsights({
        mrr: mrrMetrics,
        churn: churnMetrics,
        viral: viralMetrics
      })
    };
  }

  private async calculateMRRMetrics(date: Date): Promise<MRRMetrics> {
    // Get all active subscriptions and their changes
    const { data: subscriptions } = await supabase
      .from('user_subscriptions')
      .select(`
        *,
        users(id, created_at, vendor_type)
      `)
      .eq('status', 'active')
      .lte('created_at', date.toISOString());

    const mrrBreakdown = {
      new: 0,
      expansion: 0,
      contraction: 0,
      churn: 0,
      reactivation: 0
    };

    let totalMRR = 0;

    // Process each subscription for MRR movement
    for (const subscription of subscriptions || []) {
      const previousMRR = await this.getPreviousMRR(subscription.user_id, date);
      const currentMRR = this.calculateSubscriptionMRR(subscription);
      
      const movement = this.categorizeMRRMovement(previousMRR, currentMRR, subscription);
      mrrBreakdown[movement.type] += movement.amount;
      totalMRR += currentMRR;

      // Record individual movement for audit trail
      await supabase.from('mrr_movements').upsert({
        movement_date: date.toISOString().split('T')[0],
        supplier_id: subscription.user_id,
        movement_type: movement.type,
        previous_mrr: previousMRR,
        new_mrr: currentMRR,
        reason: movement.reason
      });
    }

    // Calculate growth metrics
    const previousMRR = await this.getTotalMRR(this.subtractDays(date, 30));
    const growthRate = previousMRR > 0 ? (totalMRR - previousMRR) / previousMRR : 0;

    return {
      total: totalMRR,
      breakdown: mrrBreakdown,
      growthRate,
      growthAmount: totalMRR - previousMRR,
      averagePerCustomer: subscriptions?.length ? totalMRR / subscriptions.length : 0,
      projectedAnnual: totalMRR * 12
    };
  }

  private calculateSubscriptionMRR(subscription: UserSubscription): number {
    // Base pricing by tier
    const TIER_PRICING = {
      'starter': 29,
      'professional': 59,
      'enterprise': 129
    };

    const basePrice = TIER_PRICING[subscription.tier] || 0;
    
    // Add addon pricing
    const addonPricing = {
      'advanced_analytics': 15,
      'custom_domain': 10,
      'priority_support': 20,
      'api_access': 25
    };

    const addonCost = (subscription.addons || []).reduce((sum, addon) => {
      return sum + (addonPricing[addon] || 0);
    }, 0);

    // Apply discounts
    const discount = subscription.discount_percent || 0;
    const subtotal = basePrice + addonCost;
    const finalMRR = subtotal * (1 - discount / 100);

    return Math.round(finalMRR * 100) / 100; // Round to 2 decimal places
  }

  private categorizeMRRMovement(previousMRR: number, currentMRR: number, subscription: UserSubscription): {
    type: 'new' | 'expansion' | 'contraction' | 'churn' | 'reactivation';
    amount: number;
    reason: string;
  } {
    const delta = currentMRR - previousMRR;

    if (previousMRR === 0 && currentMRR > 0) {
      return {
        type: 'new',
        amount: currentMRR,
        reason: `New ${subscription.tier} subscription`
      };
    }

    if (previousMRR > 0 && currentMRR === 0) {
      return {
        type: 'churn',
        amount: -previousMRR,
        reason: `Subscription cancelled`
      };
    }

    if (delta > 0) {
      return {
        type: 'expansion',
        amount: delta,
        reason: `Upgrade or addon purchase`
      };
    }

    if (delta < 0) {
      return {
        type: 'contraction',
        amount: delta,
        reason: `Downgrade or addon removal`
      };
    }

    return {
      type: 'new',
      amount: 0,
      reason: 'No change'
    };
  }

  private async calculateViralCoefficient(date: Date): Promise<ViralMetrics> {
    const cohortStart = this.subtractDays(date, 30);
    const cohortEnd = date;

    // Get cohort users (suppliers who signed up in period)
    const { data: cohortUsers } = await supabase
      .from('users')
      .select('id, created_at')
      .gte('created_at', cohortStart.toISOString())
      .lte('created_at', cohortEnd.toISOString())
      .eq('user_type', 'supplier');

    if (!cohortUsers || cohortUsers.length === 0) {
      return {
        coefficient: 0,
        invitesPerUser: 0,
        conversionRate: 0,
        cycleTimeDays: 0,
        projectedGrowth: 0
      };
    }

    // Track referral invitations sent by cohort
    const { data: invitations } = await supabase
      .from('referral_invitations')
      .select('*')
      .in('inviter_id', cohortUsers.map(u => u.id));

    // Track successful conversions
    const { data: conversions } = await supabase
      .from('referral_conversions')
      .select('*')
      .in('invitation_id', (invitations || []).map(i => i.id));

    // Calculate metrics
    const invitesPerUser = (invitations?.length || 0) / cohortUsers.length;
    const conversionRate = invitations?.length ? (conversions?.length || 0) / invitations.length : 0;
    const viralCoefficient = invitesPerUser * conversionRate;

    // Calculate average cycle time
    const cycleTimes = (conversions || []).map(conversion => {
      const invitation = invitations?.find(i => i.id === conversion.invitation_id);
      if (!invitation) return 0;
      
      const inviteSent = new Date(invitation.sent_at);
      const conversionDate = new Date(conversion.converted_at);
      return (conversionDate.getTime() - inviteSent.getTime()) / (1000 * 60 * 60 * 24);
    }).filter(time => time > 0);

    const avgCycleTime = cycleTimes.length > 0 
      ? cycleTimes.reduce((sum, time) => sum + time, 0) / cycleTimes.length 
      : 0;

    // Project growth based on viral coefficient
    const projectedGrowth = viralCoefficient > 0 
      ? cohortUsers.length * Math.pow(1 + viralCoefficient, 3) // 3-month projection
      : 0;

    return {
      coefficient: Math.round(viralCoefficient * 10000) / 10000,
      invitesPerUser: Math.round(invitesPerUser * 100) / 100,
      conversionRate: Math.round(conversionRate * 10000) / 10000,
      cycleTimeDays: Math.round(avgCycleTime * 10) / 10,
      projectedGrowth: Math.round(projectedGrowth)
    };
  }
}

interface MRRMetrics {
  total: number;
  breakdown: {
    new: number;
    expansion: number;
    contraction: number;
    churn: number;
    reactivation: number;
  };
  growthRate: number;
  growthAmount: number;
  averagePerCustomer: number;
  projectedAnnual: number;
}

interface ViralMetrics {
  coefficient: number;
  invitesPerUser: number;
  conversionRate: number;
  cycleTimeDays: number;
  projectedGrowth: number;
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] PostgreSQL: Execute complex business metrics calculations and data aggregation
- [x] Supabase: Access subscription data, user analytics, and financial records
- [x] Context7: Load docs for business metrics calculation methodologies

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/recharts/recharts", "business dashboard charts", 4000);
await mcp__context7__get-library-docs("/decimal/decimal", "financial calculations", 3000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('BusinessMetricsCalculator', () => {
  it('should calculate MRR with accurate movement categorization', () => {
    // Test MRR calculation logic with various subscription scenarios
  });
  
  it('should calculate viral coefficient with proper cohort analysis', () => {
    // Test viral coefficient calculation with invitation and conversion data
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Business metrics dashboard displays key metrics accurately', async () => {
  await mcp__playwright__browser_navigate({url: '/admin/business-metrics'});
  
  // Verify key metrics are displayed
  await expect(page.locator('[data-testid="current-mrr"]')).toBeVisible();
  await expect(page.locator('[data-testid="churn-rate"]')).toBeVisible();
  await expect(page.locator('[data-testid="viral-coefficient"]')).toBeVisible();
  
  // Test date range filtering
  await mcp__playwright__browser_click({
    element: 'last 90 days filter',
    ref: '[data-testid="date-filter-90d"]'
  });
  
  await mcp__playwright__browser_wait_for({text: 'Metrics updated'});
});
```

### ACCEPTANCE CRITERIA
- [x] MRR calculation accurately tracks all subscription movements with detailed categorization
- [x] Viral coefficient tracks referral performance with cycle time analysis
- [x] Business health score provides single metric for overall platform performance
- [x] Performance: Metrics calculations complete within 2 minutes for full historical analysis
- [x] Security: Financial data access restricted to authorized executive and finance users
- [x] Accessibility: Business metrics dashboard works with screen readers for executive reporting

### DEPENDENCIES
- Must complete after: WS-181 (Cohort Analysis System), WS-183 (LTV Calculations)
- Must complete before: Investor reporting and business intelligence integration
- Shares code with: Analytics infrastructure, subscription management, user tracking

### ESTIMATED EFFORT
- Team A Backend: 64 hours (Business metrics calculation, MRR tracking, viral coefficient analysis)
- Team B Frontend: 48 hours (Executive dashboard, charts, business insights visualization)
- Team C Integration: 24 hours (Data pipeline integration, automated reporting)
- Total: 136 hours