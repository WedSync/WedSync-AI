# TECHNICAL SPECIFICATION: WS-213 - Wedding Basics Setup
## Generated by Feature Development Session - 2025-01-25

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Couple who just signed up for WedSync
**I want to:** Quickly enter essential wedding details (date, venue, guest count, style) in a guided 3-step process
**So that:** I can unlock core fields functionality and see relevant wedding information throughout the platform without re-entering basic details

**Real Wedding Scenario:**
A newly engaged couple spends 45 minutes across multiple vendor forms entering the same basic information: wedding date (June 15, 2025), venue (The Grand Ballroom, Downtown), guest count (120), and style preferences (elegant/formal). With Wedding Basics Setup, they enter this information once during onboarding in under 5 minutes, and it automatically populates across all supplier forms, venue searches, and timeline calculations - saving 2+ hours of repetitive data entry and reducing errors from inconsistent information.

### SPECIFICATION SOURCE
- **Feature ID:** WS-213
- **Original Spec:** /CORE-SPECIFICATIONS/03-WEDME-COUPLE-PLATFORM/01-Onboarding/03-wedding-basics md.md
- **Current Implementation:** 0% complete
- **Files to Modify:** 
  - /src/lib/validations/core-fields.ts (add wedding basics validation)
- **New Files to Create:** 
  - /src/app/(onboarding)/wedding-basics/page.tsx
  - /src/components/onboarding/WeddingBasicsForm.tsx
  - /src/components/onboarding/VenueAutocomplete.tsx
  - /src/components/onboarding/GuestCountSelector.tsx
  - /src/components/onboarding/WeddingStyleSelector.tsx
  - /src/lib/services/google-places-service.ts
  - /src/lib/stores/weddingBasicsStore.ts
  - /src/app/api/onboarding/wedding-basics/route.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Update core_fields table to support wedding basics
ALTER TABLE core_fields ADD COLUMN IF NOT EXISTS ceremony_venue_id TEXT;
ALTER TABLE core_fields ADD COLUMN IF NOT EXISTS ceremony_venue_address TEXT;
ALTER TABLE core_fields ADD COLUMN IF NOT EXISTS reception_venue_name TEXT;
ALTER TABLE core_fields ADD COLUMN IF NOT EXISTS reception_venue_id TEXT;
ALTER TABLE core_fields ADD COLUMN IF NOT EXISTS reception_venue_address TEXT;
ALTER TABLE core_fields ADD COLUMN IF NOT EXISTS wedding_style TEXT[];
ALTER TABLE core_fields ADD COLUMN IF NOT EXISTS guest_count_estimated INTEGER;

-- Wedding style presets
CREATE TABLE IF NOT EXISTS wedding_style_presets (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  style_name TEXT NOT NULL UNIQUE,
  style_description TEXT,
  color_palette TEXT[],
  typical_vendors TEXT[],
  style_keywords TEXT[],
  display_order INTEGER DEFAULT 0,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Insert default wedding styles
INSERT INTO wedding_style_presets (style_name, style_description, color_palette, typical_vendors, style_keywords, display_order) VALUES
('Elegant/Formal', 'Classic and sophisticated celebrations with refined details', ARRAY['black', 'white', 'gold', 'silver'], ARRAY['formal venues', 'fine dining caterers', 'luxury photographers'], ARRAY['timeless', 'sophisticated', 'refined'], 1),
('Rustic/Country', 'Natural and relaxed celebrations with outdoor or barn settings', ARRAY['brown', 'cream', 'green', 'burgundy'], ARRAY['barn venues', 'farm-to-table caterers', 'outdoor photographers'], ARRAY['natural', 'relaxed', 'outdoor'], 2),
('Beach/Coastal', 'Ocean-inspired celebrations with relaxed seaside vibes', ARRAY['blue', 'white', 'coral', 'seafoam'], ARRAY['beach venues', 'seafood caterers', 'outdoor photographers'], ARRAY['coastal', 'relaxed', 'ocean'], 3),
('Modern/Contemporary', 'Clean and minimalist celebrations with current trends', ARRAY['white', 'gray', 'navy', 'rose gold'], ARRAY['modern venues', 'contemporary caterers', 'artistic photographers'], ARRAY['clean', 'minimalist', 'trendy'], 4),
('Vintage/Retro', 'Nostalgic celebrations inspired by past eras', ARRAY['dusty rose', 'sage', 'cream', 'gold'], ARRAY['historic venues', 'vintage rentals', 'film photographers'], ARRAY['nostalgic', 'romantic', 'historic'], 5),
('Boho/Bohemian', 'Free-spirited celebrations with eclectic and artistic elements', ARRAY['terracotta', 'sage', 'cream', 'burgundy'], ARRAY['outdoor venues', 'alternative caterers', 'artistic photographers'], ARRAY['free-spirited', 'artistic', 'eclectic'], 6);

-- Venue cache for autocomplete
CREATE TABLE IF NOT EXISTS venue_cache (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  google_place_id TEXT UNIQUE NOT NULL,
  venue_name TEXT NOT NULL,
  formatted_address TEXT NOT NULL,
  venue_type TEXT, -- 'ceremony', 'reception', 'both'
  coordinates POINT,
  rating DECIMAL(2,1),
  price_level INTEGER,
  phone_number TEXT,
  website TEXT,
  photos TEXT[],
  last_updated TIMESTAMP DEFAULT NOW(),
  search_count INTEGER DEFAULT 0
);

-- Indexes for performance
CREATE INDEX idx_venue_cache_place_id ON venue_cache(google_place_id);
CREATE INDEX idx_venue_cache_name ON venue_cache USING GIN(to_tsvector('english', venue_name));
CREATE INDEX idx_venue_cache_address ON venue_cache USING GIN(to_tsvector('english', formatted_address));
CREATE INDEX idx_core_fields_couple_wedding_date ON core_fields(couple_id, wedding_date);
```

#### API Endpoints Required

**1. Wedding Basics Management**
```typescript
// POST /api/onboarding/wedding-basics
// Save wedding basics information
interface WeddingBasicsRequest {
  weddingDate: string; // ISO date string
  ceremonyVenue: {
    name: string;
    placeId?: string;
    address: string;
    coordinates?: { lat: number; lng: number; };
  };
  receptionVenue?: {
    name: string;
    placeId?: string;
    address: string;
    coordinates?: { lat: number; lng: number; };
    sameAsCeremony?: boolean;
  };
  guestCountEstimated: number;
  weddingStyle: string[];
}

interface WeddingBasicsResponse {
  success: boolean;
  coreFieldsUpdated: string[];
  nextStep: string; // Next onboarding step
  recommendations?: {
    venues: VenueRecommendation[];
    vendors: VendorRecommendation[];
    timeline: TimelineRecommendation[];
  };
}

// GET /api/onboarding/wedding-basics
// Get current wedding basics (for editing)
interface WeddingBasicsData {
  weddingDate: string | null;
  ceremonyVenue: VenueInfo | null;
  receptionVenue: VenueInfo | null;
  guestCountEstimated: number | null;
  weddingStyle: string[];
  completionStatus: {
    weddingDate: boolean;
    venue: boolean;
    guestCount: boolean;
    style: boolean;
  };
}
```

**2. Venue Search & Autocomplete**
```typescript
// GET /api/venues/search?q={query}&location={lat,lng}&radius={meters}
// Search venues using Google Places API
interface VenueSearchRequest {
  query: string;
  location?: { lat: number; lng: number; };
  radius?: number; // meters
  type?: 'establishment' | 'wedding_venue' | 'restaurant';
}

interface VenueSearchResponse {
  venues: VenueResult[];
  cached: boolean;
}

interface VenueResult {
  placeId: string;
  name: string;
  formattedAddress: string;
  coordinates: { lat: number; lng: number; };
  rating?: number;
  priceLevel?: number;
  photos?: string[];
  types: string[];
  businessHours?: string;
  phone?: string;
  website?: string;
}

// GET /api/venues/details/{placeId}
// Get detailed venue information
interface VenueDetailsResponse extends VenueResult {
  description?: string;
  amenities: string[];
  capacity?: {
    ceremony?: number;
    reception?: number;
  };
  pricing?: {
    estimate?: string;
    currency?: string;
  };
  reviews: VenueReview[];
}
```

**3. Wedding Style Management**
```typescript
// GET /api/wedding-styles
// Get available wedding style presets
interface WeddingStylePreset {
  id: string;
  styleName: string;
  description: string;
  colorPalette: string[];
  typicalVendors: string[];
  keywords: string[];
  displayOrder: number;
}

// POST /api/wedding-styles/recommendations
// Get style recommendations based on venue and preferences
interface StyleRecommendationRequest {
  venueType?: string;
  location?: string;
  season?: string;
  budget?: string;
  preferences?: string[];
}

interface StyleRecommendationResponse {
  recommendedStyles: WeddingStylePreset[];
  reasoning: string[];
}
```

#### Frontend Components Required

**1. Wedding Basics Form Container**
```typescript
// src/app/(onboarding)/wedding-basics/page.tsx
'use client';

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { WeddingBasicsForm } from '@/components/onboarding/WeddingBasicsForm';
import { useWeddingBasicsStore } from '@/lib/stores/weddingBasicsStore';

export default function WeddingBasicsPage() {
  const router = useRouter();
  const { 
    loadWeddingBasics, 
    saveWeddingBasics, 
    isLoading, 
    data 
  } = useWeddingBasicsStore();

  useEffect(() => {
    loadWeddingBasics();
  }, [loadWeddingBasics]);

  const handleSubmit = async (formData: WeddingBasicsRequest) => {
    try {
      const result = await saveWeddingBasics(formData);
      if (result.success) {
        router.push(`/onboarding/${result.nextStep}`);
      }
    } catch (error) {
      console.error('Failed to save wedding basics:', error);
    }
  };

  if (isLoading) {
    return <div>Loading your wedding details...</div>;
  }

  return (
    <div className="max-w-2xl mx-auto px-4 py-8">
      <div className="mb-8">
        <h1 className="text-3xl font-bold text-gray-900 mb-2">
          Let's Start with the Basics
        </h1>
        <p className="text-lg text-gray-600">
          Tell us about your wedding so we can personalize your experience.
        </p>
        <div className="mt-4 bg-blue-50 p-4 rounded-lg">
          <p className="text-sm text-blue-700">
            <span className="font-medium">Step 1 of 3:</span> Wedding Basics
          </p>
          <div className="mt-2 bg-blue-200 rounded-full h-2">
            <div className="bg-blue-600 h-2 rounded-full" style={{ width: '33%' }}></div>
          </div>
        </div>
      </div>

      <WeddingBasicsForm 
        initialData={data}
        onSubmit={handleSubmit}
        onSaveDraft={saveWeddingBasics}
      />
    </div>
  );
}
```

**2. Wedding Basics Form**
```typescript
// src/components/onboarding/WeddingBasicsForm.tsx
import React, { useState, useEffect } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { VenueAutocomplete } from './VenueAutocomplete';
import { GuestCountSelector } from './GuestCountSelector';
import { WeddingStyleSelector } from './WeddingStyleSelector';

const weddingBasicsSchema = z.object({
  weddingDate: z.string().min(1, 'Wedding date is required'),
  ceremonyVenue: z.object({
    name: z.string().min(1, 'Ceremony venue is required'),
    placeId: z.string().optional(),
    address: z.string().min(1, 'Venue address is required'),
    coordinates: z.object({
      lat: z.number(),
      lng: z.number()
    }).optional()
  }),
  receptionVenue: z.object({
    name: z.string(),
    placeId: z.string().optional(),
    address: z.string(),
    coordinates: z.object({
      lat: z.number(),
      lng: z.number()
    }).optional(),
    sameAsCeremony: z.boolean().default(true)
  }).optional(),
  guestCountEstimated: z.number().min(2, 'Guest count must be at least 2').max(500, 'Guest count cannot exceed 500'),
  weddingStyle: z.array(z.string()).min(1, 'Please select at least one wedding style')
});

type WeddingBasicsFormData = z.infer<typeof weddingBasicsSchema>;

interface WeddingBasicsFormProps {
  initialData?: WeddingBasicsData;
  onSubmit: (data: WeddingBasicsFormData) => void;
  onSaveDraft: (data: Partial<WeddingBasicsFormData>) => void;
}

export function WeddingBasicsForm({
  initialData,
  onSubmit,
  onSaveDraft
}: WeddingBasicsFormProps) {
  const [sameVenue, setSameVenue] = useState(true);
  const [autoSaveTimer, setAutoSaveTimer] = useState<NodeJS.Timeout | null>(null);

  const form = useForm<WeddingBasicsFormData>({
    resolver: zodResolver(weddingBasicsSchema),
    defaultValues: {
      weddingDate: initialData?.weddingDate || '',
      ceremonyVenue: initialData?.ceremonyVenue || { name: '', address: '' },
      receptionVenue: initialData?.receptionVenue || { name: '', address: '', sameAsCeremony: true },
      guestCountEstimated: initialData?.guestCountEstimated || 100,
      weddingStyle: initialData?.weddingStyle || []
    },
    mode: 'onBlur' // Validate on blur for auto-save
  });

  // Auto-save on field blur
  const handleFieldBlur = () => {
    if (autoSaveTimer) {
      clearTimeout(autoSaveTimer);
    }
    
    const timer = setTimeout(() => {
      const currentData = form.getValues();
      onSaveDraft(currentData);
    }, 2000);
    
    setAutoSaveTimer(timer);
  };

  // Validate wedding date
  const validateWeddingDate = (date: string) => {
    const selectedDate = new Date(date);
    const today = new Date();
    const maxDate = new Date();
    maxDate.setFullYear(today.getFullYear() + 3);
    
    today.setDate(today.getDate() + 30); // Minimum 30 days in future
    
    if (selectedDate < today) {
      return 'Wedding date must be at least 30 days in the future';
    }
    
    if (selectedDate > maxDate) {
      return 'Wedding date cannot be more than 3 years in the future';
    }
    
    return true;
  };

  // Handle same venue toggle
  const handleSameVenueChange = (same: boolean) => {
    setSameVenue(same);
    if (same) {
      const ceremonyVenue = form.getValues('ceremonyVenue');
      form.setValue('receptionVenue', {
        ...ceremonyVenue,
        sameAsCeremony: true
      });
    } else {
      form.setValue('receptionVenue', {
        name: '',
        address: '',
        sameAsCeremony: false
      });
    }
  };

  return (
    <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-8">
      {/* Wedding Date */}
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-2">
          Wedding Date *
        </label>
        <input
          type="date"
          {...form.register('weddingDate', { 
            validate: validateWeddingDate,
            onBlur: handleFieldBlur 
          })}
          className="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500"
          min={new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]}
        />
        {form.formState.errors.weddingDate && (
          <p className="mt-1 text-sm text-red-600">
            {form.formState.errors.weddingDate.message}
          </p>
        )}
        <p className="mt-1 text-xs text-gray-500">
          This helps us show you relevant vendors and create your timeline
        </p>
      </div>

      {/* Ceremony Venue */}
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-2">
          Ceremony Venue *
        </label>
        <VenueAutocomplete
          value={form.watch('ceremonyVenue')}
          onChange={(venue) => {
            form.setValue('ceremonyVenue', venue);
            if (sameVenue) {
              form.setValue('receptionVenue', { ...venue, sameAsCeremony: true });
            }
            handleFieldBlur();
          }}
          placeholder="Search for your ceremony venue..."
        />
        {form.formState.errors.ceremonyVenue && (
          <p className="mt-1 text-sm text-red-600">
            {form.formState.errors.ceremonyVenue.message}
          </p>
        )}
      </div>

      {/* Reception Venue */}
      <div>
        <div className="flex items-center mb-3">
          <input
            type="checkbox"
            id="same-venue"
            checked={sameVenue}
            onChange={(e) => handleSameVenueChange(e.target.checked)}
            className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
          />
          <label htmlFor="same-venue" className="ml-2 text-sm text-gray-700">
            Reception is at the same location
          </label>
        </div>

        {!sameVenue && (
          <>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Reception Venue
            </label>
            <VenueAutocomplete
              value={form.watch('receptionVenue') || { name: '', address: '' }}
              onChange={(venue) => {
                form.setValue('receptionVenue', { ...venue, sameAsCeremony: false });
                handleFieldBlur();
              }}
              placeholder="Search for your reception venue..."
            />
          </>
        )}
      </div>

      {/* Guest Count */}
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-2">
          Estimated Guest Count *
        </label>
        <GuestCountSelector
          value={form.watch('guestCountEstimated')}
          onChange={(count) => {
            form.setValue('guestCountEstimated', count);
            handleFieldBlur();
          }}
        />
        {form.formState.errors.guestCountEstimated && (
          <p className="mt-1 text-sm text-red-600">
            {form.formState.errors.guestCountEstimated.message}
          </p>
        )}
        <p className="mt-1 text-xs text-gray-500">
          A rough estimate is fine - you can adjust this later
        </p>
      </div>

      {/* Wedding Style */}
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-2">
          Wedding Style *
        </label>
        <WeddingStyleSelector
          selectedStyles={form.watch('weddingStyle')}
          onChange={(styles) => {
            form.setValue('weddingStyle', styles);
            handleFieldBlur();
          }}
        />
        {form.formState.errors.weddingStyle && (
          <p className="mt-1 text-sm text-red-600">
            {form.formState.errors.weddingStyle.message}
          </p>
        )}
        <p className="mt-1 text-xs text-gray-500">
          Select all that apply - this helps us recommend the right vendors
        </p>
      </div>

      {/* Submit Button */}
      <div className="flex justify-between pt-6">
        <button
          type="button"
          onClick={() => window.history.back()}
          className="px-4 py-2 text-gray-600 hover:text-gray-800"
        >
          ← Back
        </button>
        
        <div className="flex gap-3">
          <button
            type="button"
            onClick={() => onSaveDraft(form.getValues())}
            className="px-6 py-2 border border-gray-300 text-gray-700 rounded-md hover:bg-gray-50"
          >
            Save & Continue Later
          </button>
          
          <button
            type="submit"
            disabled={form.formState.isSubmitting}
            className="px-8 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:opacity-50"
          >
            {form.formState.isSubmitting ? 'Saving...' : 'Continue →'}
          </button>
        </div>
      </div>
    </form>
  );
}
```

**3. Venue Autocomplete Component**
```typescript
// src/components/onboarding/VenueAutocomplete.tsx
import React, { useState, useEffect, useRef } from 'react';
import { useDebounce } from '@/hooks/useDebounce';

interface VenueInfo {
  name: string;
  placeId?: string;
  address: string;
  coordinates?: { lat: number; lng: number; };
}

interface VenueAutocompleteProps {
  value: VenueInfo;
  onChange: (venue: VenueInfo) => void;
  placeholder?: string;
}

export function VenueAutocomplete({
  value,
  onChange,
  placeholder = "Search for venues..."
}: VenueAutocompleteProps) {
  const [query, setQuery] = useState(value.name || '');
  const [suggestions, setSuggestions] = useState<VenueResult[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [showSuggestions, setShowSuggestions] = useState(false);
  const debouncedQuery = useDebounce(query, 300);
  const inputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    if (debouncedQuery.length >= 3) {
      searchVenues(debouncedQuery);
    } else {
      setSuggestions([]);
      setShowSuggestions(false);
    }
  }, [debouncedQuery]);

  const searchVenues = async (searchQuery: string) => {
    setIsLoading(true);
    try {
      const response = await fetch(`/api/venues/search?q=${encodeURIComponent(searchQuery)}`);
      const data = await response.json();
      setSuggestions(data.venues || []);
      setShowSuggestions(true);
    } catch (error) {
      console.error('Failed to search venues:', error);
      setSuggestions([]);
    } finally {
      setIsLoading(false);
    }
  };

  const handleSuggestionSelect = (venue: VenueResult) => {
    setQuery(venue.name);
    setShowSuggestions(false);
    onChange({
      name: venue.name,
      placeId: venue.placeId,
      address: venue.formattedAddress,
      coordinates: venue.coordinates
    });
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newQuery = e.target.value;
    setQuery(newQuery);
    
    // If user is typing a custom venue (not selecting from suggestions)
    if (newQuery !== value.name) {
      onChange({
        name: newQuery,
        address: newQuery, // Use name as address for custom entries
      });
    }
  };

  return (
    <div className="relative">
      <input
        ref={inputRef}
        type="text"
        value={query}
        onChange={handleInputChange}
        placeholder={placeholder}
        className="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500"
        onFocus={() => {
          if (suggestions.length > 0) {
            setShowSuggestions(true);
          }
        }}
        onBlur={() => {
          // Delay hiding suggestions to allow selection
          setTimeout(() => setShowSuggestions(false), 200);
        }}
      />
      
      {isLoading && (
        <div className="absolute right-3 top-1/2 transform -translate-y-1/2">
          <div className="animate-spin h-4 w-4 border-2 border-blue-500 border-t-transparent rounded-full"></div>
        </div>
      )}

      {showSuggestions && suggestions.length > 0 && (
        <div className="absolute z-10 w-full mt-1 bg-white border border-gray-300 rounded-md shadow-lg max-h-60 overflow-y-auto">
          {suggestions.map((venue, index) => (
            <button
              key={venue.placeId || index}
              type="button"
              onClick={() => handleSuggestionSelect(venue)}
              className="w-full px-4 py-3 text-left hover:bg-gray-50 border-b border-gray-100 last:border-b-0"
            >
              <div className="font-medium text-gray-900">{venue.name}</div>
              <div className="text-sm text-gray-600">{venue.formattedAddress}</div>
              {venue.rating && (
                <div className="flex items-center mt-1">
                  <span className="text-yellow-400">★</span>
                  <span className="text-xs text-gray-500 ml-1">{venue.rating}</span>
                </div>
              )}
            </button>
          ))}
        </div>
      )}

      <p className="mt-1 text-xs text-gray-500">
        Start typing to search venues, or enter a custom location
      </p>
    </div>
  );
}
```

**4. Guest Count Selector**
```typescript
// src/components/onboarding/GuestCountSelector.tsx
import React from 'react';

interface GuestCountSelectorProps {
  value: number;
  onChange: (count: number) => void;
}

const GUEST_COUNT_PRESETS = [
  { label: '25-50', value: 40 },
  { label: '50-75', value: 62 },
  { label: '75-100', value: 87 },
  { label: '100-125', value: 112 },
  { label: '125-150', value: 137 },
  { label: '150-200', value: 175 },
  { label: '200+', value: 225 }
];

export function GuestCountSelector({ value, onChange }: GuestCountSelectorProps) {
  const [customCount, setCustomCount] = React.useState(
    GUEST_COUNT_PRESETS.find(preset => preset.value === value) ? '' : value.toString()
  );
  const [showCustomInput, setShowCustomInput] = React.useState(
    !GUEST_COUNT_PRESETS.find(preset => preset.value === value)
  );

  const handlePresetSelect = (presetValue: number) => {
    setShowCustomInput(false);
    setCustomCount('');
    onChange(presetValue);
  };

  const handleCustomCountChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const count = parseInt(e.target.value) || 0;
    setCustomCount(e.target.value);
    if (count >= 2 && count <= 500) {
      onChange(count);
    }
  };

  return (
    <div className="space-y-4">
      {/* Preset Buttons */}
      <div className="grid grid-cols-4 gap-3">
        {GUEST_COUNT_PRESETS.map((preset) => (
          <button
            key={preset.value}
            type="button"
            onClick={() => handlePresetSelect(preset.value)}
            className={`px-3 py-2 text-sm border rounded-md transition-colors ${
              value === preset.value && !showCustomInput
                ? 'bg-blue-600 text-white border-blue-600'
                : 'bg-white text-gray-700 border-gray-300 hover:border-blue-300'
            }`}
          >
            {preset.label}
          </button>
        ))}
      </div>

      {/* Custom Input Toggle */}
      <button
        type="button"
        onClick={() => {
          setShowCustomInput(!showCustomInput);
          if (!showCustomInput) {
            setCustomCount(value.toString());
          }
        }}
        className="text-sm text-blue-600 hover:text-blue-800"
      >
        {showCustomInput ? 'Choose from presets' : 'Enter custom number'}
      </button>

      {/* Custom Input */}
      {showCustomInput && (
        <div className="flex items-center space-x-2">
          <input
            type="number"
            min="2"
            max="500"
            value={customCount}
            onChange={handleCustomCountChange}
            placeholder="Enter guest count"
            className="w-32 px-3 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500"
          />
          <span className="text-sm text-gray-600">guests</span>
        </div>
      )}

      {/* Validation Warning */}
      {value > 300 && (
        <p className="text-sm text-amber-600">
          ⚠ Large guest count - make sure to book vendors early!
        </p>
      )}
      
      {value < 10 && value > 0 && (
        <p className="text-sm text-blue-600">
          💡 Intimate wedding - consider micro-wedding specialists
        </p>
      )}
    </div>
  );
}
```

#### State Management Required

**Wedding Basics Store**
```typescript
// src/lib/stores/weddingBasicsStore.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface WeddingBasicsState {
  data: WeddingBasicsData | null;
  isLoading: boolean;
  error: string | null;
  
  // Actions
  loadWeddingBasics: () => Promise<void>;
  saveWeddingBasics: (data: WeddingBasicsRequest) => Promise<WeddingBasicsResponse>;
  saveDraft: (data: Partial<WeddingBasicsRequest>) => void;
  clearData: () => void;
}

export const useWeddingBasicsStore = create<WeddingBasicsState>()(
  persist(
    (set, get) => ({
      data: null,
      isLoading: false,
      error: null,

      loadWeddingBasics: async () => {
        set({ isLoading: true, error: null });
        try {
          const response = await fetch('/api/onboarding/wedding-basics');
          if (response.ok) {
            const data = await response.json();
            set({ data, isLoading: false });
          } else {
            set({ data: null, isLoading: false });
          }
        } catch (error) {
          set({ error: error.message, isLoading: false });
        }
      },

      saveWeddingBasics: async (formData: WeddingBasicsRequest) => {
        set({ isLoading: true, error: null });
        try {
          const response = await fetch('/api/onboarding/wedding-basics', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(formData)
          });
          
          if (!response.ok) {
            throw new Error('Failed to save wedding basics');
          }
          
          const result = await response.json();
          
          // Update local state with saved data
          set({ 
            data: { 
              ...formData,
              completionStatus: {
                weddingDate: true,
                venue: true,
                guestCount: true,
                style: true
              }
            }, 
            isLoading: false 
          });
          
          return result;
        } catch (error) {
          set({ error: error.message, isLoading: false });
          throw error;
        }
      },

      saveDraft: (draftData: Partial<WeddingBasicsRequest>) => {
        const currentData = get().data;
        set({
          data: {
            ...currentData,
            ...draftData,
            completionStatus: {
              weddingDate: !!draftData.weddingDate,
              venue: !!(draftData.ceremonyVenue?.name),
              guestCount: !!draftData.guestCountEstimated,
              style: !!(draftData.weddingStyle?.length)
            }
          }
        });
      },

      clearData: () => {
        set({ data: null, error: null });
      }
    }),
    {
      name: 'wedding-basics-storage',
      partialize: (state) => ({ data: state.data }), // Only persist data
    }
  )
);
```

### TESTING REQUIREMENTS

#### Unit Tests
- Wedding date validation (30 days future, max 3 years)
- Guest count validation (2-500 range)
- Venue autocomplete search functionality
- Wedding style selection logic
- Auto-save functionality with proper debouncing

#### Integration Tests
- Core fields table updates with wedding basics
- Google Places API integration
- Wedding style presets loading
- Venue caching system
- Form submission and validation flow

#### E2E Tests
- Complete wedding basics onboarding flow
- Venue search and selection
- Auto-save and draft restoration
- Form validation error handling
- Navigation between onboarding steps

### DEPENDENCIES & EFFORT ESTIMATE

#### Dependencies
- Core Fields System - For data storage
- Google Places API - For venue autocomplete
- Authentication System - For couple identification
- Form validation library (React Hook Form + Zod)

#### Effort Estimate: 14 development days
- **Database Design & Migration**: 2 days
- **Google Places Integration**: 3 days  
- **Wedding Basics Form**: 4 days
- **Venue Autocomplete Component**: 2 days
- **Guest Count & Style Selectors**: 2 days
- **State Management & Auto-save**: 1 day

#### Risk Factors
- **High:** Google Places API rate limits and costs
- **Medium:** Venue search accuracy and relevance
- **Medium:** Auto-save performance with frequent updates
- **Low:** Form validation complexity

### SUCCESS CRITERIA
1. Couples complete wedding basics setup in under 5 minutes
2. Wedding date validation prevents invalid date selection
3. Venue autocomplete finds relevant venues in <2 seconds
4. Auto-save works reliably with 2-second debounce
5. Guest count selector handles both presets and custom input
6. Wedding style selection supports multiple styles
7. Form data persists correctly in core_fields table
8. Next onboarding step loads based on completion status