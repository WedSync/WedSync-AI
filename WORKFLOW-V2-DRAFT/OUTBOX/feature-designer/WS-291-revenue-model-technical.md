# TECHNICAL SPECIFICATION: WS-291 - Revenue Model
## Generated by Feature Development Session - 2025-08-25

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Product Manager / Finance Team / Business Analyst
**I want to:** Implement a comprehensive revenue tracking system with subscription tiers, billing management, and financial analytics
**So that:** We can execute our freemium strategy, track unit economics, and achieve our £50k MRR target within 12 months

**Real Wedding Scenario:**
"A photographer starts on the free tier (1 form limit) and quickly hits the limit with their first client. They upgrade to Starter (£19/month) for unlimited forms. As their business grows to 20+ weddings, they need SMS automation and upgrade to Professional (£49/month). The system tracks their lifetime value (£882 average) and ensures our 29.4 LTV:CAC ratio, making each customer highly profitable."

### SPECIFICATION SOURCE
- **Feature ID:** WS-291
- **Original Spec:** /CORE-SPECIFICATIONS/00-PROJECT-OVERVIEW/06-revenue-model.md
- **Current Implementation:** 30% complete (basic Stripe integration exists)
- **Files to Modify:**
  - /src/lib/billing/subscription-manager.ts
  - /src/components/billing/PricingTiers.tsx
- **New Files to Create:**
  - /src/lib/revenue/pricing-engine.ts
  - /src/lib/revenue/unit-economics.ts
  - /src/lib/revenue/churn-prevention.ts
  - /src/components/revenue/RevenueAnalytics.tsx
  - /src/components/billing/UpgradeTriggers.tsx

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Subscription Management
CREATE TABLE IF NOT EXISTS subscription_tiers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tier_name VARCHAR(20) UNIQUE NOT NULL, -- 'free', 'starter', 'professional', 'scale', 'enterprise'
  display_name VARCHAR(50) NOT NULL,
  monthly_price_gbp DECIMAL(8,2) NOT NULL,
  annual_price_gbp DECIMAL(8,2),
  annual_discount DECIMAL(3,2) DEFAULT 0.20,
  
  -- Feature limits
  max_logins INTEGER,
  max_forms INTEGER, -- NULL means unlimited
  features JSONB NOT NULL, -- Feature flags
  
  -- Metadata
  positioning TEXT,
  target_segment TEXT,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Revenue Analytics
CREATE TABLE IF NOT EXISTS revenue_metrics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  date DATE NOT NULL,
  
  -- User metrics
  total_users INTEGER DEFAULT 0,
  paid_users INTEGER DEFAULT 0,
  
  -- Revenue
  mrr DECIMAL(10,2) DEFAULT 0, -- Monthly Recurring Revenue
  arr DECIMAL(10,2) DEFAULT 0, -- Annual Recurring Revenue
  
  -- By tier
  free_users INTEGER DEFAULT 0,
  starter_users INTEGER DEFAULT 0,
  starter_revenue DECIMAL(8,2) DEFAULT 0,
  professional_users INTEGER DEFAULT 0,
  professional_revenue DECIMAL(8,2) DEFAULT 0,
  scale_users INTEGER DEFAULT 0,
  scale_revenue DECIMAL(8,2) DEFAULT 0,
  enterprise_users INTEGER DEFAULT 0,
  enterprise_revenue DECIMAL(8,2) DEFAULT 0,
  
  -- Unit economics
  blended_cac DECIMAL(8,2) DEFAULT 0, -- Customer Acquisition Cost
  blended_ltv DECIMAL(8,2) DEFAULT 0, -- Lifetime Value
  ltv_cac_ratio DECIMAL(5,2) DEFAULT 0,
  payback_period_months DECIMAL(4,2) DEFAULT 0,
  gross_margin DECIMAL(3,2) DEFAULT 0,
  
  -- Churn
  monthly_churn_rate DECIMAL(4,3) DEFAULT 0,
  
  UNIQUE(date)
);

-- User Subscriptions
CREATE TABLE IF NOT EXISTS user_subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL,
  tier_id UUID NOT NULL,
  
  -- Stripe details
  stripe_subscription_id VARCHAR(255),
  stripe_customer_id VARCHAR(255),
  
  -- Billing
  billing_period VARCHAR(10) NOT NULL, -- 'monthly' or 'annual'
  current_period_start DATE,
  current_period_end DATE,
  
  -- Status
  status VARCHAR(20) DEFAULT 'active', -- 'active', 'past_due', 'canceled', 'paused'
  
  -- Discount tracking
  discount_code VARCHAR(50),
  discount_percentage DECIMAL(3,2),
  discount_expires_at TIMESTAMP,
  
  -- Timestamps
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  canceled_at TIMESTAMP,
  
  CONSTRAINT fk_user_subscription_user FOREIGN KEY (user_id) 
    REFERENCES users(id) ON DELETE CASCADE,
  CONSTRAINT fk_user_subscription_tier FOREIGN KEY (tier_id) 
    REFERENCES subscription_tiers(id)
);

-- Usage tracking for upgrade triggers
CREATE TABLE IF NOT EXISTS usage_tracking (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL,
  
  -- Current usage
  forms_created INTEGER DEFAULT 0,
  logins_this_month INTEGER DEFAULT 0,
  clients_managed INTEGER DEFAULT 0,
  invitations_sent INTEGER DEFAULT 0,
  
  -- Limits
  forms_limit INTEGER,
  logins_limit INTEGER,
  is_over_limit BOOLEAN DEFAULT false,
  
  -- Tracking period
  period_start DATE,
  period_end DATE,
  
  updated_at TIMESTAMP DEFAULT NOW(),
  
  CONSTRAINT fk_usage_user FOREIGN KEY (user_id) 
    REFERENCES users(id) ON DELETE CASCADE,
  
  UNIQUE(user_id, period_start)
);

-- Churn prevention tracking
CREATE TABLE IF NOT EXISTS churn_prevention (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL,
  
  -- Risk assessment
  churn_risk_score DECIMAL(3,2) DEFAULT 0, -- 0-1 scale
  risk_factors JSONB, -- Array of risk indicators
  
  -- Interventions
  interventions_attempted JSONB, -- Array of attempted saves
  last_intervention_at TIMESTAMP,
  
  -- Outcomes
  status VARCHAR(20) DEFAULT 'active', -- 'active', 'paused', 'saved', 'churned'
  churned_at TIMESTAMP,
  churn_reason VARCHAR(100),
  
  -- Value metrics
  lifetime_value DECIMAL(8,2) DEFAULT 0,
  months_subscribed INTEGER DEFAULT 0,
  
  updated_at TIMESTAMP DEFAULT NOW(),
  
  CONSTRAINT fk_churn_user FOREIGN KEY (user_id) 
    REFERENCES users(id) ON DELETE CASCADE
);

-- Marketplace revenue tracking
CREATE TABLE IF NOT EXISTS marketplace_transactions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Transaction details
  template_id UUID NOT NULL,
  buyer_id UUID NOT NULL,
  creator_id UUID NOT NULL,
  
  -- Amounts
  total_amount DECIMAL(8,2) NOT NULL,
  creator_share DECIMAL(8,2) NOT NULL, -- 70%
  platform_commission DECIMAL(8,2) NOT NULL, -- 30%
  
  -- Status
  status VARCHAR(20) DEFAULT 'pending',
  processed_at TIMESTAMP,
  
  -- Stripe
  stripe_payment_intent_id VARCHAR(255),
  
  created_at TIMESTAMP DEFAULT NOW()
);
```

#### API Endpoints Required
```typescript
// Revenue Management API
interface RevenueAPI {
  // GET /api/v1/revenue/metrics
  getRevenueMetrics(period: string): Promise<RevenueMetrics>;
  
  // GET /api/v1/billing/tiers
  getPricingTiers(): Promise<SubscriptionTier[]>;
  
  // POST /api/v1/billing/subscribe
  createSubscription(request: SubscriptionRequest): Promise<SubscriptionResponse>;
  
  // PUT /api/v1/billing/subscription/:id/upgrade
  upgradeSubscription(subscriptionId: string, newTier: string): Promise<void>;
  
  // GET /api/v1/billing/usage/:userId
  getUserUsage(userId: string): Promise<UsageStats>;
  
  // POST /api/v1/billing/discount/apply
  applyDiscount(code: string, userId: string): Promise<DiscountResult>;
  
  // GET /api/v1/revenue/unit-economics
  getUnitEconomics(): Promise<UnitEconomics>;
}

interface SubscriptionTier {
  id: string;
  tier_name: string;
  display_name: string;
  monthly_price_gbp: number;
  annual_price_gbp: number;
  annual_discount: number;
  features: {
    max_logins?: number;
    max_forms?: number;
    ai_chatbot: boolean;
    sms_whatsapp: boolean;
    api_access: boolean;
    white_label: boolean;
    custom_domain: boolean;
    priority_support: boolean;
  };
  positioning: string;
  target_segment: string;
}

interface RevenueMetrics {
  current_mrr: number;
  previous_mrr: number;
  mrr_growth: number;
  
  total_users: number;
  paid_users: number;
  conversion_rate: number;
  
  by_tier: {
    [tier: string]: {
      users: number;
      revenue: number;
      percentage: number;
    };
  };
  
  unit_economics: {
    blended_ltv: number;
    blended_cac: number;
    ltv_cac_ratio: number;
    payback_period: number;
    gross_margin: number;
  };
  
  churn: {
    monthly_rate: number;
    by_tier: { [tier: string]: number };
    at_risk_users: number;
  };
}

interface UsageStats {
  current_tier: string;
  usage: {
    forms_created: number;
    logins_this_month: number;
    clients_managed: number;
  };
  limits: {
    forms_limit?: number;
    logins_limit?: number;
  };
  upgrade_triggers: string[];
  recommended_tier?: string;
}
```

#### Frontend Components Required
```typescript
// Component: PricingTiersDisplay
// Location: /src/components/billing/PricingTiersDisplay.tsx

interface Props {
  currentTier?: string;
  showAnnualToggle?: boolean;
  highlightUpgrade?: boolean;
  context: 'marketing' | 'settings' | 'upgrade';
}

// Key functionality:
- Interactive pricing tier comparison
- Annual/monthly toggle with discount display
- Feature comparison matrix
- Upgrade call-to-action buttons
- Value proposition messaging

// Component: UsageDashboard
// Location: /src/components/billing/UsageDashboard.tsx

interface Props {
  userId: string;
  showUpgradeTriggers?: boolean;
  showUsageAlerts?: boolean;
}

// Key functionality:
- Real-time usage tracking display
- Limit warnings and upgrade prompts
- Usage trends and projections
- Tier recommendation engine
```

#### Integration Points
```typescript
// Service: RevenueEngine
// Dependencies: Stripe, analytics, user management

class RevenueEngine {
  private stripe = new Stripe(process.env.STRIPE_SECRET_KEY);
  
  async calculateMRR(date: Date): Promise<number> {
    const subscriptions = await this.database.query(`
      SELECT tier_name, COUNT(*) as users, monthly_price_gbp
      FROM user_subscriptions us
      JOIN subscription_tiers st ON us.tier_id = st.id
      WHERE us.status = 'active'
      AND us.created_at <= $1
      AND (us.canceled_at IS NULL OR us.canceled_at > $1)
      GROUP BY tier_name, monthly_price_gbp
    `, [date]);
    
    let mrr = 0;
    for (const sub of subscriptions) {
      mrr += sub.users * sub.monthly_price_gbp;
    }
    
    return mrr;
  }
  
  async checkUpgradeTriggers(userId: string): Promise<UpgradeTrigger[]> {
    const usage = await this.getUserUsage(userId);
    const subscription = await this.getUserSubscription(userId);
    const triggers = [];
    
    // Check form limit
    if (subscription.tier_name === 'free' && usage.forms_created >= 1) {
      triggers.push({
        type: 'form_limit_reached',
        message: 'You\'ve created your first form! Upgrade to create unlimited forms.',
        recommended_tier: 'starter',
        urgency: 'high'
      });
    }
    
    // Check login limit
    if (usage.logins_this_month > (subscription.features.max_logins || 999)) {
      triggers.push({
        type: 'login_limit_exceeded',
        message: 'You need more team logins. Upgrade for additional access.',
        recommended_tier: this.getNextTier(subscription.tier_name),
        urgency: 'medium'
      });
    }
    
    // Check feature needs
    if (usage.clients_managed > 20 && subscription.tier_name === 'starter') {
      triggers.push({
        type: 'automation_needed',
        message: 'Managing 20+ clients? Professional tier adds automation.',
        recommended_tier: 'professional',
        urgency: 'medium'
      });
    }
    
    return triggers;
  }
  
  async calculateUnitEconomics(): Promise<UnitEconomics> {
    // Calculate LTV by tier
    const ltvData = await this.database.query(`
      SELECT tier_name, 
             AVG(lifetime_value) as avg_ltv,
             AVG(months_subscribed) as avg_tenure
      FROM churn_prevention cp
      JOIN user_subscriptions us ON cp.user_id = us.user_id
      JOIN subscription_tiers st ON us.tier_id = st.id
      WHERE cp.status IN ('active', 'saved')
      GROUP BY tier_name
    `);
    
    // Calculate blended metrics
    const totalRevenue = ltvData.reduce((sum, tier) => sum + tier.avg_ltv, 0);
    const totalUsers = ltvData.length;
    const blendedLTV = totalRevenue / totalUsers;
    
    return {
      ltv_by_tier: ltvData,
      blended_ltv: blendedLTV,
      blended_cac: 25, // From marketing data
      ltv_cac_ratio: blendedLTV / 25,
      payback_period: 1.5, // months
      gross_margin: 0.85
    };
  }
}

// Service: ChurnPreventionEngine
// Dependencies: Usage tracking, email service, analytics

class ChurnPreventionEngine {
  async assessChurnRisk(userId: string): Promise<number> {
    const usage = await this.getUserUsage(userId);
    const subscription = await this.getUserSubscription(userId);
    const activity = await this.getUserActivity(userId);
    
    let riskScore = 0;
    
    // No login in 14 days
    if (activity.last_login_days_ago > 14) riskScore += 0.3;
    
    // No forms created
    if (usage.forms_created === 0) riskScore += 0.2;
    
    // No invitations sent
    if (usage.invitations_sent === 0) riskScore += 0.2;
    
    // Support tickets
    if (activity.support_tickets > 2) riskScore += 0.1;
    
    // Feature usage below average
    if (usage.feature_usage_score < 0.3) riskScore += 0.2;
    
    return Math.min(riskScore, 1.0);
  }
  
  async triggerRetentionAction(userId: string, riskScore: number) {
    if (riskScore > 0.7) {
      await this.sendWinBackOffer(userId);
    } else if (riskScore > 0.5) {
      await this.sendReEngagementEmail(userId);
    } else if (riskScore > 0.3) {
      await this.sendUsageReport(userId);
    }
    
    await this.logIntervention(userId, 'automated_outreach', riskScore);
  }
}
```

### CODE EXAMPLES

#### Example 1: Subscription Management
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import Stripe from 'stripe';
import { createClient } from '@/lib/supabase/server';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!);

export class SubscriptionManager {
  private supabase = createClient();
  
  async createSubscription(userId: string, tierId: string, billingPeriod: 'monthly' | 'annual') {
    // Get tier details
    const { data: tier } = await this.supabase
      .from('subscription_tiers')
      .select('*')
      .eq('id', tierId)
      .single();
    
    if (!tier) throw new Error('Tier not found');
    
    // Get or create Stripe customer
    const { data: user } = await this.supabase
      .from('users')
      .select('stripe_customer_id, email')
      .eq('id', userId)
      .single();
    
    let customerId = user?.stripe_customer_id;
    if (!customerId) {
      const customer = await stripe.customers.create({
        email: user?.email,
        metadata: { user_id: userId }
      });
      customerId = customer.id;
      
      await this.supabase
        .from('users')
        .update({ stripe_customer_id: customerId })
        .eq('id', userId);
    }
    
    // Create subscription
    const price = billingPeriod === 'annual' ? tier.annual_price_gbp : tier.monthly_price_gbp;
    const priceId = await this.getStripePriceId(tier.tier_name, billingPeriod);
    
    const subscription = await stripe.subscriptions.create({
      customer: customerId,
      items: [{ price: priceId }],
      metadata: {
        user_id: userId,
        tier_name: tier.tier_name
      }
    });
    
    // Save to database
    await this.supabase.from('user_subscriptions').insert({
      user_id: userId,
      tier_id: tierId,
      stripe_subscription_id: subscription.id,
      stripe_customer_id: customerId,
      billing_period: billingPeriod,
      current_period_start: new Date(subscription.current_period_start * 1000),
      current_period_end: new Date(subscription.current_period_end * 1000),
      status: subscription.status
    });
    
    return subscription;
  }
  
  async handleUpgradeTrigger(userId: string, trigger: string) {
    const upgradeTriggers = {
      'form_limit_reached': 'starter',
      'login_limit_exceeded': 'professional',
      'automation_needed': 'professional',
      'team_growth': 'scale'
    };
    
    const recommendedTier = upgradeTriggers[trigger];
    
    if (recommendedTier) {
      // Send upgrade notification
      await this.sendUpgradeNotification(userId, {
        trigger,
        recommended_tier: recommendedTier,
        discount_offered: this.getUpgradeDiscount(trigger)
      });
      
      // Track conversion opportunity
      await this.trackUpgradeOpportunity(userId, trigger, recommendedTier);
    }
  }
}
```

#### Example 2: Revenue Analytics Dashboard
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import React, { useEffect, useState } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';

export function RevenueAnalyticsDashboard() {
  const [metrics, setMetrics] = useState<RevenueMetrics | null>(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    loadRevenueMetrics();
  }, []);
  
  const loadRevenueMetrics = async () => {
    try {
      const response = await fetch('/api/v1/revenue/metrics');
      const data = await response.json();
      setMetrics(data);
    } catch (error) {
      console.error('Failed to load revenue metrics:', error);
    } finally {
      setLoading(false);
    }
  };
  
  if (loading || !metrics) return <div>Loading...</div>;
  
  const mrrGrowth = ((metrics.current_mrr - metrics.previous_mrr) / metrics.previous_mrr) * 100;
  
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
      <Card>
        <CardHeader>
          <CardTitle>Monthly Recurring Revenue</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="text-3xl font-bold">
            £{metrics.current_mrr.toLocaleString()}
          </div>
          <div className={`text-sm ${
            mrrGrowth >= 0 ? 'text-green-600' : 'text-red-600'
          }`}>
            {mrrGrowth >= 0 ? '+' : ''}{mrrGrowth.toFixed(1)}% from last month
          </div>
          <div className="mt-4 text-sm text-muted-foreground">
            Target: £50k (12 months)
          </div>
        </CardContent>
      </Card>
      
      <Card>
        <CardHeader>
          <CardTitle>User Growth</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="text-3xl font-bold">
            {metrics.total_users.toLocaleString()}
          </div>
          <div className="text-sm text-muted-foreground">
            {metrics.paid_users} paid ({(metrics.conversion_rate * 100).toFixed(1)}%)
          </div>
          <div className="mt-2 space-y-1">
            {Object.entries(metrics.by_tier).map(([tier, data]) => (
              <div key={tier} className="flex justify-between text-xs">
                <span className="capitalize">{tier}:</span>
                <span>{data.users} users</span>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>
      
      <Card>
        <CardHeader>
          <CardTitle>Unit Economics</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-2">
            <div className="flex justify-between">
              <span className="text-sm">LTV:CAC Ratio</span>
              <span className="text-sm font-medium">
                {metrics.unit_economics.ltv_cac_ratio.toFixed(1)}x
              </span>
            </div>
            <div className="flex justify-between">
              <span className="text-sm">Payback Period</span>
              <span className="text-sm font-medium">
                {metrics.unit_economics.payback_period} months
              </span>
            </div>
            <div className="flex justify-between">
              <span className="text-sm">Gross Margin</span>
              <span className="text-sm font-medium">
                {(metrics.unit_economics.gross_margin * 100).toFixed(0)}%
              </span>
            </div>
          </div>
        </CardContent>
      </Card>
      
      <Card>
        <CardHeader>
          <CardTitle>Churn & Retention</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">
            {(metrics.churn.monthly_rate * 100).toFixed(1)}%
          </div>
          <div className="text-sm text-muted-foreground">
            Monthly churn rate
          </div>
          <div className="mt-4">
            <div className="text-sm text-yellow-600">
              {metrics.churn.at_risk_users} users at risk
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [ ] Context7: Load docs for Stripe, billing systems
- [ ] Supabase: Revenue analytics, subscription tracking
- [ ] GitHub: Version control for pricing configurations

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/stripe/stripe-node", "subscriptions", 3000);
await mcp__context7__get-library-docs("/stripe/stripe-node", "webhooks", 2000);
await mcp__context7__get-library-docs("/supabase/supabase", "database functions", 1500);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('Revenue Model', () => {
  it('should calculate MRR correctly', () => {
    const engine = new RevenueEngine();
    // Test MRR calculation across tiers
  });
  
  it('should trigger upgrades at right thresholds', () => {
    const manager = new SubscriptionManager();
    // Test upgrade trigger logic
  });
  
  it('should track unit economics accurately', () => {
    // Test LTV, CAC, payback period calculations
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Complete subscription flow works', async () => {
  await mcp__playwright__browser_navigate({url: '/pricing'});
  
  // Select professional tier
  await mcp__playwright__browser_click({
    element: 'professional tier subscribe button',
    ref: 'button[data-tier="professional"]'
  });
  
  // Complete payment flow
  await mcp__playwright__browser_fill_form({
    fields: [
      {name: 'card_number', type: 'textbox', ref: 'input[name="cardNumber"]', value: '4242424242424242'}
    ]
  });
  
  // Verify subscription active
  await mcp__playwright__browser_snapshot();
});
```

### ACCEPTANCE CRITERIA
- [ ] Freemium pricing model implemented with 5 tiers (free, starter, professional, scale, enterprise)
- [ ] Subscription management with Stripe integration
- [ ] Usage tracking and upgrade trigger system
- [ ] Revenue analytics dashboard with MRR, unit economics
- [ ] Churn prevention system with risk assessment
- [ ] Discount and promotion management
- [ ] Annual billing with 20% discount
- [ ] Marketplace commission tracking (30% platform take)
- [ ] Financial targets tracked (£50k MRR goal)
- [ ] Unit economics maintained (29.4 LTV:CAC ratio)

### DEPENDENCIES
- Must complete after: Viral growth strategy (WS-290)
- Must complete before: Success metrics (WS-292)
- Shares code with: User management, analytics system, notification system

### ESTIMATED EFFORT
- Team A Frontend: 20 hours (pricing UI, billing dashboard, upgrade flows)
- Team B Backend: 32 hours (subscription API, usage tracking, churn prevention)
- Team C Integration: 24 hours (Stripe integration, webhook handling, payment flows)
- Team D Platform: 4 hours (pricing optimization)
- Team E General: 8 hours (revenue model documentation)
- Team F Workflows: 6 hours (billing workflow integration)
- Team G Performance: 4 hours (billing system optimization)
- Total: 98 hours