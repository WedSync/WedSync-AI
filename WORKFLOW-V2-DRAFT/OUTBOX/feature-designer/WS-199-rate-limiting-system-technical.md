# TECHNICAL SPECIFICATION: WS-199 - Rate Limiting System
## Generated by Feature Development Session - August 25, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** WedSync platform infrastructure engineer managing API performance and abuse prevention
**I want to:** Implement comprehensive rate limiting with tiered access, endpoint-specific limits, and abuse protection
**So that:** I can ensure that during peak wedding season when 500+ suppliers are simultaneously managing clients, the API remains responsive for all users; prevent abuse from bad actors attempting to scrape wedding vendor data; and provide premium subscribers with higher rate limits that support their larger business operations while maintaining fair access for free tier users

**Real Wedding Scenario:**
During a Saturday evening in peak wedding season, a premium photography supplier with 25 active couples is bulk-importing client information while couples are simultaneously submitting consultation forms. The rate limiting system allows the premium supplier 2000 API requests per hour versus 400 for free accounts, preventing them from overwhelming the system while ensuring fair access. Meanwhile, a competitor attempting to scrape vendor portfolios hits their 100 requests/hour limit after 15 minutes and receives a clear error message with upgrade options. The system detects unusual patterns - 10 requests per second to the supplier search API - and automatically implements progressive backoff, protecting the platform while legitimate wedding planning activities continue uninterrupted.

### SPECIFICATION SOURCE
- **Feature ID:** WS-199
- **Original Spec:** /CORE-SPECIFICATIONS/01-TECHNICAL-ARCHITECTURE/03-API-Architecture/04-rate-limiting md.md
- **Current Implementation:** 0% complete (new)
- **Files to Modify:** None (new feature)
- **New Files to Create:** 
  - `/wedsync/lib/rate-limiting/rate-limiter.ts`
  - `/wedsync/lib/rate-limiting/redis-store.ts`
  - `/wedsync/lib/rate-limiting/tier-configuration.ts`
  - `/wedsync/lib/rate-limiting/abuse-detection.ts`
  - `/wedsync/middleware/rate-limit.ts`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Rate limiting configuration and metrics
CREATE TABLE rate_limit_configurations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  endpoint_pattern TEXT UNIQUE NOT NULL,
  
  -- Rate limiting rules
  requests_per_minute INTEGER NOT NULL DEFAULT 60,
  requests_per_hour INTEGER NOT NULL DEFAULT 1000,
  requests_per_day INTEGER NOT NULL DEFAULT 10000,
  burst_limit INTEGER NOT NULL DEFAULT 10, -- Allows short bursts
  
  -- Subscription tier multipliers
  free_tier_multiplier DECIMAL(3,2) DEFAULT 1.0,
  basic_tier_multiplier DECIMAL(3,2) DEFAULT 2.0,
  premium_tier_multiplier DECIMAL(3,2) DEFAULT 5.0,
  enterprise_tier_multiplier DECIMAL(3,2) DEFAULT 10.0,
  
  -- Wedding industry context
  applies_to_user_types TEXT[] NOT NULL DEFAULT ARRAY['supplier', 'couple'],
  vendor_type_specific TEXT[], -- ['photographer', 'venue'] if endpoint is vendor-specific
  seasonal_multiplier DECIMAL(3,2) DEFAULT 1.0, -- Higher limits during wedding season
  
  -- Abuse prevention
  violation_threshold INTEGER DEFAULT 3, -- Violations before stricter limits
  progressive_backoff BOOLEAN DEFAULT TRUE,
  temporary_block_minutes INTEGER DEFAULT 60,
  
  -- Endpoint metadata
  operation_cost INTEGER DEFAULT 1, -- Computational cost (1-10)
  requires_authentication BOOLEAN DEFAULT TRUE,
  
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Rate limiting violations and abuse tracking
CREATE TABLE rate_limit_violations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Violation details
  identifier TEXT NOT NULL, -- User ID or IP address
  endpoint_pattern TEXT NOT NULL,
  violation_type TEXT NOT NULL CHECK (violation_type IN (
    'minute_exceeded', 'hour_exceeded', 'day_exceeded', 'burst_exceeded', 
    'suspicious_pattern', 'blocked_request'
  )),
  
  -- Context during violation
  requests_made INTEGER NOT NULL,
  limit_exceeded INTEGER NOT NULL,
  window_type TEXT NOT NULL, -- 'minute', 'hour', 'day'
  
  -- User and business context
  user_id UUID REFERENCES users(id),
  supplier_id UUID REFERENCES suppliers(id),
  subscription_tier TEXT,
  ip_address INET NOT NULL,
  user_agent TEXT,
  
  -- Wedding industry context
  during_peak_season BOOLEAN DEFAULT FALSE,
  vendor_type TEXT, -- If user is a specific vendor type
  affected_couples UUID[], -- Couples potentially affected by abuse
  
  -- Response action taken
  action_taken TEXT NOT NULL CHECK (action_taken IN (
    'throttled', 'temporary_block', 'captcha_challenge', 'account_review', 'ignored'
  )),
  block_duration_minutes INTEGER,
  progressive_backoff_applied BOOLEAN DEFAULT FALSE,
  
  -- Resolution tracking
  is_resolved BOOLEAN DEFAULT FALSE,
  resolved_at TIMESTAMPTZ,
  resolution_action TEXT,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_violations_identifier ON rate_limit_violations(identifier, created_at DESC);
CREATE INDEX idx_violations_endpoint ON rate_limit_violations(endpoint_pattern, created_at DESC);
CREATE INDEX idx_violations_unresolved ON rate_limit_violations(is_resolved, created_at DESC) WHERE is_resolved = FALSE;

-- Real-time rate limit tracking (Redis alternative in PostgreSQL for persistence)
CREATE TABLE rate_limit_buckets (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  bucket_key TEXT UNIQUE NOT NULL, -- Format: {user_id}:{endpoint}:{window}
  
  -- Bucket state
  current_count INTEGER NOT NULL DEFAULT 0,
  limit_value INTEGER NOT NULL,
  window_start TIMESTAMPTZ NOT NULL,
  window_end TIMESTAMPTZ NOT NULL,
  
  -- User context
  user_id UUID REFERENCES users(id),
  identifier TEXT NOT NULL, -- User ID or IP
  endpoint_pattern TEXT NOT NULL,
  subscription_tier TEXT NOT NULL DEFAULT 'free',
  
  -- Bucket metadata
  window_type TEXT NOT NULL CHECK (window_type IN ('minute', 'hour', 'day')),
  last_request_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- Abuse tracking
  violation_count INTEGER DEFAULT 0,
  last_violation_at TIMESTAMPTZ,
  is_temporarily_blocked BOOLEAN DEFAULT FALSE,
  blocked_until TIMESTAMPTZ,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_buckets_key ON rate_limit_buckets(bucket_key);
CREATE INDEX idx_buckets_user ON rate_limit_buckets(user_id, endpoint_pattern);
CREATE INDEX idx_buckets_cleanup ON rate_limit_buckets(window_end) WHERE current_count = 0;

-- Rate limiting performance metrics
CREATE TABLE rate_limit_metrics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  measurement_date DATE NOT NULL,
  endpoint_pattern TEXT NOT NULL,
  
  -- Request metrics
  total_requests INTEGER NOT NULL DEFAULT 0,
  blocked_requests INTEGER NOT NULL DEFAULT 0,
  throttled_requests INTEGER NOT NULL DEFAULT 0,
  
  -- Response time impact
  avg_response_time_ms INTEGER,
  rate_limit_overhead_ms DECIMAL(8,3), -- Time spent on rate limiting
  
  -- User tier breakdown
  free_tier_requests INTEGER DEFAULT 0,
  basic_tier_requests INTEGER DEFAULT 0,
  premium_tier_requests INTEGER DEFAULT 0,
  enterprise_tier_requests INTEGER DEFAULT 0,
  
  -- Wedding business metrics
  supplier_requests INTEGER DEFAULT 0,
  couple_requests INTEGER DEFAULT 0,
  peak_season_multiplier_applied INTEGER DEFAULT 0,
  
  -- Abuse prevention effectiveness
  attacks_prevented INTEGER DEFAULT 0,
  false_positive_blocks INTEGER DEFAULT 0,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(measurement_date, endpoint_pattern)
);

-- Subscription tier limits configuration
CREATE TABLE subscription_rate_limits (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tier_name TEXT NOT NULL, -- 'free', 'basic', 'premium', 'enterprise'
  
  -- Global limits
  requests_per_minute INTEGER NOT NULL,
  requests_per_hour INTEGER NOT NULL,
  requests_per_day INTEGER NOT NULL,
  
  -- Special endpoint limits
  ai_requests_per_day INTEGER DEFAULT 0, -- 0 means not allowed
  upload_requests_per_hour INTEGER DEFAULT 10,
  search_requests_per_minute INTEGER DEFAULT 30,
  form_submissions_per_hour INTEGER DEFAULT 20,
  
  -- Wedding season adjustments
  peak_season_multiplier DECIMAL(3,2) DEFAULT 1.0,
  
  -- Business limits
  max_clients_manageable INTEGER, -- For suppliers
  max_forms_per_client INTEGER,
  max_portfolio_images INTEGER,
  
  -- Abuse protection
  burst_tolerance INTEGER DEFAULT 5, -- Extra requests allowed in burst
  progressive_backoff_threshold INTEGER DEFAULT 3,
  
  is_active BOOLEAN DEFAULT TRUE,
  effective_from DATE NOT NULL DEFAULT CURRENT_DATE,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

#### API Endpoints Required
```typescript
// Rate limiting management and monitoring endpoints
// GET /api/admin/rate-limits/status
interface RateLimitStatusResponse {
  success: boolean;
  data: {
    globalMetrics: {
      totalRequests: number;
      blockedRequests: number;
      averageResponseTime: number;
    };
    endpointMetrics: EndpointRateMetrics[];
    activeViolations: RateViolation[];
    tierUsage: TierUsageMetrics[];
  };
}

// POST /api/rate-limits/check
interface RateLimitCheckRequest {
  endpoint: string;
  identifier?: string; // Optional user ID override
}

interface RateLimitCheckResponse {
  success: boolean;
  data: {
    allowed: boolean;
    remaining: number;
    resetTime: number;
    retryAfter?: number;
  };
}
```

#### Frontend Components Required
```typescript
// Component: RateLimitMonitor
// Location: /src/components/admin/RateLimitMonitor.tsx

interface Props {
  rateLimitMetrics: RateLimitMetrics[];
  violationAlerts: RateViolation[];
  subscriptionTierLimits: TierLimits[];
}

// Key functionality:
- Real-time rate limiting dashboard with endpoint-specific monitoring
- Abuse detection alerts with pattern recognition and automated responses
- Subscription tier usage visualization with upgrade recommendations
- Rate limit configuration interface for administrators
```

#### Integration Points
```typescript
// Service: RateLimiter
// Dependencies: Redis/PostgreSQL storage, subscription management, abuse detection

class RateLimiter {
  async checkRateLimit(request: RateLimitRequest): Promise<RateLimitResult> {
    // Comprehensive rate limiting with subscription tier awareness and abuse detection
  }
  
  async recordViolation(violation: RateViolation): Promise<void> {
    // Track violations with business context and automated response triggers
  }
}
```

### CODE EXAMPLES

#### Example 1: Comprehensive Rate Limiting System
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
// lib/rate-limiting/rate-limiter.ts

import { createClient } from '@supabase/supabase-js';
import { Redis } from '@upstash/redis';
import { v4 as uuidv4 } from 'uuid';

// Wedding industry rate limiting configuration
interface WedSyncRateLimitConfig {
  endpoint: string;
  userType: 'supplier' | 'couple' | 'admin';
  subscriptionTier: 'free' | 'basic' | 'premium' | 'enterprise';
  limits: {
    minute: number;
    hour: number;
    day: number;
    burst?: number;
  };
  costs: {
    computational: number; // 1-10 scale
    bandwidth: number; // 1-10 scale
    storage: number; // 1-10 scale
  };
  weddingIndustryContext: {
    vendorType?: string;
    isWeddingSeason?: boolean;
    requiresPremium?: boolean;
  };
}

export class WedSyncRateLimiter {
  private redis: Redis;
  private supabase: any;
  
  // Wedding industry specific rate limit configurations
  private readonly ENDPOINT_CONFIGS: Record<string, WedSyncRateLimitConfig> = {
    '/api/suppliers/search': {
      endpoint: '/api/suppliers/search',
      userType: 'supplier',
      subscriptionTier: 'free',
      limits: { minute: 30, hour: 1000, day: 5000 },
      costs: { computational: 3, bandwidth: 2, storage: 1 },
      weddingIndustryContext: { isWeddingSeason: true }
    },
    '/api/forms/submit': {
      endpoint: '/api/forms/submit',
      userType: 'couple',
      subscriptionTier: 'free',
      limits: { minute: 5, hour: 50, day: 200 },
      costs: { computational: 5, bandwidth: 4, storage: 6 },
      weddingIndustryContext: { requiresPremium: false }
    },
    '/api/ai/generate': {
      endpoint: '/api/ai/generate',
      userType: 'supplier',
      subscriptionTier: 'basic',
      limits: { minute: 2, hour: 30, day: 100 },
      costs: { computational: 9, bandwidth: 3, storage: 2 },
      weddingIndustryContext: { requiresPremium: true }
    },
    '/api/uploads/portfolio': {
      endpoint: '/api/uploads/portfolio',
      userType: 'supplier',
      subscriptionTier: 'free',
      limits: { minute: 3, hour: 20, day: 100, burst: 5 },
      costs: { computational: 4, bandwidth: 8, storage: 9 },
      weddingIndustryContext: { vendorType: 'photographer' }
    },
    '/api/suppliers/{id}/clients': {
      endpoint: '/api/suppliers/{id}/clients',
      userType: 'supplier',
      subscriptionTier: 'free',
      limits: { minute: 20, hour: 500, day: 2000 },
      costs: { computational: 2, bandwidth: 3, storage: 1 },
      weddingIndustryContext: {}
    }
  };

  // Subscription tier multipliers for wedding industry
  private readonly SUBSCRIPTION_MULTIPLIERS = {
    free: { minute: 1.0, hour: 1.0, day: 1.0 },
    basic: { minute: 2.0, hour: 2.5, day: 3.0 },
    premium: { minute: 5.0, hour: 7.0, day: 10.0 },
    enterprise: { minute: 20.0, hour: 25.0, day: 50.0 }
  };

  // Wedding season multipliers (May-September peak)
  private readonly SEASONAL_MULTIPLIERS = {
    peak: 1.5, // Wedding season (May-September)
    normal: 1.0, // Off-season
    holiday: 0.8 // Reduced during holidays
  };

  constructor() {
    this.redis = new Redis({
      url: process.env.UPSTASH_REDIS_REST_URL!,
      token: process.env.UPSTASH_REDIS_REST_TOKEN!,
    });

    this.supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_KEY!
    );
  }

  async checkRateLimit(request: RateLimitRequest): Promise<RateLimitResult> {
    const startTime = Date.now();
    
    try {
      // Step 1: Determine rate limit configuration
      const config = await this.getRateLimitConfig(
        request.endpoint,
        request.userType,
        request.subscriptionTier,
        request.vendorType
      );

      // Step 2: Calculate effective limits with multipliers
      const effectiveLimits = this.calculateEffectiveLimits(
        config,
        request.subscriptionTier,
        request.isWeddingSeason
      );

      // Step 3: Check current usage across all time windows
      const currentUsage = await this.getCurrentUsage(
        request.identifier,
        request.endpoint,
        ['minute', 'hour', 'day']
      );

      // Step 4: Determine if request should be allowed
      const rateLimitResult = this.evaluateRateLimit(
        currentUsage,
        effectiveLimits,
        config.limits.burst
      );

      // Step 5: Handle violations and abuse detection
      if (!rateLimitResult.allowed) {
        await this.handleRateLimitViolation({
          identifier: request.identifier,
          endpoint: request.endpoint,
          violationType: rateLimitResult.violationType!,
          currentUsage,
          effectiveLimits,
          userContext: {
            userId: request.userId,
            supplierId: request.supplierId,
            subscriptionTier: request.subscriptionTier,
            userType: request.userType,
            vendorType: request.vendorType
          }
        });

        return {
          allowed: false,
          remaining: 0,
          resetTime: rateLimitResult.resetTime!,
          retryAfter: rateLimitResult.retryAfter!,
          violationType: rateLimitResult.violationType!,
          upgradeRecommendation: this.getUpgradeRecommendation(request.subscriptionTier),
          processingTime: Date.now() - startTime
        };
      }

      // Step 6: Increment counters for allowed requests
      await this.incrementRateLimitCounters(
        request.identifier,
        request.endpoint
      );

      // Step 7: Log successful rate limit check
      await this.logRateLimitMetrics({
        endpoint: request.endpoint,
        allowed: true,
        subscriptionTier: request.subscriptionTier,
        processingTimeMs: Date.now() - startTime,
        isWeddingSeason: request.isWeddingSeason
      });

      return {
        allowed: true,
        remaining: Math.min(
          effectiveLimits.minute - currentUsage.minute,
          effectiveLimits.hour - currentUsage.hour,
          effectiveLimits.day - currentUsage.day
        ),
        resetTime: this.getNextResetTime(),
        processingTime: Date.now() - startTime
      };

    } catch (error) {
      console.error('Rate limiting error:', error);
      
      // Fail open - allow request but log the error
      await this.logRateLimitError({
        error: error instanceof Error ? error.message : 'Unknown error',
        request,
        processingTime: Date.now() - startTime
      });

      return {
        allowed: true,
        remaining: 100, // Conservative fallback
        resetTime: Date.now() + 60000, // 1 minute
        processingTime: Date.now() - startTime
      };
    }
  }

  private async getRateLimitConfig(
    endpoint: string, 
    userType: string, 
    subscriptionTier: string,
    vendorType?: string
  ): Promise<WedSyncRateLimitConfig> {
    // First check for exact endpoint match
    let config = this.ENDPOINT_CONFIGS[endpoint];
    
    // If not found, check for pattern match
    if (!config) {
      const patternMatch = Object.keys(this.ENDPOINT_CONFIGS)
        .find(pattern => this.matchesEndpointPattern(endpoint, pattern));
      
      if (patternMatch) {
        config = this.ENDPOINT_CONFIGS[patternMatch];
      }
    }

    // If still not found, check database configuration
    if (!config) {
      const { data: dbConfig } = await this.supabase
        .from('rate_limit_configurations')
        .select('*')
        .eq('endpoint_pattern', endpoint)
        .eq('is_active', true)
        .single();

      if (dbConfig) {
        config = this.convertDbConfigToConfig(dbConfig);
      }
    }

    // Fallback to default configuration
    if (!config) {
      config = this.getDefaultRateLimitConfig(userType, subscriptionTier);
    }

    return config;
  }

  private calculateEffectiveLimits(
    config: WedSyncRateLimitConfig,
    subscriptionTier: string,
    isWeddingSeason?: boolean
  ): { minute: number; hour: number; day: number } {
    const tierMultiplier = this.SUBSCRIPTION_MULTIPLIERS[subscriptionTier] || this.SUBSCRIPTION_MULTIPLIERS.free;
    const seasonMultiplier = isWeddingSeason ? this.SEASONAL_MULTIPLIERS.peak : this.SEASONAL_MULTIPLIERS.normal;

    return {
      minute: Math.floor(config.limits.minute * tierMultiplier.minute * seasonMultiplier),
      hour: Math.floor(config.limits.hour * tierMultiplier.hour * seasonMultiplier),
      day: Math.floor(config.limits.day * tierMultiplier.day * seasonMultiplier)
    };
  }

  private async getCurrentUsage(
    identifier: string,
    endpoint: string,
    windows: string[]
  ): Promise<{ minute: number; hour: number; day: number }> {
    const now = Date.now();
    const usage = { minute: 0, hour: 0, day: 0 };

    for (const window of windows) {
      const windowMs = this.getWindowDuration(window);
      const key = `rate_limit:${identifier}:${endpoint}:${window}`;
      
      try {
        // Use Redis pipeline for efficiency
        const pipeline = this.redis.pipeline();
        pipeline.get(key);
        
        const results = await pipeline.exec();
        const count = results[0][1] as number || 0;
        
        usage[window] = count;
      } catch (error) {
        console.warn(`Failed to get usage for ${window}:`, error);
        // Continue with default value
      }
    }

    return usage;
  }

  private evaluateRateLimit(
    currentUsage: { minute: number; hour: number; day: number },
    effectiveLimits: { minute: number; hour: number; day: number },
    burstLimit?: number
  ): {
    allowed: boolean;
    violationType?: string;
    resetTime?: number;
    retryAfter?: number;
  } {
    const now = Date.now();

    // Check minute limit (most restrictive)
    if (currentUsage.minute >= effectiveLimits.minute) {
      // Allow burst if configured
      if (burstLimit && currentUsage.minute < effectiveLimits.minute + burstLimit) {
        // Allow but mark as burst usage
        return { allowed: true };
      }
      
      return {
        allowed: false,
        violationType: 'minute_exceeded',
        resetTime: now + (60 * 1000), // Next minute
        retryAfter: 60
      };
    }

    // Check hour limit
    if (currentUsage.hour >= effectiveLimits.hour) {
      return {
        allowed: false,
        violationType: 'hour_exceeded',
        resetTime: now + (60 * 60 * 1000), // Next hour
        retryAfter: 3600
      };
    }

    // Check daily limit
    if (currentUsage.day >= effectiveLimits.day) {
      return {
        allowed: false,
        violationType: 'day_exceeded',
        resetTime: now + (24 * 60 * 60 * 1000), // Next day
        retryAfter: 86400
      };
    }

    return { allowed: true };
  }

  private async handleRateLimitViolation(violation: RateLimitViolation): Promise<void> {
    try {
      // Log violation to database
      await this.supabase
        .from('rate_limit_violations')
        .insert({
          identifier: violation.identifier,
          endpoint_pattern: violation.endpoint,
          violation_type: violation.violationType,
          requests_made: violation.currentUsage.minute,
          limit_exceeded: violation.effectiveLimits.minute,
          window_type: 'minute', // Most common violation type
          
          user_id: violation.userContext.userId,
          supplier_id: violation.userContext.supplierId,
          subscription_tier: violation.userContext.subscriptionTier,
          
          during_peak_season: this.isWeddingSeason(),
          vendor_type: violation.userContext.vendorType,
          
          action_taken: this.determineViolationAction(violation),
          progressive_backoff_applied: await this.shouldApplyProgressiveBackoff(violation.identifier)
        });

      // Check for abuse patterns
      await this.detectAbusePatterns(violation);

      // Apply progressive penalties for repeat offenders
      await this.applyProgressivePenalties(violation);

    } catch (error) {
      console.error('Failed to handle rate limit violation:', error);
    }
  }

  private async incrementRateLimitCounters(identifier: string, endpoint: string): Promise<void> {
    const windows = ['minute', 'hour', 'day'];
    const now = Date.now();

    try {
      const pipeline = this.redis.pipeline();

      for (const window of windows) {
        const windowMs = this.getWindowDuration(window);
        const key = `rate_limit:${identifier}:${endpoint}:${window}`;
        const expiry = Math.floor(windowMs / 1000);

        pipeline.incr(key);
        pipeline.expire(key, expiry);
      }

      await pipeline.exec();
    } catch (error) {
      console.error('Failed to increment rate limit counters:', error);
    }
  }

  private async detectAbusePatterns(violation: RateLimitViolation): Promise<void> {
    // Check for suspicious patterns
    const recentViolations = await this.supabase
      .from('rate_limit_violations')
      .select('*')
      .eq('identifier', violation.identifier)
      .gte('created_at', new Date(Date.now() - 60 * 60 * 1000).toISOString()) // Last hour
      .order('created_at', { ascending: false });

    if (recentViolations.data && recentViolations.data.length >= 5) {
      // Multiple violations in short time - likely abuse
      await this.escalateAbuseDetection({
        identifier: violation.identifier,
        violationCount: recentViolations.data.length,
        pattern: 'rapid_violations',
        severity: 'high'
      });
    }
  }

  private getUpgradeRecommendation(currentTier: string): {
    suggestedTier: string;
    benefits: string[];
    pricing?: string;
  } {
    const recommendations = {
      free: {
        suggestedTier: 'basic',
        benefits: [
          '2x more API requests',
          'Priority support',
          'Advanced analytics'
        ]
      },
      basic: {
        suggestedTier: 'premium',
        benefits: [
          '5x more API requests',
          'AI-powered features',
          'Custom integrations'
        ]
      },
      premium: {
        suggestedTier: 'enterprise',
        benefits: [
          'Unlimited API requests',
          'Dedicated support',
          'Custom development'
        ]
      }
    };

    return recommendations[currentTier] || recommendations.free;
  }

  private getWindowDuration(window: string): number {
    const durations = {
      minute: 60 * 1000,
      hour: 60 * 60 * 1000,
      day: 24 * 60 * 60 * 1000
    };
    return durations[window] || durations.minute;
  }

  private getNextResetTime(): number {
    const now = Date.now();
    const nextMinute = Math.ceil(now / 60000) * 60000;
    return nextMinute;
  }

  private isWeddingSeason(): boolean {
    const month = new Date().getMonth() + 1; // 1-12
    return month >= 5 && month <= 9; // May through September
  }

  private matchesEndpointPattern(endpoint: string, pattern: string): boolean {
    // Simple pattern matching for dynamic routes
    const patternRegex = pattern.replace(/\{[^}]+\}/g, '[^/]+');
    return new RegExp(`^${patternRegex}$`).test(endpoint);
  }

  private getDefaultRateLimitConfig(userType: string, subscriptionTier: string): WedSyncRateLimitConfig {
    return {
      endpoint: 'default',
      userType: userType as any,
      subscriptionTier: subscriptionTier as any,
      limits: { minute: 10, hour: 100, day: 1000 },
      costs: { computational: 1, bandwidth: 1, storage: 1 },
      weddingIndustryContext: {}
    };
  }
}

// Types for rate limiting
interface RateLimitRequest {
  identifier: string; // User ID or IP address
  endpoint: string;
  userId?: string;
  supplierId?: string;
  subscriptionTier: string;
  userType: 'supplier' | 'couple' | 'admin';
  vendorType?: string;
  isWeddingSeason?: boolean;
}

interface RateLimitResult {
  allowed: boolean;
  remaining: number;
  resetTime: number;
  retryAfter?: number;
  violationType?: string;
  upgradeRecommendation?: {
    suggestedTier: string;
    benefits: string[];
  };
  processingTime: number;
}

interface RateLimitViolation {
  identifier: string;
  endpoint: string;
  violationType: string;
  currentUsage: { minute: number; hour: number; day: number };
  effectiveLimits: { minute: number; hour: number; day: number };
  userContext: {
    userId?: string;
    supplierId?: string;
    subscriptionTier: string;
    userType: string;
    vendorType?: string;
  };
}

// Export singleton instance
export const rateLimiter = new WedSyncRateLimiter();

// Middleware integration function
export async function checkRateLimit(request: RateLimitRequest): Promise<RateLimitResult> {
  return rateLimiter.checkRateLimit(request);
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for Redis rate limiting, Upstash patterns
- [x] Supabase: Rate limit configuration and violation tracking
- [x] Redis: Real-time counter management and distributed caching

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/upstash/upstash-redis", "rate limiting patterns", 4000);
await mcp__context7__get-library-docs("/vercel/next.js", "api middleware", 3000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('Rate Limiting System', () => {
  it('should apply subscription tier multipliers correctly for wedding suppliers', () => {
    // Test tier-based rate limiting with wedding industry context
  });
  
  it('should implement progressive backoff for repeated violations', () => {
    // Test abuse detection and progressive penalty application
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Rate limiting blocks excessive requests with clear upgrade messaging', async () => {
  // Simulate rapid API requests to trigger rate limiting
  const promises = [];
  for (let i = 0; i < 15; i++) {
    promises.push(page.request.get('/api/suppliers/search'));
  }
  
  const responses = await Promise.all(promises);
  const blockedResponses = responses.filter(r => r.status() === 429);
  
  expect(blockedResponses.length).toBeGreaterThan(0);
  
  const rateLimitResponse = await blockedResponses[0].json();
  expect(rateLimitResponse.error.upgradeRecommendation).toBeDefined();
});
```

### ACCEPTANCE CRITERIA
- [x] Rate limiting enforces subscription tier limits (free: 1x, premium: 5x) with wedding season multipliers
- [x] Abuse detection identifies patterns and applies progressive backoff with temporary blocking
- [x] API responses include proper rate limit headers (X-RateLimit-Limit, Remaining, Reset)
- [x] Performance: Rate limit checks complete within 5ms using Redis caching
- [x] Security: Distributed rate limiting prevents circumvention across multiple servers
- [x] Accessibility: Rate limit error messages include clear upgrade paths and retry guidance

### DEPENDENCIES
- Must complete after: WS-196 (API Routes Structure), WS-197 (Middleware Setup) - provides middleware pipeline
- Must complete before: All API endpoint development, abuse prevention systems
- Shares code with: Middleware infrastructure, subscription management, monitoring systems

### ESTIMATED EFFORT
- Team A Backend: 56 hours (Rate limiting logic, violation handling, abuse detection)
- Team B Infrastructure: 40 hours (Redis setup, monitoring, configuration management)
- Total: 96 hours