# TECHNICAL SPECIFICATION: WS-096 - Deployment Pipeline Implementation
## Generated by Feature Development Session - 2025-08-22

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** WedSync development team and wedding suppliers
**I want to:** Seamless, automated deployment pipeline with zero-downtime deployments
**So that:** Wedding suppliers never experience downtime during peak booking periods, and couples can always access their forms and vendor communications

**Real Wedding Scenario:**
A venue needs to update their capacity fields during wedding season. With the deployment pipeline, updates deploy seamlessly without interrupting ongoing bookings. Couples continue submitting forms while the venue's new fields go live instantly, preventing lost bookings during the 4-6pm peak inquiry hours.

### SPECIFICATION SOURCE
- **Feature ID:** WS-096
- **Original Spec:** /CORE-SPECIFICATIONS/11-TESTING-DEPLOYMENT/02-CI-CD/02-deployment-pipeline md.md
- **Current Implementation:** 0% complete
- **Files to Modify:** 
  - /wedsync/next.config.js (add deployment config)
  - /wedsync/package.json (add deployment scripts)
- **New Files to Create:** 
  - /scripts/deployment/blue-green-deploy.sh
  - /scripts/deployment/health-check.sh
  - /scripts/deployment/database-migration.sh
  - /scripts/deployment/rollback.sh
  - /.github/workflows/deployment-pipeline.yml
  - /deployment/kubernetes/deployment.yaml
  - /deployment/docker/Dockerfile.production

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Deployment pipeline tracking
CREATE TABLE IF NOT EXISTS deployment_pipeline_runs (
  id SERIAL PRIMARY KEY,
  pipeline_id UUID DEFAULT uuid_generate_v4(),
  deployment_id UUID REFERENCES deployments(deployment_id),
  pipeline_stage VARCHAR(50) NOT NULL, -- 'build', 'test', 'deploy', 'verify', 'promote'
  stage_status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'running', 'success', 'failed', 'skipped'
  environment VARCHAR(20) NOT NULL,
  git_sha VARCHAR(40) NOT NULL,
  started_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  completed_at TIMESTAMP WITH TIME ZONE,
  duration_seconds INTEGER,
  stage_logs TEXT,
  stage_artifacts JSONB,
  error_details TEXT,
  retry_count INTEGER DEFAULT 0,
  metadata JSONB
);

-- Blue-green deployment tracking
CREATE TABLE IF NOT EXISTS blue_green_deployments (
  id SERIAL PRIMARY KEY,
  deployment_id UUID REFERENCES deployments(deployment_id),
  environment VARCHAR(20) NOT NULL,
  active_slot VARCHAR(10) NOT NULL, -- 'blue' or 'green'
  inactive_slot VARCHAR(10) NOT NULL,
  active_url VARCHAR(500) NOT NULL,
  inactive_url VARCHAR(500) NOT NULL,
  switch_timestamp TIMESTAMP WITH TIME ZONE,
  rollback_timestamp TIMESTAMP WITH TIME ZONE,
  health_check_results JSONB,
  traffic_split JSONB, -- For canary deployments
  metadata JSONB
);

-- Database migration tracking
CREATE TABLE IF NOT EXISTS migration_deployments (
  id SERIAL PRIMARY KEY,
  deployment_id UUID REFERENCES deployments(deployment_id),
  migration_batch VARCHAR(50) NOT NULL,
  migration_files TEXT[] NOT NULL,
  migration_status VARCHAR(20) DEFAULT 'pending',
  pre_migration_backup VARCHAR(500),
  migration_logs TEXT,
  rollback_sql TEXT,
  applied_at TIMESTAMP WITH TIME ZONE,
  rolled_back_at TIMESTAMP WITH TIME ZONE,
  metadata JSONB
);

-- Health check monitoring
CREATE TABLE IF NOT EXISTS deployment_health_checks (
  id SERIAL PRIMARY KEY,
  deployment_id UUID REFERENCES deployments(deployment_id),
  check_name VARCHAR(100) NOT NULL,
  check_type VARCHAR(50) NOT NULL, -- 'http', 'database', 'external_api', 'performance'
  check_status VARCHAR(20) DEFAULT 'pending',
  response_time_ms INTEGER,
  status_code INTEGER,
  response_body TEXT,
  error_message TEXT,
  checked_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  metadata JSONB
);

-- Create performance indexes
CREATE INDEX IF NOT EXISTS idx_pipeline_runs_deployment ON deployment_pipeline_runs(deployment_id, pipeline_stage);
CREATE INDEX IF NOT EXISTS idx_blue_green_env ON blue_green_deployments(environment, active_slot);
CREATE INDEX IF NOT EXISTS idx_health_checks_deployment ON deployment_health_checks(deployment_id, check_status);
```

#### API Endpoints Required
```typescript
// Deployment pipeline API
export interface PipelineStage {
  stage: 'build' | 'test' | 'deploy' | 'verify' | 'promote';
  status: 'pending' | 'running' | 'success' | 'failed' | 'skipped';
  started_at: string;
  completed_at?: string;
  duration_seconds?: number;
  logs?: string;
  artifacts?: Record<string, any>;
  error_details?: string;
}

export interface DeploymentPipeline {
  pipeline_id: string;
  deployment_id: string;
  environment: string;
  git_sha: string;
  stages: PipelineStage[];
  overall_status: string;
  current_stage?: string;
}

// POST /api/deployment/pipeline/trigger
// GET /api/deployment/pipeline/:pipelineId/status
// POST /api/deployment/pipeline/:pipelineId/promote
// POST /api/deployment/pipeline/:pipelineId/rollback
// GET /api/deployment/health-checks/:deploymentId
// POST /api/deployment/blue-green/switch
```

#### Frontend Components Required
```typescript
// Deployment Pipeline Dashboard
interface DeploymentPipelineProps {
  pipelineId: string;
  realTimeUpdates?: boolean;
}

const DeploymentPipelineView: React.FC<DeploymentPipelineProps> = ({ 
  pipelineId, 
  realTimeUpdates = true 
}) => {
  const { data: pipeline, mutate } = useSWR(
    `/api/deployment/pipeline/${pipelineId}/status`,
    fetcher,
    { refreshInterval: realTimeUpdates ? 2000 : 0 }
  );

  return (
    <div className="deployment-pipeline">
      <PipelineHeader pipeline={pipeline} />
      <PipelineStages stages={pipeline?.stages || []} />
      <HealthCheckStatus deploymentId={pipeline?.deployment_id} />
      <DeploymentActions pipelineId={pipelineId} pipeline={pipeline} />
    </div>
  );
};

// Pipeline stage visualization
const PipelineStages: React.FC<{ stages: PipelineStage[] }> = ({ stages }) => {
  return (
    <div className="pipeline-stages flex items-center space-x-4">
      {stages.map((stage, index) => (
        <div key={stage.stage} className="flex items-center">
          <div className={`stage-node ${getStageStatusClass(stage.status)}`}>
            <StageIcon stage={stage.stage} status={stage.status} />
            <div className="stage-info">
              <h4 className="font-medium">{stage.stage.toUpperCase()}</h4>
              <p className="text-sm text-gray-600">
                {stage.duration_seconds ? `${stage.duration_seconds}s` : 'Pending'}
              </p>
            </div>
          </div>
          {index < stages.length - 1 && (
            <div className="stage-connector w-8 h-px bg-gray-300" />
          )}
        </div>
      ))}
    </div>
  );
};

// Blue-Green deployment control
const BlueGreenControl: React.FC<{ deployment: BlueGreenDeployment }> = ({ deployment }) => {
  const switchSlots = async () => {
    await fetch(`/api/deployment/blue-green/switch`, {
      method: 'POST',
      body: JSON.stringify({ deployment_id: deployment.deployment_id })
    });
  };

  return (
    <div className="blue-green-control">
      <div className="flex space-x-4">
        <div className={`slot ${deployment.active_slot === 'blue' ? 'active' : 'inactive'}`}>
          <div className="slot-header">
            <span>Blue Environment</span>
            {deployment.active_slot === 'blue' && <Badge>ACTIVE</Badge>}
          </div>
          <div className="slot-url">{deployment.active_slot === 'blue' ? deployment.active_url : deployment.inactive_url}</div>
        </div>
        
        <div className="switch-control">
          <Button onClick={switchSlots} variant="primary" size="sm">
            Switch Traffic
          </Button>
        </div>
        
        <div className={`slot ${deployment.active_slot === 'green' ? 'active' : 'inactive'}`}>
          <div className="slot-header">
            <span>Green Environment</span>
            {deployment.active_slot === 'green' && <Badge>ACTIVE</Badge>}
          </div>
          <div className="slot-url">{deployment.active_slot === 'green' ? deployment.active_url : deployment.inactive_url}</div>
        </div>
      </div>
    </div>
  );
};
```

#### Integration Points
```typescript
// Deployment Pipeline Service
class DeploymentPipelineService {
  async triggerPipeline(deploymentConfig: DeploymentConfig) {
    const pipelineId = uuidv4();
    
    // Create pipeline run record
    const pipeline = await this.createPipelineRun(pipelineId, deploymentConfig);
    
    // Execute pipeline stages
    await this.executePipelineStages(pipeline);
    
    return pipeline;
  }
  
  async executePipelineStages(pipeline: DeploymentPipeline) {
    for (const stageName of ['build', 'test', 'deploy', 'verify', 'promote']) {
      try {
        await this.updateStageStatus(pipeline.pipeline_id, stageName, 'running');
        
        const stageResult = await this.executeStage(stageName, pipeline);
        
        await this.updateStageStatus(pipeline.pipeline_id, stageName, 'success', {
          logs: stageResult.logs,
          artifacts: stageResult.artifacts,
          duration_seconds: stageResult.duration
        });
      } catch (error) {
        await this.updateStageStatus(pipeline.pipeline_id, stageName, 'failed', {
          error_details: error.message,
          logs: error.logs
        });
        
        // Stop pipeline on failure
        break;
      }
    }
  }
  
  async executeBlueGreenDeployment(deploymentId: string, newVersion: string) {
    const currentDeployment = await this.getCurrentBlueGreenState(deploymentId);
    const inactiveSlot = currentDeployment.active_slot === 'blue' ? 'green' : 'blue';
    
    // Deploy to inactive slot
    await this.deployToSlot(inactiveSlot, newVersion);
    
    // Run health checks on inactive slot
    const healthChecks = await this.runHealthChecks(inactiveSlot);
    
    if (healthChecks.allPassed) {
      // Switch traffic to new version
      await this.switchTrafficToSlot(inactiveSlot);
      
      // Update blue-green state
      await this.updateBlueGreenState(deploymentId, {
        active_slot: inactiveSlot,
        inactive_slot: currentDeployment.active_slot,
        switch_timestamp: new Date().toISOString()
      });
    } else {
      throw new Error(`Health checks failed: ${healthChecks.failures.join(', ')}`);
    }
  }
}

// Health Check Service
class HealthCheckService {
  async runHealthChecks(deploymentId: string, environment: string) {
    const checks = [
      { name: 'api_health', type: 'http', url: '/api/health' },
      { name: 'database_connection', type: 'database' },
      { name: 'supabase_connection', type: 'external_api', url: 'supabase' },
      { name: 'form_submission', type: 'http', url: '/api/clients', method: 'POST' },
      { name: 'journey_execution', type: 'http', url: '/api/journeys/execute' }
    ];
    
    const results = await Promise.allSettled(
      checks.map(check => this.executeHealthCheck(deploymentId, check))
    );
    
    const passed = results.filter(r => r.status === 'fulfilled').length;
    const failed = results.filter(r => r.status === 'rejected').length;
    
    return {
      passed,
      failed,
      total: checks.length,
      allPassed: failed === 0,
      failures: results
        .filter(r => r.status === 'rejected')
        .map((r, i) => `${checks[i].name}: ${r.reason}`)
    };
  }
  
  async executeHealthCheck(deploymentId: string, check: HealthCheck) {
    const startTime = Date.now();
    let result;
    
    try {
      switch (check.type) {
        case 'http':
          result = await this.httpHealthCheck(check);
          break;
        case 'database':
          result = await this.databaseHealthCheck();
          break;
        case 'external_api':
          result = await this.externalAPIHealthCheck(check);
          break;
        default:
          throw new Error(`Unknown health check type: ${check.type}`);
      }
      
      await this.recordHealthCheck(deploymentId, check.name, {
        status: 'success',
        response_time_ms: Date.now() - startTime,
        ...result
      });
      
      return result;
    } catch (error) {
      await this.recordHealthCheck(deploymentId, check.name, {
        status: 'failed',
        response_time_ms: Date.now() - startTime,
        error_message: error.message
      });
      
      throw error;
    }
  }
}
```

### CODE EXAMPLES

#### Example 1: Blue-Green Deployment Script
```bash
#!/bin/bash
# scripts/deployment/blue-green-deploy.sh

set -e

ENVIRONMENT=${1:-staging}
GIT_SHA=${2:-HEAD}
DEPLOYMENT_ID=${3:-$(uuidgen)}

echo "üöÄ Starting Blue-Green deployment for $ENVIRONMENT"
echo "üì¶ Deploying SHA: $GIT_SHA"
echo "üÜî Deployment ID: $DEPLOYMENT_ID"

# Get current active slot
CURRENT_ACTIVE=$(curl -s "$SUPABASE_URL/rest/v1/blue_green_deployments?environment=eq.$ENVIRONMENT&select=active_slot" \
  -H "Authorization: Bearer $SUPABASE_SERVICE_ROLE_KEY" \
  | jq -r '.[0].active_slot // "blue"')

INACTIVE_SLOT="green"
if [ "$CURRENT_ACTIVE" = "green" ]; then
  INACTIVE_SLOT="blue"
fi

echo "üìç Current active: $CURRENT_ACTIVE, Deploying to: $INACTIVE_SLOT"

# Build application
echo "üèóÔ∏è Building application..."
cd wedsync
npm ci
npm run build

# Deploy to inactive slot
echo "üö¢ Deploying to $INACTIVE_SLOT slot..."
if [ "$INACTIVE_SLOT" = "blue" ]; then
  VERCEL_URL=$(npx vercel --prod --meta deployment_slot=blue --meta deployment_id="$DEPLOYMENT_ID" --token "$VERCEL_TOKEN")
else
  VERCEL_URL=$(npx vercel --prod --meta deployment_slot=green --meta deployment_id="$DEPLOYMENT_ID" --token "$VERCEL_TOKEN")
fi

echo "‚úÖ Deployed to: $VERCEL_URL"

# Wait for deployment to be ready
echo "‚è≥ Waiting for deployment to be ready..."
sleep 30

# Run health checks on inactive slot
echo "üè• Running health checks..."
HEALTH_CHECK_PASSED=true

# Check API health
HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$VERCEL_URL/api/health")
if [ "$HTTP_STATUS" -ne 200 ]; then
  echo "‚ùå API health check failed with status $HTTP_STATUS"
  HEALTH_CHECK_PASSED=false
fi

# Check database connection
DB_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$VERCEL_URL/api/status/database")
if [ "$DB_STATUS" -ne 200 ]; then
  echo "‚ùå Database health check failed with status $DB_STATUS"
  HEALTH_CHECK_PASSED=false
fi

# Check form submission
FORM_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -X POST "$VERCEL_URL/api/health/form-submission" \
  -H "Content-Type: application/json" \
  -d '{"test": true}')
if [ "$FORM_STATUS" -ne 200 ]; then
  echo "‚ùå Form submission health check failed with status $FORM_STATUS"
  HEALTH_CHECK_PASSED=false
fi

if [ "$HEALTH_CHECK_PASSED" = false ]; then
  echo "üí• Health checks failed, aborting deployment"
  exit 1
fi

echo "‚úÖ All health checks passed"

# Update deployment URL for inactive slot
curl -X PATCH "$SUPABASE_URL/rest/v1/blue_green_deployments?deployment_id=eq.$DEPLOYMENT_ID" \
  -H "Authorization: Bearer $SUPABASE_SERVICE_ROLE_KEY" \
  -H "Content-Type: application/json" \
  -d "{
    \"inactive_url\": \"$VERCEL_URL\",
    \"health_check_results\": {
      \"api_health\": $HTTP_STATUS,
      \"database_health\": $DB_STATUS,
      \"form_submission\": $FORM_STATUS
    }
  }"

# Switch traffic to new deployment
echo "üîÑ Switching traffic to $INACTIVE_SLOT slot..."

# Update DNS/Load Balancer to point to new deployment
# This would typically involve updating your load balancer configuration
# For Vercel, we'll use their deployment promotion API

if [ "$ENVIRONMENT" = "production" ]; then
  # Promote deployment to production domain
  npx vercel promote "$VERCEL_URL" --token "$VERCEL_TOKEN"
  PRODUCTION_URL="https://app.wedsync.com"
else
  # Update staging domain
  PRODUCTION_URL="https://staging.wedsync.com"
fi

# Update active slot in database
curl -X PATCH "$SUPABASE_URL/rest/v1/blue_green_deployments?deployment_id=eq.$DEPLOYMENT_ID" \
  -H "Authorization: Bearer $SUPABASE_SERVICE_ROLE_KEY" \
  -H "Content-Type: application/json" \
  -d "{
    \"active_slot\": \"$INACTIVE_SLOT\",
    \"inactive_slot\": \"$CURRENT_ACTIVE\",
    \"active_url\": \"$PRODUCTION_URL\",
    \"switch_timestamp\": \"$(date -u +"%Y-%m-%dT%H:%M:%SZ")\"
  }"

echo "üéâ Blue-Green deployment completed successfully!"
echo "üåê Active URL: $PRODUCTION_URL"
echo "üîß Previous version available at inactive slot for rollback"

# Final verification
sleep 10
FINAL_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$PRODUCTION_URL/api/health")
if [ "$FINAL_STATUS" -eq 200 ]; then
  echo "‚úÖ Final verification: Production is healthy"
else
  echo "‚ö†Ô∏è Final verification: Production health check returned $FINAL_STATUS"
fi
```

#### Example 2: Database Migration Pipeline
```bash
#!/bin/bash
# scripts/deployment/database-migration.sh

set -e

ENVIRONMENT=${1:-staging}
DEPLOYMENT_ID=${2:-$(uuidgen)}
MIGRATION_BATCH=${3:-$(date +%Y%m%d_%H%M%S)}

echo "üóÑÔ∏è Starting database migration pipeline for $ENVIRONMENT"
echo "üÜî Deployment ID: $DEPLOYMENT_ID"
echo "üì¶ Migration batch: $MIGRATION_BATCH"

# Set database URL based on environment
if [ "$ENVIRONMENT" = "production" ]; then
  DATABASE_URL="$PROD_DATABASE_URL"
  BACKUP_RETENTION_DAYS=30
else
  DATABASE_URL="$STAGING_DATABASE_URL"
  BACKUP_RETENTION_DAYS=7
fi

# Create pre-migration backup
echo "üíæ Creating pre-migration backup..."
BACKUP_FILE="backup_pre_migration_${MIGRATION_BATCH}.sql"
BACKUP_PATH="backups/$BACKUP_FILE"

pg_dump "$DATABASE_URL" --no-owner --no-privileges > "$BACKUP_PATH"
echo "‚úÖ Backup created: $BACKUP_PATH"

# Upload backup to secure storage
if command -v aws &> /dev/null; then
  aws s3 cp "$BACKUP_PATH" "s3://wedsync-backups/$ENVIRONMENT/"
  echo "‚òÅÔ∏è Backup uploaded to S3"
fi

# Record migration start in database
curl -X POST "$SUPABASE_URL/rest/v1/migration_deployments" \
  -H "Authorization: Bearer $SUPABASE_SERVICE_ROLE_KEY" \
  -H "Content-Type: application/json" \
  -d "{
    \"deployment_id\": \"$DEPLOYMENT_ID\",
    \"migration_batch\": \"$MIGRATION_BATCH\",
    \"migration_files\": [],
    \"migration_status\": \"running\",
    \"pre_migration_backup\": \"$BACKUP_PATH\"
  }"

# Get pending migrations
echo "üîç Checking for pending migrations..."
cd wedsync
PENDING_MIGRATIONS=$(npx supabase migration list --linked | grep "pending" || true)

if [ -z "$PENDING_MIGRATIONS" ]; then
  echo "‚úÖ No pending migrations found"
  exit 0
fi

echo "üìù Pending migrations:"
echo "$PENDING_MIGRATIONS"

# Apply migrations with rollback script generation
echo "‚ö° Applying migrations..."
MIGRATION_LOG_FILE="migration_log_${MIGRATION_BATCH}.txt"

{
  echo "=== Migration Log for batch $MIGRATION_BATCH ==="
  echo "Started at: $(date)"
  echo "Environment: $ENVIRONMENT"
  echo "Deployment ID: $DEPLOYMENT_ID"
  echo "================================="
  echo
  
  # Apply each migration individually to track progress
  while read -r migration_line; do
    MIGRATION_FILE=$(echo "$migration_line" | awk '{print $1}')
    echo "Applying migration: $MIGRATION_FILE"
    
    if npx supabase migration up --include-all --linked; then
      echo "‚úÖ Successfully applied: $MIGRATION_FILE"
    else
      echo "‚ùå Failed to apply: $MIGRATION_FILE"
      MIGRATION_FAILED=true
      break
    fi
  done <<< "$PENDING_MIGRATIONS"
  
  echo
  echo "Completed at: $(date)"
} > "$MIGRATION_LOG_FILE"

# Check if migrations failed
if [ "$MIGRATION_FAILED" = true ]; then
  echo "üí• Migration failed, initiating rollback..."
  
  # Restore from backup
  echo "üîÑ Restoring from backup..."
  psql "$DATABASE_URL" < "$BACKUP_PATH"
  
  # Update migration status
  curl -X PATCH "$SUPABASE_URL/rest/v1/migration_deployments?deployment_id=eq.$DEPLOYMENT_ID" \
    -H "Authorization: Bearer $SUPABASE_SERVICE_ROLE_KEY" \
    -H "Content-Type: application/json" \
    -d "{
      \"migration_status\": \"failed\",
      \"migration_logs\": \"$(cat $MIGRATION_LOG_FILE | head -c 10000)\",
      \"rolled_back_at\": \"$(date -u +"%Y-%m-%dT%H:%M:%SZ")\"
    }"
  
  echo "‚ùå Migration failed and rolled back"
  exit 1
fi

# Verify database integrity after migration
echo "üîç Verifying database integrity..."
INTEGRITY_CHECK=$(psql "$DATABASE_URL" -t -c "
  SELECT COUNT(*) FROM information_schema.tables 
  WHERE table_schema = 'public' AND table_type = 'BASE TABLE';
")

if [ "$INTEGRITY_CHECK" -lt 10 ]; then
  echo "‚ö†Ô∏è Database integrity check failed: only $INTEGRITY_CHECK tables found"
  # Consider rolling back
fi

# Update migration status to success
curl -X PATCH "$SUPABASE_URL/rest/v1/migration_deployments?deployment_id=eq.$DEPLOYMENT_ID" \
  -H "Authorization: Bearer $SUPABASE_SERVICE_ROLE_KEY" \
  -H "Content-Type: application/json" \
  -d "{
    \"migration_status\": \"success\",
    \"migration_logs\": \"$(cat $MIGRATION_LOG_FILE | head -c 10000)\",
    \"applied_at\": \"$(date -u +"%Y-%m-%dT%H:%M:%SZ")\"
  }"

echo "üéâ Database migration completed successfully!"
echo "üìã Migration log: $MIGRATION_LOG_FILE"
echo "üíæ Backup available: $BACKUP_PATH"

# Clean up old backups (keep only recent ones)
find backups/ -name "backup_pre_migration_*.sql" -mtime +$BACKUP_RETENTION_DAYS -delete || true

echo "‚úÖ Migration pipeline completed"
```

#### Example 3: Comprehensive Health Check Script
```bash
#!/bin/bash
# scripts/deployment/health-check.sh

set -e

DEPLOYMENT_URL=${1:-https://staging.wedsync.com}
DEPLOYMENT_ID=${2:-$(uuidgen)}
ENVIRONMENT=${3:-staging}
TIMEOUT=${4:-30}

echo "üè• Running comprehensive health checks"
echo "üåê URL: $DEPLOYMENT_URL"
echo "üÜî Deployment ID: $DEPLOYMENT_ID"
echo "‚è±Ô∏è Timeout: ${TIMEOUT}s"

# Initialize health check results
HEALTH_CHECKS_PASSED=0
HEALTH_CHECKS_TOTAL=0
HEALTH_CHECK_RESULTS=()

# Function to record health check
record_health_check() {
  local check_name="$1"
  local status="$2"
  local response_time="$3"
  local status_code="${4:-}"
  local error_message="${5:-}"
  
  HEALTH_CHECKS_TOTAL=$((HEALTH_CHECKS_TOTAL + 1))
  
  if [ "$status" = "success" ]; then
    HEALTH_CHECKS_PASSED=$((HEALTH_CHECKS_PASSED + 1))
    echo "‚úÖ $check_name: ${response_time}ms"
  else
    echo "‚ùå $check_name: $error_message (${response_time}ms)"
  fi
  
  # Record in database
  curl -X POST "$SUPABASE_URL/rest/v1/deployment_health_checks" \
    -H "Authorization: Bearer $SUPABASE_SERVICE_ROLE_KEY" \
    -H "Content-Type: application/json" \
    -d "{
      \"deployment_id\": \"$DEPLOYMENT_ID\",
      \"check_name\": \"$check_name\",
      \"check_type\": \"http\",
      \"check_status\": \"$status\",
      \"response_time_ms\": $response_time,
      \"status_code\": $status_code,
      \"error_message\": \"$error_message\"
    }" > /dev/null 2>&1
}

# Function to perform HTTP health check
http_health_check() {
  local endpoint="$1"
  local check_name="$2"
  local expected_status="${3:-200}"
  local method="${4:-GET}"
  local payload="${5:-}"
  
  local start_time=$(date +%s%3N)
  local status_code error_message
  
  if [ "$method" = "POST" ] && [ -n "$payload" ]; then
    status_code=$(curl -s -o /dev/null -w "%{http_code}" \
      --max-time "$TIMEOUT" \
      -X POST \
      -H "Content-Type: application/json" \
      -d "$payload" \
      "$DEPLOYMENT_URL$endpoint" 2>/dev/null || echo "000")
  else
    status_code=$(curl -s -o /dev/null -w "%{http_code}" \
      --max-time "$TIMEOUT" \
      "$DEPLOYMENT_URL$endpoint" 2>/dev/null || echo "000")
  fi
  
  local end_time=$(date +%s%3N)
  local response_time=$((end_time - start_time))
  
  if [ "$status_code" -eq "$expected_status" ]; then
    record_health_check "$check_name" "success" "$response_time" "$status_code"
    return 0
  else
    if [ "$status_code" = "000" ]; then
      error_message="Connection timeout or network error"
    else
      error_message="Expected status $expected_status, got $status_code"
    fi
    record_health_check "$check_name" "failed" "$response_time" "$status_code" "$error_message"
    return 1
  fi
}

# Run health checks
echo
echo "üîç Starting health checks..."

# 1. Basic API Health
http_health_check "/api/health" "api_health"

# 2. Database Health
http_health_check "/api/status/database" "database_health"

# 3. Authentication System
http_health_check "/api/auth/health" "auth_system" 200

# 4. Supabase Connection
http_health_check "/api/status/supabase" "supabase_connection"

# 5. Form Submission (Wedding Critical)
http_health_check "/api/health/form-test" "form_submission" 200 "POST" '{"test_mode": true, "couple_names": "Health Check", "email": "test@wedsync.com"}'

# 6. Journey Engine
http_health_check "/api/journeys/health" "journey_engine"

# 7. File Upload System
http_health_check "/api/upload/health" "file_upload_system"

# 8. Email System
http_health_check "/api/email/health" "email_system"

# 9. SMS System
http_health_check "/api/sms/health" "sms_system"

# 10. WhatsApp System
http_health_check "/api/whatsapp/health" "whatsapp_system"

# 11. Payment System (if enabled)
if [ "$ENVIRONMENT" = "production" ]; then
  http_health_check "/api/payments/health" "payment_system"
fi

# 12. Performance Check (Page Load)
echo "‚ö° Checking page load performance..."
PERF_START=$(date +%s%3N)
PAGE_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$DEPLOYMENT_URL/")
PERF_END=$(date +%s%3N)
PAGE_LOAD_TIME=$((PERF_END - PERF_START))

if [ "$PAGE_STATUS" -eq 200 ] && [ "$PAGE_LOAD_TIME" -lt 3000 ]; then
  record_health_check "page_load_performance" "success" "$PAGE_LOAD_TIME" "$PAGE_STATUS"
else
  record_health_check "page_load_performance" "failed" "$PAGE_LOAD_TIME" "$PAGE_STATUS" "Page load too slow or failed"
fi

# 13. Critical Wedding Form Endpoints
echo "üíí Checking critical wedding endpoints..."
http_health_check "/api/clients" "client_api"
http_health_check "/api/vendors" "vendor_api" 
http_health_check "/api/journeys" "journey_api"

# 14. Real-time Features (if applicable)
if command -v wscat &> /dev/null; then
  echo "üì° Checking WebSocket connection..."
  WS_START=$(date +%s%3N)
  WS_URL=$(echo "$DEPLOYMENT_URL" | sed 's/https/wss/g')
  
  if timeout 5 wscat -c "$WS_URL/api/ws/health" -x '{"type":"ping"}' > /dev/null 2>&1; then
    WS_END=$(date +%s%3N)
    WS_TIME=$((WS_END - WS_START))
    record_health_check "websocket_connection" "success" "$WS_TIME"
  else
    record_health_check "websocket_connection" "failed" 5000 "" "WebSocket connection failed"
  fi
fi

# Calculate overall health score
HEALTH_SCORE=$((HEALTH_CHECKS_PASSED * 100 / HEALTH_CHECKS_TOTAL))

echo
echo "üìä Health Check Summary"
echo "======================="
echo "‚úÖ Passed: $HEALTH_CHECKS_PASSED"
echo "‚ùå Failed: $((HEALTH_CHECKS_TOTAL - HEALTH_CHECKS_PASSED))"
echo "üìà Health Score: $HEALTH_SCORE%"
echo

# Determine if deployment should proceed
if [ "$HEALTH_SCORE" -ge 90 ]; then
  echo "üéâ Health checks PASSED - Deployment can proceed"
  exit 0
elif [ "$HEALTH_SCORE" -ge 75 ]; then
  echo "‚ö†Ô∏è Health checks WARNING - Some non-critical issues detected"
  echo "Consider investigating before proceeding to production"
  exit 0
else
  echo "üí• Health checks FAILED - Deployment should be rolled back"
  echo "Critical issues detected that could affect wedding operations"
  exit 1
fi
```

### MCP SERVER USAGE

#### Required MCP Servers
- [ ] Context7: Load deployment and DevOps documentation
- [ ] Filesystem: Create deployment scripts and configuration files
- [ ] PostgreSQL: Store deployment pipeline metrics and health check results

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/docker/docker", "multi-stage-builds", 2000);
await mcp__context7__get-library-docs("/kubernetes/kubernetes", "deployments", 3000);
await mcp__context7__get-library-docs("/vercel/vercel", "blue-green-deployments", 2000);
```

### TEST REQUIREMENTS

#### Deployment Pipeline Tests
```typescript
describe('Deployment Pipeline Validation', () => {
  it('should execute all pipeline stages successfully', () => {
    // Build stage completion
    // Test stage execution
    // Deploy stage with health checks
    // Verify stage monitoring
    // Promote stage with traffic switching
  });
  
  it('should handle blue-green deployments', () => {
    // Deploy to inactive slot
    // Run health checks
    // Switch traffic atomically
    // Maintain rollback capability
  });
  
  it('should manage database migrations safely', () => {
    // Pre-migration backup creation
    // Migration execution with rollback capability
    // Post-migration integrity verification
    // Migration status tracking
  });
});
```

### ACCEPTANCE CRITERIA
- [ ] Blue-green deployment implementation
- [ ] Zero-downtime deployments
- [ ] Database migration pipeline with rollback
- [ ] Comprehensive health check system
- [ ] Pipeline stage tracking and monitoring
- [ ] Automated rollback on failure
- [ ] Performance validation post-deployment
- [ ] Real-time pipeline status updates
- [ ] Integration with existing CI/CD workflows
- [ ] Deployment metrics and logging
- [ ] Emergency rollback procedures
- [ ] Traffic switching capabilities

### DEPENDENCIES
- Must complete after: WS-095 (GitHub Actions CI/CD)
- Must complete before: WS-097 (Environment Management), WS-098 (Rollback Procedures)
- Shares code with: All features (deployment affects everything)

### ESTIMATED EFFORT
- Team A Frontend: 10 hours (deployment dashboard and status monitoring)
- Team B Backend: 18 hours (pipeline service, health checks, database migrations)
- Team C Integration: 20 hours (deployment scripts, blue-green setup, monitoring)
- Total: 48 hours