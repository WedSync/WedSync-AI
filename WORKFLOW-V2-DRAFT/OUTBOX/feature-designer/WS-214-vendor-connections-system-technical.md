# TECHNICAL SPECIFICATION: WS-214 - Vendor Connections System
## Generated by Feature Development Session - 2025-01-25

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Couple planning our wedding
**I want to:** Search for and invite our existing vendors to join the platform, connecting them to our wedding details
**So that:** Our vendors can see our information automatically and we can coordinate everything in one place instead of managing separate email chains with 6+ vendors

**Real Wedding Scenario:**
A couple has already booked their photographer, venue coordinator, florist, and caterer through separate processes. They're now managing 4 different email threads, sharing the same wedding details (date, venue, guest count) repeatedly, and struggling to keep everyone updated when details change. With Vendor Connections, they search for their photographer (finds them already on platform), invite their 3 other vendors via email, and within 2 days all vendors can see the couple's wedding timeline, guest count, and venue details automatically - eliminating 15+ back-and-forth emails and ensuring everyone has consistent information.

### SPECIFICATION SOURCE
- **Feature ID:** WS-214
- **Original Spec:** /CORE-SPECIFICATIONS/03-WEDME-COUPLE-PLATFORM/01-Onboarding/04-vendor-connections md.md
- **Current Implementation:** 0% complete
- **Files to Modify:** 
  - /src/lib/validations/core-fields.ts (add vendor connection validation)
- **New Files to Create:** 
  - /src/app/(onboarding)/vendor-connections/page.tsx
  - /src/components/onboarding/VendorConnectionsFlow.tsx
  - /src/components/vendors/VendorSearch.tsx
  - /src/components/vendors/VendorInviteForm.tsx
  - /src/components/vendors/ConnectedVendorsList.tsx
  - /src/lib/services/vendor-invitation-service.ts
  - /src/lib/stores/vendorConnectionsStore.ts
  - /src/app/api/onboarding/vendor-connections/route.ts
  - /src/app/api/vendors/search/route.ts
  - /src/app/api/vendors/invite/route.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Vendor invitations tracking
CREATE TABLE IF NOT EXISTS vendor_invitations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  couple_id UUID REFERENCES couples(id) ON DELETE CASCADE,
  invitation_code TEXT UNIQUE NOT NULL,
  vendor_email TEXT NOT NULL,
  vendor_name TEXT NOT NULL,
  vendor_type TEXT NOT NULL CHECK (vendor_type IN (
    'photographer', 'venue', 'caterer', 'florist', 'dj_band', 
    'planner', 'baker', 'transport', 'hair_makeup', 'officiant', 'other'
  )),
  vendor_phone TEXT,
  personal_message TEXT,
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'accepted', 'declined', 'expired')),
  supplier_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- Set when vendor joins
  invited_at TIMESTAMP DEFAULT NOW(),
  responded_at TIMESTAMP,
  expires_at TIMESTAMP DEFAULT (NOW() + INTERVAL '30 days'),
  reminder_sent_at TIMESTAMP[],
  created_at TIMESTAMP DEFAULT NOW()
);

-- Couple-Supplier connections (established relationships)
CREATE TABLE IF NOT EXISTS couple_supplier_connections (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  couple_id UUID REFERENCES couples(id) ON DELETE CASCADE,
  supplier_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  connection_type TEXT NOT NULL CHECK (connection_type IN ('invited', 'connected', 'hired')),
  vendor_type TEXT NOT NULL,
  invitation_id UUID REFERENCES vendor_invitations(id) ON DELETE SET NULL,
  contract_signed BOOLEAN DEFAULT false,
  access_level TEXT DEFAULT 'standard' CHECK (access_level IN ('view_only', 'standard', 'full')),
  connected_at TIMESTAMP DEFAULT NOW(),
  last_activity TIMESTAMP DEFAULT NOW(),
  is_active BOOLEAN DEFAULT true,
  UNIQUE(couple_id, supplier_id)
);

-- Vendor categories for search and organization
CREATE TABLE IF NOT EXISTS vendor_categories (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  category_key TEXT UNIQUE NOT NULL,
  category_name TEXT NOT NULL,
  category_description TEXT,
  typical_timeline_weeks INTEGER, -- When typically booked (weeks before wedding)
  is_essential BOOLEAN DEFAULT false, -- Core vendor types
  search_keywords TEXT[],
  display_order INTEGER DEFAULT 0,
  is_active BOOLEAN DEFAULT true
);

-- Insert default vendor categories
INSERT INTO vendor_categories (category_key, category_name, category_description, typical_timeline_weeks, is_essential, search_keywords, display_order) VALUES
('photographer', 'Photographer', 'Wedding photography services', 52, true, ARRAY['photo', 'picture', 'image', 'shoot'], 1),
('venue', 'Venue Coordinator', 'Wedding venue and coordination services', 78, true, ARRAY['location', 'hall', 'space', 'reception'], 2),
('caterer', 'Caterer', 'Food and beverage services', 26, true, ARRAY['food', 'catering', 'menu', 'dining'], 3),
('florist', 'Florist', 'Flowers and floral arrangements', 12, true, ARRAY['flowers', 'bouquet', 'centerpiece', 'floral'], 4),
('dj_band', 'DJ/Band', 'Music and entertainment services', 32, true, ARRAY['music', 'dj', 'band', 'entertainment'], 5),
('planner', 'Wedding Planner', 'Full-service wedding planning', 78, false, ARRAY['planner', 'coordinator', 'organizer'], 6),
('baker', 'Baker/Cake Designer', 'Wedding cake and dessert services', 16, false, ARRAY['cake', 'dessert', 'baker', 'sweets'], 7),
('hair_makeup', 'Hair & Makeup', 'Beauty services for wedding day', 8, false, ARRAY['hair', 'makeup', 'beauty', 'styling'], 8),
('transport', 'Transportation', 'Wedding day transportation services', 20, false, ARRAY['transport', 'limo', 'car', 'ride'], 9),
('officiant', 'Officiant', 'Ceremony officiation services', 24, false, ARRAY['officiant', 'minister', 'ceremony', 'vows'], 10);

-- Invitation templates for different vendor types
CREATE TABLE IF NOT EXISTS vendor_invitation_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  vendor_type TEXT NOT NULL,
  template_name TEXT NOT NULL,
  subject_line TEXT NOT NULL,
  email_body TEXT NOT NULL,
  includes_timeline BOOLEAN DEFAULT true,
  includes_venue_details BOOLEAN DEFAULT true,
  includes_guest_count BOOLEAN DEFAULT true,
  is_default BOOLEAN DEFAULT false,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_vendor_invitations_couple ON vendor_invitations(couple_id);
CREATE INDEX idx_vendor_invitations_email ON vendor_invitations(vendor_email);
CREATE INDEX idx_vendor_invitations_code ON vendor_invitations(invitation_code);
CREATE INDEX idx_vendor_invitations_status ON vendor_invitations(status);
CREATE INDEX idx_couple_supplier_connections_couple ON couple_supplier_connections(couple_id);
CREATE INDEX idx_couple_supplier_connections_supplier ON couple_supplier_connections(supplier_id);
CREATE INDEX idx_vendor_categories_key ON vendor_categories(category_key);
```

#### API Endpoints Required

**1. Vendor Search & Discovery**
```typescript
// GET /api/vendors/search?q={query}&type={category}&location={city,state}
// Search for existing vendors on platform
interface VendorSearchRequest {
  query: string;
  vendorType?: string;
  location?: string;
  radius?: number; // miles
  verified?: boolean;
}

interface VendorSearchResponse {
  vendors: SupplierProfile[];
  total: number;
  hasMore: boolean;
  suggestions?: string[]; // Alternative search terms
}

interface SupplierProfile {
  id: string;
  businessName: string;
  vendorType: string;
  location: string;
  profileImage?: string;
  rating?: number;
  reviewCount?: number;
  yearEstablished?: number;
  specialties: string[];
  packageStartingPrice?: number;
  isVerified: boolean;
  portfolioImages: string[];
  quickDescription: string;
}
```

**2. Vendor Invitations Management**
```typescript
// POST /api/vendors/invite
// Send invitation to vendor
interface VendorInviteRequest {
  vendorName: string;
  vendorEmail: string;
  vendorType: string;
  vendorPhone?: string;
  personalMessage?: string;
  includeWeddingDetails: boolean;
  templateId?: string;
}

interface VendorInviteResponse {
  success: boolean;
  invitationId: string;
  invitationCode: string;
  expiresAt: string;
  message: string;
}

// POST /api/vendors/invite/bulk
// Send multiple invitations
interface BulkVendorInviteRequest {
  vendors: VendorInviteRequest[];
  commonMessage?: string;
}

// GET /api/onboarding/vendor-connections
// Get current vendor connections status
interface VendorConnectionsStatus {
  connectedVendors: ConnectedVendor[];
  pendingInvitations: PendingInvitation[];
  suggestedVendorTypes: string[];
  completionPercentage: number;
}

interface ConnectedVendor {
  id: string;
  supplierProfile: SupplierProfile;
  vendorType: string;
  connectionType: 'invited' | 'connected' | 'hired';
  connectedAt: string;
  lastActivity?: string;
  accessLevel: 'view_only' | 'standard' | 'full';
}

interface PendingInvitation {
  id: string;
  vendorName: string;
  vendorEmail: string;
  vendorType: string;
  status: 'pending' | 'expired';
  invitedAt: string;
  expiresAt: string;
  remindersSent: number;
}
```

**3. Invitation Management**
```typescript
// POST /api/vendors/invitations/{id}/resend
// Resend invitation reminder

// DELETE /api/vendors/invitations/{id}
// Cancel pending invitation

// POST /api/vendors/invitations/{id}/extend
// Extend invitation expiration
interface InvitationExtendRequest {
  additionalDays: number; // 1-30
}

// GET /api/vendors/categories
// Get available vendor categories
interface VendorCategory {
  key: string;
  name: string;
  description: string;
  isEssential: boolean;
  typicalTimelineWeeks: number;
  searchKeywords: string[];
}
```

#### Frontend Components Required

**1. Vendor Connections Flow Container**
```typescript
// src/app/(onboarding)/vendor-connections/page.tsx
'use client';

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { VendorConnectionsFlow } from '@/components/onboarding/VendorConnectionsFlow';
import { useVendorConnectionsStore } from '@/lib/stores/vendorConnectionsStore';

export default function VendorConnectionsPage() {
  const router = useRouter();
  const { 
    loadConnectionsStatus, 
    isLoading, 
    connectionsStatus 
  } = useVendorConnectionsStore();

  useEffect(() => {
    loadConnectionsStatus();
  }, [loadConnectionsStatus]);

  const handleComplete = () => {
    // Navigate to next onboarding step or dashboard
    router.push('/onboarding/preferences');
  };

  const handleSkip = () => {
    // Allow skipping vendor connections
    router.push('/onboarding/preferences');
  };

  if (isLoading) {
    return <div>Loading your vendor connections...</div>;
  }

  return (
    <div className="max-w-4xl mx-auto px-4 py-8">
      <div className="mb-8">
        <h1 className="text-3xl font-bold text-gray-900 mb-2">
          Connect Your Vendors
        </h1>
        <p className="text-lg text-gray-600">
          Bring your existing vendors onto the platform so everyone stays in sync.
        </p>
        <div className="mt-4 bg-blue-50 p-4 rounded-lg">
          <p className="text-sm text-blue-700">
            <span className="font-medium">Step 2 of 3:</span> Vendor Connections
          </p>
          <div className="mt-2 bg-blue-200 rounded-full h-2">
            <div className="bg-blue-600 h-2 rounded-full" style={{ width: '66%' }}></div>
          </div>
        </div>
      </div>

      <VendorConnectionsFlow 
        initialStatus={connectionsStatus}
        onComplete={handleComplete}
        onSkip={handleSkip}
      />
    </div>
  );
}
```

**2. Vendor Connections Flow**
```typescript
// src/components/onboarding/VendorConnectionsFlow.tsx
import React, { useState } from 'react';
import { VendorSearch } from '@/components/vendors/VendorSearch';
import { VendorInviteForm } from '@/components/vendors/VendorInviteForm';
import { ConnectedVendorsList } from '@/components/vendors/ConnectedVendorsList';

interface VendorConnectionsFlowProps {
  initialStatus: VendorConnectionsStatus;
  onComplete: () => void;
  onSkip: () => void;
}

export function VendorConnectionsFlow({
  initialStatus,
  onComplete,
  onSkip
}: VendorConnectionsFlowProps) {
  const [activeStep, setActiveStep] = useState<'search' | 'invite' | 'review'>('search');
  const [selectedVendorType, setSelectedVendorType] = useState<string>('');

  const commonVendorTypes = [
    { key: 'photographer', name: 'Photographer', icon: 'üì∏' },
    { key: 'venue', name: 'Venue Coordinator', icon: 'üèõÔ∏è' },
    { key: 'caterer', name: 'Caterer', icon: 'üçΩÔ∏è' },
    { key: 'florist', name: 'Florist', icon: 'üå∏' },
    { key: 'dj_band', name: 'DJ/Band', icon: 'üéµ' },
    { key: 'planner', name: 'Wedding Planner', icon: 'üìã' }
  ];

  return (
    <div className="space-y-8">
      {/* Value Proposition */}
      <div className="bg-gradient-to-r from-blue-50 to-indigo-50 p-6 rounded-lg">
        <h3 className="text-lg font-semibold text-gray-900 mb-2">
          Why connect your vendors?
        </h3>
        <ul className="space-y-2 text-sm text-gray-700">
          <li className="flex items-start">
            <span className="text-green-500 mr-2">‚úì</span>
            They'll automatically see your wedding date, venue, and guest count
          </li>
          <li className="flex items-start">
            <span className="text-green-500 mr-2">‚úì</span>
            No more repeating the same information in emails
          </li>
          <li className="flex items-start">
            <span className="text-green-500 mr-2">‚úì</span>
            Everyone stays updated when details change
          </li>
          <li className="flex items-start">
            <span className="text-green-500 mr-2">‚úì</span>
            Vendors can coordinate with each other seamlessly
          </li>
        </ul>
      </div>

      {/* Connected Vendors Summary */}
      {initialStatus.connectedVendors.length > 0 && (
        <ConnectedVendorsList 
          vendors={initialStatus.connectedVendors}
          pendingInvitations={initialStatus.pendingInvitations}
        />
      )}

      {/* Vendor Type Selection */}
      <div>
        <h3 className="text-lg font-semibold text-gray-900 mb-4">
          Which vendors are you working with?
        </h3>
        <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
          {commonVendorTypes.map((vendor) => (
            <button
              key={vendor.key}
              onClick={() => setSelectedVendorType(vendor.key)}
              className="p-4 border-2 border-gray-200 rounded-lg hover:border-blue-300 transition-colors"
            >
              <div className="text-2xl mb-2">{vendor.icon}</div>
              <div className="font-medium text-gray-900">{vendor.name}</div>
            </button>
          ))}
        </div>
      </div>

      {/* Vendor Search or Invite */}
      {selectedVendorType && (
        <div className="border-t pt-8">
          <div className="mb-6">
            <h4 className="text-lg font-semibold text-gray-900 mb-2">
              {commonVendorTypes.find(v => v.key === selectedVendorType)?.name}
            </h4>
            <p className="text-sm text-gray-600">
              Search for your vendor on our platform, or send them an invitation to join.
            </p>
          </div>

          <div className="grid md:grid-cols-2 gap-8">
            <div>
              <h5 className="font-medium text-gray-900 mb-3">
                Search Existing Vendors
              </h5>
              <VendorSearch 
                vendorType={selectedVendorType}
                onVendorSelect={(vendor) => {
                  // Handle connecting to existing vendor
                }}
              />
            </div>

            <div>
              <h5 className="font-medium text-gray-900 mb-3">
                Invite Your Vendor
              </h5>
              <VendorInviteForm 
                vendorType={selectedVendorType}
                onInviteSent={(invitation) => {
                  // Handle invitation sent
                  setSelectedVendorType('');
                }}
              />
            </div>
          </div>
        </div>
      )}

      {/* Bulk Invite Option */}
      <div className="bg-gray-50 p-6 rounded-lg">
        <h4 className="font-semibold text-gray-900 mb-2">
          Have multiple vendors to invite?
        </h4>
        <p className="text-sm text-gray-600 mb-4">
          You can paste multiple email addresses and send invitations all at once.
        </p>
        <button className="text-blue-600 hover:text-blue-800 text-sm font-medium">
          Send bulk invitations ‚Üí
        </button>
      </div>

      {/* Navigation */}
      <div className="flex justify-between pt-8 border-t">
        <button
          type="button"
          onClick={() => window.history.back()}
          className="px-4 py-2 text-gray-600 hover:text-gray-800"
        >
          ‚Üê Back
        </button>
        
        <div className="flex gap-3">
          <button
            type="button"
            onClick={onSkip}
            className="px-6 py-2 border border-gray-300 text-gray-700 rounded-md hover:bg-gray-50"
          >
            Skip for Now
          </button>
          
          <button
            type="button"
            onClick={onComplete}
            className="px-8 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700"
          >
            Continue ‚Üí
          </button>
        </div>
      </div>
    </div>
  );
}
```

**3. Vendor Invite Form**
```typescript
// src/components/vendors/VendorInviteForm.tsx
import React, { useState } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';

const vendorInviteSchema = z.object({
  vendorName: z.string().min(2, 'Vendor name is required'),
  vendorEmail: z.string().email('Valid email address required'),
  vendorPhone: z.string().optional(),
  personalMessage: z.string().optional(),
  includeWeddingDetails: z.boolean().default(true)
});

type VendorInviteFormData = z.infer<typeof vendorInviteSchema>;

interface VendorInviteFormProps {
  vendorType: string;
  onInviteSent: (invitation: any) => void;
}

export function VendorInviteForm({
  vendorType,
  onInviteSent
}: VendorInviteFormProps) {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [showPreview, setShowPreview] = useState(false);

  const form = useForm<VendorInviteFormData>({
    resolver: zodResolver(vendorInviteSchema),
    defaultValues: {
      includeWeddingDetails: true,
      personalMessage: `Hi [Vendor Name]!\n\nWe're so excited to be working with you for our wedding. We've started using WedSync to organize everything, and it would be amazing if you could join us on the platform.\n\nThis way, you'll automatically have access to our wedding details, timeline, and can coordinate with our other vendors seamlessly.\n\nLooking forward to working together!\n\nBest,\n[Couple Names]`
    }
  });

  const handleSubmit = async (data: VendorInviteFormData) => {
    setIsSubmitting(true);
    try {
      const response = await fetch('/api/vendors/invite', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          ...data,
          vendorType
        })
      });

      if (!response.ok) {
        throw new Error('Failed to send invitation');
      }

      const invitation = await response.json();
      onInviteSent(invitation);
      
      // Reset form
      form.reset();
    } catch (error) {
      console.error('Failed to send invitation:', error);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="bg-white border border-gray-200 rounded-lg p-4">
      <form onSubmit={form.handleSubmit(handleSubmit)} className="space-y-4">
        {/* Vendor Name */}
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Vendor/Business Name *
          </label>
          <input
            {...form.register('vendorName')}
            placeholder="e.g., Smith Photography"
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 text-sm"
          />
          {form.formState.errors.vendorName && (
            <p className="mt-1 text-xs text-red-600">
              {form.formState.errors.vendorName.message}
            </p>
          )}
        </div>

        {/* Email */}
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Email Address *
          </label>
          <input
            type="email"
            {...form.register('vendorEmail')}
            placeholder="vendor@example.com"
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 text-sm"
          />
          {form.formState.errors.vendorEmail && (
            <p className="mt-1 text-xs text-red-600">
              {form.formState.errors.vendorEmail.message}
            </p>
          )}
        </div>

        {/* Phone (Optional) */}
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Phone Number (Optional)
          </label>
          <input
            type="tel"
            {...form.register('vendorPhone')}
            placeholder="(555) 123-4567"
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 text-sm"
          />
        </div>

        {/* Include Wedding Details */}
        <div className="flex items-center">
          <input
            type="checkbox"
            {...form.register('includeWeddingDetails')}
            className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
          />
          <label className="ml-2 text-sm text-gray-700">
            Include our wedding details in the invitation
          </label>
        </div>

        {/* Personal Message */}
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Personal Message (Optional)
          </label>
          <textarea
            {...form.register('personalMessage')}
            rows={4}
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 text-sm"
            placeholder="Add a personal note to your vendor..."
          />
        </div>

        {/* Preview Button */}
        <button
          type="button"
          onClick={() => setShowPreview(!showPreview)}
          className="text-sm text-blue-600 hover:text-blue-800"
        >
          {showPreview ? 'Hide' : 'Preview'} invitation email
        </button>

        {/* Submit Button */}
        <button
          type="submit"
          disabled={isSubmitting}
          className="w-full px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:opacity-50 text-sm"
        >
          {isSubmitting ? 'Sending Invitation...' : 'Send Invitation'}
        </button>
      </form>

      {/* Email Preview */}
      {showPreview && (
        <div className="mt-4 p-4 bg-gray-50 border border-gray-200 rounded-md">
          <h5 className="font-medium text-gray-900 mb-2">Email Preview</h5>
          <div className="text-sm space-y-2">
            <div><strong>Subject:</strong> Wedding Coordination Invitation - [Couple Names]</div>
            <div className="border-t pt-2">
              <div className="whitespace-pre-wrap">
                {form.watch('personalMessage') || 'Default invitation message will be used'}
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
```

#### State Management Required

**Vendor Connections Store**
```typescript
// src/lib/stores/vendorConnectionsStore.ts
import { create } from 'zustand';

interface VendorConnectionsState {
  connectionsStatus: VendorConnectionsStatus | null;
  searchResults: SupplierProfile[];
  isLoading: boolean;
  error: string | null;
  
  // Actions
  loadConnectionsStatus: () => Promise<void>;
  searchVendors: (query: string, vendorType?: string) => Promise<void>;
  inviteVendor: (invitation: VendorInviteRequest) => Promise<VendorInviteResponse>;
  connectToVendor: (vendorId: string, vendorType: string) => Promise<void>;
  resendInvitation: (invitationId: string) => Promise<void>;
  cancelInvitation: (invitationId: string) => Promise<void>;
}

export const useVendorConnectionsStore = create<VendorConnectionsState>((set, get) => ({
  connectionsStatus: null,
  searchResults: [],
  isLoading: false,
  error: null,

  loadConnectionsStatus: async () => {
    set({ isLoading: true, error: null });
    try {
      const response = await fetch('/api/onboarding/vendor-connections');
      const status = await response.json();
      set({ connectionsStatus: status, isLoading: false });
    } catch (error) {
      set({ error: error.message, isLoading: false });
    }
  },

  searchVendors: async (query: string, vendorType?: string) => {
    set({ isLoading: true, error: null });
    try {
      const params = new URLSearchParams({ q: query });
      if (vendorType) params.append('type', vendorType);
      
      const response = await fetch(`/api/vendors/search?${params}`);
      const data = await response.json();
      set({ searchResults: data.vendors, isLoading: false });
    } catch (error) {
      set({ error: error.message, isLoading: false });
    }
  },

  inviteVendor: async (invitation: VendorInviteRequest) => {
    try {
      const response = await fetch('/api/vendors/invite', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(invitation)
      });

      if (!response.ok) {
        throw new Error('Failed to send invitation');
      }

      const result = await response.json();
      
      // Refresh connections status
      get().loadConnectionsStatus();
      
      return result;
    } catch (error) {
      set({ error: error.message });
      throw error;
    }
  },

  connectToVendor: async (vendorId: string, vendorType: string) => {
    try {
      const response = await fetch('/api/vendors/connect', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ vendorId, vendorType })
      });

      if (!response.ok) {
        throw new Error('Failed to connect to vendor');
      }

      // Refresh connections status
      get().loadConnectionsStatus();
    } catch (error) {
      set({ error: error.message });
    }
  },

  resendInvitation: async (invitationId: string) => {
    try {
      const response = await fetch(`/api/vendors/invitations/${invitationId}/resend`, {
        method: 'POST'
      });

      if (!response.ok) {
        throw new Error('Failed to resend invitation');
      }

      // Refresh connections status
      get().loadConnectionsStatus();
    } catch (error) {
      set({ error: error.message });
    }
  },

  cancelInvitation: async (invitationId: string) => {
    try {
      const response = await fetch(`/api/vendors/invitations/${invitationId}`, {
        method: 'DELETE'
      });

      if (!response.ok) {
        throw new Error('Failed to cancel invitation');
      }

      // Refresh connections status
      get().loadConnectionsStatus();
    } catch (error) {
      set({ error: error.message });
    }
  }
}));
```

### TESTING REQUIREMENTS

#### Unit Tests
- Vendor invitation email generation
- Invitation code generation and validation
- Vendor search functionality
- Connection establishment logic
- Bulk invitation processing

#### Integration Tests
- Vendor invitation sending via email service
- Database operations for invitations and connections
- Vendor search across supplier profiles
- Invitation acceptance flow
- Expired invitation cleanup

#### E2E Tests
- Complete vendor connection flow
- Vendor search and selection
- Invitation sending and tracking
- Bulk vendor invitations
- Vendor response handling

### DEPENDENCIES & EFFORT ESTIMATE

#### Dependencies
- Email Service (Resend) - For sending invitations
- Core Fields System - For wedding details in invitations
- Supplier Management System - For vendor search
- Authentication System - For vendor account creation

#### Effort Estimate: 18 development days
- **Database Design & Migration**: 3 days
- **Vendor Search System**: 4 days  
- **Invitation System**: 5 days
- **Email Templates & Service**: 3 days
- **Frontend Components**: 3 days

#### Risk Factors
- **High:** Email deliverability for vendor invitations
- **Medium:** Vendor search accuracy and relevance
- **Medium:** Invitation acceptance tracking complexity
- **Low:** Bulk invitation performance

### SUCCESS CRITERIA
1. Couples can search and find existing vendors in <3 seconds
2. Vendor invitations are sent within 30 seconds
3. Invitation emails have >90% deliverability rate
4. Vendors can accept invitations and access couple details immediately
5. Bulk invitations support up to 20 vendors at once
6. Invitation status tracking works accurately
7. Connected vendors can see couple's wedding details automatically
8. System handles invitation expiration and reminders properly