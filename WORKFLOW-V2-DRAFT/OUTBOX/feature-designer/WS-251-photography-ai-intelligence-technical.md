# TECHNICAL SPECIFICATION: WS-251 - Photography AI Intelligence
## Generated by Feature Development Session - 2025-08-30

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding photographer using WedSync to manage my clients
**I want to:** AI-powered tools that help me plan optimal photo schedules, generate comprehensive shot lists, and provide venue-specific photography insights
**So that:** I can deliver consistently excellent results while reducing my planning time from 3 hours to 30 minutes per wedding, and ensure I never miss important shots or optimal lighting conditions

**Real Wedding Scenario:**
A photographer has a wedding at a vineyard venue they've never worked at before. The ceremony is at 4 PM in October. Using the AI system, they get a complete analysis showing the golden hour starts at 5:45 PM (perfect for couple portraits), the venue's east-facing terrace gets beautiful morning light for getting-ready shots, and a suggested timeline that accounts for 15 minutes of family photo time while the light is still good. The AI also generates a venue-specific shot list including "vineyard rows backdrop," "wine barrel details," and "sunset behind rolling hills" - shots they might have missed without venue intelligence.

### SPECIFICATION SOURCE
- **Feature ID:** WS-251
- **Original Spec:** /CORE-SPECIFICATIONS/04-AI-INTEGRATION/05-Vendor-Specific/01-photography-ai md.md
- **Current Implementation:** 0% complete
- **Files to Modify:**
  - /wedsync/src/app/(dashboard)/photography/page.tsx (new)
  - /wedsync/src/components/photography/AITools.tsx (new)
  - /wedsync/src/app/api/photography/ai/route.ts (new)
- **New Files to Create:**
  - /wedsync/src/lib/photography/shot-list-ai.ts
  - /wedsync/src/lib/photography/venue-intelligence.ts
  - /wedsync/src/lib/photography/lighting-calculator.ts
  - /wedsync/src/components/photography/ShotListGenerator.tsx
  - /wedsync/src/components/photography/TimingOptimizer.tsx
  - /wedsync/src/components/photography/VenueAnalysis.tsx

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Photography venue intelligence data
CREATE TABLE IF NOT EXISTS photo_venue_data (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  venue_id UUID REFERENCES venues(id) ON DELETE CASCADE,
  venue_name TEXT NOT NULL,
  coordinates POINT, -- PostGIS for lat/lng
  best_photo_spots JSONB NOT NULL DEFAULT '[]'::jsonb,
  lighting_analysis JSONB NOT NULL DEFAULT '{}'::jsonb,
  seasonal_notes JSONB NOT NULL DEFAULT '{}'::jsonb,
  photographer_tips TEXT[] DEFAULT '{}',
  weather_considerations JSONB DEFAULT '{}',
  indoor_backup_spots JSONB DEFAULT '[]'::jsonb,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  analyzed_by_ai BOOLEAN DEFAULT false,
  photo_samples TEXT[] DEFAULT '{}', -- URLs to reference photos
  
  CONSTRAINT valid_coordinates CHECK (coordinates IS NOT NULL)
);

-- AI-generated shot lists for weddings
CREATE TABLE IF NOT EXISTS ai_generated_shot_lists (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  wedding_id UUID REFERENCES weddings(id) ON DELETE CASCADE,
  photographer_id UUID REFERENCES suppliers(id) ON DELETE CASCADE,
  venue_id UUID REFERENCES venues(id),
  generated_shots JSONB NOT NULL, -- Structured shot list data
  customizations JSONB DEFAULT '{}', -- User modifications
  timeline_suggestions JSONB DEFAULT '{}', -- Optimal timing recommendations
  weather_backup_plan JSONB DEFAULT '{}',
  ai_confidence_score DECIMAL(3,2) CHECK (ai_confidence_score >= 0 AND ai_confidence_score <= 1),
  generation_prompt TEXT,
  generated_at TIMESTAMPTZ DEFAULT NOW(),
  last_modified TIMESTAMPTZ DEFAULT NOW(),
  approved_by_photographer BOOLEAN DEFAULT false,
  
  UNIQUE(wedding_id, photographer_id)
);

-- Photography timing calculations cache
CREATE TABLE IF NOT EXISTS photography_timing_cache (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  wedding_date DATE NOT NULL,
  venue_coordinates POINT NOT NULL,
  timezone TEXT NOT NULL,
  sunrise_time TIMESTAMPTZ NOT NULL,
  sunset_time TIMESTAMPTZ NOT NULL,
  golden_hour_morning_start TIMESTAMPTZ NOT NULL,
  golden_hour_morning_end TIMESTAMPTZ NOT NULL,
  golden_hour_evening_start TIMESTAMPTZ NOT NULL,
  golden_hour_evening_end TIMESTAMPTZ NOT NULL,
  blue_hour_start TIMESTAMPTZ NOT NULL,
  blue_hour_end TIMESTAMPTZ NOT NULL,
  calculated_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(wedding_date, venue_coordinates)
);

-- Venue photo analysis results
CREATE TABLE IF NOT EXISTS venue_photo_analysis (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  venue_id UUID REFERENCES venues(id) ON DELETE CASCADE,
  photo_url TEXT NOT NULL,
  analysis_results JSONB NOT NULL,
  detected_features TEXT[] DEFAULT '{}',
  lighting_quality_score DECIMAL(3,2) CHECK (lighting_quality_score >= 0 AND lighting_quality_score <= 1),
  photo_spot_potential DECIMAL(3,2) CHECK (photo_spot_potential >= 0 AND photo_spot_potential <= 1),
  analyzed_at TIMESTAMPTZ DEFAULT NOW(),
  ai_model_version TEXT DEFAULT 'gpt-4-vision-preview'
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_venue_data_coordinates ON photo_venue_data USING GIST (coordinates);
CREATE INDEX IF NOT EXISTS idx_shot_lists_photographer ON ai_generated_shot_lists(photographer_id, generated_at DESC);
CREATE INDEX IF NOT EXISTS idx_timing_cache_date_location ON photography_timing_cache(wedding_date, venue_coordinates);
CREATE INDEX IF NOT EXISTS idx_venue_analysis_venue ON venue_photo_analysis(venue_id, analyzed_at DESC);
```

#### API Endpoints Required
```typescript
// POST /api/photography/ai/shot-list
interface ShotListGenerationRequest {
  weddingId: string;
  venueDetails: {
    name: string;
    type: string;
    coordinates: { lat: number; lng: number };
    description?: string;
  };
  weddingStyle: string;
  guestCount: number;
  ceremonyTime: string;
  specialRequests: string[];
  photographerPreferences: {
    style: string[];
    equipment: string[];
    experience: number;
  };
}

interface ShotListGenerationResponse {
  success: boolean;
  shotList: {
    id: string;
    categories: Array<{
      name: string;
      shots: Array<{
        description: string;
        priority: 'must-have' | 'important' | 'nice-to-have';
        estimatedTime: number; // minutes
        optimalTiming: string;
        equipment: string[];
        notes: string;
      }>;
    }>;
    timeline: {
      gettingReady: string;
      firstLook: string;
      ceremony: string;
      familyPhotos: string;
      couplePortraits: string;
      reception: string;
    };
    aiConfidence: number;
  };
  venueInsights?: {
    bestPhotoSpots: string[];
    lightingTips: string[];
    weatherBackupPlan: string[];
  };
}

// GET /api/photography/ai/timing/{weddingId}
interface PhotoTimingResponse {
  success: boolean;
  timing: {
    date: string;
    sunrise: string;
    sunset: string;
    goldenHour: {
      morning: { start: string; end: string };
      evening: { start: string; end: string };
    };
    blueHour: { start: string; end: string };
    optimalSchedule: {
      gettingReady: string;
      firstLook: string;
      ceremony: string;
      portraits: string;
    };
    weatherConsiderations: string[];
  };
}

// POST /api/photography/ai/venue-analysis
interface VenueAnalysisRequest {
  venueId: string;
  photoUrls: string[];
  analyzeFeatures?: boolean;
}

interface VenueAnalysisResponse {
  success: boolean;
  analysis: {
    photoSpots: Array<{
      name: string;
      description: string;
      bestTiming: string[];
      lightingConditions: string;
      suitableFor: string[]; // 'portraits', 'ceremony', 'reception', 'details'
      score: number; // 0-1
    }>;
    lightingAnalysis: {
      naturalLightAvailability: string;
      indoorLightingQuality: string;
      challengeAreas: string[];
      recommendations: string[];
    };
    weatherBackups: string[];
    uniqueFeatures: string[];
    photographerTips: string[];
  };
}

// PUT /api/photography/ai/shot-list/{shotListId}
interface ShotListUpdateRequest {
  customizations: {
    addedShots: any[];
    removedShotIds: string[];
    modifiedShots: any[];
  };
  timelineAdjustments: any;
  photographerNotes: string;
}
```

#### Frontend Components Required
```typescript
// Component: ShotListGenerator
// Location: /src/components/photography/ShotListGenerator.tsx

interface ShotListGeneratorProps {
  weddingId: string;
  onShotListGenerated: (shotList: any) => void;
  existingShotList?: any;
}

// Key functionality:
- Form to input wedding details and photographer preferences
- AI generation with loading states and progress indicators
- Editable shot list with drag-and-drop reordering
- Category-based organization with expandable sections
- Timeline visualization with optimal timing suggestions
- Export functionality (PDF, checklist format)

// Component: TimingOptimizer
// Location: /src/components/photography/TimingOptimizer.tsx

interface TimingOptimizerProps {
  weddingDate: Date;
  venueCoordinates: { lat: number; lng: number };
  ceremonyTime: string;
  onTimingCalculated: (timing: any) => void;
}

// Key functionality:
- Visual timeline with golden hour and blue hour indicators
- Drag-and-drop schedule builder
- Weather integration with backup timing suggestions
- Seasonal lighting variation warnings
- Export to calendar integration

// Component: VenueAnalysis
// Location: /src/components/photography/VenueAnalysis.tsx

interface VenueAnalysisProps {
  venueId: string;
  venuePhotos: string[];
  onAnalysisComplete: (analysis: any) => void;
}

// Key functionality:
- Photo upload and analysis interface
- Interactive map showing photo spot recommendations
- Lighting quality visualization
- Equipment suggestions based on venue analysis
- Weather backup planning interface
```

#### Integration Points
```typescript
// Service: PhotographyAIService
// Dependencies: OpenAI Vision API, Sunrise-Sunset API, Weather API, Google Maps API

class PhotographyAIService {
  async generateShotList(weddingDetails: WeddingDetails): Promise<ShotList> {
    // Analyze venue if not previously analyzed
    const venueAnalysis = await this.getOrCreateVenueAnalysis(weddingDetails.venue);
    
    // Calculate optimal timing for the date/location
    const timing = await this.calculatePhotoTiming(weddingDetails.date, weddingDetails.venue.coordinates);
    
    // Generate AI-powered shot list
    const shotList = await this.generateAIShotList(weddingDetails, venueAnalysis, timing);
    
    // Cache results for future use
    await this.cacheShotList(shotList, weddingDetails.id);
    
    return shotList;
  }

  async analyzeVenue(venueId: string, photoUrls: string[]): Promise<VenueAnalysis> {
    // Use OpenAI Vision to analyze venue photos
    const analysisResults = await Promise.all(
      photoUrls.map(url => this.analyzeVenuePhoto(url))
    );
    
    // Aggregate insights from all photos
    const aggregatedAnalysis = this.aggregatePhotoAnalysis(analysisResults);
    
    // Store analysis for future use
    await this.storeVenueAnalysis(venueId, aggregatedAnalysis);
    
    return aggregatedAnalysis;
  }

  async calculateOptimalTiming(weddingDate: Date, coordinates: Coordinates): Promise<PhotoTiming> {
    // Check cache first
    const cached = await this.getCachedTiming(weddingDate, coordinates);
    if (cached) return cached;
    
    // Calculate sunrise/sunset times
    const sunTimes = await this.getSunTimes(coordinates, weddingDate);
    
    // Calculate golden hour and blue hour
    const timing = this.calculatePhotoTiming(sunTimes);
    
    // Cache results
    await this.cachePhotoTiming(weddingDate, coordinates, timing);
    
    return timing;
  }
}

// Service: LightingCalculatorService
// Dependencies: Astronomical calculations, Weather API integration

class LightingCalculatorService {
  async calculateSunTimes(coordinates: Coordinates, date: Date): Promise<SunTimes> {
    const response = await fetch(
      `https://api.sunrise-sunset.org/json?lat=${coordinates.lat}&lng=${coordinates.lng}&date=${date.toISOString().split('T')[0]}&formatted=0`
    );
    
    const data = await response.json();
    
    return {
      sunrise: new Date(data.results.sunrise),
      sunset: new Date(data.results.sunset),
      solarNoon: new Date(data.results.solar_noon),
      civilTwilightBegin: new Date(data.results.civil_twilight_begin),
      civilTwilightEnd: new Date(data.results.civil_twilight_end)
    };
  }

  calculateGoldenHour(sunTimes: SunTimes): GoldenHour {
    return {
      morning: {
        start: new Date(sunTimes.sunrise.getTime() + 15 * 60 * 1000), // 15 min after sunrise
        end: new Date(sunTimes.sunrise.getTime() + 60 * 60 * 1000) // 1 hour after sunrise
      },
      evening: {
        start: new Date(sunTimes.sunset.getTime() - 60 * 60 * 1000), // 1 hour before sunset
        end: new Date(sunTimes.sunset.getTime() - 15 * 60 * 1000) // 15 min before sunset
      }
    };
  }
}
```

### CODE EXAMPLES

#### Example 1: AI-Powered Shot List Generation
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { OpenAI } from 'openai';
import { supabase } from '@/lib/supabase';

interface WeddingDetails {
  id: string;
  venue: {
    name: string;
    type: string;
    coordinates: { lat: number; lng: number };
    description?: string;
  };
  style: string;
  guestCount: number;
  ceremonyTime: string;
  seasonalNotes: string;
  specialRequests: string[];
  photographerStyle: string[];
}

export class ShotListAI {
  private openai: OpenAI;

  constructor() {
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });
  }

  async generateComprehensiveShotList(weddingDetails: WeddingDetails): Promise<any> {
    try {
      // Get venue analysis if available
      const venueAnalysis = await this.getVenueAnalysis(weddingDetails.venue.name);
      
      // Calculate optimal timing
      const photoTiming = await this.calculatePhotoTiming(
        new Date(weddingDetails.ceremonyTime), 
        weddingDetails.venue.coordinates
      );

      // Create comprehensive prompt for AI
      const prompt = this.buildShotListPrompt(weddingDetails, venueAnalysis, photoTiming);

      // Generate shot list using OpenAI
      const completion = await this.openai.chat.completions.create({
        model: "gpt-4",
        messages: [
          {
            role: "system",
            content: "You are an expert wedding photographer with 15 years of experience. Generate comprehensive, detailed shot lists that ensure no important moments are missed. Focus on the specific venue type, wedding style, and practical timing considerations."
          },
          {
            role: "user",
            content: prompt
          }
        ],
        temperature: 0.3, // Lower temperature for more consistent results
        max_tokens: 2000
      });

      const rawShotList = completion.choices[0]?.message?.content;
      if (!rawShotList) throw new Error('Failed to generate shot list');

      // Parse and structure the AI response
      const structuredShotList = await this.parseAndStructureShotList(rawShotList, weddingDetails);

      // Store in database for future reference
      await this.storeShotList(weddingDetails.id, structuredShotList);

      return structuredShotList;

    } catch (error) {
      console.error('Error generating shot list:', error);
      throw new Error('Failed to generate AI shot list');
    }
  }

  private buildShotListPrompt(
    wedding: WeddingDetails, 
    venueAnalysis: any, 
    timing: any
  ): string {
    return `Generate a comprehensive wedding shot list for:

WEDDING DETAILS:
- Venue: ${wedding.venue.name} (${wedding.venue.type})
- Wedding Style: ${wedding.style}
- Guest Count: ${wedding.guestCount}
- Ceremony Time: ${wedding.ceremonyTime}
- Season: ${wedding.seasonalNotes}
- Special Requests: ${wedding.specialRequests.join(', ')}
- Photographer Style: ${wedding.photographerStyle.join(', ')}

VENUE INSIGHTS:
${venueAnalysis?.bestPhotoSpots ? `Best Photo Spots: ${venueAnalysis.bestPhotoSpots.join(', ')}` : 'No venue analysis available'}
${venueAnalysis?.uniqueFeatures ? `Unique Features: ${venueAnalysis.uniqueFeatures.join(', ')}` : ''}

OPTIMAL TIMING:
- Golden Hour: ${timing.goldenHour?.evening?.start} - ${timing.goldenHour?.evening?.end}
- Blue Hour: ${timing.blueHour?.start} - ${timing.blueHour?.end}
- Sunset: ${timing.sunset}

Please provide a structured shot list with these categories:
1. GETTING READY (30-45 minutes)
2. FIRST LOOK (15-20 minutes) 
3. FAMILY FORMALS (30-45 minutes)
4. COUPLE PORTRAITS (45-60 minutes)
5. CEREMONY MOMENTS (captured during ceremony)
6. COCKTAIL HOUR (candid coverage)
7. RECEPTION DETAILS & DANCING

For each category, include:
- Specific shots with clear descriptions
- Priority level (Must-Have, Important, Nice-to-Have)
- Estimated time needed
- Optimal timing based on light/schedule
- Equipment recommendations
- Venue-specific opportunities

Focus on shots that are:
- Specific to ${wedding.venue.type} venues
- Appropriate for ${wedding.style} wedding style  
- Achievable with ${wedding.guestCount} guests
- Optimized for the available lighting conditions

Include practical details like backup indoor locations and weather contingencies.`;
  }

  private async parseAndStructureShotList(rawShotList: string, wedding: WeddingDetails): Promise<any> {
    // Parse the AI-generated text into structured data
    const categories = [];
    const lines = rawShotList.split('\n').filter(line => line.trim());
    
    let currentCategory = null;
    let currentShots = [];

    for (const line of lines) {
      const trimmed = line.trim();
      
      // Detect category headers (ALL CAPS with numbers)
      if (/^\d+\.\s+[A-Z\s]+(\([^)]+\))?\s*$/.test(trimmed)) {
        // Save previous category if exists
        if (currentCategory) {
          categories.push({
            ...currentCategory,
            shots: currentShots
          });
        }
        
        // Start new category
        const categoryName = trimmed.replace(/^\d+\.\s+/, '').replace(/\s*\([^)]+\)\s*$/, '');
        const timeMatch = trimmed.match(/\(([^)]+)\)/);
        
        currentCategory = {
          name: categoryName,
          estimatedTime: timeMatch ? timeMatch[1] : 'Variable',
          shots: []
        };
        currentShots = [];
      }
      // Detect individual shots (starting with bullet or dash)
      else if (/^[-•]\s+/.test(trimmed) && currentCategory) {
        const shotDescription = trimmed.replace(/^[-•]\s+/, '');
        const priority = this.determinePriority(shotDescription);
        
        currentShots.push({
          id: `shot-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
          description: shotDescription,
          priority: priority,
          estimatedTime: this.estimateTimeForShot(shotDescription),
          equipment: this.suggestEquipment(shotDescription),
          notes: this.extractNotes(shotDescription),
          completed: false
        });
      }
    }
    
    // Don't forget the last category
    if (currentCategory) {
      categories.push({
        ...currentCategory,
        shots: currentShots
      });
    }

    return {
      id: `shotlist-${wedding.id}`,
      weddingId: wedding.id,
      categories,
      metadata: {
        generatedAt: new Date().toISOString(),
        venue: wedding.venue.name,
        style: wedding.style,
        guestCount: wedding.guestCount,
        totalEstimatedTime: this.calculateTotalTime(categories)
      }
    };
  }

  private determinePriority(description: string): 'must-have' | 'important' | 'nice-to-have' {
    const mustHaveKeywords = ['ring exchange', 'first kiss', 'walking down aisle', 'vows', 'family formal'];
    const importantKeywords = ['first dance', 'cake cutting', 'bouquet toss', 'father daughter'];
    
    const lowerDesc = description.toLowerCase();
    
    if (mustHaveKeywords.some(keyword => lowerDesc.includes(keyword))) {
      return 'must-have';
    }
    
    if (importantKeywords.some(keyword => lowerDesc.includes(keyword))) {
      return 'important';
    }
    
    return 'nice-to-have';
  }

  private estimateTimeForShot(description: string): number {
    // Simple time estimation based on shot complexity
    if (description.toLowerCase().includes('family formal')) return 5;
    if (description.toLowerCase().includes('group')) return 3;
    if (description.toLowerCase().includes('detail')) return 2;
    if (description.toLowerCase().includes('portrait')) return 4;
    return 1; // Default 1 minute for quick shots
  }

  private async storeShotList(weddingId: string, shotList: any): Promise<void> {
    await supabase
      .from('ai_generated_shot_lists')
      .upsert({
        wedding_id: weddingId,
        photographer_id: await this.getCurrentPhotographerId(),
        generated_shots: shotList,
        ai_confidence_score: 0.85, // This would be calculated based on AI response quality
        generated_at: new Date().toISOString()
      });
  }

  private async getCurrentPhotographerId(): Promise<string> {
    const { data: { user } } = await supabase.auth.getUser();
    return user?.id || '';
  }

  private async getVenueAnalysis(venueName: string): Promise<any> {
    const { data } = await supabase
      .from('photo_venue_data')
      .select('*')
      .ilike('venue_name', `%${venueName}%`)
      .limit(1)
      .single();
    
    return data;
  }
}
```

#### Example 2: Venue Photo Analysis with AI Vision
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { OpenAI } from 'openai';

export class VenueAnalysisService {
  private openai: OpenAI;

  constructor() {
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });
  }

  async analyzeVenuePhotos(venueId: string, photoUrls: string[]): Promise<any> {
    try {
      const analysisResults = [];

      for (const photoUrl of photoUrls) {
        const analysis = await this.analyzeIndividualPhoto(photoUrl);
        analysisResults.push(analysis);
        
        // Add delay to respect API rate limits
        await this.delay(500);
      }

      // Aggregate all analysis results
      const venueAnalysis = this.aggregateAnalysis(analysisResults);
      
      // Store results in database
      await this.storeVenueAnalysis(venueId, venueAnalysis, photoUrls);

      return venueAnalysis;

    } catch (error) {
      console.error('Venue analysis failed:', error);
      throw new Error('Failed to analyze venue photos');
    }
  }

  private async analyzeIndividualPhoto(photoUrl: string): Promise<any> {
    try {
      const response = await this.openai.chat.completions.create({
        model: "gpt-4-vision-preview",
        messages: [
          {
            role: "system",
            content: "You are an expert wedding photographer analyzing venue photos. Identify photo opportunities, lighting conditions, architectural features, and practical considerations for wedding photography."
          },
          {
            role: "user",
            content: [
              {
                type: "text",
                text: `Analyze this wedding venue photo for photography opportunities. Please provide:

1. PHOTO SPOTS: Identify the best areas for different types of photos (ceremony, portraits, family photos, detail shots)

2. LIGHTING ANALYSIS: Describe the natural lighting conditions, time of day considerations, and any challenging lighting situations

3. ARCHITECTURAL FEATURES: Note interesting architectural elements that could enhance photos

4. PRACTICAL CONSIDERATIONS: Any accessibility issues, space limitations, or logistics photographers should know

5. EQUIPMENT RECOMMENDATIONS: Suggest specific equipment that would work well in this space

6. TIMING RECOMMENDATIONS: Best times of day for photos in this location

Format your response as structured JSON with these categories.`
              },
              {
                type: "image_url",
                image_url: {
                  url: photoUrl,
                  detail: "high"
                }
              }
            ]
          }
        ],
        max_tokens: 1000,
        temperature: 0.2
      });

      const analysisText = response.choices[0]?.message?.content;
      
      // Parse JSON response or create structured data from text
      let analysisData;
      try {
        analysisData = JSON.parse(analysisText || '{}');
      } catch {
        // If AI didn't return valid JSON, parse the text response
        analysisData = this.parseAnalysisText(analysisText || '');
      }

      return {
        photoUrl,
        analysis: analysisData,
        analyzedAt: new Date().toISOString()
      };

    } catch (error) {
      console.error(`Error analyzing photo ${photoUrl}:`, error);
      return {
        photoUrl,
        analysis: { error: 'Analysis failed' },
        analyzedAt: new Date().toISOString()
      };
    }
  }

  private aggregateAnalysis(results: any[]): any {
    const aggregated = {
      photoSpots: [],
      lightingAnalysis: {
        naturalLightAvailability: 'varied',
        challenges: [],
        recommendations: []
      },
      architecturalFeatures: [],
      practicalConsiderations: [],
      equipmentRecommendations: new Set(),
      timingRecommendations: [],
      weatherBackupSpots: [],
      uniqueFeatures: []
    };

    // Process each analysis result
    for (const result of results) {
      if (result.analysis.error) continue;

      const analysis = result.analysis;

      // Aggregate photo spots
      if (analysis.photoSpots) {
        aggregated.photoSpots.push(...(Array.isArray(analysis.photoSpots) ? analysis.photoSpots : [analysis.photoSpots]));
      }

      // Aggregate lighting information
      if (analysis.lightingAnalysis) {
        if (analysis.lightingAnalysis.challenges) {
          aggregated.lightingAnalysis.challenges.push(...analysis.lightingAnalysis.challenges);
        }
        if (analysis.lightingAnalysis.recommendations) {
          aggregated.lightingAnalysis.recommendations.push(...analysis.lightingAnalysis.recommendations);
        }
      }

      // Aggregate architectural features
      if (analysis.architecturalFeatures) {
        aggregated.architecturalFeatures.push(...analysis.architecturalFeatures);
      }

      // Aggregate equipment recommendations
      if (analysis.equipmentRecommendations) {
        analysis.equipmentRecommendations.forEach(item => aggregated.equipmentRecommendations.add(item));
      }

      // Aggregate timing recommendations
      if (analysis.timingRecommendations) {
        aggregated.timingRecommendations.push(...analysis.timingRecommendations);
      }
    }

    // Convert Set back to Array and remove duplicates from other arrays
    return {
      ...aggregated,
      equipmentRecommendations: Array.from(aggregated.equipmentRecommendations),
      photoSpots: this.removeDuplicates(aggregated.photoSpots),
      lightingAnalysis: {
        ...aggregated.lightingAnalysis,
        challenges: this.removeDuplicates(aggregated.lightingAnalysis.challenges),
        recommendations: this.removeDuplicates(aggregated.lightingAnalysis.recommendations)
      },
      architecturalFeatures: this.removeDuplicates(aggregated.architecturalFeatures),
      timingRecommendations: this.removeDuplicates(aggregated.timingRecommendations)
    };
  }

  private async storeVenueAnalysis(venueId: string, analysis: any, photoUrls: string[]): Promise<void> {
    await supabase
      .from('photo_venue_data')
      .upsert({
        venue_id: venueId,
        best_photo_spots: analysis.photoSpots || [],
        lighting_analysis: analysis.lightingAnalysis || {},
        photographer_tips: analysis.practicalConsiderations || [],
        analyzed_by_ai: true,
        photo_samples: photoUrls,
        updated_at: new Date().toISOString()
      });

    // Store individual photo analysis results
    for (const photoUrl of photoUrls) {
      const photoResult = analysis.results?.find(r => r.photoUrl === photoUrl);
      if (photoResult) {
        await supabase
          .from('venue_photo_analysis')
          .insert({
            venue_id: venueId,
            photo_url: photoUrl,
            analysis_results: photoResult.analysis,
            analyzed_at: new Date().toISOString(),
            ai_model_version: 'gpt-4-vision-preview'
          });
      }
    }
  }

  private parseAnalysisText(text: string): any {
    // Fallback parser for when AI doesn't return JSON
    const sections = {
      photoSpots: [],
      lightingAnalysis: {},
      architecturalFeatures: [],
      equipmentRecommendations: [],
      timingRecommendations: []
    };

    const lines = text.split('\n').filter(line => line.trim());
    
    let currentSection = null;
    
    for (const line of lines) {
      const trimmed = line.trim();
      
      if (trimmed.toLowerCase().includes('photo spot')) {
        currentSection = 'photoSpots';
      } else if (trimmed.toLowerCase().includes('lighting')) {
        currentSection = 'lightingAnalysis';
      } else if (trimmed.toLowerCase().includes('architectural')) {
        currentSection = 'architecturalFeatures';
      } else if (trimmed.toLowerCase().includes('equipment')) {
        currentSection = 'equipmentRecommendations';
      } else if (trimmed.toLowerCase().includes('timing')) {
        currentSection = 'timingRecommendations';
      } else if (trimmed.startsWith('-') || trimmed.startsWith('•') && currentSection) {
        const content = trimmed.replace(/^[-•]\s*/, '');
        if (currentSection === 'lightingAnalysis') {
          sections[currentSection].recommendations = sections[currentSection].recommendations || [];
          sections[currentSection].recommendations.push(content);
        } else {
          sections[currentSection].push(content);
        }
      }
    }
    
    return sections;
  }

  private removeDuplicates(array: string[]): string[] {
    return Array.from(new Set(array.filter(item => typeof item === 'string' && item.trim())));
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Ref MCP: Search docs for OpenAI Vision API, Sunrise/Sunset APIs, Google Maps integration
- [x] PostgreSQL MCP: Database operations for venue data and shot lists
- [x] Supabase MCP: Real-time updates and file storage for venue photos
- [x] Sequential Thinking MCP: Complex venue analysis algorithm planning and shot list optimization
- [x] Browser MCP: Interactive testing of AI tools and timeline components
- [x] OpenAI MCP: Direct AI API calls for shot list generation and photo analysis

#### Ref MCP Searches Needed
```bash
# Use Ref MCP to search for:
# - "OpenAI Vision API wedding photography analysis"
# - "Sunrise Sunset API integration best practices"  
# - "React drag and drop timeline components"
# - "Google Maps Places API venue coordinates"
# - "PDF generation for shot lists React"
```

#### Browser MCP Interactive Testing
```bash
# Use Browser MCP for:
# - Test shot list generation form and AI loading states
# - Verify timeline component drag-and-drop functionality
# - Test venue photo upload and analysis display
# - Capture screenshots of generated shot lists for documentation
# - Test mobile responsiveness of photography tools
# - Verify PDF export functionality for shot lists
# - Test integration with calendar applications
```

#### Sequential Thinking MCP Planning (For Complex Features)
```yaml
# Use Sequential Thinking MCP to optimize photography AI:

# 1. Shot List Generation Strategy
- What wedding photography knowledge should AI prioritize?
- How to balance comprehensive coverage with practical time limits?
- What venue-specific factors most impact shot planning?

# 2. Venue Analysis Optimization  
- How many photos needed for accurate venue analysis?
# - What lighting conditions can AI reliably detect and recommend?
- How to provide actionable insights vs overwhelming information?

# 3. Timing Calculation Accuracy
- How to account for seasonal variations and weather patterns?
- What buffer times are realistic for different shot types?
- How to integrate ceremony schedule with optimal lighting?

# 4. User Experience Design
- How to present AI suggestions without overwhelming photographers?
- What customization options are most valuable?
- How to build photographer confidence in AI recommendations?
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('ShotListAI', () => {
  it('should generate structured shot list from wedding details', async () => {
    const ai = new ShotListAI();
    const weddingDetails = {
      venue: { name: 'Garden Venue', type: 'outdoor', coordinates: {lat: 40.7128, lng: -74.0060} },
      style: 'rustic',
      guestCount: 100,
      ceremonyTime: '2024-06-15T16:00:00Z'
    };
    
    const shotList = await ai.generateComprehensiveShotList(weddingDetails);
    
    expect(shotList.categories).toBeDefined();
    expect(shotList.categories.length).toBeGreaterThan(5);
    expect(shotList.metadata.venue).toBe('Garden Venue');
  });

  it('should calculate accurate photo timing for given coordinates', async () => {
    const calculator = new LightingCalculatorService();
    const timing = await calculator.calculateOptimalTiming(
      new Date('2024-06-15'),
      { lat: 40.7128, lng: -74.0060 }
    );
    
    expect(timing.sunrise).toBeDefined();
    expect(timing.sunset).toBeDefined();
    expect(timing.goldenHour.evening.start).toBefore(timing.sunset);
  });
});

describe('VenueAnalysisService', () => {
  it('should analyze venue photos and return structured insights', async () => {
    const service = new VenueAnalysisService();
    const mockPhotoUrls = ['https://example.com/venue1.jpg'];
    
    const analysis = await service.analyzeVenuePhotos('venue-123', mockPhotoUrls);
    
    expect(analysis.photoSpots).toBeDefined();
    expect(analysis.lightingAnalysis).toBeDefined();
    expect(analysis.equipmentRecommendations).toBeDefined();
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP for automated testing
test('Photography AI tools - shot list generation flow', async () => {
  await mcp__playwright__browser_navigate({url: '/photography/ai-tools'});
  
  // Fill out wedding details form
  await mcp__playwright__browser_fill_form([
    {name: 'venue-name', type: 'textbox', ref: '[data-testid="venue-name"]', value: 'Mountain View Lodge'},
    {name: 'venue-type', type: 'combobox', ref: '[data-testid="venue-type"]', value: 'outdoor'},
    {name: 'guest-count', type: 'textbox', ref: '[data-testid="guest-count"]', value: '150'},
    {name: 'ceremony-time', type: 'textbox', ref: '[data-testid="ceremony-time"]', value: '2024-07-20T17:00'}
  ]);
  
  // Generate shot list
  await mcp__playwright__browser_click({
    element: 'generate button',
    ref: '[data-testid="generate-shot-list"]'
  });
  
  // Wait for AI generation
  await mcp__playwright__browser_wait_for({text: 'Shot list generated'});
  
  // Verify shot list categories are displayed
  await mcp__playwright__browser_wait_for({text: 'GETTING READY'});
  await mcp__playwright__browser_wait_for({text: 'COUPLE PORTRAITS'});
  
  // Take screenshot for documentation
  await mcp__playwright__browser_take_screenshot({
    filename: 'photography-ai-shot-list.png',
    fullPage: true
  });
});

test('Venue analysis photo upload and insights', async () => {
  await mcp__playwright__browser_navigate({url: '/photography/venue-analysis'});
  
  // Upload venue photos (mock)
  await mcp__playwright__browser_file_upload({
    paths: ['/path/to/test/venue-photo.jpg']
  });
  
  // Start analysis
  await mcp__playwright__browser_click({
    element: 'analyze button',
    ref: '[data-testid="analyze-venue"]'
  });
  
  // Wait for AI analysis
  await mcp__playwright__browser_wait_for({text: 'Analysis complete'});
  
  // Verify insights are displayed
  await mcp__playwright__browser_wait_for({text: 'Photo Spots'});
  await mcp__playwright__browser_wait_for({text: 'Lighting Analysis'});
  
  // Take screenshot of analysis results
  await mcp__playwright__browser_take_screenshot({
    filename: 'venue-analysis-results.png'
  });
});

test('Photo timing calculator with timeline visualization', async () => {
  await mcp__playwright__browser_navigate({url: '/photography/timing-calculator'});
  
  // Enter wedding details
  await mcp__playwright__browser_type({
    element: 'wedding date input',
    ref: '[data-testid="wedding-date"]',
    text: '2024-08-15'
  });
  
  await mcp__playwright__browser_type({
    element: 'venue location',
    ref: '[data-testid="venue-location"]', 
    text: 'Napa Valley, CA'
  });
  
  // Calculate timing
  await mcp__playwright__browser_click({
    element: 'calculate button',
    ref: '[data-testid="calculate-timing"]'
  });
  
  // Verify timeline visualization
  await mcp__playwright__browser_wait_for({text: 'Golden Hour'});
  await mcp__playwright__browser_wait_for({text: 'Blue Hour'});
  
  // Test timeline interaction
  await mcp__playwright__browser_drag({
    startElement: 'couple portraits block',
    startRef: '[data-testid="couple-portraits"]',
    endElement: 'golden hour slot',
    endRef: '[data-testid="golden-hour-slot"]'
  });
  
  // Capture interactive timeline
  await mcp__playwright__browser_take_screenshot({
    filename: 'photography-timeline-calculator.png'
  });
});
```

#### Interactive Testing with Browser MCP
```typescript
// Use Browser MCP during development for immediate feedback
// 1. Test shot list generation with different venue types
const venueTypes = ['outdoor', 'indoor', 'beach', 'church', 'barn'];

for (const venueType of venueTypes) {
  await browser_navigate('/photography/ai-tools');
  
  await browser_fill_form([
    {name: 'venue-type', type: 'combobox', ref: '[data-testid="venue-type"]', value: venueType},
    {name: 'guest-count', type: 'textbox', ref: '[data-testid="guest-count"]', value: '100'}
  ]);
  
  await browser_click('[data-testid="generate-shot-list"]');
  await browser_wait_for('Shot list generated');
  
  await browser_take_screenshot(`shot-list-${venueType}.png`);
}

// 2. Test timing calculator accuracy
await browser_navigate('/photography/timing-calculator');

// Test different seasons and locations
const testCases = [
  { date: '2024-06-21', location: 'New York, NY' }, // Summer solstice
  { date: '2024-12-21', location: 'New York, NY' }, // Winter solstice  
  { date: '2024-09-15', location: 'California, CA' }  // Fall wedding
];

for (const testCase of testCases) {
  await browser_type('[data-testid="wedding-date"]', testCase.date);
  await browser_type('[data-testid="venue-location"]', testCase.location);
  await browser_click('[data-testid="calculate-timing"]');
  
  await browser_wait_for('Golden Hour');
  await browser_take_screenshot(`timing-${testCase.date}-${testCase.location.replace(/\s/g, '-')}.png`);
}

// 3. Test mobile responsiveness
await browser_resize(375, 667);
await browser_navigate('/photography/ai-tools');
await browser_take_screenshot('photography-ai-mobile.png');
```

### ACCEPTANCE CRITERIA
- [x] **AI Shot List Generation**: Comprehensive, venue-specific shot lists generated using GPT-4 with wedding photography expertise
- [x] **Optimal Timing Calculator**: Accurate sunrise/sunset, golden hour, and blue hour calculations based on venue coordinates and wedding date
- [x] **Venue Analysis**: AI-powered photo analysis of venue images providing actionable photography insights
- [x] **Timeline Optimization**: Visual timeline builder that optimizes photo sessions based on lighting conditions
- [x] **Equipment Recommendations**: AI suggests specific photography equipment based on venue analysis and shot requirements
- [x] **Weather Contingency Planning**: Backup indoor location suggestions and alternative timing recommendations
- [x] **Shot List Customization**: Photographers can modify, add, and organize AI-generated shot lists
- [ ] Performance: Shot list generation completes within 30 seconds, venue analysis within 60 seconds per photo
- [ ] Security: All uploaded venue photos stored securely with proper access controls
- [ ] Accessibility: Photography tools interface meets WCAG 2.1 AA standards
- [x] **Navigation Integration: Feature properly integrated into parent dashboard/navigation (MANDATORY for all UI features)**
  - [x] Photography AI Tools section added to photographer dashboard under "Smart Tools"
  - [x] Mobile navigation includes camera icon for photography features
  - [x] Breadcrumb navigation shows "Dashboard > Photography > AI Tools"
  - [x] Active state highlighting for photography tool sections
  - [x] Accessibility labels for photography navigation ("AI-powered photography tools")
  - [x] Navigation integration verified with Browser MCP testing

### DEPENDENCIES
- Must complete after: WS-250 (Chatbot Analytics) - shares AI infrastructure patterns
- Must complete before: WS-252 (Music Database Integration) - establishes vendor-specific AI patterns
- Shares code with: WS-127 (Photography AI System) - may be duplicate or related feature

### ESTIMATED EFFORT
- Team A Frontend: 36 hours (AI tool interfaces, timeline visualization, mobile optimization)
- Team B Backend: 42 hours (AI integration, venue analysis, timing calculations, database schema)
- Team C Integration: 18 hours (OpenAI Vision API, Sunrise-Sunset API, Maps API)
- Team D Platform: 12 hours (Photo storage optimization, caching strategy)
- Team E General: 20 hours (Testing, documentation, QA)
- Team F Workflows: 8 hours (Photography workflow design and integration)
- Team G Performance: 10 hours (AI response optimization, database query tuning)
- Total: 146 hours