# TECHNICAL SPECIFICATION: WS-122 - Field Extraction Implementation
## Generated by Feature Development Session - August 23, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding venue coordinator managing 50+ weddings per year
**I want to:** Have AI automatically identify and categorize every field from my uploaded forms with wedding-specific intelligence
**So that:** The 200+ fields across my 8 different forms are correctly extracted with proper validation rules, saving 8 hours of manual setup per form update

**Real Wedding Scenario:**
A venue coordinator has different forms for ceremony setup, reception layout, catering preferences, and vendor coordination. Each form has 20-40 fields with specific validation needs (dates must be future, guest counts must be numbers, dietary fields must be multi-select). Manual field extraction means checking each field type, setting validation, and mapping to the right category. With AI field extraction, the system recognizes "Number of Guests" as a numeric field with 1-500 range, "Ceremony Time" as a time field, and "Dietary Requirements" as a multi-select automatically.

### SPECIFICATION SOURCE
- **Feature ID:** WS-122
- **Original Spec:** /CORE-SPECIFICATIONS/04-AI-INTEGRATION/02-Form-Intelligence/02-field-extraction md.md
- **Current Implementation:** 0% complete
- **Files to Modify:** None - New feature building on WS-121
- **New Files to Create:**
  - /src/lib/ai/field-extractor.ts
  - /src/lib/ai/wedding-field-detector.ts
  - /src/lib/ai/confidence-scorer.ts
  - /src/lib/ai/extraction-recovery.ts
  - /src/components/forms/field-review.tsx
  - /src/app/api/forms/field-extraction/route.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Field extraction metadata and patterns
CREATE TABLE IF NOT EXISTS field_extraction_patterns (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  pattern_name TEXT NOT NULL UNIQUE,
  pattern_regex TEXT NOT NULL,
  field_type TEXT NOT NULL,
  category TEXT CHECK (category IN ('core', 'photography', 'catering', 'music', 'venue', 'general')),
  confidence_weight DECIMAL(3,2) DEFAULT 1.0,
  usage_count INTEGER DEFAULT 0,
  success_rate DECIMAL(3,2),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Wedding field mappings
CREATE TABLE IF NOT EXISTS wedding_field_mappings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  extracted_label TEXT NOT NULL,
  normalized_name TEXT NOT NULL,
  core_field_id TEXT,
  category TEXT NOT NULL,
  supplier_type TEXT[], -- ['photographer', 'venue', 'caterer', etc.]
  auto_populate BOOLEAN DEFAULT false,
  validation_rules JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Field extraction history for learning
CREATE TABLE IF NOT EXISTS field_extraction_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  job_id UUID REFERENCES pdf_analysis_jobs(id),
  original_label TEXT NOT NULL,
  detected_type TEXT NOT NULL,
  confidence_score DECIMAL(3,2),
  user_corrected_type TEXT,
  user_confirmed BOOLEAN DEFAULT false,
  extraction_method TEXT CHECK (extraction_method IN ('ai', 'pattern', 'manual', 'fallback')),
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_extraction_patterns_type ON field_extraction_patterns(field_type);
CREATE INDEX idx_wedding_mappings_category ON wedding_field_mappings(category);
CREATE INDEX idx_extraction_history_confidence ON field_extraction_history(confidence_score);
```

#### API Endpoints Required
```typescript
// POST /api/forms/field-extraction/extract
interface ExtractFieldsRequest {
  text: string;
  imageUrls?: string[];
  context: 'wedding' | 'general';
  supplierType?: 'photographer' | 'venue' | 'caterer' | 'florist' | 'dj';
  jobId?: string; // Link to PDF analysis job
}

interface ExtractFieldsResponse {
  success: boolean;
  data: {
    fields: ExtractedField[];
    confidence: {
      overall: number;
      byField: Record<string, number>;
      issues: string[];
    };
    categories: {
      core: ExtractedField[];
      vendorSpecific: ExtractedField[];
      custom: ExtractedField[];
    };
  };
}

// POST /api/forms/field-extraction/enhance
interface EnhanceFieldsRequest {
  fields: ExtractedField[];
  supplierType: string;
  applyWeddingIntelligence: boolean;
}

interface EnhanceFieldsResponse {
  fields: EnhancedField[];
  mappings: CoreFieldMapping[];
  suggestions: FieldSuggestion[];
}

// PUT /api/forms/field-extraction/confirm
interface ConfirmFieldsRequest {
  historyId: string;
  fields: {
    id: string;
    userConfirmed: boolean;
    corrections?: {
      type?: string;
      label?: string;
      validation?: any;
    };
  }[];
}
```

#### Frontend Components Required
```typescript
// Component: FieldExtractionReview
// Location: /src/components/forms/field-extraction-review.tsx

interface FieldExtractionReviewProps {
  extractedFields: ExtractedField[];
  confidence: ExtractionConfidence;
  onFieldCorrect: (fieldId: string, correction: FieldCorrection) => void;
  onConfirmAll: () => void;
  showWeddingMappings?: boolean;
}

// Key functionality:
- Display extracted fields grouped by confidence level
- Show AI reasoning for each field type detection
- Quick correction interface for misidentified fields
- Wedding field mapping suggestions
- Bulk actions for similar fields
- Real-time validation preview

// Component: WeddingFieldMapper
// Location: /src/components/forms/wedding-field-mapper.tsx

interface WeddingFieldMapperProps {
  fields: ExtractedField[];
  supplierType: string;
  onMapField: (fieldId: string, coreFieldId: string) => void;
  onCreateCustomField: (field: ExtractedField) => void;
}

// Key functionality:
- Visual mapping between extracted and core wedding fields
- Drag-and-drop field association
- Auto-suggest likely mappings based on labels
- Preview of auto-population behavior
- Custom field creation for non-standard fields
```

#### Integration Points
```typescript
// Service: FieldExtractor
// Dependencies: OpenAI API, Pattern Matcher, Wedding Detector

class FieldExtractor {
  private openai: OpenAI;
  private weddingDetector: WeddingFieldDetector;
  private patternMatcher: PatternMatcher;
  
  async extractFields(
    text: string,
    context: ExtractionContext
  ): Promise<ExtractedField[]> {
    // Step 1: AI extraction for comprehensive analysis
    const aiFields = await this.extractWithAI(text, context);
    
    // Step 2: Pattern-based extraction for validation
    const patternFields = await this.extractWithPatterns(text);
    
    // Step 3: Merge and enhance with wedding intelligence
    const mergedFields = this.mergeExtractions(aiFields, patternFields);
    
    // Step 4: Apply wedding-specific enhancements
    if (context.type === 'wedding') {
      return this.enhanceWithWeddingContext(mergedFields, context.supplierType);
    }
    
    return mergedFields;
  }
  
  private async extractWithAI(text: string, context: ExtractionContext) {
    const systemPrompt = this.buildExtractionPrompt(context);
    
    const response = await this.openai.chat.completions.create({
      model: 'gpt-4',
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: `Extract all form fields from:\n\n${text}` }
      ],
      response_format: { type: 'json_object' },
      temperature: 0.1 // Low temperature for consistency
    });
    
    const result = JSON.parse(response.choices[0].message.content);
    return this.parseAIResponse(result);
  }
  
  private enhanceWithWeddingContext(
    fields: ExtractedField[],
    supplierType?: string
  ): ExtractedField[] {
    return fields.map(field => {
      const weddingCategory = this.weddingDetector.detectCategory(field.label);
      const coreMapping = this.findCoreFieldMapping(field, supplierType);
      
      return {
        ...field,
        weddingCategory,
        coreFieldId: coreMapping?.id,
        autoPopulate: coreMapping?.autoPopulate || false,
        supplierRelevance: this.calculateSupplierRelevance(field, supplierType),
        validation: this.enhanceValidation(field, weddingCategory)
      };
    });
  }
}
```

### CODE EXAMPLES

#### Example 1: Wedding Field Detection Implementation
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { supabase } from '@/lib/supabase';

export class WeddingFieldDetector {
  private weddingPatterns = {
    // Core wedding fields that all suppliers need
    core: {
      weddingDate: {
        patterns: [/wedding\s*date/i, /ceremony\s*date/i, /big\s*day/i],
        fieldType: 'date',
        validation: { required: true, futureDate: true }
      },
      coupleNames: {
        patterns: [/couple|bride|groom|partner\s*names?/i],
        fieldType: 'text',
        validation: { required: true, maxLength: 200 }
      },
      guestCount: {
        patterns: [/guest\s*count|number\s*of\s*guests|total\s*guests/i],
        fieldType: 'number',
        validation: { required: true, min: 1, max: 1000 }
      },
      venueAddress: {
        patterns: [/venue\s*address|ceremony\s*location|reception\s*location/i],
        fieldType: 'address',
        validation: { required: true, geocoding: true }
      }
    },
    
    // Photography-specific fields
    photography: {
      shotList: {
        patterns: [/shot\s*list|must\s*have\s*shots|photo\s*list/i],
        fieldType: 'textarea',
        validation: { maxLength: 2000 }
      },
      firstLook: {
        patterns: [/first\s*look|private\s*moment|reveal/i],
        fieldType: 'boolean',
        validation: {}
      },
      familyPhotos: {
        patterns: [/family\s*photos|group\s*photos|formal\s*shots/i],
        fieldType: 'textarea',
        validation: { maxLength: 1000 }
      }
    },
    
    // Catering-specific fields
    catering: {
      dietaryRestrictions: {
        patterns: [/dietary|allergies|food\s*restrictions/i],
        fieldType: 'multiselect',
        validation: { 
          options: ['Vegetarian', 'Vegan', 'Gluten-Free', 'Nut-Free', 'Dairy-Free', 'Halal', 'Kosher', 'Other']
        }
      },
      mealChoice: {
        patterns: [/meal\s*choice|dinner\s*selection|entree/i],
        fieldType: 'select',
        validation: { required: true }
      },
      serviceStyle: {
        patterns: [/service\s*style|buffet|plated|family\s*style/i],
        fieldType: 'select',
        validation: {
          options: ['Plated', 'Buffet', 'Family Style', 'Cocktail Style']
        }
      }
    }
  };
  
  async detectWeddingField(label: string, context?: string): Promise<WeddingFieldMatch | null> {
    const normalizedLabel = label.toLowerCase();
    const contextString = (context || '').toLowerCase();
    
    // Check each category
    for (const [category, fields] of Object.entries(this.weddingPatterns)) {
      for (const [fieldName, config] of Object.entries(fields)) {
        for (const pattern of config.patterns) {
          if (pattern.test(normalizedLabel) || pattern.test(contextString)) {
            return {
              category,
              fieldName,
              fieldType: config.fieldType,
              validation: config.validation,
              confidence: this.calculateMatchConfidence(normalizedLabel, pattern),
              autoPopulate: category === 'core'
            };
          }
        }
      }
    }
    
    return null;
  }
  
  private calculateMatchConfidence(label: string, pattern: RegExp): number {
    const match = label.match(pattern);
    if (!match) return 0;
    
    // Higher confidence for exact matches
    const exactMatch = match[0].length === label.length;
    const baseScore = exactMatch ? 0.9 : 0.7;
    
    // Adjust based on match position
    const matchPosition = match.index || 0;
    const positionPenalty = matchPosition * 0.01;
    
    return Math.max(0.5, baseScore - positionPenalty);
  }
  
  async learnFromCorrection(
    originalLabel: string,
    detectedType: string,
    correctedType: string,
    supplierType: string
  ) {
    // Store correction for pattern improvement
    await supabase
      .from('field_extraction_history')
      .insert({
        original_label: originalLabel,
        detected_type: detectedType,
        user_corrected_type: correctedType,
        supplier_type: supplierType,
        created_at: new Date().toISOString()
      });
    
    // Update pattern confidence if multiple corrections
    const { data: corrections } = await supabase
      .from('field_extraction_history')
      .select('*')
      .eq('original_label', originalLabel)
      .eq('user_corrected_type', correctedType);
    
    if (corrections && corrections.length >= 3) {
      // Pattern needs adjustment
      await this.suggestPatternUpdate(originalLabel, correctedType);
    }
  }
}
```

#### Example 2: Confidence Scoring System
```typescript
// Comprehensive confidence scoring for extracted fields
export class FieldConfidenceScorer {
  calculateFieldConfidence(field: ExtractedField): FieldConfidence {
    const scores = {
      labelClarity: this.scoreLabelClarity(field.label),
      typeMatch: this.scoreTypeMatch(field),
      validationLogic: this.scoreValidation(field.validation),
      weddingRelevance: this.scoreWeddingRelevance(field),
      patternMatch: this.scorePatternMatch(field)
    };
    
    // Weighted average
    const weights = {
      labelClarity: 0.25,
      typeMatch: 0.30,
      validationLogic: 0.15,
      weddingRelevance: 0.20,
      patternMatch: 0.10
    };
    
    const overall = Object.entries(scores).reduce((sum, [key, score]) => {
      return sum + (score * weights[key]);
    }, 0);
    
    return {
      overall: Math.round(overall * 100),
      breakdown: scores,
      issues: this.identifyIssues(scores),
      recommendation: this.getRecommendation(overall)
    };
  }
  
  private scoreLabelClarity(label: string): number {
    if (!label || label.length < 3) return 0.2;
    if (label.length > 100) return 0.5;
    if (!/[a-zA-Z]/.test(label)) return 0.3;
    if (/^[A-Z]/.test(label)) return 0.9; // Proper capitalization
    return 0.7;
  }
  
  private scoreTypeMatch(field: ExtractedField): number {
    // Check if detected type matches expected patterns
    const typePatterns = {
      email: /email|e-?mail/i,
      phone: /phone|tel|mobile/i,
      date: /date|when|day/i,
      number: /count|number|quantity/i,
      select: /choose|select|pick/i
    };
    
    const pattern = typePatterns[field.type];
    if (pattern && pattern.test(field.label)) {
      return 0.95;
    }
    
    if (field.type === 'text') {
      return 0.5; // Generic type, lower confidence
    }
    
    return 0.7;
  }
  
  private scoreWeddingRelevance(field: ExtractedField): number {
    const weddingKeywords = [
      'wedding', 'ceremony', 'reception', 'bride', 'groom',
      'guest', 'venue', 'photographer', 'caterer', 'flowers',
      'music', 'dance', 'timeline', 'schedule'
    ];
    
    const label = field.label.toLowerCase();
    const matchCount = weddingKeywords.filter(keyword => 
      label.includes(keyword)
    ).length;
    
    if (matchCount >= 2) return 1.0;
    if (matchCount === 1) return 0.8;
    return 0.4;
  }
  
  private identifyIssues(scores: any): string[] {
    const issues = [];
    
    if (scores.labelClarity < 0.5) {
      issues.push('Field label may be unclear or too short');
    }
    if (scores.typeMatch < 0.6) {
      issues.push('Field type detection uncertain');
    }
    if (scores.weddingRelevance < 0.5) {
      issues.push('May not be wedding-specific field');
    }
    
    return issues;
  }
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [ ] Context7: Load OpenAI API documentation for field extraction
- [ ] Supabase: Database operations for patterns and history
- [ ] Filesystem: Access extracted text from PDF analysis

#### Context7 Queries Needed
```typescript
// Load OpenAI structured output documentation
await mcp__context7__get-library-docs("/openai/openai", "structured outputs json_object", 3000);

// Load form validation libraries
await mcp__context7__get-library-docs("/react-hook-form/react-hook-form", "validation rules patterns", 2000);

// Load natural language processing utilities
await mcp__context7__get-library-docs("/compromise/compromise", "text parsing extraction", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('FieldExtractor', () => {
  const extractor = new FieldExtractor();
  
  it('should extract email fields correctly', async () => {
    const text = 'Email Address: ________';
    const fields = await extractor.extractFields(text, { type: 'general' });
    expect(fields[0].type).toBe('email');
    expect(fields[0].label).toBe('Email Address');
  });
  
  it('should detect wedding-specific fields', async () => {
    const text = 'Wedding Date: _____ Number of Guests: _____';
    const fields = await extractor.extractFields(text, { type: 'wedding' });
    
    expect(fields[0].weddingCategory).toBe('core');
    expect(fields[0].coreFieldId).toBe('wedding_date');
    expect(fields[1].coreFieldId).toBe('guest_count');
  });
  
  it('should handle multi-select fields', async () => {
    const text = 'Dietary Requirements (select all that apply): □ Vegetarian □ Vegan □ Gluten-Free';
    const fields = await extractor.extractFields(text, { type: 'wedding' });
    
    expect(fields[0].type).toBe('multiselect');
    expect(fields[0].validation.options).toContain('Vegetarian');
  });
  
  it('should calculate confidence scores', async () => {
    const scorer = new FieldConfidenceScorer();
    const field = { label: 'Email', type: 'email', validation: { required: true } };
    const confidence = scorer.calculateFieldConfidence(field);
    
    expect(confidence.overall).toBeGreaterThan(70);
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Field extraction and correction flow', async () => {
  // Navigate to extraction review page
  await mcp__playwright__browser_navigate({url: '/forms/extraction/review'});
  
  // Check extracted fields display
  await mcp__playwright__browser_snapshot();
  // Should show extracted fields with confidence indicators
  
  // Correct a misidentified field
  await mcp__playwright__browser_click({
    element: 'Edit field type',
    ref: '[data-field="guest_count"] button'
  });
  
  await mcp__playwright__browser_select_option({
    element: 'Field type selector',
    ref: 'select[name="fieldType"]',
    values: ['number']
  });
  
  // Confirm all fields
  await mcp__playwright__browser_click({
    element: 'Confirm All Fields',
    ref: 'button#confirm-all'
  });
  
  // Verify fields saved
  await mcp__playwright__browser_wait_for({
    text: 'Fields confirmed and saved'
  });
});
```

### ACCEPTANCE CRITERIA
- [ ] Extracts 90%+ of fields from well-formatted forms
- [ ] Correctly identifies field types with 85%+ accuracy
- [ ] Detects wedding-specific fields with proper categorization
- [ ] Provides confidence scores for each extracted field
- [ ] Allows manual correction of misidentified fields
- [ ] Maps fields to core wedding data when applicable
- [ ] Handles multi-language forms (English primary)
- [ ] Processes extraction in under 5 seconds per page
- [ ] Learns from user corrections to improve accuracy
- [ ] Provides fallback extraction for API failures

### DEPENDENCIES
- Must complete after: WS-121 (PDF Analysis System)
- Must complete before: WS-123 (Smart Mapping)
- Shares code with: WS-121, WS-123 (AI form intelligence pipeline)

### ESTIMATED EFFORT
- Team A Frontend: 12 hours (review UI, correction interface)
- Team B Backend: 20 hours (extraction logic, AI integration, patterns)
- Team C Integration: 8 hours (database, learning system)
- Total: 40 hours