# TECHNICAL SPECIFICATION: WS-216 - Auto-Population System
## Generated by Feature Development Session - 2025-01-25

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Couple planning our wedding
**I want to:** Have my wedding details automatically appear in vendor forms and questionnaires without manual entry
**So that:** I save 3-4 hours per vendor by not having to re-enter the same information, and vendors get consistent, accurate data instantly

**Real Wedding Scenario:**
A couple books their photographer and completes a detailed intake form with 25+ fields (names, date, venue, timeline, guest count, special requests). Later, when they book their caterer, florist, and DJ, each vendor sends separate intake forms asking for the same basic information. With Auto-Population, when the caterer sends their "Event Details Form," the couple opens it and sees all their core wedding information already filled in - they just need to add catering-specific details like dietary restrictions. This saves 20-30 minutes per vendor form and ensures all vendors work with identical base information, preventing coordination errors.

### SPECIFICATION SOURCE
- **Feature ID:** WS-216
- **Original Spec:** /CORE-SPECIFICATIONS/03-WEDME-COUPLE-PLATFORM/03-Core-Fields/02-auto-population md.md
- **Current Implementation:** 0% complete (depends on WS-215 Field Management System)
- **Files to Modify:** 
  - /src/lib/validations/core-fields.ts (add population rules)
  - /src/components/fields/CoreFieldsManager.tsx (add population indicators)
- **New Files to Create:** 
  - /src/lib/services/auto-population-service.ts
  - /src/components/forms/AutoPopulationProvider.tsx
  - /src/components/forms/PopulatedFormField.tsx
  - /src/components/forms/PopulationStatusBanner.tsx
  - /src/hooks/useAutoPopulation.ts
  - /src/app/api/auto-population/rules/route.ts
  - /src/app/api/auto-population/populate/route.ts
  - /src/app/api/auto-population/mappings/route.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Auto-population rules defining field mappings
CREATE TABLE IF NOT EXISTS auto_population_rules (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  rule_name VARCHAR(100) NOT NULL,
  rule_description TEXT,
  source_field_key VARCHAR(50) REFERENCES core_field_definitions(field_key),
  target_field_patterns TEXT[] NOT NULL, -- Array of patterns to match target fields
  transformation_function TEXT, -- Optional JS function to transform data
  priority_level INTEGER DEFAULT 10, -- Higher = more priority when conflicts
  conditions JSONB DEFAULT '{}', -- Conditions for when rule applies
  supplier_type TEXT, -- photographer, caterer, etc. (null = all)
  form_type TEXT, -- intake, questionnaire, contract, etc. (null = all)
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW(),
  created_by UUID REFERENCES auth.users(id)
);

-- Form field mappings - tracks which form fields map to which core fields
CREATE TABLE IF NOT EXISTS form_field_mappings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES auth.users(id),
  form_identifier TEXT NOT NULL, -- Form ID/name from supplier's system
  form_field_name TEXT NOT NULL, -- The actual field name in their form
  form_field_label TEXT, -- Display label for the field
  mapped_core_field VARCHAR(50) REFERENCES core_field_definitions(field_key),
  mapping_confidence DECIMAL(3,2) DEFAULT 0.5, -- 0.0 to 1.0 confidence score
  mapping_method TEXT DEFAULT 'manual' CHECK (mapping_method IN ('manual', 'ai_suggested', 'pattern_match')),
  transformation_rule TEXT, -- How to transform core field data for this form field
  last_used_at TIMESTAMP,
  usage_count INTEGER DEFAULT 0,
  is_verified BOOLEAN DEFAULT false, -- Manually confirmed by supplier
  created_at TIMESTAMP DEFAULT NOW()
);

-- Population sessions - tracks when forms are auto-populated
CREATE TABLE IF NOT EXISTS auto_population_sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  couple_id UUID REFERENCES couples(id) ON DELETE CASCADE,
  supplier_id UUID REFERENCES auth.users(id),
  form_identifier TEXT NOT NULL,
  populated_fields JSONB NOT NULL, -- Which fields were populated with what values
  population_metadata JSONB DEFAULT '{}', -- Additional context
  population_accuracy DECIMAL(3,2), -- How accurate was the population (user feedback)
  user_corrections JSONB DEFAULT '{}', -- What did user correct after population
  session_status TEXT DEFAULT 'active' CHECK (session_status IN ('active', 'submitted', 'expired')),
  populated_at TIMESTAMP DEFAULT NOW(),
  expires_at TIMESTAMP -- When population expires (forms shouldn't be populated forever)
);

-- Population rules for common field patterns
INSERT INTO auto_population_rules (rule_name, rule_description, source_field_key, target_field_patterns, supplier_type) VALUES
-- Essential Wedding Details
('Wedding Date Population', 'Auto-fill wedding date fields', 'wedding_date', ARRAY['wedding_date', 'event_date', 'ceremony_date', 'date_of_wedding', 'date', 'weddingDate'], null),
('Guest Count Population', 'Auto-fill guest count fields', 'guest_count', ARRAY['guest_count', 'number_of_guests', 'headcount', 'total_guests', 'guestCount', 'attendees'], null),
('Ceremony Time Population', 'Auto-fill ceremony time fields', 'ceremony_time', ARRAY['ceremony_time', 'start_time', 'event_start_time', 'ceremony_start'], null),

-- Couple Information
('Partner 1 Name Population', 'Auto-fill first partner name', 'partner1_name', ARRAY['bride_name', 'partner1_name', 'client_name', 'primary_contact', 'name1'], null),
('Partner 1 Email Population', 'Auto-fill first partner email', 'partner1_email', ARRAY['bride_email', 'partner1_email', 'primary_email', 'email1', 'contact_email'], null),
('Partner 1 Phone Population', 'Auto-fill first partner phone', 'partner1_phone', ARRAY['bride_phone', 'partner1_phone', 'primary_phone', 'phone1', 'contact_phone'], null),
('Partner 2 Name Population', 'Auto-fill second partner name', 'partner2_name', ARRAY['groom_name', 'partner2_name', 'secondary_contact', 'name2'], null),
('Partner 2 Email Population', 'Auto-fill second partner email', 'partner2_email', ARRAY['groom_email', 'partner2_email', 'secondary_email', 'email2'], null),
('Partner 2 Phone Population', 'Auto-fill second partner phone', 'partner2_phone', ARRAY['groom_phone', 'partner2_phone', 'secondary_phone', 'phone2'], null),

-- Venue Information
('Ceremony Venue Population', 'Auto-fill ceremony venue name', 'ceremony_venue_name', ARRAY['ceremony_venue', 'venue_name', 'location', 'ceremony_location'], null),
('Ceremony Address Population', 'Auto-fill ceremony venue address', 'ceremony_venue_address', ARRAY['ceremony_address', 'venue_address', 'location_address', 'ceremony_location_address'], null),
('Reception Venue Population', 'Auto-fill reception venue name', 'reception_venue_name', ARRAY['reception_venue', 'reception_location', 'party_venue'], 'caterer'),
('Reception Address Population', 'Auto-fill reception venue address', 'reception_venue_address', ARRAY['reception_address', 'reception_location_address', 'party_address'], 'caterer'),

-- Timeline Information
('Getting Ready Time Population', 'Auto-fill getting ready time', 'getting_ready_time', ARRAY['getting_ready_time', 'prep_start_time', 'hair_makeup_time'], 'photographer'),
('Reception Start Population', 'Auto-fill reception start time', 'reception_start_time', ARRAY['reception_start', 'party_start_time', 'dinner_time'], 'caterer'),
('Reception End Population', 'Auto-fill reception end time', 'reception_end_time', ARRAY['reception_end', 'party_end_time', 'event_end_time'], 'caterer');

-- Indexes for performance
CREATE INDEX idx_auto_population_rules_source ON auto_population_rules(source_field_key);
CREATE INDEX idx_form_field_mappings_supplier ON form_field_mappings(supplier_id, form_identifier);
CREATE INDEX idx_auto_population_sessions_couple ON auto_population_sessions(couple_id);
CREATE INDEX idx_auto_population_sessions_supplier ON auto_population_sessions(supplier_id);
```

#### API Endpoints Required

**1. Auto-Population Service**
```typescript
// POST /api/auto-population/populate
// Populate a form with couple's core field data
interface PopulateFormRequest {
  supplierId: string;
  formIdentifier: string;
  formFields: FormFieldDefinition[]; // Fields in the form to populate
  populationPreferences?: {
    onlyRequiredFields?: boolean;
    skipConfidentialFields?: boolean;
    maxAge?: number; // Don't use data older than X days
  };
}

interface FormFieldDefinition {
  fieldName: string;
  fieldLabel?: string;
  fieldType: string;
  isRequired?: boolean;
  currentValue?: any;
}

interface PopulateFormResponse {
  sessionId: string;
  populatedFields: PopulatedField[];
  unmappedFields: string[];
  conflictFields: ConflictField[];
  populationStats: {
    totalFields: number;
    populatedFields: number;
    populationPercentage: number;
    confidenceScore: number;
  };
  expiresAt: string;
}

interface PopulatedField {
  fieldName: string;
  originalValue?: any;
  populatedValue: any;
  sourceField: string; // Which core field provided this value
  confidence: number; // 0.0 to 1.0
  transformationUsed?: string;
  requiresVerification: boolean;
}

interface ConflictField {
  fieldName: string;
  existingValue: any;
  suggestedValue: any;
  conflictReason: string;
  recommendation: 'keep_existing' | 'use_suggested' | 'manual_review';
}

// GET /api/auto-population/session/{sessionId}
// Get population session details
interface PopulationSessionResponse {
  sessionId: string;
  populatedFields: PopulatedField[];
  sessionStatus: 'active' | 'submitted' | 'expired';
  populatedAt: string;
  expiresAt: string;
  userCorrections: Record<string, any>;
}

// POST /api/auto-population/session/{sessionId}/feedback
// Provide feedback on population accuracy
interface PopulationFeedbackRequest {
  overallAccuracy: number; // 1-5 rating
  fieldFeedback: Record<string, {
    wasAccurate: boolean;
    correctedValue?: any;
    feedbackNotes?: string;
  }>;
  generalFeedback?: string;
}
```

**2. Mapping Management**
```typescript
// GET /api/auto-population/mappings
// Get field mappings for supplier's forms
interface FieldMappingsResponse {
  mappings: FieldMapping[];
  unmappedForms: string[];
  mappingStats: {
    totalForms: number;
    mappedForms: number;
    totalFields: number;
    mappedFields: number;
    averageConfidence: number;
  };
}

interface FieldMapping {
  formIdentifier: string;
  formFieldName: string;
  formFieldLabel: string;
  mappedCoreField: string;
  mappedCoreFieldName: string;
  confidence: number;
  mappingMethod: 'manual' | 'ai_suggested' | 'pattern_match';
  lastUsed: string;
  usageCount: number;
  isVerified: boolean;
}

// POST /api/auto-population/mappings
// Create or update field mappings
interface CreateMappingRequest {
  supplierId: string;
  formIdentifier: string;
  formFieldName: string;
  formFieldLabel?: string;
  coreFieldKey: string;
  confidence?: number;
  transformationRule?: string;
}

// POST /api/auto-population/mappings/auto-detect
// AI-powered mapping detection for new forms
interface AutoDetectMappingsRequest {
  supplierId: string;
  formIdentifier: string;
  formFields: {
    fieldName: string;
    fieldLabel?: string;
    fieldType?: string;
    placeholder?: string;
    helpText?: string;
  }[];
}

interface AutoDetectMappingsResponse {
  suggestedMappings: {
    formFieldName: string;
    suggestedCoreField: string;
    confidence: number;
    reasoning: string;
  }[];
  requiresManualMapping: string[];
}
```

**3. Population Rules Management**
```typescript
// GET /api/auto-population/rules
// Get auto-population rules (admin/supplier management)
interface PopulationRulesResponse {
  rules: PopulationRule[];
  fieldPatterns: Record<string, string[]>; // Common patterns for each field
}

interface PopulationRule {
  id: string;
  ruleName: string;
  sourceField: string;
  targetPatterns: string[];
  supplierType?: string;
  formType?: string;
  transformationFunction?: string;
  priority: number;
  isActive: boolean;
  usageStats: {
    timesApplied: number;
    successRate: number;
    lastUsed: string;
  };
}

// POST /api/auto-population/rules
// Create custom population rule
interface CreatePopulationRuleRequest {
  ruleName: string;
  ruleDescription: string;
  sourceFieldKey: string;
  targetFieldPatterns: string[];
  supplierType?: string;
  formType?: string;
  transformationFunction?: string;
  priority?: number;
}
```

#### Frontend Components Required

**1. Auto-Population Provider**
```typescript
// src/components/forms/AutoPopulationProvider.tsx
import React, { createContext, useContext, useState, useEffect } from 'react';
import { useAutoPopulation } from '@/hooks/useAutoPopulation';

interface AutoPopulationContextType {
  isPopulating: boolean;
  populationSession: PopulationSession | null;
  populatedFields: Record<string, PopulatedField>;
  populateForm: (formData: PopulateFormRequest) => Promise<void>;
  getFieldValue: (fieldName: string) => any;
  isFieldPopulated: (fieldName: string) => boolean;
  getFieldConfidence: (fieldName: string) => number;
  markFieldVerified: (fieldName: string) => void;
  clearPopulation: () => void;
}

const AutoPopulationContext = createContext<AutoPopulationContextType | null>(null);

export function AutoPopulationProvider({ children }: { children: React.ReactNode }) {
  const {
    populationSession,
    populatedFields,
    isPopulating,
    populateForm,
    clearPopulation,
    submitFeedback
  } = useAutoPopulation();

  const [verifiedFields, setVerifiedFields] = useState<Set<string>>(new Set());

  const getFieldValue = (fieldName: string) => {
    const populated = populatedFields[fieldName];
    return populated ? populated.populatedValue : undefined;
  };

  const isFieldPopulated = (fieldName: string) => {
    return fieldName in populatedFields;
  };

  const getFieldConfidence = (fieldName: string) => {
    const populated = populatedFields[fieldName];
    return populated ? populated.confidence : 0;
  };

  const markFieldVerified = (fieldName: string) => {
    setVerifiedFields(prev => new Set([...prev, fieldName]));
  };

  const contextValue: AutoPopulationContextType = {
    isPopulating,
    populationSession,
    populatedFields,
    populateForm,
    getFieldValue,
    isFieldPopulated,
    getFieldConfidence,
    markFieldVerified,
    clearPopulation
  };

  return (
    <AutoPopulationContext.Provider value={contextValue}>
      {children}
    </AutoPopulationContext.Provider>
  );
}

export function useAutoPopulationContext() {
  const context = useContext(AutoPopulationContext);
  if (!context) {
    throw new Error('useAutoPopulationContext must be used within AutoPopulationProvider');
  }
  return context;
}
```

**2. Populated Form Field Component**
```typescript
// src/components/forms/PopulatedFormField.tsx
import React, { useState, useEffect } from 'react';
import { useAutoPopulationContext } from './AutoPopulationProvider';

interface PopulatedFormFieldProps {
  fieldName: string;
  fieldLabel: string;
  fieldType?: string;
  value?: any;
  onChange: (value: any) => void;
  required?: boolean;
  placeholder?: string;
  disabled?: boolean;
  children?: React.ReactNode; // Allow custom input components
}

export function PopulatedFormField({
  fieldName,
  fieldLabel,
  fieldType = 'text',
  value,
  onChange,
  required = false,
  placeholder,
  disabled = false,
  children
}: PopulatedFormFieldProps) {
  const {
    isFieldPopulated,
    getFieldValue,
    getFieldConfidence,
    markFieldVerified
  } = useAutoPopulationContext();

  const [currentValue, setCurrentValue] = useState(value);
  const [hasUserInput, setHasUserInput] = useState(false);
  const [showPopulationInfo, setShowPopulationInfo] = useState(false);

  const isPopulated = isFieldPopulated(fieldName);
  const populatedValue = getFieldValue(fieldName);
  const confidence = getFieldConfidence(fieldName);

  // Auto-populate if field is empty and we have population data
  useEffect(() => {
    if (isPopulated && !hasUserInput && (currentValue === undefined || currentValue === '')) {
      setCurrentValue(populatedValue);
      onChange(populatedValue);
    }
  }, [isPopulated, populatedValue, currentValue, hasUserInput, onChange]);

  const handleValueChange = (newValue: any) => {
    setCurrentValue(newValue);
    setHasUserInput(true);
    onChange(newValue);

    // Mark as verified if user manually entered/confirmed
    if (isPopulated) {
      markFieldVerified(fieldName);
    }
  };

  const handleAcceptPopulated = () => {
    setCurrentValue(populatedValue);
    setHasUserInput(true);
    onChange(populatedValue);
    markFieldVerified(fieldName);
  };

  const getConfidenceColor = (confidence: number) => {
    if (confidence >= 0.8) return 'text-green-600';
    if (confidence >= 0.6) return 'text-yellow-600';
    return 'text-orange-600';
  };

  const getConfidenceText = (confidence: number) => {
    if (confidence >= 0.8) return 'High confidence';
    if (confidence >= 0.6) return 'Medium confidence';
    return 'Low confidence - please verify';
  };

  return (
    <div className="space-y-2">
      {/* Field Label */}
      <div className="flex items-center justify-between">
        <label className="block text-sm font-medium text-gray-700">
          {fieldLabel}
          {required && <span className="text-red-500 ml-1">*</span>}
        </label>

        {/* Population Indicator */}
        {isPopulated && (
          <div className="flex items-center space-x-2">
            <button
              type="button"
              onClick={() => setShowPopulationInfo(!showPopulationInfo)}
              className={`text-xs px-2 py-1 rounded-full ${getConfidenceColor(confidence)} bg-opacity-10 border border-current`}
              title={getConfidenceText(confidence)}
            >
              ✨ Auto-filled
            </button>
            <span className={`text-xs ${getConfidenceColor(confidence)}`}>
              {Math.round(confidence * 100)}%
            </span>
          </div>
        )}
      </div>

      {/* Population Info Banner */}
      {isPopulated && showPopulationInfo && (
        <div className={`p-3 rounded-md border-l-4 ${
          confidence >= 0.8 ? 'bg-green-50 border-green-400' :
          confidence >= 0.6 ? 'bg-yellow-50 border-yellow-400' :
          'bg-orange-50 border-orange-400'
        }`}>
          <div className="flex items-start justify-between">
            <div>
              <p className="text-sm text-gray-700">
                This field was automatically filled from your wedding profile.
              </p>
              <p className={`text-xs mt-1 ${getConfidenceColor(confidence)}`}>
                {getConfidenceText(confidence)}
              </p>
            </div>
            
            {currentValue !== populatedValue && (
              <button
                type="button"
                onClick={handleAcceptPopulated}
                className="text-xs text-blue-600 hover:text-blue-800 underline"
              >
                Use suggested: "{populatedValue}"
              </button>
            )}
          </div>
        </div>
      )}

      {/* Field Input */}
      <div className="relative">
        {children ? (
          React.cloneElement(children as React.ReactElement, {
            value: currentValue,
            onChange: handleValueChange,
            disabled,
            className: `${(children as React.ReactElement).props.className} ${
              isPopulated ? 'border-blue-300 bg-blue-50' : ''
            }`
          })
        ) : (
          <input
            type={fieldType}
            value={currentValue || ''}
            onChange={(e) => handleValueChange(e.target.value)}
            placeholder={placeholder}
            disabled={disabled}
            className={`w-full px-3 py-2 border rounded-md focus:ring-2 focus:ring-blue-500 ${
              disabled ? 'bg-gray-100' : 'bg-white'
            } ${
              isPopulated ? 'border-blue-300 bg-blue-50' : 'border-gray-300'
            }`}
          />
        )}

        {/* Population Status Icon */}
        {isPopulated && (
          <div className="absolute inset-y-0 right-0 flex items-center pr-3">
            <div 
              className={`w-2 h-2 rounded-full ${
                confidence >= 0.8 ? 'bg-green-500' :
                confidence >= 0.6 ? 'bg-yellow-500' :
                'bg-orange-500'
              }`}
              title={`Auto-populated with ${Math.round(confidence * 100)}% confidence`}
            />
          </div>
        )}
      </div>
    </div>
  );
}
```

**3. Population Status Banner**
```typescript
// src/components/forms/PopulationStatusBanner.tsx
import React, { useState } from 'react';
import { useAutoPopulationContext } from './AutoPopulationProvider';

export function PopulationStatusBanner() {
  const {
    populationSession,
    populatedFields,
    clearPopulation
  } = useAutoPopulationContext();

  const [isExpanded, setIsExpanded] = useState(false);

  if (!populationSession || Object.keys(populatedFields).length === 0) {
    return null;
  }

  const populatedCount = Object.keys(populatedFields).length;
  const highConfidenceCount = Object.values(populatedFields).filter(f => f.confidence >= 0.8).length;
  const lowConfidenceCount = Object.values(populatedFields).filter(f => f.confidence < 0.6).length;

  return (
    <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6">
      <div className="flex items-center justify-between">
        <div className="flex items-center space-x-3">
          <div className="flex-shrink-0">
            ✨
          </div>
          <div>
            <h3 className="text-sm font-medium text-blue-900">
              Form Auto-Populated
            </h3>
            <p className="text-sm text-blue-700">
              We've filled in {populatedCount} field{populatedCount !== 1 ? 's' : ''} from your wedding profile
            </p>
          </div>
        </div>

        <div className="flex items-center space-x-2">
          <button
            onClick={() => setIsExpanded(!isExpanded)}
            className="text-sm text-blue-600 hover:text-blue-800"
          >
            {isExpanded ? 'Hide Details' : 'Show Details'}
          </button>
          <button
            onClick={clearPopulation}
            className="text-sm text-gray-500 hover:text-gray-700"
          >
            Clear All
          </button>
        </div>
      </div>

      {isExpanded && (
        <div className="mt-4 pt-4 border-t border-blue-200">
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            {/* High Confidence Fields */}
            {highConfidenceCount > 0 && (
              <div>
                <h4 className="text-xs font-medium text-green-900 mb-2">
                  High Confidence ({highConfidenceCount})
                </h4>
                <ul className="text-xs text-green-700 space-y-1">
                  {Object.entries(populatedFields)
                    .filter(([_, field]) => field.confidence >= 0.8)
                    .map(([fieldName, field]) => (
                      <li key={fieldName} className="truncate">
                        {fieldName}: {String(field.populatedValue).substring(0, 20)}
                        {String(field.populatedValue).length > 20 ? '...' : ''}
                      </li>
                    ))}
                </ul>
              </div>
            )}

            {/* Medium Confidence Fields */}
            {Object.values(populatedFields).filter(f => f.confidence >= 0.6 && f.confidence < 0.8).length > 0 && (
              <div>
                <h4 className="text-xs font-medium text-yellow-900 mb-2">
                  Medium Confidence ({Object.values(populatedFields).filter(f => f.confidence >= 0.6 && f.confidence < 0.8).length})
                </h4>
                <ul className="text-xs text-yellow-700 space-y-1">
                  {Object.entries(populatedFields)
                    .filter(([_, field]) => field.confidence >= 0.6 && field.confidence < 0.8)
                    .map(([fieldName, field]) => (
                      <li key={fieldName} className="truncate">
                        {fieldName}: {String(field.populatedValue).substring(0, 20)}
                        {String(field.populatedValue).length > 20 ? '...' : ''}
                      </li>
                    ))}
                </ul>
              </div>
            )}

            {/* Low Confidence Fields */}
            {lowConfidenceCount > 0 && (
              <div>
                <h4 className="text-xs font-medium text-orange-900 mb-2">
                  Please Verify ({lowConfidenceCount})
                </h4>
                <ul className="text-xs text-orange-700 space-y-1">
                  {Object.entries(populatedFields)
                    .filter(([_, field]) => field.confidence < 0.6)
                    .map(([fieldName, field]) => (
                      <li key={fieldName} className="truncate">
                        {fieldName}: {String(field.populatedValue).substring(0, 20)}
                        {String(field.populatedValue).length > 20 ? '...' : ''}
                      </li>
                    ))}
                </ul>
              </div>
            )}
          </div>

          <div className="mt-4 flex items-center justify-between text-xs text-blue-600">
            <span>
              Session expires: {new Date(populationSession.expiresAt).toLocaleString()}
            </span>
            <span>
              From: {populationSession.populatedFields.length} wedding profile fields
            </span>
          </div>
        </div>
      )}
    </div>
  );
}
```

#### Auto-Population Hook
```typescript
// src/hooks/useAutoPopulation.ts
import { useState, useCallback } from 'react';

interface PopulationSession {
  sessionId: string;
  populatedFields: PopulatedField[];
  sessionStatus: string;
  populatedAt: string;
  expiresAt: string;
}

interface PopulatedField {
  fieldName: string;
  originalValue?: any;
  populatedValue: any;
  sourceField: string;
  confidence: number;
  requiresVerification: boolean;
}

export function useAutoPopulation() {
  const [populationSession, setPopulationSession] = useState<PopulationSession | null>(null);
  const [populatedFields, setPopulatedFields] = useState<Record<string, PopulatedField>>({});
  const [isPopulating, setIsPopulating] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const populateForm = useCallback(async (formData: PopulateFormRequest) => {
    setIsPopulating(true);
    setError(null);

    try {
      const response = await fetch('/api/auto-population/populate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(formData)
      });

      if (!response.ok) {
        throw new Error('Failed to populate form');
      }

      const result: PopulateFormResponse = await response.json();

      // Create session object
      const session: PopulationSession = {
        sessionId: result.sessionId,
        populatedFields: result.populatedFields,
        sessionStatus: 'active',
        populatedAt: new Date().toISOString(),
        expiresAt: result.expiresAt
      };

      setPopulationSession(session);

      // Index populated fields by field name for easy lookup
      const fieldsIndex = result.populatedFields.reduce((acc, field) => {
        acc[field.fieldName] = field;
        return acc;
      }, {} as Record<string, PopulatedField>);

      setPopulatedFields(fieldsIndex);

    } catch (err) {
      setError(err instanceof Error ? err.message : 'Population failed');
      throw err;
    } finally {
      setIsPopulating(false);
    }
  }, []);

  const clearPopulation = useCallback(() => {
    setPopulationSession(null);
    setPopulatedFields({});
    setError(null);
  }, []);

  const submitFeedback = useCallback(async (feedback: PopulationFeedbackRequest) => {
    if (!populationSession) return;

    try {
      const response = await fetch(`/api/auto-population/session/${populationSession.sessionId}/feedback`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(feedback)
      });

      if (!response.ok) {
        throw new Error('Failed to submit feedback');
      }

      // Mark session as submitted
      setPopulationSession(prev => prev ? { ...prev, sessionStatus: 'submitted' } : null);

    } catch (err) {
      console.error('Failed to submit population feedback:', err);
    }
  }, [populationSession]);

  return {
    populationSession,
    populatedFields,
    isPopulating,
    error,
    populateForm,
    clearPopulation,
    submitFeedback
  };
}
```

### TESTING REQUIREMENTS

#### Unit Tests
- Field pattern matching algorithm
- Data transformation functions
- Population rule evaluation logic
- Confidence scoring calculations
- Form field mapping detection

#### Integration Tests
- Database operations for population sessions
- Field mapping creation and updates
- Population rule application
- Session expiration handling
- Feedback collection and processing

#### E2E Tests
- Complete auto-population workflow
- Form field population accuracy
- User verification and correction flow
- Population session management
- Supplier form integration

### DEPENDENCIES & EFFORT ESTIMATE

#### Dependencies
- **WS-215 Field Management System** - Core fields data source
- **Vendor Connection System** - Access to supplier forms
- **Real-time Updates System** - Live population updates
- **AI/ML Services** - Field mapping suggestions

#### Effort Estimate: 20 development days
- **Database Design & Migration**: 3 days
- **Population Rule Engine**: 4 days  
- **Form Field Mapping System**: 4 days
- **Auto-Population Components**: 5 days
- **Population Feedback System**: 2 days
- **Testing & Integration**: 2 days

#### Risk Factors
- **High:** Form field mapping accuracy and maintenance
- **Medium:** Population rule conflicts and priority handling
- **Medium:** Data transformation complexity for different field types
- **Low:** Session management and expiration handling

### SUCCESS CRITERIA
1. Forms can be auto-populated with 80%+ field accuracy
2. Population completes in under 3 seconds for typical forms
3. Field mapping confidence scores accurately reflect accuracy
4. Users can easily verify and correct populated values
5. Population rules handle 90% of common field patterns
6. Supplier forms integrate seamlessly with population system
7. Population feedback improves mapping accuracy over time
8. Session management prevents stale data population