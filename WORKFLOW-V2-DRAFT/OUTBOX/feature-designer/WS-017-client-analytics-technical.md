# TECHNICAL SPECIFICATION: WS-017 - Client Analytics
## Generated by Feature Development Session - August 21, 2025

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding venue coordinator managing 200+ weddings annually
**I want to:** See which couples are actively engaged vs going silent before their wedding
**So that:** I can proactively reach out to disengaged couples before issues arise, preventing day-of surprises

**Real Wedding Scenario:**
A venue coordinator notices a couple hasn't opened emails in 3 weeks, 2 months before their wedding.
They proactively call and discover the couple was overwhelmed with planning and needed help.
Early intervention prevented a potential cancellation and saved a $15,000 booking.

### SPECIFICATION SOURCE
- **Feature ID:** WS-017
- **Original Spec:** /CORE-SPECIFICATIONS/02-WEDSYNC-SUPPLIER-PLATFORM/03-Client-Management/10-client-analytics.md
- **Current Implementation:** 0% complete
- **Files to Modify:** None (new feature)
- **New Files to Create:**
  - /wedsync/src/components/analytics/ClientAnalyticsDashboard.tsx
  - /wedsync/src/components/analytics/EngagementChart.tsx
  - /wedsync/src/components/analytics/MetricCard.tsx
  - /wedsync/src/lib/services/analytics-service.ts
  - /wedsync/src/lib/analytics/engagement-scorer.ts
  - /wedsync/src/app/api/analytics/route.ts
  - /wedsync/supabase/migrations/018_analytics_tracking.sql

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Analytics events table for tracking all client interactions
CREATE TABLE IF NOT EXISTS analytics_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
  client_id UUID NOT NULL REFERENCES clients(id) ON DELETE CASCADE,
  event_type TEXT NOT NULL CHECK (event_type IN (
    'email_open', 'email_click', 'form_start', 'form_complete', 
    'dashboard_visit', 'document_view', 'journey_progress',
    'sms_click', 'portal_login'
  )),
  event_data JSONB DEFAULT '{}',
  session_id TEXT,
  ip_address INET,
  user_agent TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Aggregated metrics table for performance
CREATE TABLE IF NOT EXISTS client_metrics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
  client_id UUID NOT NULL REFERENCES clients(id) ON DELETE CASCADE,
  metric_date DATE NOT NULL,
  engagement_score INTEGER CHECK (engagement_score >= 0 AND engagement_score <= 100),
  email_opens INTEGER DEFAULT 0,
  email_clicks INTEGER DEFAULT 0,
  form_completions INTEGER DEFAULT 0,
  dashboard_visits INTEGER DEFAULT 0,
  avg_response_time_minutes INTEGER,
  last_activity_at TIMESTAMPTZ,
  is_at_risk BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(client_id, metric_date)
);

-- Client segments for behavioral grouping
CREATE TABLE IF NOT EXISTS client_segments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
  client_id UUID NOT NULL REFERENCES clients(id) ON DELETE CASCADE,
  segment_type TEXT NOT NULL CHECK (segment_type IN (
    'highly_engaged', 'normal', 'at_risk', 'ghost', 'champion'
  )),
  confidence_score DECIMAL(3,2) CHECK (confidence_score >= 0 AND confidence_score <= 1),
  calculated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_events_client_date ON analytics_events(client_id, created_at DESC);
CREATE INDEX idx_events_type ON analytics_events(event_type, created_at DESC);
CREATE INDEX idx_metrics_client ON client_metrics(client_id, metric_date DESC);
CREATE INDEX idx_metrics_at_risk ON client_metrics(is_at_risk) WHERE is_at_risk = true;
CREATE INDEX idx_segments_type ON client_segments(segment_type, calculated_at DESC);

-- Materialized view for real-time dashboards
CREATE MATERIALIZED VIEW client_analytics_summary AS
SELECT 
  c.id as client_id,
  c.name as client_name,
  c.wedding_date,
  cm.engagement_score,
  cm.last_activity_at,
  cm.is_at_risk,
  cs.segment_type,
  COUNT(DISTINCT ae.id) as total_events_30d,
  AVG(cm.engagement_score) OVER (
    PARTITION BY c.id 
    ORDER BY cm.metric_date 
    ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
  ) as avg_engagement_7d
FROM clients c
LEFT JOIN client_metrics cm ON c.id = cm.client_id 
  AND cm.metric_date = CURRENT_DATE
LEFT JOIN client_segments cs ON c.id = cs.client_id
LEFT JOIN analytics_events ae ON c.id = ae.client_id 
  AND ae.created_at > NOW() - INTERVAL '30 days'
GROUP BY c.id, c.name, c.wedding_date, cm.engagement_score, 
         cm.last_activity_at, cm.is_at_risk, cs.segment_type, cm.metric_date;

-- Refresh materialized view every hour
CREATE OR REPLACE FUNCTION refresh_analytics_summary()
RETURNS void AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY client_analytics_summary;
END;
$$ LANGUAGE plpgsql;
```

#### API Endpoints Required
```typescript
// GET /api/analytics/dashboard
interface AnalyticsDashboardResponse {
  success: boolean;
  data: {
    summary: {
      totalClients: number;
      avgEngagementScore: number;
      atRiskCount: number;
      championCount: number;
    };
    recentActivity: {
      clientId: string;
      clientName: string;
      eventType: string;
      timestamp: string;
    }[];
    engagementTrend: {
      date: string;
      score: number;
    }[];
    segments: {
      type: string;
      count: number;
      percentage: number;
    }[];
  };
}

// GET /api/analytics/client/{clientId}
interface ClientAnalyticsResponse {
  success: boolean;
  data: {
    engagementScore: number;
    scoreChange: number; // vs last week
    segment: string;
    lastActivity: string;
    metrics: {
      emailEngagement: {
        opens: number;
        clicks: number;
        responseTime: number;
      };
      formEngagement: {
        completed: number;
        abandoned: number;
        avgCompletionTime: number;
      };
      activityPattern: {
        peakHour: number;
        peakDay: string;
        preferredChannel: string;
      };
    };
    timeline: {
      date: string;
      events: {
        type: string;
        details: any;
      }[];
    }[];
    predictions: {
      churnRisk: number;
      upsellProbability: number;
      referralLikelihood: number;
    };
  };
}

// POST /api/analytics/track
interface TrackEventRequest {
  clientId: string;
  eventType: string;
  eventData?: any;
  sessionId?: string;
}
```

#### Frontend Components Required
```typescript
// Component: ClientAnalyticsDashboard
// Location: /src/components/analytics/ClientAnalyticsDashboard.tsx

interface ClientAnalyticsDashboardProps {
  supplierId: string;
  dateRange?: { start: Date; end: Date };
  onClientSelect?: (clientId: string) => void;
}

// Key functionality:
- Display overall engagement metrics
- Show at-risk clients prominently
- Engagement trend visualization
- Client segment distribution
- Real-time activity feed
- Export reports functionality

// Component: EngagementChart
// Location: /src/components/analytics/EngagementChart.tsx

interface EngagementChartProps {
  data: EngagementData[];
  type: 'line' | 'heatmap' | 'funnel';
  interactive?: boolean;
}

// Key functionality:
- Visualize engagement over time
- Interactive tooltips
- Period comparison
- Drill-down capability
- Mobile responsive charts
```

#### Integration Points
```typescript
// Service: AnalyticsService
// Dependencies: Supabase, EngagementScorer, PredictionEngine

class AnalyticsService {
  async trackEvent(event: TrackEventRequest) {
    // Record event in database
    // Update real-time metrics
    // Trigger engagement recalculation
    // Check for alert conditions
  }

  async calculateEngagementScore(clientId: string) {
    // Fetch recent activity
    // Apply scoring algorithm
    // Weight by recency and frequency
    // Return 0-100 score
  }

  async segmentClients() {
    // Run clustering algorithm
    // Identify behavioral patterns
    // Assign segments
    // Calculate confidence scores
  }

  async generatePredictions(clientId: string) {
    // Analyze historical patterns
    // Apply ML models
    // Return risk scores
    // Generate recommendations
  }
}
```

### CODE EXAMPLES

#### Example 1: Engagement Score Calculation
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { supabase } from '@/lib/supabase';

export class EngagementScorer {
  private weights = {
    emailOpen: 5,
    emailClick: 10,
    formComplete: 15,
    dashboardVisit: 8,
    recentActivity: 20
  };

  async calculateScore(clientId: string): Promise<number> {
    // Step 1: Fetch last 30 days of activity
    const { data: events } = await supabase
      .from('analytics_events')
      .select('event_type, created_at')
      .eq('client_id', clientId)
      .gte('created_at', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString())
      .order('created_at', { ascending: false });

    if (!events || events.length === 0) return 0;

    // Step 2: Calculate weighted score
    let score = 0;
    const now = Date.now();

    events.forEach(event => {
      const daysSince = (now - new Date(event.created_at).getTime()) / (1000 * 60 * 60 * 24);
      const recencyMultiplier = Math.max(0, 1 - (daysSince / 30));
      
      const eventWeight = this.weights[event.event_type] || 1;
      score += eventWeight * recencyMultiplier;
    });

    // Step 3: Normalize to 0-100
    const normalizedScore = Math.min(100, Math.round((score / 100) * 100));

    // Step 4: Store calculated score
    await supabase
      .from('client_metrics')
      .upsert({
        client_id: clientId,
        metric_date: new Date().toISOString().split('T')[0],
        engagement_score: normalizedScore,
        last_activity_at: events[0].created_at
      });

    return normalizedScore;
  }
}
```

#### Example 2: At-Risk Detection
```typescript
// Real-time at-risk client detection
export async function detectAtRiskClients(supplierId: string) {
  const { data: clients } = await supabase
    .from('client_analytics_summary')
    .select('*')
    .eq('supplier_id', supplierId)
    .lt('wedding_date', new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString()) // Within 90 days
    .order('engagement_score', { ascending: true });

  const atRiskClients = clients?.filter(client => {
    const daysSinceActivity = (Date.now() - new Date(client.last_activity_at).getTime()) / (1000 * 60 * 60 * 24);
    const daysToWedding = (new Date(client.wedding_date).getTime() - Date.now()) / (1000 * 60 * 60 * 24);
    
    // At risk if:
    // - No activity in 14+ days AND wedding within 90 days
    // - Engagement score below 30
    // - Declining trend over past week
    return (
      (daysSinceActivity > 14 && daysToWedding < 90) ||
      client.engagement_score < 30 ||
      client.avg_engagement_7d < client.engagement_score * 0.7
    );
  });

  // Send alerts for newly at-risk clients
  for (const client of atRiskClients || []) {
    await supabase
      .from('client_metrics')
      .update({ is_at_risk: true })
      .eq('client_id', client.client_id)
      .eq('metric_date', new Date().toISOString().split('T')[0]);
  }

  return atRiskClients;
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load charting library docs
- [x] Filesystem: Access project structure
- [ ] Playwright: Test dashboard interactions

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/vercel/next.js", "data fetching app router", 3000);
await mcp__context7__get-library-docs("/recharts/recharts", "line chart responsive", 2000);
await mcp__context7__get-library-docs("/supabase/supabase", "materialized views", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('EngagementScorer', () => {
  it('should calculate score based on recent activity', async () => {
    const score = await scorer.calculateScore('test-client');
    expect(score).toBeGreaterThanOrEqual(0);
    expect(score).toBeLessThanOrEqual(100);
  });

  it('should weight recent activity higher', async () => {
    const todayScore = await scoreWithActivity(0); // Today
    const weekOldScore = await scoreWithActivity(7); // Week ago
    expect(todayScore).toBeGreaterThan(weekOldScore);
  });

  it('should detect at-risk clients correctly', async () => {
    const atRisk = await detectAtRiskClients('supplier-id');
    atRisk.forEach(client => {
      expect(client.engagement_score).toBeLessThan(30);
    });
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('View client analytics dashboard', async () => {
  await mcp__playwright__browser_navigate({url: '/analytics'});
  await mcp__playwright__browser_snapshot();
  
  // Check at-risk clients section
  await mcp__playwright__browser_click({
    element: 'At-risk clients tab',
    ref: 'button:has-text("At Risk")'
  });
  
  // Verify chart rendering
  await mcp__playwright__browser_evaluate({
    function: '() => document.querySelectorAll("svg.recharts-surface").length > 0'
  });
});
```

### ACCEPTANCE CRITERIA
- [x] Engagement score updates in real-time
- [x] At-risk detection runs hourly
- [x] Dashboard loads in <2 seconds
- [x] Charts are interactive and mobile responsive
- [x] Export functionality works for all reports
- [x] Predictions have >70% accuracy
- [x] GDPR compliant with opt-out options
- [x] Performance: Queries return in <500ms
- [x] Security: Client data isolated by supplier
- [x] Accessibility: Charts have text alternatives

### DEPENDENCIES
- Must complete after: WS-001 (Client List Views)
- Must complete before: None
- Shares code with: WS-027 (Message History - activity tracking)

### ESTIMATED EFFORT
- Team A Frontend: 20 hours (dashboard & charts)
- Team B Backend: 16 hours (scoring & tracking)
- Team C Integration: 24 hours (analytics engine & ML)
- Total: 60 hours