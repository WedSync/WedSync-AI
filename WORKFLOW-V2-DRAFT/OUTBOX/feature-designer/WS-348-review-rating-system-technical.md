# TECHNICAL SPECIFICATION: WS-348 - Review & Rating System
## Generated by Feature Development Session - 2025-01-20

### USER STORY & BUSINESS CONTEXT
**As a:** Couple planning my wedding
**I want to:** Read authentic reviews from other couples and rate my wedding suppliers based on my experience
**So that:** I can make informed decisions when selecting vendors and help other couples by sharing my honest feedback

**As a:** Wedding supplier (photographer, venue, florist, caterer)
**I want to:** Receive detailed feedback from couples, showcase positive reviews, and respond professionally to all feedback
**So that:** I can improve my services, build trust with potential clients, and maintain my professional reputation

**Real Wedding Scenario:**
Emma and David just completed their dream wedding. They want to share their experience with their photographer Sarah, who exceeded expectations with surprise engagement photos during the reception. Meanwhile, venue coordinator Mark provided average service with some communication delays. The review system allows them to provide nuanced, detailed feedback that helps Sarah showcase her extra mile service and helps Mark improve his communication processes.

### SPECIFICATION SOURCE
- **Feature ID:** WS-348
- **Priority Level:** CRITICAL (Reviews drive 85% of vendor selection decisions)
- **Original Spec:** /CORE-SPECIFICATIONS/review-rating-system/
- **Current Implementation:** 0% complete (template replacement required)
- **Dependencies:** User authentication, supplier profiles, wedding completion tracking
- **Files to Modify:** Supplier profile components, dashboard widgets, notification system
- **New Files to Create:** Review management system, rating components, moderation tools

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Review Categories for Different Service Types
CREATE TABLE review_categories (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    category_name TEXT NOT NULL UNIQUE,
    category_type TEXT NOT NULL CHECK (category_type IN (
        'photography', 'venue', 'catering', 'florals', 'music_dj', 
        'videography', 'planning', 'transport', 'beauty', 'officiant',
        'decoration', 'stationery', 'entertainment', 'accommodation'
    )),
    rating_criteria TEXT[] NOT NULL DEFAULT '{}', -- ['quality', 'communication', 'value', 'professionalism', 'timeliness']
    is_active BOOLEAN DEFAULT TRUE,
    display_order INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Main Reviews Table
CREATE TABLE reviews (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    reviewer_id UUID NOT NULL REFERENCES users(id), -- The couple/client
    wedding_id UUID REFERENCES weddings(id) ON DELETE SET NULL,
    review_category_id UUID NOT NULL REFERENCES review_categories(id),
    
    -- Core Review Data
    overall_rating DECIMAL(2,1) NOT NULL CHECK (overall_rating >= 1.0 AND overall_rating <= 5.0),
    detailed_ratings JSONB DEFAULT '{}', -- {'quality': 5.0, 'communication': 4.5, 'value': 4.0, 'professionalism': 5.0}
    review_title TEXT NOT NULL,
    review_content TEXT NOT NULL,
    
    -- Service Details
    service_date DATE NOT NULL, -- Wedding date or service completion date
    service_location TEXT, -- Venue or service location
    package_type TEXT, -- What package/service was purchased
    total_spent DECIMAL(10,2), -- Optional: helps with value assessment
    
    -- Review Metadata
    is_verified BOOLEAN DEFAULT FALSE, -- Verified as real client
    is_featured BOOLEAN DEFAULT FALSE, -- Highlighted review
    is_anonymous BOOLEAN DEFAULT FALSE, -- Hide reviewer identity
    reviewer_name TEXT, -- Display name (may be different from user name if anonymous)
    
    -- Moderation
    moderation_status TEXT CHECK (moderation_status IN ('pending', 'approved', 'rejected', 'flagged')) DEFAULT 'pending',
    moderation_notes TEXT,
    moderated_at TIMESTAMPTZ,
    moderated_by UUID REFERENCES users(id),
    
    -- Engagement
    helpful_count INTEGER DEFAULT 0, -- How many found this review helpful
    report_count INTEGER DEFAULT 0, -- How many times reported
    
    -- Media Attachments
    photo_urls TEXT[] DEFAULT '{}', -- Review photos
    video_urls TEXT[] DEFAULT '{}', -- Review videos
    
    -- Verification Data
    verification_method TEXT CHECK (verification_method IN ('booking_confirmed', 'payment_verified', 'manual_verified')),
    verification_data JSONB DEFAULT '{}', -- Booking details, payment records, etc.
    
    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    published_at TIMESTAMPTZ, -- When approved and published
    
    -- Indexes and Constraints
    INDEX idx_reviews_supplier (supplier_id, moderation_status, published_at),
    INDEX idx_reviews_rating (overall_rating, published_at),
    INDEX idx_reviews_wedding (wedding_id),
    INDEX idx_reviews_moderation (moderation_status, created_at),
    
    -- Prevent duplicate reviews for same service
    UNIQUE(supplier_id, reviewer_id, wedding_id)
);

-- Supplier Responses to Reviews
CREATE TABLE review_responses (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    review_id UUID NOT NULL REFERENCES reviews(id) ON DELETE CASCADE,
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    response_content TEXT NOT NULL,
    is_public BOOLEAN DEFAULT TRUE, -- Public response or private note
    
    -- Moderation for responses
    moderation_status TEXT CHECK (moderation_status IN ('pending', 'approved', 'rejected')) DEFAULT 'approved',
    moderated_at TIMESTAMPTZ,
    moderated_by UUID REFERENCES users(id),
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    INDEX idx_review_responses_review (review_id),
    INDEX idx_review_responses_supplier (supplier_id)
);

-- Review Helpfulness Voting
CREATE TABLE review_votes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    review_id UUID NOT NULL REFERENCES reviews(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    vote_type TEXT CHECK (vote_type IN ('helpful', 'not_helpful')) NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    
    UNIQUE(review_id, user_id), -- One vote per user per review
    INDEX idx_review_votes_review (review_id, vote_type)
);

-- Review Reports/Flags
CREATE TABLE review_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    review_id UUID NOT NULL REFERENCES reviews(id) ON DELETE CASCADE,
    reporter_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    report_reason TEXT CHECK (report_reason IN (
        'inappropriate_content', 'fake_review', 'spam', 'offensive_language', 
        'personal_attack', 'irrelevant', 'duplicate', 'other'
    )) NOT NULL,
    report_details TEXT,
    
    -- Moderation
    status TEXT CHECK (status IN ('pending', 'reviewed', 'action_taken', 'dismissed')) DEFAULT 'pending',
    admin_notes TEXT,
    reviewed_by UUID REFERENCES users(id),
    reviewed_at TIMESTAMPTZ,
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    
    UNIQUE(review_id, reporter_id), -- One report per user per review
    INDEX idx_review_reports_status (status, created_at)
);

-- Supplier Rating Statistics (Cached for Performance)
CREATE TABLE supplier_rating_stats (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    
    -- Overall Statistics
    total_reviews INTEGER DEFAULT 0,
    average_rating DECIMAL(2,1) DEFAULT 0,
    rating_distribution JSONB DEFAULT '{"5": 0, "4": 0, "3": 0, "2": 0, "1": 0}',
    
    -- Detailed Criteria Averages
    quality_avg DECIMAL(2,1) DEFAULT 0,
    communication_avg DECIMAL(2,1) DEFAULT 0,
    value_avg DECIMAL(2,1) DEFAULT 0,
    professionalism_avg DECIMAL(2,1) DEFAULT 0,
    timeliness_avg DECIMAL(2,1) DEFAULT 0,
    
    -- Review Breakdown
    verified_reviews_count INTEGER DEFAULT 0,
    featured_reviews_count INTEGER DEFAULT 0,
    recent_reviews_count INTEGER DEFAULT 0, -- Last 6 months
    
    -- Engagement Stats
    total_helpful_votes INTEGER DEFAULT 0,
    total_response_rate DECIMAL(5,2) DEFAULT 0, -- Percentage of reviews with supplier responses
    
    -- Trending Information
    rating_trend TEXT CHECK (rating_trend IN ('improving', 'stable', 'declining', 'insufficient_data')) DEFAULT 'insufficient_data',
    trend_percentage DECIMAL(5,2) DEFAULT 0, -- How much rating changed over last period
    
    last_updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    UNIQUE(supplier_id),
    INDEX idx_supplier_ratings_avg (average_rating, total_reviews)
);

-- Review Templates and Prompts (Help Users Write Better Reviews)
CREATE TABLE review_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    category_id UUID NOT NULL REFERENCES review_categories(id),
    template_name TEXT NOT NULL,
    template_type TEXT CHECK (template_type IN ('quick_review', 'detailed_review', 'prompt_questions')) NOT NULL,
    template_content JSONB NOT NULL, -- Questions, prompts, or template structure
    is_active BOOLEAN DEFAULT TRUE,
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    
    INDEX idx_review_templates_category (category_id, template_type)
);

-- Review Invitations (Automated Follow-up System)
CREATE TABLE review_invitations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    client_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    wedding_id UUID REFERENCES weddings(id) ON DELETE CASCADE,
    
    -- Invitation Details
    invitation_type TEXT CHECK (invitation_type IN ('post_service', 'post_wedding', 'follow_up')) NOT NULL,
    service_completion_date DATE NOT NULL,
    invitation_sent_at TIMESTAMPTZ,
    
    -- Response Tracking
    invitation_status TEXT CHECK (invitation_status IN ('pending', 'sent', 'opened', 'completed', 'declined', 'expired')) DEFAULT 'pending',
    review_submitted BOOLEAN DEFAULT FALSE,
    review_id UUID REFERENCES reviews(id),
    
    -- Follow-up Configuration
    reminder_count INTEGER DEFAULT 0,
    last_reminder_at TIMESTAMPTZ,
    max_reminders INTEGER DEFAULT 2,
    
    -- Tracking
    email_opens INTEGER DEFAULT 0,
    email_clicks INTEGER DEFAULT 0,
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ, -- 30-60 days after service completion
    
    UNIQUE(supplier_id, client_id, wedding_id),
    INDEX idx_review_invitations_status (invitation_status, service_completion_date),
    INDEX idx_review_invitations_supplier (supplier_id, invitation_status)
);

-- Review Analytics and Insights
CREATE TABLE review_analytics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    supplier_id UUID NOT NULL REFERENCES suppliers(id) ON DELETE CASCADE,
    analytics_date DATE NOT NULL,
    
    -- Daily Metrics
    reviews_received INTEGER DEFAULT 0,
    average_rating_daily DECIMAL(2,1) DEFAULT 0,
    total_helpful_votes INTEGER DEFAULT 0,
    responses_posted INTEGER DEFAULT 0,
    
    -- Engagement Metrics
    review_page_views INTEGER DEFAULT 0,
    review_detail_views INTEGER DEFAULT 0,
    contact_inquiries_from_reviews INTEGER DEFAULT 0,
    booking_conversions_from_reviews INTEGER DEFAULT 0,
    
    -- Sentiment Analysis (AI-powered)
    positive_sentiment_percentage DECIMAL(5,2) DEFAULT 0,
    negative_sentiment_percentage DECIMAL(5,2) DEFAULT 0,
    neutral_sentiment_percentage DECIMAL(5,2) DEFAULT 0,
    
    -- Keywords and Topics (AI-extracted)
    trending_positive_keywords TEXT[] DEFAULT '{}',
    trending_negative_keywords TEXT[] DEFAULT '{}',
    common_praise_topics TEXT[] DEFAULT '{}',
    common_concern_topics TEXT[] DEFAULT '{}',
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    
    UNIQUE(supplier_id, analytics_date),
    INDEX idx_review_analytics_supplier (supplier_id, analytics_date)
);

-- Insert default review categories
INSERT INTO review_categories (category_name, category_type, rating_criteria, display_order) VALUES
('Wedding Photography', 'photography', '["quality", "communication", "value", "professionalism", "timeliness", "creativity"]', 1),
('Wedding Venue', 'venue', '["quality", "communication", "value", "professionalism", "staff_service", "atmosphere"]', 2),
('Catering Services', 'catering', '["quality", "communication", "value", "professionalism", "presentation", "dietary_accommodation"]', 3),
('Wedding Florals', 'florals', '["quality", "communication", "value", "professionalism", "creativity", "freshness"]', 4),
('DJ/Music Services', 'music_dj', '["quality", "communication", "value", "professionalism", "crowd_engagement", "equipment"]', 5),
('Wedding Videography', 'videography', '["quality", "communication", "value", "professionalism", "timeliness", "creativity"]', 6),
('Wedding Planning', 'planning', '["organization", "communication", "value", "professionalism", "stress_management", "vendor_coordination"]', 7),
('Transportation', 'transport', '["reliability", "communication", "value", "professionalism", "vehicle_condition", "punctuality"]', 8),
('Beauty Services', 'beauty', '["quality", "communication", "value", "professionalism", "timeliness", "longevity"]', 9),
('Wedding Officiant', 'officiant', '["ceremony_quality", "communication", "value", "professionalism", "personalization", "presence"]', 10);

-- Insert review templates
INSERT INTO review_templates (category_id, template_name, template_type, template_content) VALUES
((SELECT id FROM review_categories WHERE category_name = 'Wedding Photography'), 'Photography Quick Review', 'quick_review', 
'{"prompts": ["How was the photo quality?", "Was the photographer professional?", "Did they capture your special moments?", "Would you recommend them?"]}'),
((SELECT id FROM review_categories WHERE category_name = 'Wedding Venue'), 'Venue Detailed Review', 'detailed_review',
'{"sections": ["Venue Atmosphere", "Staff Service", "Food Quality", "Value for Money", "Overall Experience"], "questions": ["Describe the venue atmosphere", "How was the staff service?", "What did you think of the food?", "Was it good value?", "Overall thoughts?"]}');
```

#### API Endpoints Required
```typescript
// Review System API Interfaces
interface CreateReviewRequest {
    supplier_id: string;
    wedding_id?: string;
    review_category_id: string;
    overall_rating: number; // 1.0 to 5.0
    detailed_ratings: Record<string, number>; // {'quality': 5.0, 'communication': 4.5}
    review_title: string;
    review_content: string;
    service_date: string; // ISO date
    service_location?: string;
    package_type?: string;
    total_spent?: number;
    is_anonymous?: boolean;
    reviewer_name?: string; // For anonymous reviews
    photo_urls?: string[];
    video_urls?: string[];
}

interface CreateReviewResponse {
    success: boolean;
    review_id: string;
    moderation_status: 'pending' | 'approved' | 'rejected';
    estimated_approval_time: string;
    message: string;
}

interface ReviewItem {
    id: string;
    supplier_id: string;
    supplier_name: string;
    supplier_avatar: string;
    reviewer_id: string;
    reviewer_name: string;
    reviewer_avatar?: string;
    wedding_id?: string;
    
    overall_rating: number;
    detailed_ratings: Record<string, number>;
    review_title: string;
    review_content: string;
    
    service_date: string;
    service_location?: string;
    package_type?: string;
    
    is_verified: boolean;
    is_featured: boolean;
    is_anonymous: boolean;
    
    helpful_count: number;
    has_user_voted?: boolean; // If current user has voted
    user_vote_type?: 'helpful' | 'not_helpful';
    
    photo_urls: string[];
    video_urls: string[];
    
    supplier_response?: {
        id: string;
        content: string;
        created_at: string;
    };
    
    created_at: string;
    published_at: string;
}

interface GetReviewsRequest {
    supplier_id?: string;
    reviewer_id?: string;
    category_id?: string;
    min_rating?: number;
    max_rating?: number;
    is_verified?: boolean;
    has_photos?: boolean;
    sort_by?: 'newest' | 'oldest' | 'highest_rating' | 'lowest_rating' | 'most_helpful';
    limit?: number;
    offset?: number;
}

interface GetReviewsResponse {
    success: boolean;
    reviews: ReviewItem[];
    total_count: number;
    average_rating: number;
    rating_distribution: Record<string, number>;
    has_more: boolean;
}

interface SupplierRatingStats {
    supplier_id: string;
    total_reviews: number;
    average_rating: number;
    rating_distribution: Record<string, number>; // {"5": 45, "4": 23, "3": 8, "2": 2, "1": 1}
    
    // Detailed criteria averages
    quality_avg: number;
    communication_avg: number;
    value_avg: number;
    professionalism_avg: number;
    timeliness_avg: number;
    
    verified_reviews_count: number;
    recent_reviews_count: number; // Last 6 months
    total_helpful_votes: number;
    response_rate: number; // Percentage of reviews with responses
    
    rating_trend: 'improving' | 'stable' | 'declining' | 'insufficient_data';
    trend_percentage: number;
    
    last_updated_at: string;
}

interface ReviewResponseRequest {
    review_id: string;
    response_content: string;
    is_public?: boolean;
}

interface ReviewResponseResponse {
    success: boolean;
    response_id: string;
    moderation_status: string;
    message: string;
}

interface ReviewVoteRequest {
    review_id: string;
    vote_type: 'helpful' | 'not_helpful';
}

interface ReviewVoteResponse {
    success: boolean;
    new_helpful_count: number;
    user_vote_type: 'helpful' | 'not_helpful' | null;
}

interface ReportReviewRequest {
    review_id: string;
    report_reason: 'inappropriate_content' | 'fake_review' | 'spam' | 'offensive_language' | 'personal_attack' | 'irrelevant' | 'duplicate' | 'other';
    report_details?: string;
}

interface ReportReviewResponse {
    success: boolean;
    report_id: string;
    message: string;
}

interface ReviewInvitationRequest {
    supplier_id: string;
    client_email: string;
    client_name: string;
    wedding_id?: string;
    service_completion_date: string;
    invitation_type: 'post_service' | 'post_wedding' | 'follow_up';
    custom_message?: string;
}

interface ReviewInvitationResponse {
    success: boolean;
    invitation_id: string;
    email_sent: boolean;
    estimated_delivery: string;
}

interface ReviewAnalyticsRequest {
    supplier_id: string;
    date_range: {
        start: string;
        end: string;
    };
    metrics: string[]; // ['rating_trends', 'sentiment_analysis', 'keyword_insights', 'conversion_tracking']
}

interface ReviewAnalyticsResponse {
    success: boolean;
    data: {
        rating_trends: {
            dates: string[];
            average_ratings: number[];
            review_counts: number[];
        };
        sentiment_analysis: {
            positive_percentage: number;
            negative_percentage: number;
            neutral_percentage: number;
            sentiment_over_time: {
                date: string;
                positive: number;
                negative: number;
                neutral: number;
            }[];
        };
        keyword_insights: {
            positive_keywords: { word: string; count: number; }[];
            negative_keywords: { word: string; count: number; }[];
            trending_topics: string[];
        };
        conversion_tracking: {
            review_page_views: number;
            contact_inquiries: number;
            booking_conversions: number;
            conversion_rate: number;
        };
    };
}
```

### CODE EXAMPLES

#### Example 1: Review Submission Component
```typescript
// /src/components/reviews/ReviewSubmissionForm.tsx
'use client';

import { useState, useEffect } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Checkbox } from '@/components/ui/checkbox';
import { Badge } from '@/components/ui/badge';
import { toast } from 'sonner';
import { 
    Star, 
    StarHalf, 
    Upload, 
    X, 
    Check, 
    AlertCircle,
    Camera,
    Video,
    Calendar,
    MapPin,
    DollarSign
} from 'lucide-react';

interface ReviewCategory {
    id: string;
    category_name: string;
    category_type: string;
    rating_criteria: string[];
}

interface Supplier {
    id: string;
    business_name: string;
    category: string;
    avatar_url?: string;
}

interface ReviewSubmissionFormProps {
    supplier: Supplier;
    weddingId?: string;
    onSubmitted?: (reviewId: string) => void;
}

export default function ReviewSubmissionForm({ 
    supplier, 
    weddingId, 
    onSubmitted 
}: ReviewSubmissionFormProps) {
    const [categories, setCategories] = useState<ReviewCategory[]>([]);
    const [selectedCategory, setSelectedCategory] = useState<ReviewCategory | null>(null);
    const [formData, setFormData] = useState({
        overall_rating: 0,
        detailed_ratings: {} as Record<string, number>,
        review_title: '',
        review_content: '',
        service_date: '',
        service_location: '',
        package_type: '',
        total_spent: '',
        is_anonymous: false,
        reviewer_name: ''
    });
    const [uploadedFiles, setUploadedFiles] = useState<{
        photos: File[];
        videos: File[];
    }>({ photos: [], videos: [] });
    const [isSubmitting, setIsSubmitting] = useState(false);
    const [showSuccess, setShowSuccess] = useState(false);

    useEffect(() => {
        loadReviewCategories();
    }, []);

    const loadReviewCategories = async () => {
        try {
            const response = await fetch('/api/reviews/categories');
            const data = await response.json();
            setCategories(data.categories || []);
            
            // Auto-select category based on supplier type
            const matchingCategory = data.categories.find(
                (cat: ReviewCategory) => cat.category_type === supplier.category
            );
            if (matchingCategory) {
                setSelectedCategory(matchingCategory);
                initializeDetailedRatings(matchingCategory.rating_criteria);
            }
        } catch (error) {
            console.error('Failed to load review categories:', error);
            toast.error('Failed to load review form');
        }
    };

    const initializeDetailedRatings = (criteria: string[]) => {
        const initialRatings = {} as Record<string, number>;
        criteria.forEach(criterion => {
            initialRatings[criterion] = 0;
        });
        setFormData(prev => ({ ...prev, detailed_ratings: initialRatings }));
    };

    const handleOverallRatingChange = (rating: number) => {
        setFormData(prev => ({ 
            ...prev, 
            overall_rating: rating,
            // Auto-populate detailed ratings with overall rating
            detailed_ratings: Object.keys(prev.detailed_ratings).reduce((acc, key) => {
                acc[key] = rating;
                return acc;
            }, {} as Record<string, number>)
        }));
    };

    const handleDetailedRatingChange = (criterion: string, rating: number) => {
        setFormData(prev => ({
            ...prev,
            detailed_ratings: {
                ...prev.detailed_ratings,
                [criterion]: rating
            }
        }));
        
        // Update overall rating as average of detailed ratings
        const detailedRatings = { ...formData.detailed_ratings, [criterion]: rating };
        const avgRating = Object.values(detailedRatings).reduce((sum, r) => sum + r, 0) / Object.values(detailedRatings).length;
        setFormData(prev => ({ ...prev, overall_rating: Math.round(avgRating * 2) / 2 }));
    };

    const handleFileUpload = (type: 'photo' | 'video', files: FileList | null) => {
        if (!files) return;
        
        const maxFiles = type === 'photo' ? 10 : 3;
        const maxSize = type === 'photo' ? 5 * 1024 * 1024 : 50 * 1024 * 1024; // 5MB for photos, 50MB for videos
        
        const validFiles = Array.from(files).filter(file => {
            if (file.size > maxSize) {
                toast.error(`File ${file.name} is too large. Max size is ${maxSize / (1024 * 1024)}MB`);
                return false;
            }
            return true;
        }).slice(0, maxFiles);

        setUploadedFiles(prev => ({
            ...prev,
            [type === 'photo' ? 'photos' : 'videos']: [
                ...prev[type === 'photo' ? 'photos' : 'videos'],
                ...validFiles
            ].slice(0, maxFiles)
        }));
    };

    const removeFile = (type: 'photos' | 'videos', index: number) => {
        setUploadedFiles(prev => ({
            ...prev,
            [type]: prev[type].filter((_, i) => i !== index)
        }));
    };

    const validateForm = (): boolean => {
        if (!selectedCategory) {
            toast.error('Please select a service category');
            return false;
        }
        
        if (formData.overall_rating === 0) {
            toast.error('Please provide an overall rating');
            return false;
        }
        
        if (Object.values(formData.detailed_ratings).some(rating => rating === 0)) {
            toast.error('Please rate all criteria');
            return false;
        }
        
        if (!formData.review_title.trim()) {
            toast.error('Please provide a review title');
            return false;
        }
        
        if (!formData.review_content.trim() || formData.review_content.trim().length < 50) {
            toast.error('Please provide a detailed review (minimum 50 characters)');
            return false;
        }
        
        if (!formData.service_date) {
            toast.error('Please provide the service date');
            return false;
        }
        
        if (formData.is_anonymous && !formData.reviewer_name.trim()) {
            toast.error('Please provide a display name for anonymous reviews');
            return false;
        }

        return true;
    };

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        
        if (!validateForm()) return;
        
        setIsSubmitting(true);
        
        try {
            // Upload media files first
            let photoUrls: string[] = [];
            let videoUrls: string[] = [];
            
            if (uploadedFiles.photos.length > 0) {
                const photoFormData = new FormData();
                uploadedFiles.photos.forEach((file, index) => {
                    photoFormData.append(`photo_${index}`, file);
                });
                
                const photoResponse = await fetch('/api/media/upload', {
                    method: 'POST',
                    body: photoFormData
                });
                const photoData = await photoResponse.json();
                photoUrls = photoData.urls || [];
            }
            
            if (uploadedFiles.videos.length > 0) {
                const videoFormData = new FormData();
                uploadedFiles.videos.forEach((file, index) => {
                    videoFormData.append(`video_${index}`, file);
                });
                
                const videoResponse = await fetch('/api/media/upload', {
                    method: 'POST',
                    body: videoFormData
                });
                const videoData = await videoResponse.json();
                videoUrls = videoData.urls || [];
            }

            // Submit review
            const reviewData = {
                supplier_id: supplier.id,
                wedding_id: weddingId,
                review_category_id: selectedCategory!.id,
                overall_rating: formData.overall_rating,
                detailed_ratings: formData.detailed_ratings,
                review_title: formData.review_title,
                review_content: formData.review_content,
                service_date: formData.service_date,
                service_location: formData.service_location || undefined,
                package_type: formData.package_type || undefined,
                total_spent: formData.total_spent ? parseFloat(formData.total_spent) : undefined,
                is_anonymous: formData.is_anonymous,
                reviewer_name: formData.is_anonymous ? formData.reviewer_name : undefined,
                photo_urls: photoUrls,
                video_urls: videoUrls
            };

            const response = await fetch('/api/reviews', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(reviewData)
            });

            const result = await response.json();
            
            if (result.success) {
                setShowSuccess(true);
                toast.success('Review submitted successfully!');
                onSubmitted?.(result.review_id);
            } else {
                throw new Error(result.message || 'Failed to submit review');
            }
            
        } catch (error) {
            console.error('Failed to submit review:', error);
            toast.error('Failed to submit review. Please try again.');
        } finally {
            setIsSubmitting(false);
        }
    };

    const renderStarRating = (
        rating: number, 
        onChange: (rating: number) => void,
        size: 'sm' | 'md' | 'lg' = 'md'
    ) => {
        const sizeClasses = {
            sm: 'h-4 w-4',
            md: 'h-6 w-6',
            lg: 'h-8 w-8'
        };

        return (
            <div className="flex gap-1">
                {[1, 2, 3, 4, 5].map((star) => (
                    <button
                        key={star}
                        type="button"
                        onClick={() => onChange(star)}
                        className={`${sizeClasses[size]} transition-colors ${
                            star <= rating 
                                ? 'text-yellow-500' 
                                : 'text-gray-300 hover:text-yellow-400'
                        }`}
                    >
                        <Star className={`${sizeClasses[size]} ${star <= rating ? 'fill-current' : ''}`} />
                    </button>
                ))}
            </div>
        );
    };

    if (showSuccess) {
        return (
            <Card className="max-w-2xl mx-auto">
                <CardContent className="p-8 text-center">
                    <div className="flex justify-center mb-4">
                        <div className="bg-green-100 p-3 rounded-full">
                            <Check className="h-8 w-8 text-green-600" />
                        </div>
                    </div>
                    <h3 className="text-xl font-semibold mb-2">Review Submitted Successfully!</h3>
                    <p className="text-muted-foreground mb-4">
                        Thank you for sharing your experience. Your review will be published after moderation.
                    </p>
                    <Button onClick={() => setShowSuccess(false)}>
                        Submit Another Review
                    </Button>
                </CardContent>
            </Card>
        );
    }

    return (
        <Card className="max-w-4xl mx-auto">
            <CardHeader>
                <CardTitle className="flex items-center gap-3">
                    <div className="flex items-center gap-3">
                        {supplier.avatar_url && (
                            <img 
                                src={supplier.avatar_url} 
                                alt={supplier.business_name}
                                className="w-12 h-12 rounded-full object-cover"
                            />
                        )}
                        <div>
                            <h2 className="text-xl font-bold">Review {supplier.business_name}</h2>
                            <Badge variant="secondary">{supplier.category}</Badge>
                        </div>
                    </div>
                </CardTitle>
                <CardDescription>
                    Share your experience to help other couples and provide valuable feedback
                </CardDescription>
            </CardHeader>

            <CardContent>
                <form onSubmit={handleSubmit} className="space-y-6">
                    {/* Service Category Selection */}
                    {categories.length > 1 && (
                        <div className="space-y-2">
                            <Label>Service Category</Label>
                            <Select 
                                value={selectedCategory?.id || ''} 
                                onValueChange={(value) => {
                                    const category = categories.find(cat => cat.id === value);
                                    setSelectedCategory(category || null);
                                    if (category) {
                                        initializeDetailedRatings(category.rating_criteria);
                                    }
                                }}
                            >
                                <SelectTrigger>
                                    <SelectValue placeholder="Select service category" />
                                </SelectTrigger>
                                <SelectContent>
                                    {categories.map((category) => (
                                        <SelectItem key={category.id} value={category.id}>
                                            {category.category_name}
                                        </SelectItem>
                                    ))}
                                </SelectContent>
                            </Select>
                        </div>
                    )}

                    {selectedCategory && (
                        <>
                            {/* Overall Rating */}
                            <div className="space-y-3">
                                <Label>Overall Rating *</Label>
                                <div className="flex items-center gap-3">
                                    {renderStarRating(formData.overall_rating, handleOverallRatingChange, 'lg')}
                                    <span className="text-lg font-semibold">
                                        {formData.overall_rating > 0 ? `${formData.overall_rating}/5` : 'Not rated'}
                                    </span>
                                </div>
                            </div>

                            {/* Detailed Ratings */}
                            <div className="space-y-4">
                                <Label>Detailed Ratings *</Label>
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    {selectedCategory.rating_criteria.map((criterion) => (
                                        <div key={criterion} className="flex items-center justify-between p-3 border rounded-lg">
                                            <span className="font-medium capitalize">
                                                {criterion.replace('_', ' ')}
                                            </span>
                                            {renderStarRating(
                                                formData.detailed_ratings[criterion] || 0,
                                                (rating) => handleDetailedRatingChange(criterion, rating)
                                            )}
                                        </div>
                                    ))}
                                </div>
                            </div>

                            {/* Review Title */}
                            <div className="space-y-2">
                                <Label htmlFor="review_title">Review Title *</Label>
                                <Input
                                    id="review_title"
                                    placeholder="Summarize your experience in one line"
                                    value={formData.review_title}
                                    onChange={(e) => setFormData(prev => ({ ...prev, review_title: e.target.value }))}
                                    maxLength={100}
                                />
                                <div className="text-xs text-muted-foreground text-right">
                                    {formData.review_title.length}/100
                                </div>
                            </div>

                            {/* Review Content */}
                            <div className="space-y-2">
                                <Label htmlFor="review_content">Detailed Review *</Label>
                                <Textarea
                                    id="review_content"
                                    placeholder="Share your detailed experience, what you loved, any areas for improvement..."
                                    value={formData.review_content}
                                    onChange={(e) => setFormData(prev => ({ ...prev, review_content: e.target.value }))}
                                    rows={6}
                                    maxLength={2000}
                                />
                                <div className="text-xs text-muted-foreground text-right">
                                    {formData.review_content.length}/2000 (minimum 50 characters)
                                </div>
                            </div>

                            {/* Service Details */}
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <div className="space-y-2">
                                    <Label htmlFor="service_date">Service Date *</Label>
                                    <div className="relative">
                                        <Calendar className="absolute left-3 top-3 h-4 w-4 text-muted-foreground" />
                                        <Input
                                            id="service_date"
                                            type="date"
                                            value={formData.service_date}
                                            onChange={(e) => setFormData(prev => ({ ...prev, service_date: e.target.value }))}
                                            className="pl-10"
                                        />
                                    </div>
                                </div>

                                <div className="space-y-2">
                                    <Label htmlFor="service_location">Service Location</Label>
                                    <div className="relative">
                                        <MapPin className="absolute left-3 top-3 h-4 w-4 text-muted-foreground" />
                                        <Input
                                            id="service_location"
                                            placeholder="Venue or location"
                                            value={formData.service_location}
                                            onChange={(e) => setFormData(prev => ({ ...prev, service_location: e.target.value }))}
                                            className="pl-10"
                                        />
                                    </div>
                                </div>

                                <div className="space-y-2">
                                    <Label htmlFor="package_type">Package/Service Type</Label>
                                    <Input
                                        id="package_type"
                                        placeholder="e.g., Full Day Photography, Premium Package"
                                        value={formData.package_type}
                                        onChange={(e) => setFormData(prev => ({ ...prev, package_type: e.target.value }))}
                                    />
                                </div>

                                <div className="space-y-2">
                                    <Label htmlFor="total_spent">Total Spent (Optional)</Label>
                                    <div className="relative">
                                        <DollarSign className="absolute left-3 top-3 h-4 w-4 text-muted-foreground" />
                                        <Input
                                            id="total_spent"
                                            type="number"
                                            placeholder="0.00"
                                            value={formData.total_spent}
                                            onChange={(e) => setFormData(prev => ({ ...prev, total_spent: e.target.value }))}
                                            className="pl-10"
                                        />
                                    </div>
                                </div>
                            </div>

                            {/* Media Upload */}
                            <div className="space-y-4">
                                <Label>Add Photos & Videos (Optional)</Label>
                                
                                {/* Photo Upload */}
                                <div className="space-y-2">
                                    <div className="flex items-center gap-2">
                                        <Camera className="h-4 w-4" />
                                        <span className="text-sm font-medium">Photos (up to 10)</span>
                                    </div>
                                    <Input
                                        type="file"
                                        accept="image/*"
                                        multiple
                                        onChange={(e) => handleFileUpload('photo', e.target.files)}
                                        className="cursor-pointer"
                                    />
                                    {uploadedFiles.photos.length > 0 && (
                                        <div className="flex flex-wrap gap-2 mt-2">
                                            {uploadedFiles.photos.map((file, index) => (
                                                <div key={index} className="relative">
                                                    <img
                                                        src={URL.createObjectURL(file)}
                                                        alt={`Upload ${index + 1}`}
                                                        className="w-20 h-20 object-cover rounded-lg"
                                                    />
                                                    <button
                                                        type="button"
                                                        onClick={() => removeFile('photos', index)}
                                                        className="absolute -top-2 -right-2 bg-red-500 text-white rounded-full p-1"
                                                    >
                                                        <X className="h-3 w-3" />
                                                    </button>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                </div>

                                {/* Video Upload */}
                                <div className="space-y-2">
                                    <div className="flex items-center gap-2">
                                        <Video className="h-4 w-4" />
                                        <span className="text-sm font-medium">Videos (up to 3)</span>
                                    </div>
                                    <Input
                                        type="file"
                                        accept="video/*"
                                        multiple
                                        onChange={(e) => handleFileUpload('video', e.target.files)}
                                        className="cursor-pointer"
                                    />
                                    {uploadedFiles.videos.length > 0 && (
                                        <div className="flex flex-wrap gap-2 mt-2">
                                            {uploadedFiles.videos.map((file, index) => (
                                                <div key={index} className="relative bg-gray-100 rounded-lg p-3">
                                                    <div className="flex items-center gap-2">
                                                        <Video className="h-4 w-4" />
                                                        <span className="text-sm truncate max-w-32">
                                                            {file.name}
                                                        </span>
                                                    </div>
                                                    <button
                                                        type="button"
                                                        onClick={() => removeFile('videos', index)}
                                                        className="absolute -top-2 -right-2 bg-red-500 text-white rounded-full p-1"
                                                    >
                                                        <X className="h-3 w-3" />
                                                    </button>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                </div>
                            </div>

                            {/* Privacy Options */}
                            <div className="space-y-3">
                                <div className="flex items-center space-x-2">
                                    <Checkbox
                                        id="is_anonymous"
                                        checked={formData.is_anonymous}
                                        onCheckedChange={(checked) => 
                                            setFormData(prev => ({ ...prev, is_anonymous: checked as boolean }))
                                        }
                                    />
                                    <Label htmlFor="is_anonymous" className="text-sm">
                                        Post this review anonymously
                                    </Label>
                                </div>
                                
                                {formData.is_anonymous && (
                                    <div className="ml-6 space-y-2">
                                        <Label htmlFor="reviewer_name">Display Name *</Label>
                                        <Input
                                            id="reviewer_name"
                                            placeholder="How would you like to appear on this review?"
                                            value={formData.reviewer_name}
                                            onChange={(e) => setFormData(prev => ({ ...prev, reviewer_name: e.target.value }))}
                                        />
                                    </div>
                                )}
                            </div>

                            {/* Terms and Submit */}
                            <div className="border-t pt-6">
                                <div className="flex items-start gap-3 mb-4 p-4 bg-blue-50 rounded-lg">
                                    <AlertCircle className="h-5 w-5 text-blue-600 mt-0.5" />
                                    <div className="text-sm text-blue-800">
                                        <p className="font-medium mb-1">Review Guidelines</p>
                                        <ul className="list-disc list-inside space-y-1">
                                            <li>Be honest and constructive in your feedback</li>
                                            <li>Focus on your actual experience with the supplier</li>
                                            <li>Avoid personal attacks or inappropriate language</li>
                                            <li>Reviews are moderated and may take 24-48 hours to publish</li>
                                        </ul>
                                    </div>
                                </div>

                                <Button 
                                    type="submit" 
                                    className="w-full" 
                                    size="lg"
                                    disabled={isSubmitting}
                                >
                                    {isSubmitting ? 'Submitting Review...' : 'Submit Review'}
                                </Button>
                            </div>
                        </>
                    )}
                </form>
            </CardContent>
        </Card>
    );
}
```

#### Example 2: Review Display and Management Service
```typescript
// /src/lib/reviews/review-service.ts
import { createServerComponentClient } from '@supabase/auth-helpers-nextjs';
import { cookies } from 'next/headers';

export class ReviewService {
    private supabase = createServerComponentClient({ cookies });

    async createReview(reviewData: CreateReviewRequest): Promise<CreateReviewResponse> {
        try {
            // Verify user can review this supplier
            const canReview = await this.verifyReviewEligibility(
                reviewData.supplier_id, 
                reviewData.wedding_id
            );
            
            if (!canReview) {
                throw new Error('Not eligible to review this supplier');
            }

            // Insert review
            const { data: review, error } = await this.supabase
                .from('reviews')
                .insert({
                    supplier_id: reviewData.supplier_id,
                    wedding_id: reviewData.wedding_id,
                    review_category_id: reviewData.review_category_id,
                    overall_rating: reviewData.overall_rating,
                    detailed_ratings: reviewData.detailed_ratings,
                    review_title: reviewData.review_title,
                    review_content: reviewData.review_content,
                    service_date: reviewData.service_date,
                    service_location: reviewData.service_location,
                    package_type: reviewData.package_type,
                    total_spent: reviewData.total_spent,
                    is_anonymous: reviewData.is_anonymous || false,
                    reviewer_name: reviewData.reviewer_name,
                    photo_urls: reviewData.photo_urls || [],
                    video_urls: reviewData.video_urls || [],
                    verification_method: 'booking_confirmed', // Based on wedding_id
                    moderation_status: 'pending'
                })
                .select()
                .single();

            if (error) throw error;

            // Update supplier rating stats
            await this.updateSupplierRatingStats(reviewData.supplier_id);

            // Send notification to supplier
            await this.notifySupplierNewReview(reviewData.supplier_id, review.id);

            return {
                success: true,
                review_id: review.id,
                moderation_status: 'pending',
                estimated_approval_time: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),
                message: 'Review submitted successfully. It will be published after moderation.'
            };

        } catch (error) {
            console.error('Failed to create review:', error);
            return {
                success: false,
                review_id: '',
                moderation_status: 'rejected',
                estimated_approval_time: '',
                message: error.message || 'Failed to submit review'
            };
        }
    }

    async getReviews(params: GetReviewsRequest): Promise<GetReviewsResponse> {
        try {
            let query = this.supabase
                .from('reviews')
                .select(`
                    *,
                    suppliers!inner(id, business_name, profile_image_url),
                    users!reviews_reviewer_id_fkey(id, first_name, last_name, profile_image_url),
                    review_responses!inner(id, response_content, created_at),
                    review_categories!inner(category_name)
                `)
                .eq('moderation_status', 'approved')
                .not('published_at', 'is', null);

            // Apply filters
            if (params.supplier_id) {
                query = query.eq('supplier_id', params.supplier_id);
            }
            
            if (params.reviewer_id) {
                query = query.eq('reviewer_id', params.reviewer_id);
            }
            
            if (params.category_id) {
                query = query.eq('review_category_id', params.category_id);
            }
            
            if (params.min_rating) {
                query = query.gte('overall_rating', params.min_rating);
            }
            
            if (params.max_rating) {
                query = query.lte('overall_rating', params.max_rating);
            }
            
            if (params.is_verified !== undefined) {
                query = query.eq('is_verified', params.is_verified);
            }
            
            if (params.has_photos) {
                query = query.not('photo_urls', 'eq', '{}');
            }

            // Apply sorting
            switch (params.sort_by) {
                case 'oldest':
                    query = query.order('published_at', { ascending: true });
                    break;
                case 'highest_rating':
                    query = query.order('overall_rating', { ascending: false });
                    break;
                case 'lowest_rating':
                    query = query.order('overall_rating', { ascending: true });
                    break;
                case 'most_helpful':
                    query = query.order('helpful_count', { ascending: false });
                    break;
                default: // newest
                    query = query.order('published_at', { ascending: false });
            }

            // Apply pagination
            const limit = params.limit || 20;
            const offset = params.offset || 0;
            query = query.range(offset, offset + limit - 1);

            const { data: reviews, error } = await query;
            if (error) throw error;

            // Get total count for pagination
            const { count } = await this.supabase
                .from('reviews')
                .select('*', { count: 'exact', head: true })
                .eq('moderation_status', 'approved');

            // Calculate rating statistics
            const ratingStats = await this.calculateRatingStats(params.supplier_id);

            return {
                success: true,
                reviews: reviews.map(review => this.formatReviewItem(review)),
                total_count: count || 0,
                average_rating: ratingStats.average_rating,
                rating_distribution: ratingStats.rating_distribution,
                has_more: (offset + limit) < (count || 0)
            };

        } catch (error) {
            console.error('Failed to get reviews:', error);
            return {
                success: false,
                reviews: [],
                total_count: 0,
                average_rating: 0,
                rating_distribution: {},
                has_more: false
            };
        }
    }

    async respondToReview(params: ReviewResponseRequest): Promise<ReviewResponseResponse> {
        try {
            // Verify supplier owns the review
            const { data: review } = await this.supabase
                .from('reviews')
                .select('supplier_id, suppliers!inner(user_id)')
                .eq('id', params.review_id)
                .single();

            if (!review) {
                throw new Error('Review not found');
            }

            // Get current user
            const { data: { user } } = await this.supabase.auth.getUser();
            if (!user || review.suppliers.user_id !== user.id) {
                throw new Error('Not authorized to respond to this review');
            }

            // Insert response
            const { data: response, error } = await this.supabase
                .from('review_responses')
                .insert({
                    review_id: params.review_id,
                    supplier_id: review.supplier_id,
                    response_content: params.response_content,
                    is_public: params.is_public !== false
                })
                .select()
                .single();

            if (error) throw error;

            // Update supplier response rate stats
            await this.updateSupplierRatingStats(review.supplier_id);

            // Notify review author of response
            await this.notifyReviewerOfResponse(params.review_id, response.id);

            return {
                success: true,
                response_id: response.id,
                moderation_status: 'approved',
                message: 'Response posted successfully'
            };

        } catch (error) {
            console.error('Failed to respond to review:', error);
            return {
                success: false,
                response_id: '',
                moderation_status: 'rejected',
                message: error.message || 'Failed to post response'
            };
        }
    }

    async voteOnReview(params: ReviewVoteRequest): Promise<ReviewVoteResponse> {
        try {
            const { data: { user } } = await this.supabase.auth.getUser();
            if (!user) throw new Error('Authentication required');

            // Check existing vote
            const { data: existingVote } = await this.supabase
                .from('review_votes')
                .select('*')
                .eq('review_id', params.review_id)
                .eq('user_id', user.id)
                .single();

            if (existingVote) {
                if (existingVote.vote_type === params.vote_type) {
                    // Remove vote if same type
                    await this.supabase
                        .from('review_votes')
                        .delete()
                        .eq('id', existingVote.id);
                } else {
                    // Update vote type
                    await this.supabase
                        .from('review_votes')
                        .update({ vote_type: params.vote_type })
                        .eq('id', existingVote.id);
                }
            } else {
                // Insert new vote
                await this.supabase
                    .from('review_votes')
                    .insert({
                        review_id: params.review_id,
                        user_id: user.id,
                        vote_type: params.vote_type
                    });
            }

            // Update helpful count
            const { count } = await this.supabase
                .from('review_votes')
                .select('*', { count: 'exact', head: true })
                .eq('review_id', params.review_id)
                .eq('vote_type', 'helpful');

            await this.supabase
                .from('reviews')
                .update({ helpful_count: count || 0 })
                .eq('id', params.review_id);

            return {
                success: true,
                new_helpful_count: count || 0,
                user_vote_type: params.vote_type
            };

        } catch (error) {
            console.error('Failed to vote on review:', error);
            return {
                success: false,
                new_helpful_count: 0,
                user_vote_type: null
            };
        }
    }

    private async verifyReviewEligibility(supplierId: string, weddingId?: string): Promise<boolean> {
        // Verify user has had service from this supplier
        if (weddingId) {
            const { data: booking } = await this.supabase
                .from('wedding_suppliers')
                .select('*')
                .eq('wedding_id', weddingId)
                .eq('supplier_id', supplierId)
                .eq('status', 'completed')
                .single();
                
            return !!booking;
        }
        
        return true; // Allow review without wedding ID for now
    }

    private async updateSupplierRatingStats(supplierId: string): Promise<void> {
        // Get all approved reviews for supplier
        const { data: reviews } = await this.supabase
            .from('reviews')
            .select('overall_rating, detailed_ratings, created_at')
            .eq('supplier_id', supplierId)
            .eq('moderation_status', 'approved');

        if (!reviews || reviews.length === 0) return;

        const totalReviews = reviews.length;
        const averageRating = reviews.reduce((sum, r) => sum + r.overall_rating, 0) / totalReviews;
        
        // Calculate rating distribution
        const ratingDistribution = { "5": 0, "4": 0, "3": 0, "2": 0, "1": 0 };
        reviews.forEach(review => {
            const rating = Math.floor(review.overall_rating);
            ratingDistribution[rating.toString()]++;
        });

        // Calculate detailed criteria averages
        const criteriaAvgs = this.calculateDetailedCriteriaAverages(reviews);
        
        // Calculate recent reviews (last 6 months)
        const sixMonthsAgo = new Date(Date.now() - 6 * 30 * 24 * 60 * 60 * 1000);
        const recentReviews = reviews.filter(r => new Date(r.created_at) > sixMonthsAgo);

        // Update or insert stats
        await this.supabase
            .from('supplier_rating_stats')
            .upsert({
                supplier_id: supplierId,
                total_reviews: totalReviews,
                average_rating: Math.round(averageRating * 10) / 10,
                rating_distribution: ratingDistribution,
                quality_avg: criteriaAvgs.quality || 0,
                communication_avg: criteriaAvgs.communication || 0,
                value_avg: criteriaAvgs.value || 0,
                professionalism_avg: criteriaAvgs.professionalism || 0,
                timeliness_avg: criteriaAvgs.timeliness || 0,
                recent_reviews_count: recentReviews.length,
                last_updated_at: new Date().toISOString()
            }, {
                onConflict: 'supplier_id'
            });
    }

    private calculateDetailedCriteriaAverages(reviews: any[]): Record<string, number> {
        const criteriaAvgs: Record<string, number> = {};
        const criteriaCounts: Record<string, number> = {};

        reviews.forEach(review => {
            if (review.detailed_ratings) {
                Object.entries(review.detailed_ratings).forEach(([criterion, rating]) => {
                    criteriaAvgs[criterion] = (criteriaAvgs[criterion] || 0) + (rating as number);
                    criteriaCounts[criterion] = (criteriaCounts[criterion] || 0) + 1;
                });
            }
        });

        // Calculate averages
        Object.keys(criteriaAvgs).forEach(criterion => {
            criteriaAvgs[criterion] = Math.round((criteriaAvgs[criterion] / criteriaCounts[criterion]) * 10) / 10;
        });

        return criteriaAvgs;
    }

    private async calculateRatingStats(supplierId?: string) {
        let query = this.supabase
            .from('reviews')
            .select('overall_rating')
            .eq('moderation_status', 'approved');

        if (supplierId) {
            query = query.eq('supplier_id', supplierId);
        }

        const { data: reviews } = await query;
        
        if (!reviews || reviews.length === 0) {
            return {
                average_rating: 0,
                rating_distribution: { "5": 0, "4": 0, "3": 0, "2": 0, "1": 0 }
            };
        }

        const average_rating = reviews.reduce((sum, r) => sum + r.overall_rating, 0) / reviews.length;
        const rating_distribution = { "5": 0, "4": 0, "3": 0, "2": 0, "1": 0 };
        
        reviews.forEach(review => {
            const rating = Math.floor(review.overall_rating);
            rating_distribution[rating.toString()]++;
        });

        return {
            average_rating: Math.round(average_rating * 10) / 10,
            rating_distribution
        };
    }

    private formatReviewItem(review: any): ReviewItem {
        return {
            id: review.id,
            supplier_id: review.supplier_id,
            supplier_name: review.suppliers.business_name,
            supplier_avatar: review.suppliers.profile_image_url,
            reviewer_id: review.reviewer_id,
            reviewer_name: review.is_anonymous ? review.reviewer_name : `${review.users.first_name} ${review.users.last_name}`,
            reviewer_avatar: review.is_anonymous ? undefined : review.users.profile_image_url,
            wedding_id: review.wedding_id,
            overall_rating: review.overall_rating,
            detailed_ratings: review.detailed_ratings,
            review_title: review.review_title,
            review_content: review.review_content,
            service_date: review.service_date,
            service_location: review.service_location,
            package_type: review.package_type,
            is_verified: review.is_verified,
            is_featured: review.is_featured,
            is_anonymous: review.is_anonymous,
            helpful_count: review.helpful_count,
            photo_urls: review.photo_urls,
            video_urls: review.video_urls,
            supplier_response: review.review_responses.length > 0 ? {
                id: review.review_responses[0].id,
                content: review.review_responses[0].response_content,
                created_at: review.review_responses[0].created_at
            } : undefined,
            created_at: review.created_at,
            published_at: review.published_at
        };
    }

    private async notifySupplierNewReview(supplierId: string, reviewId: string): Promise<void> {
        // Implementation for notifying supplier of new review
        // This would integrate with the notification system
    }

    private async notifyReviewerOfResponse(reviewId: string, responseId: string): Promise<void> {
        // Implementation for notifying reviewer of supplier response
        // This would integrate with the notification system
    }
}
```

#### Example 3: Review Analytics Dashboard Component
```typescript
// /src/components/reviews/ReviewAnalyticsDashboard.tsx
'use client';

import { useState, useEffect } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Progress } from '@/components/ui/progress';
import { 
    Star, 
    TrendingUp, 
    TrendingDown, 
    MessageSquare,
    Heart,
    Eye,
    Users,
    Award,
    AlertCircle,
    ChevronUp,
    ChevronDown
} from 'lucide-react';
import { LineChart, Line, BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, PieChart, Pie, Cell } from 'recharts';

interface ReviewStats {
    total_reviews: number;
    average_rating: number;
    rating_distribution: Record<string, number>;
    recent_reviews_count: number;
    verified_reviews_count: number;
    response_rate: number;
    rating_trend: 'improving' | 'stable' | 'declining' | 'insufficient_data';
    trend_percentage: number;
}

interface ReviewAnalytics {
    rating_trends: {
        dates: string[];
        average_ratings: number[];
        review_counts: number[];
    };
    sentiment_analysis: {
        positive_percentage: number;
        negative_percentage: number;
        neutral_percentage: number;
        sentiment_over_time: {
            date: string;
            positive: number;
            negative: number;
            neutral: number;
        }[];
    };
    keyword_insights: {
        positive_keywords: { word: string; count: number; }[];
        negative_keywords: { word: string; count: number; }[];
        trending_topics: string[];
    };
    conversion_tracking: {
        review_page_views: number;
        contact_inquiries: number;
        booking_conversions: number;
        conversion_rate: number;
    };
}

const COLORS = ['#10B981', '#F59E0B', '#EF4444'];

export default function ReviewAnalyticsDashboard({ supplierId }: { supplierId: string }) {
    const [stats, setStats] = useState<ReviewStats | null>(null);
    const [analytics, setAnalytics] = useState<ReviewAnalytics | null>(null);
    const [loading, setLoading] = useState(true);
    const [dateRange, setDateRange] = useState('30d');

    useEffect(() => {
        loadReviewData();
    }, [supplierId, dateRange]);

    const loadReviewData = async () => {
        setLoading(true);
        try {
            const [statsRes, analyticsRes] = await Promise.all([
                fetch(`/api/reviews/stats?supplier_id=${supplierId}`),
                fetch(`/api/reviews/analytics?supplier_id=${supplierId}&period=${dateRange}`)
            ]);

            const statsData = await statsRes.json();
            const analyticsData = await analyticsRes.json();

            setStats(statsData.stats);
            setAnalytics(analyticsData.data);
        } catch (error) {
            console.error('Failed to load review data:', error);
        } finally {
            setLoading(false);
        }
    };

    const renderStarRating = (rating: number, size: 'sm' | 'md' = 'md') => {
        const sizeClass = size === 'sm' ? 'h-4 w-4' : 'h-5 w-5';
        const stars = [];
        const fullStars = Math.floor(rating);
        const hasHalfStar = rating % 1 !== 0;

        for (let i = 0; i < 5; i++) {
            if (i < fullStars) {
                stars.push(<Star key={i} className={`${sizeClass} text-yellow-500 fill-current`} />);
            } else if (i === fullStars && hasHalfStar) {
                stars.push(<Star key={i} className={`${sizeClass} text-yellow-500 fill-current`} style={{ clipPath: 'inset(0 50% 0 0)' }} />);
            } else {
                stars.push(<Star key={i} className={`${sizeClass} text-gray-300`} />);
            }
        }

        return <div className="flex items-center gap-1">{stars}</div>;
    };

    const getTrendIcon = (trend: string, percentage: number) => {
        if (trend === 'improving') {
            return <ChevronUp className="h-4 w-4 text-green-600" />;
        } else if (trend === 'declining') {
            return <ChevronDown className="h-4 w-4 text-red-600" />;
        }
        return null;
    };

    const getTrendColor = (trend: string) => {
        switch (trend) {
            case 'improving': return 'text-green-600';
            case 'declining': return 'text-red-600';
            default: return 'text-gray-600';
        }
    };

    if (loading || !stats || !analytics) {
        return (
            <div className="flex items-center justify-center p-8">
                <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
            </div>
        );
    }

    return (
        <div className="space-y-6">
            {/* Header */}
            <div className="flex justify-between items-center">
                <div>
                    <h1 className="text-3xl font-bold tracking-tight">Review Analytics</h1>
                    <p className="text-muted-foreground">
                        Insights and performance metrics for your reviews
                    </p>
                </div>
                <div className="flex gap-2">
                    <Button 
                        variant={dateRange === '7d' ? 'default' : 'outline'}
                        onClick={() => setDateRange('7d')}
                    >
                        7 Days
                    </Button>
                    <Button 
                        variant={dateRange === '30d' ? 'default' : 'outline'}
                        onClick={() => setDateRange('30d')}
                    >
                        30 Days
                    </Button>
                    <Button 
                        variant={dateRange === '90d' ? 'default' : 'outline'}
                        onClick={() => setDateRange('90d')}
                    >
                        90 Days
                    </Button>
                </div>
            </div>

            {/* Key Metrics */}
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                <Card>
                    <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                        <CardTitle className="text-sm font-medium">Average Rating</CardTitle>
                        <Award className="h-4 w-4 text-muted-foreground" />
                    </CardHeader>
                    <CardContent>
                        <div className="flex items-center gap-2">
                            <div className="text-2xl font-bold">{stats.average_rating.toFixed(1)}</div>
                            {renderStarRating(stats.average_rating, 'sm')}
                        </div>
                        <div className="flex items-center gap-1 mt-1">
                            {getTrendIcon(stats.rating_trend, stats.trend_percentage)}
                            <p className={`text-xs ${getTrendColor(stats.rating_trend)}`}>
                                {stats.rating_trend === 'improving' ? '+' : stats.rating_trend === 'declining' ? '-' : ''}
                                {stats.trend_percentage > 0 ? `${stats.trend_percentage}%` : 'No change'}
                            </p>
                        </div>
                    </CardContent>
                </Card>

                <Card>
                    <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                        <CardTitle className="text-sm font-medium">Total Reviews</CardTitle>
                        <MessageSquare className="h-4 w-4 text-muted-foreground" />
                    </CardHeader>
                    <CardContent>
                        <div className="text-2xl font-bold">{stats.total_reviews}</div>
                        <p className="text-xs text-muted-foreground">
                            {stats.recent_reviews_count} in last 6 months
                        </p>
                    </CardContent>
                </Card>

                <Card>
                    <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                        <CardTitle className="text-sm font-medium">Response Rate</CardTitle>
                        <MessageSquare className="h-4 w-4 text-muted-foreground" />
                    </CardHeader>
                    <CardContent>
                        <div className="text-2xl font-bold">{stats.response_rate.toFixed(1)}%</div>
                        <Progress value={stats.response_rate} className="mt-2" />
                    </CardContent>
                </Card>

                <Card>
                    <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                        <CardTitle className="text-sm font-medium">Verified Reviews</CardTitle>
                        <Users className="h-4 w-4 text-muted-foreground" />
                    </CardHeader>
                    <CardContent>
                        <div className="text-2xl font-bold">{stats.verified_reviews_count}</div>
                        <p className="text-xs text-muted-foreground">
                            {((stats.verified_reviews_count / stats.total_reviews) * 100).toFixed(1)}% verified
                        </p>
                    </CardContent>
                </Card>
            </div>

            {/* Rating Distribution */}
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <Card>
                    <CardHeader>
                        <CardTitle>Rating Distribution</CardTitle>
                        <CardDescription>Breakdown of ratings received</CardDescription>
                    </CardHeader>
                    <CardContent>
                        <div className="space-y-3">
                            {[5, 4, 3, 2, 1].map((rating) => (
                                <div key={rating} className="flex items-center gap-3">
                                    <div className="flex items-center gap-1 w-16">
                                        <span className="text-sm font-medium">{rating}</span>
                                        <Star className="h-3 w-3 text-yellow-500 fill-current" />
                                    </div>
                                    <Progress 
                                        value={(stats.rating_distribution[rating.toString()] / stats.total_reviews) * 100} 
                                        className="flex-1" 
                                    />
                                    <span className="text-sm text-muted-foreground w-12 text-right">
                                        {stats.rating_distribution[rating.toString()]}
                                    </span>
                                </div>
                            ))}
                        </div>
                    </CardContent>
                </Card>

                <Card>
                    <CardHeader>
                        <CardTitle>Sentiment Analysis</CardTitle>
                        <CardDescription>Overall sentiment from reviews</CardDescription>
                    </CardHeader>
                    <CardContent>
                        <div className="h-48">
                            <ResponsiveContainer width="100%" height="100%">
                                <PieChart>
                                    <Pie
                                        data={[
                                            { name: 'Positive', value: analytics.sentiment_analysis.positive_percentage, color: COLORS[0] },
                                            { name: 'Neutral', value: analytics.sentiment_analysis.neutral_percentage, color: COLORS[1] },
                                            { name: 'Negative', value: analytics.sentiment_analysis.negative_percentage, color: COLORS[2] }
                                        ]}
                                        cx="50%"
                                        cy="50%"
                                        outerRadius={80}
                                        fill="#8884d8"
                                        dataKey="value"
                                        label={({ name, value }) => `${name}: ${value.toFixed(1)}%`}
                                    >
                                        {[0, 1, 2].map((entry, index) => (
                                            <Cell key={`cell-${index}`} fill={COLORS[index]} />
                                        ))}
                                    </Pie>
                                    <Tooltip />
                                </PieChart>
                            </ResponsiveContainer>
                        </div>
                    </CardContent>
                </Card>
            </div>

            {/* Charts and Insights */}
            <Tabs defaultValue="trends" className="space-y-4">
                <TabsList>
                    <TabsTrigger value="trends">Rating Trends</TabsTrigger>
                    <TabsTrigger value="keywords">Keywords</TabsTrigger>
                    <TabsTrigger value="conversion">Conversions</TabsTrigger>
                </TabsList>

                <TabsContent value="trends" className="space-y-4">
                    <Card>
                        <CardHeader>
                            <CardTitle>Rating Trends Over Time</CardTitle>
                            <CardDescription>Track your rating performance</CardDescription>
                        </CardHeader>
                        <CardContent>
                            <div className="h-80">
                                <ResponsiveContainer width="100%" height="100%">
                                    <LineChart data={analytics.rating_trends.dates.map((date, index) => ({
                                        date: new Date(date).toLocaleDateString(),
                                        rating: analytics.rating_trends.average_ratings[index],
                                        count: analytics.rating_trends.review_counts[index]
                                    }))}>
                                        <CartesianGrid strokeDasharray="3 3" />
                                        <XAxis dataKey="date" />
                                        <YAxis domain={[1, 5]} />
                                        <Tooltip />
                                        <Line 
                                            type="monotone" 
                                            dataKey="rating" 
                                            stroke="#10B981" 
                                            strokeWidth={2} 
                                            dot={{ fill: '#10B981' }}
                                        />
                                    </LineChart>
                                </ResponsiveContainer>
                            </div>
                        </CardContent>
                    </Card>
                </TabsContent>

                <TabsContent value="keywords" className="space-y-4">
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <Card>
                            <CardHeader>
                                <CardTitle className="text-green-600">Top Positive Keywords</CardTitle>
                                <CardDescription>What customers love most</CardDescription>
                            </CardHeader>
                            <CardContent>
                                <div className="space-y-2">
                                    {analytics.keyword_insights.positive_keywords.slice(0, 10).map((keyword) => (
                                        <div key={keyword.word} className="flex justify-between items-center">
                                            <span className="text-sm font-medium">{keyword.word}</span>
                                            <Badge variant="secondary">{keyword.count}</Badge>
                                        </div>
                                    ))}
                                </div>
                            </CardContent>
                        </Card>

                        <Card>
                            <CardHeader>
                                <CardTitle className="text-red-600">Areas for Improvement</CardTitle>
                                <CardDescription>Keywords to focus on</CardDescription>
                            </CardHeader>
                            <CardContent>
                                <div className="space-y-2">
                                    {analytics.keyword_insights.negative_keywords.slice(0, 10).map((keyword) => (
                                        <div key={keyword.word} className="flex justify-between items-center">
                                            <span className="text-sm font-medium">{keyword.word}</span>
                                            <Badge variant="destructive">{keyword.count}</Badge>
                                        </div>
                                    ))}
                                </div>
                                {analytics.keyword_insights.negative_keywords.length === 0 && (
                                    <div className="text-center py-4 text-muted-foreground">
                                        <AlertCircle className="h-8 w-8 mx-auto mb-2" />
                                        <p>No negative keywords found</p>
                                    </div>
                                )}
                            </CardContent>
                        </Card>
                    </div>
                </TabsContent>

                <TabsContent value="conversion" className="space-y-4">
                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                        <Card>
                            <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                                <CardTitle className="text-sm font-medium">Page Views</CardTitle>
                                <Eye className="h-4 w-4 text-muted-foreground" />
                            </CardHeader>
                            <CardContent>
                                <div className="text-2xl font-bold">
                                    {analytics.conversion_tracking.review_page_views.toLocaleString()}
                                </div>
                                <p className="text-xs text-muted-foreground">
                                    Total review page views
                                </p>
                            </CardContent>
                        </Card>

                        <Card>
                            <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                                <CardTitle className="text-sm font-medium">Inquiries</CardTitle>
                                <MessageSquare className="h-4 w-4 text-muted-foreground" />
                            </CardHeader>
                            <CardContent>
                                <div className="text-2xl font-bold">
                                    {analytics.conversion_tracking.contact_inquiries}
                                </div>
                                <p className="text-xs text-muted-foreground">
                                    From review pages
                                </p>
                            </CardContent>
                        </Card>

                        <Card>
                            <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                                <CardTitle className="text-sm font-medium">Bookings</CardTitle>
                                <Users className="h-4 w-4 text-muted-foreground" />
                            </CardHeader>
                            <CardContent>
                                <div className="text-2xl font-bold">
                                    {analytics.conversion_tracking.booking_conversions}
                                </div>
                                <p className="text-xs text-muted-foreground">
                                    Direct from reviews
                                </p>
                            </CardContent>
                        </Card>

                        <Card>
                            <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                                <CardTitle className="text-sm font-medium">Conversion Rate</CardTitle>
                                <TrendingUp className="h-4 w-4 text-muted-foreground" />
                            </CardHeader>
                            <CardContent>
                                <div className="text-2xl font-bold">
                                    {analytics.conversion_tracking.conversion_rate.toFixed(1)}%
                                </div>
                                <p className="text-xs text-muted-foreground">
                                    Views to bookings
                                </p>
                            </CardContent>
                        </Card>
                    </div>
                </TabsContent>
            </Tabs>
        </div>
    );
}
```

### ACCEPTANCE CRITERIA
- [ ] **Review Submission**: Complete review form with rating criteria specific to service types
- [ ] **Multi-criteria Ratings**: Detailed ratings for quality, communication, value, professionalism, etc.
- [ ] **Media Upload**: Support for photo and video attachments in reviews
- [ ] **Verification System**: Verify reviews through booking confirmation and payment records
- [ ] **Supplier Responses**: Allow suppliers to respond professionally to all reviews
- [ ] **Helpfulness Voting**: Users can vote on review helpfulness
- [ ] **Review Moderation**: Automated and manual moderation system with appeal process
- [ ] **Analytics Dashboard**: Comprehensive insights including sentiment analysis and keyword trends
- [ ] **Mobile Optimization**: Fully responsive review interface for mobile users
- [ ] **Review Invitations**: Automated follow-up system to request reviews after service completion
- [ ] **Spam Prevention**: Advanced anti-spam measures and duplicate review detection
- [ ] **Privacy Controls**: Anonymous review options and GDPR compliance
- [ ] **Search and Filtering**: Advanced search and filtering options for reviews
- [ ] **Rating Statistics**: Real-time calculation and caching of supplier rating statistics
- [ ] **Integration**: Seamless integration with supplier profiles and booking system

### DEPENDENCIES
- Must complete after: User authentication, supplier profiles, booking system
- Must complete before: Public marketplace, supplier directory
- Shares code with: Notification system, media upload, analytics dashboard, user management

### ESTIMATED EFFORT
- Team A Frontend: 40 hours (Review forms, display components, analytics dashboard)
- Team B Backend: 36 hours (Review service, moderation system, statistics calculation)
- Team C Integration: 20 hours (Email notifications, booking verification, media processing)
- Team D Platform: 16 hours (Database optimization, caching, search indexing)
- Team E General: 12 hours (Mobile optimization, GDPR compliance, content moderation)
- Total: 124 hours

### BUSINESS IMPACT
**Revenue Impact**:
- 85% of couples check reviews before booking suppliers
- Suppliers with 4+ star ratings get 3x more inquiries
- Review system drives 60% of booking decisions

**User Value**:
- Builds trust between couples and suppliers
- Provides valuable feedback loop for service improvement
- Creates social proof that drives business growth
- Establishes quality standards across the platform

**Competitive Advantage**:
- Most comprehensive review system in wedding industry
- AI-powered sentiment analysis and insights
- Advanced verification preventing fake reviews
- Integrated response management for suppliers
- Conversion tracking showing ROI from reviews