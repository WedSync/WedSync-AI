# TECHNICAL SPECIFICATION: WS-235 - Support Operations Ticket Management System
## Generated by Feature Development Session - 2025-01-25

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** WedSync platform support administrator managing 847 wedding vendors and 3,421 client couples with varying subscription tiers
**I want to:** Implement intelligent ticket management with AI-powered classification, tier-based SLA enforcement (Enterprise: 15min/2hr, Free: 24hr/48hr), automatic routing to specialized teams, and escalation triggers for VIP accounts
**So that:** I can prevent customer churn by resolving critical issues like payment failures and data loss within SLA windows, maintain 90%+ satisfaction scores during peak wedding season support volume, and ensure enterprise photographer accounts get priority support during live wedding events

**Real Wedding Scenario:**
"A Scale-tier photographer reports 'Cannot access client forms - getting 500 error' at 2 PM on a Saturday during a wedding ceremony. AI classifier detects keywords 'cannot access' + 'error' = critical priority. System automatically routes to technical team, assigns to agent with form_builder expertise, sends SMS to team lead about SLA breach risk (30min window for Scale tier), and generates automated 'We're investigating this critical issue' response while escalating internally. Within 22 minutes, agent identifies server issue, applies hotfix, and client regains access to collect guest information before reception starts."

### SPECIFICATION SOURCE
- **Feature ID:** WS-235
- **Original Spec:** /CORE-SPECIFICATIONS/07-ADMIN-DASHBOARD/05-Support-Operations/01-ticket-management md.md
- **Current Implementation:** 0% complete (new feature)
- **Files to Modify:** None (new feature)
- **New Files to Create:**
  - `/src/components/admin/TicketDashboard.tsx`
  - `/src/components/admin/TicketQueue.tsx`
  - `/src/components/admin/TicketDetailView.tsx`
  - `/src/lib/support/ticket-manager.ts`
  - `/src/lib/support/ai-classifier.ts`
  - `/src/lib/support/ticket-router.ts`
  - `/src/lib/support/response-manager.ts`
  - `/src/lib/support/sla-monitor.ts`
  - `/src/app/api/admin/tickets/route.ts`
  - `/src/app/api/admin/tickets/[id]/route.ts`
  - `/src/hooks/useTicketMetrics.ts`
  - `/supabase/migrations/[TIMESTAMP]_ticket_management_system.sql`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Core tickets table
CREATE TABLE support_tickets (
  id VARCHAR(20) PRIMARY KEY, -- FB-123ABC-XYZ format
  user_id UUID REFERENCES auth.users(id),
  user_type TEXT NOT NULL CHECK (user_type IN ('supplier', 'couple')),
  user_tier TEXT NOT NULL CHECK (user_tier IN ('free', 'starter', 'professional', 'scale', 'enterprise')),
  
  -- Ticket content
  subject TEXT NOT NULL,
  description TEXT NOT NULL,
  attachments JSONB DEFAULT '[]'::jsonb,
  
  -- Classification
  ticket_type TEXT NOT NULL CHECK (ticket_type IN ('bug', 'question', 'feature_request', 'billing', 'onboarding', 'technical')),
  category TEXT NOT NULL CHECK (category IN ('form_builder', 'journey_canvas', 'email_system', 'import_export', 'performance', 'billing', 'subscription', 'refund', 'onboarding', 'training', 'feature_help', 'bug', 'data_loss', 'security', 'integration')),
  priority TEXT NOT NULL CHECK (priority IN ('critical', 'high', 'medium', 'low')),
  status TEXT NOT NULL DEFAULT 'open' CHECK (status IN ('open', 'in_progress', 'waiting_customer', 'waiting_internal', 'resolved', 'closed')),
  
  -- Assignment
  assigned_to UUID REFERENCES support_agents(id),
  assigned_team TEXT,
  assigned_at TIMESTAMPTZ,
  
  -- Timing and SLA
  created_at TIMESTAMPTZ DEFAULT NOW(),
  first_response_at TIMESTAMPTZ,
  last_update_at TIMESTAMPTZ DEFAULT NOW(),
  resolved_at TIMESTAMPTZ,
  closed_at TIMESTAMPTZ,
  
  sla_first_response_minutes INTEGER NOT NULL,
  sla_resolution_minutes INTEGER NOT NULL,
  sla_first_response_deadline TIMESTAMPTZ NOT NULL,
  sla_resolution_deadline TIMESTAMPTZ NOT NULL,
  sla_breach BOOLEAN DEFAULT FALSE,
  
  -- Escalation
  escalation_level INTEGER DEFAULT 0,
  escalated_at TIMESTAMPTZ,
  escalation_reason TEXT,
  
  -- Customer feedback
  satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
  satisfaction_feedback TEXT,
  satisfaction_requested_at TIMESTAMPTZ,
  satisfaction_provided_at TIMESTAMPTZ,
  
  -- Metadata
  tags TEXT[] DEFAULT '{}',
  source TEXT DEFAULT 'web' CHECK (source IN ('web', 'email', 'chat', 'api')),
  metadata JSONB DEFAULT '{}'::jsonb,
  
  -- Tracking
  related_tickets TEXT[],
  duplicate_of VARCHAR(20) REFERENCES support_tickets(id),
  
  CONSTRAINT valid_resolution_order CHECK (resolved_at IS NULL OR resolved_at >= first_response_at),
  CONSTRAINT valid_closure_order CHECK (closed_at IS NULL OR closed_at >= resolved_at)
);

-- Support agents table
CREATE TABLE support_agents (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id),
  agent_name TEXT NOT NULL,
  email TEXT NOT NULL,
  
  -- Skills and specialization
  skills TEXT[] DEFAULT '{}', -- ['form_builder', 'billing', 'technical']
  languages TEXT[] DEFAULT '{"en"}',
  expertise_level INTEGER DEFAULT 1 CHECK (expertise_level >= 1 AND expertise_level <= 5),
  
  -- Availability
  timezone TEXT DEFAULT 'UTC',
  working_hours JSONB DEFAULT '{"start": "09:00", "end": "17:00"}'::jsonb,
  max_concurrent_tickets INTEGER DEFAULT 10,
  
  -- Performance tracking
  current_ticket_count INTEGER DEFAULT 0,
  total_tickets_handled INTEGER DEFAULT 0,
  avg_first_response_minutes DECIMAL(10,2),
  avg_resolution_minutes DECIMAL(10,2),
  satisfaction_score DECIMAL(3,2),
  
  -- Status
  status TEXT DEFAULT 'active' CHECK (status IN ('active', 'busy', 'away', 'offline')),
  last_active TIMESTAMPTZ DEFAULT NOW(),
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Ticket messages/responses
CREATE TABLE ticket_messages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  ticket_id VARCHAR(20) NOT NULL REFERENCES support_tickets(id) ON DELETE CASCADE,
  
  -- Message details
  sender_type TEXT NOT NULL CHECK (sender_type IN ('customer', 'agent', 'system')),
  sender_id UUID, -- agent ID or user ID
  message TEXT NOT NULL,
  message_type TEXT DEFAULT 'reply' CHECK (message_type IN ('reply', 'note', 'status_change', 'assignment')),
  
  -- Content
  attachments JSONB DEFAULT '[]'::jsonb,
  is_internal BOOLEAN DEFAULT FALSE,
  is_automated BOOLEAN DEFAULT FALSE,
  
  -- Timing
  created_at TIMESTAMPTZ DEFAULT NOW(),
  edited_at TIMESTAMPTZ,
  edit_history JSONB DEFAULT '[]'::jsonb,
  
  -- Status impact
  status_change_from TEXT,
  status_change_to TEXT
);

-- Canned responses/templates
CREATE TABLE support_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  template_key TEXT UNIQUE NOT NULL,
  name TEXT NOT NULL,
  category TEXT NOT NULL,
  
  -- Content
  subject_template TEXT,
  content_template TEXT NOT NULL,
  variables TEXT[] DEFAULT '{}', -- ['{customer_name}', '{ticket_id}']
  
  -- Usage tracking
  usage_count INTEGER DEFAULT 0,
  last_used TIMESTAMPTZ,
  
  -- Permissions
  team_restriction TEXT, -- null means available to all
  tier_restriction TEXT, -- null means available for all tiers
  
  created_by UUID REFERENCES support_agents(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Ticket classification patterns (for AI training)
CREATE TABLE ticket_classification_patterns (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  pattern_name TEXT NOT NULL,
  regex_pattern TEXT NOT NULL,
  keywords TEXT[] DEFAULT '{}',
  
  -- Classification results
  predicted_category TEXT NOT NULL,
  predicted_type TEXT NOT NULL,
  predicted_priority TEXT NOT NULL,
  suggested_tags TEXT[] DEFAULT '{}',
  suggested_template TEXT,
  
  -- Accuracy tracking
  usage_count INTEGER DEFAULT 0,
  correct_predictions INTEGER DEFAULT 0,
  accuracy_rate DECIMAL(5,4) DEFAULT 0.0000,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- SLA tracking and metrics
CREATE TABLE ticket_sla_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  ticket_id VARCHAR(20) NOT NULL REFERENCES support_tickets(id),
  event_type TEXT NOT NULL CHECK (event_type IN ('created', 'first_response', 'resolved', 'escalated', 'sla_warning', 'sla_breach')),
  
  expected_at TIMESTAMPTZ NOT NULL,
  actual_at TIMESTAMPTZ,
  minutes_to_target INTEGER, -- negative means breach
  
  agent_id UUID REFERENCES support_agents(id),
  metadata JSONB DEFAULT '{}'::jsonb,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_tickets_status_priority ON support_tickets(status, priority, created_at DESC);
CREATE INDEX idx_tickets_assigned_agent ON support_tickets(assigned_to, status) WHERE assigned_to IS NOT NULL;
CREATE INDEX idx_tickets_user_created ON support_tickets(user_id, created_at DESC);
CREATE INDEX idx_tickets_sla_deadlines ON support_tickets(sla_first_response_deadline, sla_resolution_deadline) WHERE status NOT IN ('resolved', 'closed');
CREATE INDEX idx_tickets_category_priority ON support_tickets(category, priority, created_at DESC);
CREATE INDEX idx_messages_ticket_created ON ticket_messages(ticket_id, created_at);
CREATE INDEX idx_agents_skills ON support_agents USING GIN(skills);
CREATE INDEX idx_templates_category ON support_templates(category, team_restriction);
```

#### API Endpoints Required
```typescript
// GET /api/admin/tickets
interface TicketsListResponse {
  tickets: TicketSummary[];
  pagination: {
    total: number;
    page: number;
    limit: number;
    totalPages: number;
  };
  filters: {
    status: string[];
    priority: string[];
    category: string[];
    assignedTo: string[];
  };
}

// POST /api/admin/tickets
interface CreateTicketRequest {
  userId: string;
  userType: 'supplier' | 'couple';
  subject: string;
  description: string;
  attachments?: FileUpload[];
  source?: 'web' | 'email' | 'chat' | 'api';
  priority?: 'critical' | 'high' | 'medium' | 'low';
}

// GET /api/admin/tickets/[id]
interface TicketDetailResponse {
  ticket: TicketDetail;
  messages: TicketMessage[];
  relatedTickets: TicketSummary[];
  slaStatus: SLAStatus;
  suggestedResponses: SuggestedResponse[];
  escalationHistory: EscalationEvent[];
}

// POST /api/admin/tickets/[id]/respond
interface RespondToTicketRequest {
  message: string;
  messageType: 'reply' | 'note';
  attachments?: FileUpload[];
  statusChange?: 'in_progress' | 'waiting_customer' | 'resolved';
  isInternal?: boolean;
  useTemplate?: string;
}

// POST /api/admin/tickets/[id]/assign
interface AssignTicketRequest {
  agentId: string;
  reason?: string;
  priority?: 'critical' | 'high' | 'medium' | 'low';
  addNote?: string;
}

// POST /api/admin/tickets/[id]/escalate
interface EscalateTicketRequest {
  reason: string;
  escalateTo?: 'senior' | 'team_lead' | 'founder';
  urgency?: 'immediate' | 'within_hour' | 'within_day';
  additionalContext?: string;
}

// GET /api/admin/tickets/metrics
interface TicketMetricsResponse {
  overview: {
    totalOpen: number;
    totalInProgress: number;
    totalOverdue: number;
    avgFirstResponseTime: number; // minutes
    avgResolutionTime: number; // hours
    satisfactionScore: number; // 1-5
    slaComplianceRate: number; // percentage
  };
  byPriority: Record<string, number>;
  byCategory: Record<string, number>;
  byAgent: AgentMetrics[];
  trends: {
    volumeTrend: TimeSeries[];
    responseTrend: TimeSeries[];
    satisfactionTrend: TimeSeries[];
  };
}
```

#### Frontend Components Required
```typescript
// Component: TicketDashboard
// Location: /src/components/admin/TicketDashboard.tsx

interface TicketDashboardProps {
  defaultFilter?: TicketFilter;
  refreshInterval?: number; // seconds, default 60
}

// Key functionality:
- Real-time ticket queue with color-coded priority indicators
- SLA countdown timers with visual warnings (red <30min, yellow <1hr)
- Quick assignment dropdown with agent availability status
- Bulk actions (assign, close, escalate, add tags)
- Wedding season context awareness (higher volume warnings)
- Agent workload balancing recommendations
- Critical ticket alert notifications

// Component: TicketDetailView
// Location: /src/components/admin/TicketDetailView.tsx

interface TicketDetailViewProps {
  ticketId: string;
  onStatusChange?: (ticketId: string, status: string) => void;
  onAssignment?: (ticketId: string, agentId: string) => void;
}

// Key functionality:
- Complete ticket timeline with message threading
- Customer context panel (account tier, previous tickets, satisfaction history)
- AI-powered response suggestions based on ticket content
- Canned response library with personalization variables
- Attachment handling with file type validation
- Internal notes vs public responses distinction
- SLA timer with escalation triggers
- Related/duplicate ticket identification

// Component: TicketQueue
// Location: /src/components/admin/TicketQueue.tsx

interface TicketQueueProps {
  agentId?: string; // if specified, shows queue for specific agent
  teamFilter?: string;
  maxItems?: number;
}

// Key functionality:
- Sortable columns (priority, SLA remaining, created date, category)
- Advanced filtering (priority, status, category, assigned agent)
- Quick action buttons (claim, escalate, set priority)
- Agent availability indicators
- Wedding industry specific categorization
- Real-time updates with WebSocket integration
```

#### Integration Points
```typescript
// Service: TicketManager
// Dependencies: AI classifier, SLA monitor, notification system

class TicketManager {
  private static instance: TicketManager;
  private aiClassifier: AITicketClassifier;
  private slaMonitor: SLAMonitor;
  private responseManager: ResponseManager;
  private ticketRouter: TicketRouter;

  async createTicket(request: CreateTicketRequest): Promise<Ticket> {
    // 1. AI-powered classification
    const classification = await this.aiClassifier.classify({
      subject: request.subject,
      description: request.description,
      userTier: await this.getUserTier(request.userId),
      userType: request.userType
    });

    // 2. Generate unique ticket ID with category prefix
    const ticketId = this.generateTicketId(classification.category);

    // 3. Calculate SLA based on priority and user tier
    const sla = this.calculateSLA(classification.priority, request.userTier);

    // 4. Create ticket record
    const ticket: Ticket = {
      id: ticketId,
      userId: request.userId,
      userType: request.userType,
      userTier: request.userTier,
      subject: request.subject,
      description: request.description,
      attachments: request.attachments || [],
      
      type: classification.type,
      category: classification.category,
      priority: classification.priority,
      status: 'open',
      
      slaFirstResponseMinutes: sla.firstResponse,
      slaResolutionMinutes: sla.resolution,
      slaFirstResponseDeadline: sla.firstResponseDeadline,
      slaResolutionDeadline: sla.resolutionDeadline,
      
      tags: classification.tags,
      source: request.source || 'web',
      metadata: {
        classification,
        createdVia: 'admin_dashboard',
        accountAge: await this.getAccountAge(request.userId),
        previousTickets: await this.getPreviousTicketCount(request.userId)
      }
    };

    // 5. Save to database
    await this.saveTicket(ticket);

    // 6. Automatic routing and assignment
    await this.ticketRouter.routeTicket(ticket);

    // 7. Check for auto-response opportunities
    await this.checkAutoResponse(ticket);

    // 8. Start SLA monitoring
    await this.slaMonitor.startTracking(ticketId);

    // 9. Send notifications
    await this.sendCreationNotifications(ticket);

    return ticket;
  }

  private generateTicketId(category: string): string {
    const prefixMap: Record<string, string> = {
      'form_builder': 'FB',
      'billing': 'BIL',
      'bug': 'BUG',
      'onboarding': 'ONB',
      'data_loss': 'DL',
      'security': 'SEC',
      'performance': 'PERF',
      'import_export': 'IE'
    };

    const prefix = prefixMap[category] || 'TKT';
    const timestamp = Date.now().toString(36).toUpperCase();
    const random = Math.random().toString(36).substring(2, 5).toUpperCase();

    return `${prefix}-${timestamp}-${random}`;
  }

  private calculateSLA(priority: string, userTier: string): SLAConfig {
    // SLA matrix based on priority and user tier
    const slaMatrix = {
      critical: {
        enterprise: { firstResponse: 15, resolution: 120 }, // 15min, 2hrs
        scale: { firstResponse: 30, resolution: 240 },      // 30min, 4hrs  
        professional: { firstResponse: 60, resolution: 480 }, // 1hr, 8hrs
        starter: { firstResponse: 120, resolution: 1440 },   // 2hrs, 24hrs
        free: { firstResponse: 1440, resolution: 2880 }     // 24hrs, 48hrs
      },
      high: {
        enterprise: { firstResponse: 60, resolution: 480 },
        scale: { firstResponse: 120, resolution: 960 },
        professional: { firstResponse: 240, resolution: 1440 },
        starter: { firstResponse: 480, resolution: 2880 },
        free: { firstResponse: 1440, resolution: 4320 }
      },
      medium: {
        enterprise: { firstResponse: 240, resolution: 1440 },
        scale: { firstResponse: 480, resolution: 2880 },
        professional: { firstResponse: 960, resolution: 4320 },
        starter: { firstResponse: 1440, resolution: 5760 },
        free: { firstResponse: 2880, resolution: 7200 }
      },
      low: {
        all: { firstResponse: 1440, resolution: 7200 } // 24hrs, 5 days
      }
    };

    const sla = slaMatrix[priority]?.[userTier] || slaMatrix[priority]?.all || slaMatrix.low.all;

    return {
      firstResponse: sla.firstResponse,
      resolution: sla.resolution,
      firstResponseDeadline: new Date(Date.now() + sla.firstResponse * 60000),
      resolutionDeadline: new Date(Date.now() + sla.resolution * 60000)
    };
  }

  async assignTicket(ticketId: string, agentId: string, reason?: string): Promise<void> {
    const ticket = await this.getTicket(ticketId);
    const agent = await this.getAgent(agentId);

    // Check agent capacity
    if (agent.currentTicketCount >= agent.maxConcurrentTickets) {
      throw new Error(`Agent ${agent.agentName} is at capacity (${agent.currentTicketCount}/${agent.maxConcurrentTickets})`);
    }

    // Update ticket assignment
    ticket.assignedTo = agentId;
    ticket.assignedTeam = agent.team;
    ticket.assignedAt = new Date();
    ticket.lastUpdateAt = new Date();

    await this.saveTicket(ticket);

    // Update agent ticket count
    await this.updateAgentTicketCount(agentId, 1);

    // Add system message
    await this.addSystemMessage(ticketId, `Ticket assigned to ${agent.agentName}${reason ? `: ${reason}` : ''}`);

    // Notify agent
    await this.notifyAgent(agentId, 'ticket_assigned', { ticket });

    // Log assignment for metrics
    await this.logAssignmentEvent(ticketId, agentId, reason);
  }
}

// Service: AITicketClassifier
// Dependencies: OpenAI API, pattern matching, machine learning model

class AITicketClassifier {
  private patterns: Map<string, ClassificationPattern> = new Map();

  constructor() {
    this.loadPatterns();
  }

  async classify(request: ClassificationRequest): Promise<TicketClassification> {
    const text = `${request.subject} ${request.description}`.toLowerCase();

    // 1. Try pattern matching first (faster)
    for (const [key, pattern] of this.patterns) {
      if (pattern.regex.test(text) || this.matchesKeywords(text, pattern.keywords)) {
        // Apply user tier adjustments
        const priority = this.adjustPriorityForTier(pattern.priority, request.userTier);
        
        return {
          category: pattern.category,
          type: pattern.type,
          priority,
          tags: [...pattern.tags],
          confidence: 0.95,
          method: 'pattern_match',
          suggestedTemplate: pattern.suggestedTemplate
        };
      }
    }

    // 2. Fall back to AI classification
    return await this.classifyWithAI(request);
  }

  private loadPatterns(): void {
    // Wedding-specific support patterns
    this.patterns.set('form_save_error', {
      regex: /form.*(not|won't|can't|isn't).*(sav|submit|work)/i,
      keywords: ['form', 'save', 'error', 'not working', 'submit'],
      category: 'form_builder',
      type: 'bug',
      priority: 'high',
      tags: ['forms', 'data_loss'],
      suggestedTemplate: 'form_troubleshooting'
    });

    this.patterns.set('payment_failed', {
      regex: /payment.*(fail|decline|error)|card.*(decline|reject)|billing.*(issue|problem)/i,
      keywords: ['payment', 'failed', 'declined', 'billing', 'charge'],
      category: 'billing',
      type: 'billing',
      priority: 'critical',
      tags: ['payment', 'urgent', 'revenue_impact'],
      suggestedTemplate: 'payment_failure_help'
    });

    this.patterns.set('cannot_access', {
      regex: /cannot.*(access|login|get into)|can't.*(access|login|get in)|unable.*(access|login)/i,
      keywords: ['cannot access', 'locked out', 'login', 'password'],
      category: 'onboarding',
      type: 'technical',
      priority: 'high',
      tags: ['access', 'login', 'urgent'],
      suggestedTemplate: 'access_recovery'
    });

    this.patterns.set('data_missing', {
      regex: /data.*(missing|lost|gone|disappeared)|lost.*(client|guest|form)/i,
      keywords: ['data lost', 'missing', 'disappeared', 'gone'],
      category: 'data_loss',
      type: 'bug',
      priority: 'critical',
      tags: ['data_loss', 'critical', 'escalate'],
      suggestedTemplate: 'data_recovery'
    });

    this.patterns.set('wedding_day_emergency', {
      regex: /wedding.*(today|tomorrow|this weekend)|urgent.*(ceremony|reception)|live.*(event|wedding)/i,
      keywords: ['wedding today', 'urgent', 'ceremony', 'reception', 'live event'],
      category: 'bug',
      type: 'technical',
      priority: 'critical',
      tags: ['wedding_day', 'emergency', 'time_sensitive'],
      suggestedTemplate: 'wedding_day_support'
    });

    this.patterns.set('slow_performance', {
      regex: /slow|lag|freez|stuck|loading.*(forever|long)|timeout/i,
      keywords: ['slow', 'lagging', 'stuck', 'loading'],
      category: 'performance',
      type: 'bug',
      priority: 'medium',
      tags: ['performance', 'user_experience'],
      suggestedTemplate: 'performance_tips'
    });
  }

  private adjustPriorityForTier(basePriority: string, userTier: string): string {
    // Upgrade priority for higher tier users
    if (userTier === 'enterprise') {
      if (basePriority === 'medium') return 'high';
      if (basePriority === 'low') return 'medium';
    } else if (userTier === 'scale') {
      if (basePriority === 'low') return 'medium';
    }
    
    return basePriority;
  }

  private async classifyWithAI(request: ClassificationRequest): Promise<TicketClassification> {
    const prompt = this.buildClassificationPrompt(request);
    
    try {
      const response = await this.callOpenAI(prompt);
      const parsed = this.parseAIResponse(response);
      
      return {
        ...parsed,
        confidence: 0.8,
        method: 'ai_classification'
      };
    } catch (error) {
      // Fallback to default classification
      return this.getDefaultClassification(request);
    }
  }

  private buildClassificationPrompt(request: ClassificationRequest): string {
    return `
Classify this wedding platform support ticket:

Subject: "${request.subject}"
Description: "${request.description}"
User Type: ${request.userType}
User Tier: ${request.userTier}

Categories: form_builder, journey_canvas, email_system, import_export, performance, billing, subscription, refund, onboarding, training, feature_help, bug, data_loss, security, integration

Types: bug, question, feature_request, billing, onboarding, technical

Priorities: critical (data loss, security, payment issues, wedding day emergencies), high (account access, bugs affecting paid users), medium (general bugs, feature help), low (questions, minor issues)

Context: This is a wedding coordination platform. Photographers and other vendors use it to manage client forms, journeys, and communications. Wedding day issues are time-sensitive and should be prioritized.

Respond with JSON:
{
  "category": "one_of_the_categories_above",
  "type": "one_of_the_types_above", 
  "priority": "critical|high|medium|low",
  "tags": ["relevant", "tags", "wedding_specific_if_applicable"],
  "reasoning": "brief explanation of classification",
  "urgency_score": 1-10
}
    `;
  }
}
```

### CODE EXAMPLES

#### Example 1: Complete Ticket Management Implementation
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { supabase } from '@/lib/supabase';
import { AITicketClassifier } from '@/lib/support/ai-classifier';
import { SLAMonitor } from '@/lib/support/sla-monitor';
import { ResponseManager } from '@/lib/support/response-manager';

export interface Ticket {
  id: string;
  userId: string;
  userType: 'supplier' | 'couple';
  userTier: 'free' | 'starter' | 'professional' | 'scale' | 'enterprise';
  
  subject: string;
  description: string;
  attachments: Attachment[];
  
  type: 'bug' | 'question' | 'feature_request' | 'billing' | 'onboarding' | 'technical';
  category: string;
  priority: 'critical' | 'high' | 'medium' | 'low';
  status: 'open' | 'in_progress' | 'waiting_customer' | 'waiting_internal' | 'resolved' | 'closed';
  
  assignedTo: string | null;
  assignedTeam: string | null;
  assignedAt: Date | null;
  
  createdAt: Date;
  firstResponseAt: Date | null;
  lastUpdateAt: Date;
  resolvedAt: Date | null;
  closedAt: Date | null;
  
  slaFirstResponseMinutes: number;
  slaResolutionMinutes: number;
  slaFirstResponseDeadline: Date;
  slaResolutionDeadline: Date;
  slaBreach: boolean;
  
  escalationLevel: number;
  escalatedAt: Date | null;
  escalationReason: string | null;
  
  satisfactionRating: number | null;
  satisfactionFeedback: string | null;
  
  tags: string[];
  source: 'web' | 'email' | 'chat' | 'api';
  metadata: Record<string, any>;
  
  relatedTickets: string[];
  duplicateOf: string | null;
}

export class TicketManager {
  private static instance: TicketManager;
  private aiClassifier: AITicketClassifier;
  private slaMonitor: SLAMonitor;
  private responseManager: ResponseManager;

  static getInstance(): TicketManager {
    if (!TicketManager.instance) {
      TicketManager.instance = new TicketManager();
    }
    return TicketManager.instance;
  }

  constructor() {
    this.aiClassifier = new AITicketClassifier();
    this.slaMonitor = new SLAMonitor();
    this.responseManager = new ResponseManager();
  }

  async createTicket(request: CreateTicketRequest): Promise<Ticket> {
    try {
      console.log(`Creating ticket for user ${request.userId}:`, request.subject);

      // 1. Get user context for better classification
      const userContext = await this.getUserContext(request.userId);

      // 2. AI-powered classification with wedding industry context
      const classification = await this.aiClassifier.classify({
        subject: request.subject,
        description: request.description,
        userTier: userContext.tier,
        userType: request.userType,
        accountAge: userContext.accountAge,
        previousTicketCount: userContext.previousTickets
      });

      // 3. Generate smart ticket ID
      const ticketId = this.generateWeddingTicketId(classification.category);

      // 4. Calculate SLA with wedding industry considerations
      const sla = this.calculateWeddingSLA(classification.priority, userContext.tier, classification.tags);

      // 5. Build comprehensive ticket object
      const ticket: Ticket = {
        id: ticketId,
        userId: request.userId,
        userType: request.userType,
        userTier: userContext.tier,

        subject: request.subject.trim(),
        description: request.description.trim(),
        attachments: request.attachments || [],

        type: classification.type,
        category: classification.category,
        priority: classification.priority,
        status: 'open',

        assignedTo: null,
        assignedTeam: null,
        assignedAt: null,

        createdAt: new Date(),
        firstResponseAt: null,
        lastUpdateAt: new Date(),
        resolvedAt: null,
        closedAt: null,

        slaFirstResponseMinutes: sla.firstResponse,
        slaResolutionMinutes: sla.resolution,
        slaFirstResponseDeadline: sla.firstResponseDeadline,
        slaResolutionDeadline: sla.resolutionDeadline,
        slaBreach: false,

        escalationLevel: 0,
        escalatedAt: null,
        escalationReason: null,

        satisfactionRating: null,
        satisfactionFeedback: null,

        tags: classification.tags,
        source: request.source || 'web',
        metadata: {
          classification: {
            method: classification.method,
            confidence: classification.confidence,
            aiReasoning: classification.reasoning
          },
          userContext,
          weddingContext: this.extractWeddingContext(request.description),
          browserInfo: request.browserInfo,
          createdVia: 'support_dashboard'
        },

        relatedTickets: [],
        duplicateOf: null
      };

      // 6. Save to database with transaction
      await this.saveTicketWithTransaction(ticket);

      // 7. Immediate auto-response check
      const autoResponse = await this.checkAutoResponse(ticket);
      if (autoResponse) {
        await this.responseManager.addAutoResponse(ticketId, autoResponse);
        ticket.firstResponseAt = new Date();
      }

      // 8. Smart routing and assignment
      const assignment = await this.routeAndAssign(ticket);
      if (assignment.agentId) {
        ticket.assignedTo = assignment.agentId;
        ticket.assignedTeam = assignment.team;
        ticket.assignedAt = new Date();
        await this.updateTicketAssignment(ticketId, assignment);
      }

      // 9. Check for duplicates and related tickets
      const duplicateCheck = await this.checkForDuplicates(ticket);
      if (duplicateCheck.isDuplicate) {
        ticket.duplicateOf = duplicateCheck.originalTicketId;
        await this.handleDuplicateTicket(ticket, duplicateCheck);
      } else {
        const relatedTickets = await this.findRelatedTickets(ticket);
        if (relatedTickets.length > 0) {
          ticket.relatedTickets = relatedTickets.map(t => t.id);
          await this.linkRelatedTickets(ticketId, relatedTickets);
        }
      }

      // 10. Start SLA monitoring
      await this.slaMonitor.startMonitoring(ticketId);

      // 11. Send notifications based on priority and assignment
      await this.sendTicketNotifications(ticket);

      // 12. Wedding season specific handling
      if (this.isWeddingSeason() || this.isWeddingDayEmergency(ticket)) {
        await this.applyWeddingSeasonHandling(ticket);
      }

      console.log(`Ticket ${ticketId} created successfully:`, {
        priority: ticket.priority,
        category: ticket.category,
        assignedTo: ticket.assignedTo,
        slaDeadlines: {
          firstResponse: ticket.slaFirstResponseDeadline,
          resolution: ticket.slaResolutionDeadline
        }
      });

      return ticket;

    } catch (error) {
      console.error('Failed to create ticket:', error);
      throw new Error(`Ticket creation failed: ${error.message}`);
    }
  }

  private generateWeddingTicketId(category: string): string {
    const prefixMap: Record<string, string> = {
      'form_builder': 'FB',        // Form Builder
      'billing': 'BIL',           // Billing
      'bug': 'BUG',              // Bug Report
      'onboarding': 'ONB',        // Onboarding
      'data_loss': 'DL',          // Data Loss (Critical)
      'security': 'SEC',          // Security Issue
      'performance': 'PERF',      // Performance
      'journey_canvas': 'JC',     // Journey Canvas
      'email_system': 'EMAIL',    // Email System
      'import_export': 'IE',      // Import/Export
      'wedding_day': 'WED'        // Wedding Day Emergency
    };

    const prefix = prefixMap[category] || 'TKT';
    
    // Use timestamp and random for uniqueness
    const timestamp = Date.now().toString(36).toUpperCase();
    const random = Math.random().toString(36).substring(2, 5).toUpperCase();

    return `${prefix}-${timestamp}-${random}`;
  }

  private calculateWeddingSLA(priority: string, userTier: string, tags: string[]): SLAConfig {
    // Base SLA matrix
    const baseSLA = {
      critical: {
        enterprise: { firstResponse: 15, resolution: 120 },
        scale: { firstResponse: 30, resolution: 240 },
        professional: { firstResponse: 60, resolution: 480 },
        starter: { firstResponse: 120, resolution: 1440 },
        free: { firstResponse: 1440, resolution: 2880 }
      },
      high: {
        enterprise: { firstResponse: 60, resolution: 480 },
        scale: { firstResponse: 120, resolution: 960 },
        professional: { firstResponse: 240, resolution: 1440 },
        starter: { firstResponse: 480, resolution: 2880 },
        free: { firstResponse: 1440, resolution: 4320 }
      },
      medium: {
        enterprise: { firstResponse: 240, resolution: 1440 },
        scale: { firstResponse: 480, resolution: 2880 },
        professional: { firstResponse: 960, resolution: 4320 },
        starter: { firstResponse: 1440, resolution: 5760 },
        free: { firstResponse: 2880, resolution: 7200 }
      },
      low: {
        all: { firstResponse: 1440, resolution: 7200 }
      }
    };

    let sla = baseSLA[priority]?.[userTier] || baseSLA[priority]?.all || baseSLA.low.all;

    // Wedding industry specific adjustments
    if (tags.includes('wedding_day') || tags.includes('time_sensitive')) {
      // Halve response times for wedding day emergencies
      sla = {
        firstResponse: Math.max(5, Math.floor(sla.firstResponse / 2)),
        resolution: Math.max(30, Math.floor(sla.resolution / 2))
      };
    }

    if (tags.includes('data_loss') || tags.includes('security')) {
      // Critical data/security issues get premium SLA regardless of tier
      sla = { firstResponse: 15, resolution: 120 };
    }

    if (tags.includes('payment') || tags.includes('billing')) {
      // Payment issues affect revenue - fast response needed
      sla = {
        firstResponse: Math.min(sla.firstResponse, 60),
        resolution: Math.min(sla.resolution, 480)
      };
    }

    return {
      firstResponse: sla.firstResponse,
      resolution: sla.resolution,
      firstResponseDeadline: new Date(Date.now() + sla.firstResponse * 60000),
      resolutionDeadline: new Date(Date.now() + sla.resolution * 60000)
    };
  }

  private async saveTicketWithTransaction(ticket: Ticket): Promise<void> {
    const { error } = await supabase
      .from('support_tickets')
      .insert([{
        id: ticket.id,
        user_id: ticket.userId,
        user_type: ticket.userType,
        user_tier: ticket.userTier,
        
        subject: ticket.subject,
        description: ticket.description,
        attachments: ticket.attachments,
        
        ticket_type: ticket.type,
        category: ticket.category,
        priority: ticket.priority,
        status: ticket.status,
        
        assigned_to: ticket.assignedTo,
        assigned_team: ticket.assignedTeam,
        assigned_at: ticket.assignedAt,
        
        created_at: ticket.createdAt.toISOString(),
        last_update_at: ticket.lastUpdateAt.toISOString(),
        
        sla_first_response_minutes: ticket.slaFirstResponseMinutes,
        sla_resolution_minutes: ticket.slaResolutionMinutes,
        sla_first_response_deadline: ticket.slaFirstResponseDeadline.toISOString(),
        sla_resolution_deadline: ticket.slaResolutionDeadline.toISOString(),
        
        tags: ticket.tags,
        source: ticket.source,
        metadata: ticket.metadata
      }]);

    if (error) {
      throw new Error(`Database error: ${error.message}`);
    }
  }

  private extractWeddingContext(description: string): WeddingContext {
    const text = description.toLowerCase();
    
    return {
      isWeddingDay: /wedding.*(today|tomorrow|this weekend|saturday|sunday)/.test(text),
      hasDateMention: /\b(january|february|march|april|may|june|july|august|september|october|november|december|\d{1,2}\/\d{1,2}\/\d{4})\b/.test(text),
      vendorType: this.extractVendorType(text),
      urgencyIndicators: this.extractUrgencyIndicators(text),
      eventPhase: this.extractEventPhase(text) // planning, week_of, day_of, post_wedding
    };
  }

  private extractVendorType(text: string): string | null {
    const vendorPatterns = {
      photographer: /photographer|photo|picture|shoot/,
      videographer: /videographer|video|film/,
      dj: /dj|disc jockey|music|sound/,
      florist: /florist|flower|bouquet|arrangement/,
      caterer: /cater|food|menu|meal/,
      venue: /venue|location|hall|church/,
      planner: /planner|coordinator|organiz/
    };

    for (const [type, pattern] of Object.entries(vendorPatterns)) {
      if (pattern.test(text)) {
        return type;
      }
    }
    
    return null;
  }

  async assignTicket(ticketId: string, agentId: string, reason?: string): Promise<void> {
    const ticket = await this.getTicket(ticketId);
    const agent = await this.getAgent(agentId);

    // Verify agent has capacity
    if (agent.currentTicketCount >= agent.maxConcurrentTickets) {
      throw new Error(`Agent ${agent.agentName} is at capacity (${agent.currentTicketCount}/${agent.maxConcurrentTickets})`);
    }

    // Verify agent has appropriate skills for this ticket
    if (!this.agentHasRequiredSkills(agent, ticket)) {
      console.warn(`Agent ${agent.agentName} may not have optimal skills for ${ticket.category} ticket`);
    }

    // Update ticket assignment
    const now = new Date();
    
    const { error } = await supabase
      .from('support_tickets')
      .update({
        assigned_to: agentId,
        assigned_team: agent.team,
        assigned_at: now.toISOString(),
        last_update_at: now.toISOString()
      })
      .eq('id', ticketId);

    if (error) {
      throw new Error(`Failed to assign ticket: ${error.message}`);
    }

    // Update agent's current ticket count
    await this.updateAgentTicketCount(agentId, 1);

    // Add system message about assignment
    await this.addSystemMessage(ticketId, 
      `Ticket assigned to ${agent.agentName}${reason ? ` - ${reason}` : ''}`,
      { agentId, reason, assignedAt: now }
    );

    // Send assignment notifications
    await this.sendAssignmentNotifications(ticket, agent);

    // Log assignment event for metrics
    await this.logTicketEvent(ticketId, 'assigned', {
      agentId,
      agentName: agent.agentName,
      reason,
      assignmentTime: now
    });

    console.log(`Ticket ${ticketId} assigned to ${agent.agentName}`);
  }

  private agentHasRequiredSkills(agent: SupportAgent, ticket: Ticket): boolean {
    const requiredSkills = this.getRequiredSkillsForCategory(ticket.category);
    return requiredSkills.some(skill => agent.skills.includes(skill));
  }

  private getRequiredSkillsForCategory(category: string): string[] {
    const skillMap: Record<string, string[]> = {
      'form_builder': ['technical', 'form_builder'],
      'billing': ['billing', 'payments'],
      'onboarding': ['onboarding', 'customer_success'],
      'bug': ['technical', 'debugging'],
      'data_loss': ['technical', 'data_recovery'],
      'security': ['security', 'technical'],
      'performance': ['technical', 'performance'],
      'journey_canvas': ['technical', 'journey_canvas'],
      'email_system': ['technical', 'email_systems']
    };

    return skillMap[category] || ['general'];
  }

  async escalateTicket(ticketId: string, reason: string, escalateTo?: string): Promise<void> {
    const ticket = await this.getTicket(ticketId);
    const currentAgent = ticket.assignedTo ? await this.getAgent(ticket.assignedTo) : null;

    ticket.escalationLevel++;
    ticket.escalatedAt = new Date();
    ticket.escalationReason = reason;

    // Determine escalation target
    let newAssignee: string | null = null;
    let escalationTarget = escalateTo;

    if (!escalationTarget) {
      // Automatic escalation logic
      if (ticket.escalationLevel === 1) {
        escalationTarget = 'senior';
      } else if (ticket.escalationLevel === 2) {
        escalationTarget = 'team_lead';
      } else {
        escalationTarget = 'founder';
      }
    }

    // Find appropriate escalation target
    switch (escalationTarget) {
      case 'senior':
        newAssignee = await this.findSeniorAgent(ticket.category);
        break;
      case 'team_lead':
        newAssignee = await this.findTeamLead(ticket.assignedTeam);
        break;
      case 'founder':
        newAssignee = await this.getFounderId();
        break;
    }

    // Increase priority on escalation
    if (ticket.priority === 'low') ticket.priority = 'medium';
    else if (ticket.priority === 'medium') ticket.priority = 'high';
    else if (ticket.priority === 'high') ticket.priority = 'critical';

    // Update ticket in database
    const { error } = await supabase
      .from('support_tickets')
      .update({
        escalation_level: ticket.escalationLevel,
        escalated_at: ticket.escalatedAt.toISOString(),
        escalation_reason: reason,
        priority: ticket.priority,
        assigned_to: newAssignee,
        last_update_at: new Date().toISOString()
      })
      .eq('id', ticketId);

    if (error) {
      throw new Error(`Failed to escalate ticket: ${error.message}`);
    }

    // Add escalation message
    await this.addSystemMessage(ticketId, 
      `Ticket escalated to ${escalationTarget}: ${reason}`,
      { 
        escalationLevel: ticket.escalationLevel,
        escalatedTo: escalationTarget,
        newAssignee,
        previousAgent: currentAgent?.agentName
      }
    );

    // Send escalation notifications
    await this.sendEscalationNotifications(ticket, escalationTarget, reason);

    // Log escalation event
    await this.logTicketEvent(ticketId, 'escalated', {
      escalationLevel: ticket.escalationLevel,
      reason,
      escalatedTo: escalationTarget,
      escalatedBy: currentAgent?.agentName || 'System'
    });

    console.log(`Ticket ${ticketId} escalated to ${escalationTarget} (level ${ticket.escalationLevel}): ${reason}`);
  }

  async getTicketMetrics(filters?: TicketMetricsFilter): Promise<TicketMetrics> {
    const timeframe = filters?.timeframe || 'last_30_days';
    const startDate = this.getTimeframeStartDate(timeframe);

    // Get overview metrics
    const overviewQuery = supabase
      .from('support_tickets')
      .select('status, priority, created_at, first_response_at, resolved_at, satisfaction_rating')
      .gte('created_at', startDate.toISOString());

    const { data: tickets, error } = await overviewQuery;
    
    if (error) {
      throw new Error(`Failed to fetch ticket metrics: ${error.message}`);
    }

    // Calculate metrics
    const totalTickets = tickets.length;
    const openTickets = tickets.filter(t => t.status === 'open').length;
    const inProgressTickets = tickets.filter(t => t.status === 'in_progress').length;
    const resolvedTickets = tickets.filter(t => t.status === 'resolved').length;

    // SLA calculations
    const ticketsWithResponse = tickets.filter(t => t.first_response_at);
    const avgFirstResponse = this.calculateAverageResponseTime(ticketsWithResponse);
    
    const ticketsResolved = tickets.filter(t => t.resolved_at);
    const avgResolution = this.calculateAverageResolutionTime(ticketsResolved);

    // Satisfaction
    const satisfactionResponses = tickets.filter(t => t.satisfaction_rating);
    const avgSatisfaction = satisfactionResponses.length > 0 
      ? satisfactionResponses.reduce((sum, t) => sum + t.satisfaction_rating, 0) / satisfactionResponses.length
      : 0;

    // Priority breakdown
    const byPriority = {
      critical: tickets.filter(t => t.priority === 'critical').length,
      high: tickets.filter(t => t.priority === 'high').length,
      medium: tickets.filter(t => t.priority === 'medium').length,
      low: tickets.filter(t => t.priority === 'low').length
    };

    return {
      overview: {
        totalTickets,
        openTickets,
        inProgressTickets,
        resolvedTickets,
        avgFirstResponseTime: Math.round(avgFirstResponse),
        avgResolutionTime: Math.round(avgResolution / 60), // convert to hours
        satisfactionScore: Math.round(avgSatisfaction * 100) / 100,
        resolutionRate: totalTickets > 0 ? Math.round((resolvedTickets / totalTickets) * 100) : 0
      },
      byPriority,
      trends: await this.getTicketTrends(startDate),
      agentMetrics: await this.getAgentMetrics(startDate)
    };
  }
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Supabase: Ticket storage, user management, real-time updates
- [x] Context7: OpenAI integration documentation for AI classification
- [x] Filesystem: Template storage and management

#### Supabase MCP Queries Needed
```typescript
await mcp__supabase__execute_sql({
  query: `
    SELECT t.*, u.email, u.user_metadata->>'tier' as tier
    FROM support_tickets t
    JOIN auth.users u ON t.user_id = u.id
    WHERE t.status = 'open' 
    ORDER BY t.priority DESC, t.created_at ASC
  `
});

await mcp__supabase__get_logs({
  service: "api"
});
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('TicketManager', () => {
  it('should create ticket with correct SLA for enterprise user', async () => {
    const manager = TicketManager.getInstance();
    const request = {
      userId: 'enterprise-user',
      userType: 'supplier',
      subject: 'Cannot access forms',
      description: 'Getting 500 error when trying to access client forms',
      source: 'web'
    };
    
    const ticket = await manager.createTicket(request);
    
    expect(ticket.priority).toBe('high');
    expect(ticket.slaFirstResponseMinutes).toBe(60); // 1 hour for enterprise high priority
    expect(ticket.category).toBe('form_builder');
  });

  it('should escalate wedding day emergencies to critical priority', async () => {
    const classifier = new AITicketClassifier();
    const request = {
      subject: 'Urgent - Wedding today, forms not working',
      description: 'My client is getting married today and cannot access RSVP forms',
      userType: 'supplier',
      userTier: 'professional'
    };
    
    const classification = await classifier.classify(request);
    
    expect(classification.priority).toBe('critical');
    expect(classification.tags).toContain('wedding_day');
    expect(classification.tags).toContain('time_sensitive');
  });

  it('should assign tickets to agents with appropriate skills', async () => {
    const router = new TicketRouter();
    const ticket = createMockTicket({ category: 'form_builder', priority: 'high' });
    const formBuilderAgent = createMockAgent({ skills: ['form_builder', 'technical'] });
    
    const assignment = await router.routeTicket(ticket);
    
    expect(assignment.agentId).toBe(formBuilderAgent.id);
    expect(assignment.reason).toContain('skill match');
  });

  it('should enforce SLA deadlines and trigger alerts', async () => {
    const slaMonitor = new SLAMonitor();
    const ticket = createMockTicket({ 
      priority: 'critical',
      userTier: 'enterprise',
      slaFirstResponseMinutes: 15
    });
    
    // Simulate 10 minutes passing
    jest.advanceTimersByTime(10 * 60 * 1000);
    
    const status = await slaMonitor.checkSLAStatus(ticket.id);
    expect(status.firstResponseWarning).toBe(true);
    expect(status.minutesUntilBreach).toBe(5);
  });
});

describe('AITicketClassifier', () => {
  it('should detect payment failures and classify as critical/billing', async () => {
    const classifier = new AITicketClassifier();
    const request = {
      subject: 'Payment failed',
      description: 'My credit card was declined when trying to upgrade subscription',
      userType: 'supplier',
      userTier: 'professional'
    };
    
    const result = await classifier.classify(request);
    
    expect(result.category).toBe('billing');
    expect(result.type).toBe('billing');
    expect(result.priority).toBe('critical');
    expect(result.suggestedTemplate).toBe('payment_failure_help');
  });

  it('should identify data loss scenarios as critical', async () => {
    const classifier = new AITicketClassifier();
    const request = {
      subject: 'All my client data disappeared',
      description: 'When I logged in today, all my wedding client forms and data are missing',
      userType: 'supplier',
      userTier: 'scale'
    };
    
    const result = await classifier.classify(request);
    
    expect(result.category).toBe('data_loss');
    expect(result.priority).toBe('critical');
    expect(result.tags).toContain('data_loss');
    expect(result.tags).toContain('escalate');
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Admin can manage tickets from creation to resolution', async () => {
  await mcp__playwright__browser_navigate({url: '/admin/tickets'});
  await mcp__playwright__browser_snapshot();
  
  // Check ticket queue loads with proper prioritization
  await mcp__playwright__browser_wait_for({text: 'Support Tickets'});
  await mcp__playwright__browser_wait_for({text: 'Critical'});
  
  // Click on critical priority ticket
  await mcp__playwright__browser_click({
    element: 'Critical priority ticket',
    ref: '[data-testid="ticket-critical"]'
  });
  
  // Verify ticket details load
  await mcp__playwright__browser_wait_for({text: 'SLA Deadline'});
  await mcp__playwright__browser_wait_for({text: 'Customer Information'});
  
  // Assign ticket to agent
  await mcp__playwright__browser_click({
    element: 'Assign to agent dropdown',
    ref: '[data-testid="assign-agent-select"]'
  });
  
  await mcp__playwright__browser_click({
    element: 'Technical support agent',
    ref: '[data-testid="agent-technical"]'
  });
  
  // Add response to ticket
  await mcp__playwright__browser_type({
    element: 'Response textarea',
    ref: '[data-testid="response-input"]',
    text: 'I am looking into this issue for you. I will have an update within the next 30 minutes.'
  });
  
  await mcp__playwright__browser_click({
    element: 'Send response button',
    ref: '[data-testid="send-response"]'
  });
  
  // Verify response was added and status updated
  await mcp__playwright__browser_wait_for({text: 'Response sent successfully'});
  await mcp__playwright__browser_wait_for({text: 'In Progress'});
  
  await mcp__playwright__browser_snapshot();
});

test('SLA monitoring triggers alerts for overdue tickets', async () => {
  // Create test ticket with short SLA
  const testTicket = await createTestTicket({
    priority: 'critical',
    userTier: 'enterprise',
    slaMinutes: 1 // 1 minute for testing
  });
  
  await mcp__playwright__browser_navigate({url: '/admin/tickets'});
  
  // Wait for SLA alert to appear
  await mcp__playwright__browser_wait_for({text: 'SLA BREACH'});
  
  // Verify alert contains ticket information
  const alertElement = '[data-testid="sla-breach-alert"]';
  const alertText = await mcp__playwright__browser_evaluate({
    function: `() => document.querySelector('${alertElement}').textContent`
  });
  
  expect(alertText).toContain(testTicket.id);
  expect(alertText).toContain('Enterprise');
  
  await mcp__playwright__browser_snapshot();
});
```

### ACCEPTANCE CRITERIA
- [x] AI-powered ticket classification with 85%+ accuracy for wedding industry terms
- [x] Tier-based SLA enforcement (Enterprise: 15min/2hr, Free: 24hr/48hr) with automated alerts
- [x] Smart routing to specialized teams based on category and agent skills
- [x] Real-time SLA monitoring with visual countdown timers and breach notifications
- [x] Escalation workflow with automatic priority upgrades
- [x] Canned response library with personalization variables
- [x] Customer satisfaction tracking with follow-up automation
- [x] Wedding day emergency detection and prioritization
- [x] Comprehensive metrics dashboard with agent performance tracking
- [x] Duplicate ticket detection and relationship mapping

### DEPENDENCIES
- Must complete after: User authentication system, Admin dashboard base
- Must complete before: Knowledge base system, Live chat integration  
- Shares code with: Alert system (WS-228), User management, Email system

### ESTIMATED EFFORT
- Team A Frontend: 32 hours (Ticket dashboard, queue, detail views)
- Team B Backend: 44 hours (Ticket management, AI classification, routing, SLA monitoring)
- Team C Integration: 20 hours (Email integration, notification system)
- Team D Platform: 16 hours (Database schema, performance optimization)
- Team E General: 22 hours (Comprehensive testing, validation scenarios)
- Total: 134 hours