# TECHNICAL SPECIFICATION: WS-172 - Offline Functionality
## Generated by Feature Development Session - 2025-01-24

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding coordinator working at remote venues
**I want to:** Access client timelines, vendor contacts, and forms when internet is unavailable
**So that:** I can continue coordinating the wedding even in areas with poor connectivity

**Real Wedding Scenario:**
A venue coordinator at a barn wedding with no WiFi can still view the timeline, mark vendor arrivals, take notes about setup issues, and update the couple's timeline - all syncing automatically when connection returns.

### SPECIFICATION SOURCE
- **Feature ID:** WS-172
- **Original Spec:** /CORE-SPECIFICATIONS/09-MOBILE-OPTIMIZATION/03-offline-functionality md.md
- **Current Implementation:** 0% complete
- **Files to Create:**
  - /src/lib/offline/storage-manager.ts
  - /src/lib/offline/sync-engine.ts
  - /src/lib/offline/conflict-resolver.ts
  - /src/components/offline/OfflineIndicator.tsx
  - /src/hooks/useOfflineData.ts

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Offline data sync
CREATE TABLE IF NOT EXISTS offline_sync_queue (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES user_profiles(id),
  action_type TEXT CHECK (action_type IN ('create', 'update', 'delete')),
  table_name TEXT,
  record_id TEXT,
  data JSONB,
  created_offline_at TIMESTAMPTZ DEFAULT NOW(),
  synced_at TIMESTAMPTZ
);

CREATE INDEX idx_offline_sync_user ON offline_sync_queue(user_id);
CREATE INDEX idx_offline_sync_pending ON offline_sync_queue(synced_at) WHERE synced_at IS NULL;
```

#### API Endpoints Required
```typescript
// POST /api/offline/sync
interface SyncRequest {
  changes: Array<{
    action: 'create' | 'update' | 'delete';
    table: string;
    id: string;
    data: object;
    timestamp: string;
  }>;
  lastSyncTime: string;
}

interface SyncResponse {
  success: boolean;
  conflicts: Array<{
    id: string;
    serverData: object;
    clientData: object;
    resolution: 'server_wins' | 'client_wins' | 'merge';
  }>;
  serverChanges: Array<{
    action: string;
    table: string;
    data: object;
  }>;
}
```

### CODE EXAMPLES

#### Example 1: Offline Storage Manager
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { openDB, DBSchema, IDBPDatabase } from 'idb';

interface WedSyncDB extends DBSchema {
  clients: {
    key: string;
    value: {
      id: string;
      name: string;
      wedding_date: string;
      timeline: object;
      last_modified: number;
    };
  };
  forms: {
    key: string;
    value: {
      id: string;
      title: string;
      fields: object;
      responses: object[];
    };
  };
  sync_queue: {
    key: string;
    value: {
      id: string;
      action: 'create' | 'update' | 'delete';
      table: string;
      data: object;
      timestamp: number;
    };
  };
}

export class OfflineStorageManager {
  private db: IDBPDatabase<WedSyncDB> | null = null;

  async init() {
    this.db = await openDB<WedSyncDB>('wedsync-offline', 1, {
      upgrade(db) {
        db.createObjectStore('clients', { keyPath: 'id' });
        db.createObjectStore('forms', { keyPath: 'id' });
        db.createObjectStore('sync_queue', { keyPath: 'id' });
      },
    });
  }

  async storeClient(client: any) {
    if (!this.db) await this.init();
    
    client.last_modified = Date.now();
    await this.db!.put('clients', client);
    
    // Queue for sync if online
    if (navigator.onLine) {
      await this.queueSync('update', 'clients', client);
    }
  }

  async getClient(id: string) {
    if (!this.db) await this.init();
    return await this.db!.get('clients', id);
  }

  async queueSync(action: string, table: string, data: any) {
    if (!this.db) await this.init();
    
    const syncItem = {
      id: crypto.randomUUID(),
      action,
      table,
      data,
      timestamp: Date.now()
    };
    
    await this.db!.put('sync_queue', syncItem);
  }

  async getAllPendingSync() {
    if (!this.db) await this.init();
    return await this.db!.getAll('sync_queue');
  }
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [ ] Context7: Load docs for IndexedDB, PWA offline
- [ ] PostgreSQL: Create sync tables

### ACCEPTANCE CRITERIA
- [ ] Critical data cached locally for offline access
- [ ] Forms can be filled and submitted offline
- [ ] Changes sync automatically when connection returns
- [ ] Conflict resolution works for simultaneous edits
- [ ] Offline indicator shows connection status
- [ ] Background sync queues pending changes
- [ ] Data remains accessible after app restart
- [ ] Storage quota managed efficiently

### DEPENDENCIES
- Must complete after: WS-171 (PWA Configuration)
- Must complete before: None
- Shares code with: WS-173 (Performance Optimization)

### ESTIMATED EFFORT
- Team A Frontend: 20 hours
- Team B Backend: 16 hours
- Total: 36 hours