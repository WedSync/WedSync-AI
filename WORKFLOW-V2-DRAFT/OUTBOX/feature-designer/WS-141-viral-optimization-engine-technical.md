# TECHNICAL SPECIFICATION: WS-141 - Viral Optimization Engine
## Generated by Feature Development Session - 2025-08-24

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding florist with 50 happy couples
**I want to:** Easily invite my past couples to join WedSync and refer their engaged friends
**So that:** I can grow my business through referrals and my couples can help their friends find trusted vendors

**Real Wedding Scenario:**
A florist sends personalized invites to past couples. One couple shares with their engaged friend who's struggling to coordinate 8 vendors. The friend signs up, invites all vendors including a new florist, creating a network effect. The original florist gets referral credit and premium features.

### SPECIFICATION SOURCE
- **Feature ID:** WS-141
- **Original Spec:** /CORE-SPECIFICATIONS/13-BUSINESS-OPERATIONS/05-viral-optimization md.md
- **Current Implementation:** 0% complete
- **Files to Modify:** 
  - /src/app/(dashboard)/dashboard/page.tsx
  - /src/lib/analytics/tracking.ts
- **New Files to Create:**
  - /src/lib/viral/viral-metrics.ts
  - /src/lib/viral/invitation-optimizer.ts
  - /src/lib/viral/network-amplifier.ts
  - /src/components/viral/InvitationFlow.tsx
  - /src/components/viral/ReferralTracker.tsx
  - /src/components/viral/ViralDashboard.tsx
  - /src/app/api/viral/metrics/route.ts
  - /src/app/api/viral/invite/route.ts
  - /src/app/api/viral/suggestions/route.ts
  - /supabase/migrations/20250824000005_viral_optimization_system.sql

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Viral metrics tracking
CREATE TABLE IF NOT EXISTS viral_metrics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  date DATE NOT NULL,
  invites_sent INT DEFAULT 0,
  invites_accepted INT DEFAULT 0,
  users_who_invited INT DEFAULT 0,
  total_active_users INT,
  viral_coefficient DECIMAL(3,2),
  cycle_time_days DECIMAL(5,2),
  calculated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Invitation funnel tracking
CREATE TABLE IF NOT EXISTS invitation_funnel (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  invite_id UUID NOT NULL,
  sender_id UUID REFERENCES users(id),
  sender_type TEXT, -- 'supplier' or 'couple'
  recipient_email TEXT NOT NULL,
  recipient_type TEXT, -- 'supplier' or 'couple'
  relationship TEXT, -- 'past_client', 'vendor', 'friend'
  sent_at TIMESTAMPTZ DEFAULT NOW(),
  opened_at TIMESTAMPTZ,
  clicked_at TIMESTAMPTZ,
  signed_up_at TIMESTAMPTZ,
  activated_at TIMESTAMPTZ,
  template_variant TEXT,
  channel TEXT DEFAULT 'email'
);

-- Network connections for wedding industry
CREATE TABLE IF NOT EXISTS network_connections (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES suppliers(id),
  couple_id UUID REFERENCES couples(id),
  connection_type TEXT, -- 'direct_client', 'referred', 'venue_recommended'
  connection_strength INT DEFAULT 5, -- 1-10 based on interaction
  wedding_date DATE,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create index for performance
CREATE INDEX idx_invitation_funnel_sender ON invitation_funnel(sender_id);
CREATE INDEX idx_network_connections_supplier ON network_connections(supplier_id);
```

#### API Endpoints Required
```typescript
// GET /api/viral/metrics
interface ViralMetricsResponse {
  coefficient: number;
  invitesPerUser: number;
  conversionRate: number;
  cycleTimeDays: number;
  trend: 'improving' | 'stable' | 'declining';
  suggestions: string[];
}

// POST /api/viral/invite
interface OptimizedInviteRequest {
  recipients: Array<{
    email: string;
    name?: string;
    relationship: 'past_client' | 'vendor' | 'friend';
  }>;
  context: {
    weddingRole?: string;
    weddingDate?: string;
  };
}

interface InviteResponse {
  sent: number;
  failed: number;
  trackingIds: string[];
}

// GET /api/viral/suggestions
interface ViralSuggestionsResponse {
  suggestions: Array<{
    id: string;
    title: string;
    description: string;
    estimatedImpact: 'high' | 'medium' | 'low';
    implementationEffort: 'easy' | 'medium' | 'hard';
  }>;
}
```

#### Frontend Components Required
```typescript
// Component: InvitationFlow
// Location: /src/components/viral/InvitationFlow.tsx

interface InvitationFlowProps {
  userType: 'supplier' | 'couple';
  pastClients?: Client[];
  vendors?: Vendor[];
  onComplete: (invitesSent: number) => void;
}

// Component: ReferralTracker
// Location: /src/components/viral/ReferralTracker.tsx

interface ReferralTrackerProps {
  userId: string;
  referrals: Referral[];
  rewards: Reward[];
}

// Component: ViralDashboard
// Location: /src/components/viral/ViralDashboard.tsx

interface ViralDashboardProps {
  metrics: ViralMetrics;
  funnel: FunnelData;
  suggestions: Suggestion[];
}

// Key functionality:
- Multi-channel invitation sending (email, WhatsApp, SMS)
- A/B testing of invitation templates
- Viral coefficient calculation and tracking
- Network effect visualization
- Referral reward management
- Super-connector identification
```

#### Integration Points
```typescript
// Service: ViralOptimizationService
// Dependencies: Analytics, Email, Social APIs

class ViralOptimizationService {
  static async calculateViralCoefficient(period: DateRange): Promise<number> {
    const metrics = await this.getMetricsForPeriod(period);
    
    const invitesPerUser = metrics.invites_sent / metrics.users_who_invited;
    const conversionRate = metrics.invites_accepted / metrics.invites_sent;
    
    return invitesPerUser * conversionRate;
  }

  static async identifySuperConnectors(): Promise<User[]> {
    // Find wedding vendors with high network value
    const query = `
      SELECT s.*, 
             COUNT(DISTINCT nc.couple_id) as couple_connections,
             AVG(nc.connection_strength) as avg_strength
      FROM suppliers s
      JOIN network_connections nc ON s.id = nc.supplier_id
      GROUP BY s.id
      HAVING couple_connections > 20
      ORDER BY (couple_connections * avg_strength) DESC
      LIMIT 100
    `;
    
    return await db.query(query);
  }

  static async optimizeInvitationTiming(recipient: string): Promise<Date> {
    // Best times for wedding industry professionals
    const patterns = await this.getEngagementPatterns(recipient);
    return this.selectOptimalTime(patterns);
  }
}
```

### CODE EXAMPLES

#### Example 1: Optimized Invitation Flow
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { createClient } from '@/lib/supabase/server';
import { generateInviteCode } from '@/lib/utils/codes';

interface WeddingInvitation {
  sender: User;
  recipient: string;
  relationship: 'past_client' | 'vendor' | 'friend';
  context: {
    weddingDate?: Date;
    venueConnection?: string;
  };
}

export class OptimizedInviteSystem {
  static async sendWeddingNetworkInvite(invitation: WeddingInvitation) {
    const supabase = createClient();
    
    // Select template based on relationship
    const template = this.selectTemplate(invitation.relationship);
    
    // A/B test subject lines
    const variant = Math.random() > 0.5 ? 'social_proof' : 'value_prop';
    const subject = variant === 'social_proof' 
      ? `${invitation.sender.name} thought you'd love this (847 couples using it)`
      : `Save 10+ hours on wedding coordination`;
    
    // Track in funnel
    const inviteId = generateInviteCode();
    await supabase.from('invitation_funnel').insert({
      invite_id: inviteId,
      sender_id: invitation.sender.id,
      sender_type: invitation.sender.type,
      recipient_email: invitation.recipient,
      relationship: invitation.relationship,
      template_variant: variant
    });
    
    // Send via optimal channel
    const channel = await this.selectBestChannel(invitation.recipient);
    
    if (channel === 'whatsapp' && invitation.sender.phone) {
      await this.sendWhatsAppInvite(invitation, inviteId);
    } else {
      await this.sendEmailInvite(invitation, inviteId, subject, template);
    }
    
    // Schedule follow-ups
    await this.scheduleFollowUps(inviteId, invitation);
    
    return { inviteId, channel, variant };
  }

  private static selectTemplate(relationship: string): string {
    const templates = {
      past_client: 'Hey {name}, remember how chaotic wedding planning was? I've been using WedSync to coordinate with all my couples now - it literally saves me 10+ hours per wedding. Thought it might help you with your friends getting married!',
      vendor: 'Hi {name}, I know we both deal with the same wedding coordination headaches. Found this tool that syncs everything between vendors automatically. 847 wedding pros using it this month. Worth checking out?',
      friend: 'Saw you're planning your wedding! I use WedSync with all my wedding clients - it keeps everyone on the same page. Free for couples, might save you some stress!'
    };
    
    return templates[relationship] || templates.friend;
  }
}
```

#### Example 2: Viral Metrics Dashboard
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import React, { useEffect, useState } from 'react';
import { LineChart, FunnelChart } from '@/components/charts';
import { Card } from '@/components/ui/Card';

export const ViralDashboard: React.FC = () => {
  const [metrics, setMetrics] = useState<ViralMetrics | null>(null);
  const [funnel, setFunnel] = useState<FunnelData | null>(null);

  useEffect(() => {
    fetchViralData();
  }, []);

  const fetchViralData = async () => {
    const [metricsRes, funnelRes] = await Promise.all([
      fetch('/api/viral/metrics'),
      fetch('/api/viral/funnel')
    ]);
    
    setMetrics(await metricsRes.json());
    setFunnel(await funnelRes.json());
  };

  if (!metrics || !funnel) return <div>Loading viral metrics...</div>;

  const viralHealth = metrics.coefficient >= 1.0 ? 'healthy' : 
                      metrics.coefficient >= 0.7 ? 'growing' : 'needs-attention';

  return (
    <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
      {/* Key Metric Card */}
      <Card className={`col-span-1 ${viralHealth === 'healthy' ? 'border-green-500' : 'border-yellow-500'}`}>
        <h3 className="text-lg font-semibold mb-2">Viral Coefficient</h3>
        <div className="text-4xl font-bold">
          {metrics.coefficient.toFixed(2)}
          {metrics.coefficient >= 1.0 && <span className="ml-2">🚀</span>}
        </div>
        <p className="text-sm text-gray-600 mt-2">
          Each user brings {metrics.coefficient.toFixed(2)} new users
        </p>
        <div className="mt-4 space-y-2">
          <div className="flex justify-between text-sm">
            <span>Invites per user:</span>
            <span className="font-medium">{metrics.invitesPerUser.toFixed(1)}</span>
          </div>
          <div className="flex justify-between text-sm">
            <span>Conversion rate:</span>
            <span className="font-medium">{(metrics.conversionRate * 100).toFixed(1)}%</span>
          </div>
          <div className="flex justify-between text-sm">
            <span>Cycle time:</span>
            <span className="font-medium">{metrics.cycleTimeDays.toFixed(0)} days</span>
          </div>
        </div>
      </Card>

      {/* Invitation Funnel */}
      <Card className="col-span-2">
        <h3 className="text-lg font-semibold mb-4">Invitation Funnel</h3>
        <FunnelChart
          data={[
            { stage: 'Invites Sent', value: funnel.sent, color: '#3B82F6' },
            { stage: 'Opened (Email)', value: funnel.opened, color: '#10B981' },
            { stage: 'Clicked Link', value: funnel.clicked, color: '#F59E0B' },
            { stage: 'Signed Up', value: funnel.signedUp, color: '#8B5CF6' },
            { stage: 'Activated', value: funnel.activated, color: '#EC4899' }
          ]}
          height={300}
        />
        <div className="grid grid-cols-4 gap-2 mt-4">
          {funnel.conversionRates.map((rate, idx) => (
            <div key={idx} className="text-center">
              <div className="text-2xl font-bold">{rate.value}%</div>
              <div className="text-xs text-gray-600">{rate.label}</div>
            </div>
          ))}
        </div>
      </Card>

      {/* Growth Suggestions */}
      <Card className="col-span-3">
        <h3 className="text-lg font-semibold mb-4">Optimization Opportunities</h3>
        <div className="space-y-3">
          {metrics.suggestions.map((suggestion, idx) => (
            <div key={idx} className="flex items-start p-3 bg-gray-50 rounded-lg">
              <div className="flex-1">
                <h4 className="font-medium">{suggestion.title}</h4>
                <p className="text-sm text-gray-600 mt-1">{suggestion.description}</p>
              </div>
              <div className="ml-4">
                <span className={`px-2 py-1 text-xs rounded ${
                  suggestion.impact === 'high' ? 'bg-green-100 text-green-800' :
                  suggestion.impact === 'medium' ? 'bg-yellow-100 text-yellow-800' :
                  'bg-gray-100 text-gray-800'
                }`}>
                  {suggestion.impact} impact
                </span>
              </div>
            </div>
          ))}
        </div>
      </Card>
    </div>
  );
};
```

### MCP SERVER USAGE

#### Required MCP Servers
- [ ] Context7: Load docs for viral growth patterns, analytics
- [ ] PostgreSQL: Query network connections and metrics
- [ ] Playwright: Test invitation flows and tracking

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/vercel/next.js", "analytics tracking", 2000);
await mcp__context7__get-library-docs("/supabase/supabase", "realtime subscriptions", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('ViralOptimizationService', () => {
  it('should calculate viral coefficient correctly', async () => {
    const mockMetrics = {
      invites_sent: 1000,
      users_who_invited: 100,
      invites_accepted: 150
    };
    
    // K = (1000/100) * (150/1000) = 10 * 0.15 = 1.5
    const coefficient = await ViralOptimizationService.calculateViralCoefficient();
    expect(coefficient).toBe(1.5);
  });

  it('should identify super connectors', async () => {
    const superConnectors = await ViralOptimizationService.identifySuperConnectors();
    expect(superConnectors).toBeDefined();
    expect(superConnectors[0]).toHaveProperty('couple_connections');
    expect(superConnectors[0].couple_connections).toBeGreaterThan(20);
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Viral invitation flow', async () => {
  await mcp__playwright__browser_navigate({ url: '/dashboard/grow' });
  await mcp__playwright__browser_snapshot();
  
  // Click invite button
  await mcp__playwright__browser_click({
    element: 'Invite past clients button',
    ref: '[data-testid="invite-clients-btn"]'
  });
  
  // Select recipients
  await mcp__playwright__browser_click({
    element: 'Select all checkbox',
    ref: '[data-testid="select-all-clients"]'
  });
  
  // Send invitations
  await mcp__playwright__browser_click({
    element: 'Send invitations button',
    ref: '[data-testid="send-invites-btn"]'
  });
  
  // Verify tracking
  await mcp__playwright__browser_wait_for({ text: 'Invitations sent successfully' });
  
  // Check funnel tracking
  const funnelData = await getFunnelData();
  expect(funnelData.sent).toBeGreaterThan(0);
});
```

### ACCEPTANCE CRITERIA
- [ ] Viral coefficient calculation accurate to 2 decimal places
- [ ] Invitation funnel tracks all 5 stages (sent, opened, clicked, signed up, activated)
- [ ] A/B testing randomly assigns variants and tracks performance
- [ ] Super-connectors identified based on network connections
- [ ] Multi-channel invitations (email, WhatsApp, SMS) supported
- [ ] Referral rewards tracked and applied automatically
- [ ] Performance: Metrics calculation under 500ms
- [ ] Security: Invitation codes are unique and expire after 30 days
- [ ] Accessibility: Invitation flow meets WCAG 2.1 AA

### DEPENDENCIES
- Must complete after: WS-131 (Business Metrics) for tracking
- Must complete before: WS-143 (Marketing Automation)
- Shares code with: WS-142 (Customer Success), WS-134 (Marketing Automation)

### ESTIMATED EFFORT
- Team A Frontend: 32 hours (dashboard, invitation flow, tracking)
- Team B Backend: 40 hours (metrics calculation, funnel tracking, optimization)
- Team C Integration: 24 hours (multi-channel sending, A/B testing)
- Total: 96 hours