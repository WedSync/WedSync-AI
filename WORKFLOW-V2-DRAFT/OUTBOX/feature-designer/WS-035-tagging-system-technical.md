# TECHNICAL SPECIFICATION: WS-035 - Tagging System
## Generated by Feature Development Session - 2025-08-21

### USER STORY & BUSINESS CONTEXT (THINK HARD - BE FACTUAL)
**As a:** Wedding planner managing different types of clients (luxury, budget, destination, local)
**I want to:** Add custom tags to clients and filter by those tags
**So that:** I can quickly find all "luxury weddings over $50k" or "destination weddings needing travel coordination" without remembering individual details

**Real Wedding Scenario:**
A planner tags clients with: "luxury", "destination", "short-timeline", "high-maintenance", "referral-source-venue". When planning their week, they can instantly filter to see all "short-timeline" weddings that need extra attention, or all "luxury" clients for premium service coordination.

### SPECIFICATION SOURCE
- **Feature ID:** WS-035
- **Original Spec:** /CORE-SPECIFICATIONS/02-WEDSYNC-SUPPLIER-PLATFORM/03-Client-Management/07-tagging-system md.md
- **Current Implementation:** 0% complete
- **Files to Modify:**
  - `/src/components/clients/ClientListView.tsx` (add tag filtering)
  - `/src/components/clients/ClientProfile.tsx` (add tag management)
- **New Files to Create:**
  - `/src/components/tags/TagManager.tsx`
  - `/src/components/tags/TagInput.tsx`
  - `/src/components/tags/TagFilter.tsx`
  - `/src/lib/services/tagService.ts`

### TECHNICAL DESIGN

#### Database Schema Required
```sql
-- Tags table
CREATE TABLE IF NOT EXISTS tags (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id UUID REFERENCES suppliers(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  color TEXT DEFAULT '#3B82F6',
  description TEXT,
  usage_count INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(supplier_id, name)
);

-- Client-tag relationships
CREATE TABLE IF NOT EXISTS client_tags (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  client_id UUID REFERENCES clients(id) ON DELETE CASCADE,
  tag_id UUID REFERENCES tags(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(client_id, tag_id)
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_tags_supplier_id ON tags(supplier_id);
CREATE INDEX IF NOT EXISTS idx_client_tags_client_id ON client_tags(client_id);
CREATE INDEX IF NOT EXISTS idx_client_tags_tag_id ON client_tags(tag_id);
```

#### API Endpoints Required
```typescript
// GET /api/tags
interface GetTagsResponse {
  tags: Tag[];
}

// POST /api/tags
interface CreateTagRequest {
  name: string;
  color?: string;
  description?: string;
}

// PUT /api/clients/[id]/tags
interface UpdateClientTagsRequest {
  tag_ids: string[];
}

// GET /api/clients?tags=tag1,tag2
interface FilterByTagsRequest {
  tags: string[];
  operator: 'AND' | 'OR'; // AND = client must have ALL tags, OR = client must have ANY tag
}
```

#### Frontend Components Required
```typescript
// Component: TagManager
// Location: /src/components/tags/TagManager.tsx

interface TagManagerProps {
  clientId: string;
  currentTags: Tag[];
  onTagsChange: (tags: Tag[]) => void;
}

// Key functionality:
- Add/remove tags from client
- Create new tags inline
- Tag autocomplete with existing tags
- Color picker for new tags
- Tag usage statistics

// Component: TagInput
interface TagInputProps {
  value: Tag[];
  onChange: (tags: Tag[]) => void;
  placeholder?: string;
  suggestions: Tag[];
}

// Key functionality:
- Multi-select input with pills
- Keyboard navigation (Enter to add, Backspace to remove)
- Fuzzy search matching
- Tag creation on the fly

// Component: TagFilter
interface TagFilterProps {
  availableTags: Tag[];
  selectedTags: Tag[];
  onTagsChange: (tags: Tag[]) => void;
  operator: 'AND' | 'OR';
  onOperatorChange: (operator: 'AND' | 'OR') => void;
}

// Key functionality:
- Multi-select tag filtering
- AND/OR logic toggle
- Clear all filters option
- Visual count of matching clients
```

#### Integration Points
```typescript
// Service: TagService
// Dependencies: Supabase

class TagService {
  async getTagsForSupplier(): Promise<Tag[]> {
    const { data, error } = await supabase
      .from('tags')
      .select('*')
      .eq('supplier_id', getCurrentSupplierId())
      .order('usage_count', { ascending: false });
      
    if (error) throw error;
    return data;
  }
  
  async createTag(tagData: CreateTagRequest): Promise<Tag> {
    const { data, error } = await supabase
      .from('tags')
      .insert({
        ...tagData,
        supplier_id: getCurrentSupplierId()
      })
      .select()
      .single();
      
    if (error) throw error;
    return data;
  }
  
  async updateClientTags(clientId: string, tagIds: string[]): Promise<void> {
    // Remove existing tags
    await supabase
      .from('client_tags')
      .delete()
      .eq('client_id', clientId);
    
    // Add new tags
    if (tagIds.length > 0) {
      const insertData = tagIds.map(tagId => ({
        client_id: clientId,
        tag_id: tagId
      }));
      
      const { error } = await supabase
        .from('client_tags')
        .insert(insertData);
        
      if (error) throw error;
      
      // Update usage counts
      await this.updateTagUsageCounts(tagIds);
    }
  }
  
  async getClientsWithTags(tagIds: string[], operator: 'AND' | 'OR' = 'OR'): Promise<Client[]> {
    let query = supabase
      .from('clients')
      .select(`
        *,
        client_tags!inner(tag_id)
      `);
    
    if (operator === 'AND') {
      // Client must have ALL specified tags
      for (const tagId of tagIds) {
        query = query.eq('client_tags.tag_id', tagId);
      }
    } else {
      // Client must have ANY of the specified tags
      query = query.in('client_tags.tag_id', tagIds);
    }
    
    const { data, error } = await query;
    if (error) throw error;
    
    return data;
  }
  
  private async updateTagUsageCounts(tagIds: string[]): Promise<void> {
    for (const tagId of tagIds) {
      await supabase.rpc('increment_tag_usage', { tag_id: tagId });
    }
  }
}
```

### CODE EXAMPLES

#### Example 1: Tag Input Component
```typescript
// ACTUAL CODE PATTERN TO FOLLOW:
import { useState, useRef, useEffect } from 'react';
import { X } from 'lucide-react';

interface TagInputProps {
  value: Tag[];
  onChange: (tags: Tag[]) => void;
  suggestions: Tag[];
  placeholder?: string;
}

export function TagInput({ value, onChange, suggestions, placeholder }: TagInputProps) {
  const [inputValue, setInputValue] = useState('');
  const [isOpen, setIsOpen] = useState(false);
  const [focusedIndex, setFocusedIndex] = useState(-1);
  const inputRef = useRef<HTMLInputElement>(null);
  
  const filteredSuggestions = suggestions.filter(tag =>
    tag.name.toLowerCase().includes(inputValue.toLowerCase()) &&
    !value.find(selectedTag => selectedTag.id === tag.id)
  );
  
  const handleKeyDown = (e: React.KeyboardEvent) => {
    switch (e.key) {
      case 'Enter':
        e.preventDefault();
        if (focusedIndex >= 0 && filteredSuggestions[focusedIndex]) {
          addTag(filteredSuggestions[focusedIndex]);
        } else if (inputValue.trim()) {
          createAndAddTag(inputValue.trim());
        }
        break;
        
      case 'Backspace':
        if (!inputValue && value.length > 0) {
          removeTag(value[value.length - 1].id);
        }
        break;
        
      case 'ArrowDown':
        e.preventDefault();
        setFocusedIndex(prev => 
          prev < filteredSuggestions.length - 1 ? prev + 1 : prev
        );
        break;
        
      case 'ArrowUp':
        e.preventDefault();
        setFocusedIndex(prev => prev > 0 ? prev - 1 : -1);
        break;
        
      case 'Escape':
        setIsOpen(false);
        setFocusedIndex(-1);
        break;
    }
  };
  
  const addTag = (tag: Tag) => {
    onChange([...value, tag]);
    setInputValue('');
    setIsOpen(false);
    setFocusedIndex(-1);
  };
  
  const removeTag = (tagId: string) => {
    onChange(value.filter(tag => tag.id !== tagId));
  };
  
  const createAndAddTag = async (name: string) => {
    try {
      const newTag = await tagService.createTag({
        name,
        color: generateRandomColor()
      });
      addTag(newTag);
    } catch (error) {
      console.error('Failed to create tag:', error);
    }
  };
  
  return (
    <div className="relative">
      <div className="flex flex-wrap gap-1 p-2 border border-gray-300 rounded-md min-h-[40px] focus-within:border-blue-500">
        {value.map(tag => (
          <span
            key={tag.id}
            className="inline-flex items-center gap-1 px-2 py-1 text-sm rounded-full"
            style={{ backgroundColor: tag.color + '20', color: tag.color }}
          >
            {tag.name}
            <button
              type="button"
              onClick={() => removeTag(tag.id)}
              className="hover:bg-black hover:bg-opacity-20 rounded-full p-0.5"
            >
              <X size={12} />
            </button>
          </span>
        ))}
        
        <input
          ref={inputRef}
          type="text"
          value={inputValue}
          onChange={(e) => {
            setInputValue(e.target.value);
            setIsOpen(true);
            setFocusedIndex(-1);
          }}
          onKeyDown={handleKeyDown}
          onFocus={() => setIsOpen(true)}
          placeholder={value.length === 0 ? placeholder : ''}
          className="flex-1 outline-none bg-transparent min-w-[100px]"
        />
      </div>
      
      {isOpen && (inputValue || filteredSuggestions.length > 0) && (
        <div className="absolute z-10 w-full mt-1 bg-white border border-gray-300 rounded-md shadow-lg max-h-60 overflow-y-auto">
          {filteredSuggestions.map((tag, index) => (
            <button
              key={tag.id}
              type="button"
              onClick={() => addTag(tag)}
              className={`w-full px-3 py-2 text-left hover:bg-gray-100 flex items-center gap-2 ${
                index === focusedIndex ? 'bg-gray-100' : ''
              }`}
            >
              <span
                className="w-3 h-3 rounded-full"
                style={{ backgroundColor: tag.color }}
              />
              {tag.name}
              <span className="ml-auto text-sm text-gray-500">
                {tag.usage_count} clients
              </span>
            </button>
          ))}
          
          {inputValue && !filteredSuggestions.find(tag => 
            tag.name.toLowerCase() === inputValue.toLowerCase()
          ) && (
            <button
              type="button"
              onClick={() => createAndAddTag(inputValue)}
              className={`w-full px-3 py-2 text-left hover:bg-gray-100 border-t border-gray-200 ${
                focusedIndex === filteredSuggestions.length ? 'bg-gray-100' : ''
              }`}
            >
              Create "{inputValue}"
            </button>
          )}
        </div>
      )}
    </div>
  );
}
```

### MCP SERVER USAGE

#### Required MCP Servers
- [x] Context7: Load docs for React input components, color picker libraries
- [x] Playwright: Test tag input interactions, filtering workflows
- [x] Filesystem: Access existing input component patterns

#### Context7 Queries Needed
```typescript
await mcp__context7__get-library-docs("/react/react", "input handling patterns", 2000);
await mcp__context7__get-library-docs("/supabase/supabase", "many-to-many relationships", 2000);
```

### TEST REQUIREMENTS

#### Unit Tests Required
```typescript
describe('TagService', () => {
  it('should create new tags correctly', async () => {
    const tagData = { name: 'luxury', color: '#FF0000' };
    const tag = await tagService.createTag(tagData);
    expect(tag.name).toBe('luxury');
    expect(tag.color).toBe('#FF0000');
  });
  
  it('should filter clients by tags with AND operator', async () => {
    const clients = await tagService.getClientsWithTags(['tag1', 'tag2'], 'AND');
    // Should return clients that have BOTH tag1 AND tag2
  });
});
```

#### E2E Tests Required
```typescript
// Using Playwright MCP
test('Tag management workflow', async () => {
  await mcp__playwright__browser_navigate({url: '/clients'});
  
  // Test tag filtering
  await mcp__playwright__browser_click({
    element: 'Tag filter dropdown',
    ref: '[data-testid="tag-filter"]'
  });
  
  await mcp__playwright__browser_click({
    element: 'Luxury tag option',
    ref: '[data-testid="tag-luxury"]'
  });
  
  // Test adding tags to client
  await mcp__playwright__browser_click({
    element: 'First client row',
    ref: '[data-testid="client-row-1"]'
  });
  
  await mcp__playwright__browser_type({
    element: 'Tag input',
    ref: '[data-testid="tag-input"]',
    text: 'destination'
  });
  
  await mcp__playwright__browser_press_key({key: 'Enter'});
  
  await mcp__playwright__browser_snapshot();
});
```

### ACCEPTANCE CRITERIA
- [x] Can create, edit, and delete custom tags with colors
- [x] Tags auto-complete from existing options while typing
- [x] Filter clients by single or multiple tags with AND/OR logic
- [x] Tag usage counts display accurately
- [x] Performance: Tag filtering with 1000+ clients completes in <2 seconds
- [x] Security: Tags isolated by supplier via RLS
- [x] Accessibility: Keyboard navigation, screen reader support

### DEPENDENCIES
- Must complete after: WS-031 (Client List Views)
- Must complete before: None (enhances existing features)
- Shares code with: Client management components, filtering utilities

### ESTIMATED EFFORT
- Team A Frontend: 10 hours
- Team B Backend: 8 hours
- Team C Integration: 4 hours
- Total: 22 hours