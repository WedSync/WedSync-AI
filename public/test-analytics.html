<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Viral Analytics Test Page</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            padding: 20px; 
            max-width: 800px; 
            margin: 0 auto;
        }
        .test-section { 
            margin: 20px 0; 
            padding: 15px; 
            border: 1px solid #ddd; 
            border-radius: 8px;
        }
        .result { 
            margin: 10px 0; 
            padding: 10px; 
            background: #f5f5f5; 
            border-radius: 4px;
        }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        button { 
            padding: 10px 20px; 
            margin: 5px; 
            background: #007bff; 
            color: white; 
            border: none; 
            border-radius: 4px; 
            cursor: pointer;
        }
        button:hover { background: #0056b3; }
    </style>
</head>
<body>
    <h1>WS-170 Viral Analytics Validation Tests</h1>
    
    <div class="test-section">
        <h2>1. Viral Coefficient Calculation Test</h2>
        <button onclick="testViralCoefficient()">Run Viral Coefficient Test</button>
        <div id="viral-result" class="result"></div>
    </div>

    <div class="test-section">
        <h2>2. Attribution Modeling Test</h2>
        <button onclick="testAttributionModel()">Run Attribution Test</button>
        <div id="attribution-result" class="result"></div>
    </div>

    <div class="test-section">
        <h2>3. Growth Metrics Aggregation Test</h2>
        <button onclick="testGrowthMetrics()">Run Growth Metrics Test</button>
        <div id="growth-result" class="result"></div>
    </div>

    <div class="test-section">
        <h2>4. Data Privacy Validation Test</h2>
        <button onclick="testDataPrivacy()">Run Privacy Test</button>
        <div id="privacy-result" class="result"></div>
    </div>

    <script>
        // Global test functions for Playwright MCP to call
        window.calculateViralCoefficient = function(testData) {
            try {
                // Simulate viral coefficient calculation
                const conversionRate = testData.invitesSent > 0 ? testData.conversions / testData.invitesSent : 0;
                const invitesPerUser = testData.newUsers > 0 ? testData.invitesSent / testData.newUsers : 0;
                const viralCoefficient = invitesPerUser * conversionRate;

                return {
                    viralCoefficient: Math.round(viralCoefficient * 1000) / 1000,
                    conversionRate: Math.round(conversionRate * 1000) / 1000,
                    invitesPerUser: Math.round(invitesPerUser * 1000) / 1000,
                    totalUsers: testData.newUsers,
                    totalInvites: testData.invitesSent,
                    totalConversions: testData.conversions,
                    period: 'test',
                    timeframe: 'monthly',
                    aggregationDate: new Date().toISOString()
                };
            } catch (error) {
                throw new Error(`Viral coefficient calculation failed: ${error.message}`);
            }
        };

        window.calculateAttributionModel = function(testSources) {
            try {
                const totalConversions = testSources.reduce((sum, source) => sum + source.conversions, 0);
                
                return {
                    sources: testSources.map(source => ({
                        source: source.source,
                        conversions: source.conversions,
                        cost: source.cost,
                        attributionScore: totalConversions > 0 ? source.conversions / totalConversions : 0,
                        costPerAcquisition: source.conversions > 0 ? source.cost / source.conversions : 0
                    })),
                    totalConversions,
                    topPerformingSource: testSources.reduce((max, source) => 
                        source.conversions > max.conversions ? source : max, testSources[0]
                    )?.source
                };
            } catch (error) {
                throw new Error(`Attribution model calculation failed: ${error.message}`);
            }
        };

        window.aggregateGrowthMetrics = function(dateRange) {
            try {
                const startDate = new Date(dateRange.start);
                const endDate = new Date(dateRange.end);
                const daysDiff = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));
                
                // Generate mock daily data
                const daily = [];
                for (let i = 0; i < Math.min(daysDiff, 31); i++) {
                    const date = new Date(startDate);
                    date.setDate(date.getDate() + i);
                    daily.push({
                        date: date.toISOString().split('T')[0],
                        newUsers: Math.floor(Math.random() * 50) + 10,
                        viralCoefficient: Math.round((Math.random() * 0.5 + 0.3) * 1000) / 1000,
                        organicGrowth: Math.floor(Math.random() * 30) + 5,
                        paidGrowth: Math.floor(Math.random() * 15) + 2,
                        viralGrowth: Math.floor(Math.random() * 10) + 1
                    });
                }
                
                // Generate weekly aggregations
                const weekly = daily.reduce((weeks, day, index) => {
                    const weekIndex = Math.floor(index / 7);
                    if (!weeks[weekIndex]) {
                        weeks[weekIndex] = {
                            week: `2025-W${weekIndex + 1}`,
                            newUsers: 0,
                            viralCoefficient: 0,
                            growthRate: 0,
                            cumulativeUsers: 1000
                        };
                    }
                    weeks[weekIndex].newUsers += day.newUsers;
                    weeks[weekIndex].viralCoefficient += day.viralCoefficient;
                    return weeks;
                }, []).map(week => ({
                    ...week,
                    viralCoefficient: Math.round(week.viralCoefficient / 7 * 1000) / 1000,
                    cumulativeUsers: week.cumulativeUsers + week.newUsers
                }));
                
                // Generate monthly aggregation
                const monthly = [{
                    month: '2025-01',
                    newUsers: daily.reduce((sum, day) => sum + day.newUsers, 0),
                    viralCoefficient: Math.round(daily.reduce((sum, day) => sum + day.viralCoefficient, 0) / daily.length * 1000) / 1000,
                    monthOverMonthGrowth: 15.5,
                    retentionRate: 0.87
                }];
                
                return { daily, weekly, monthly };
            } catch (error) {
                throw new Error(`Growth metrics aggregation failed: ${error.message}`);
            }
        };

        // UI test functions
        async function testViralCoefficient() {
            const resultDiv = document.getElementById('viral-result');
            
            try {
                const testData = {
                    newUsers: 100,
                    invitesSent: 250,
                    conversions: 75
                };
                
                const result = window.calculateViralCoefficient(testData);
                const expectedCoefficient = (testData.invitesSent / testData.newUsers) * (testData.conversions / testData.invitesSent);
                const accurate = Math.abs(result.viralCoefficient - expectedCoefficient) < 0.001;
                
                resultDiv.className = `result ${accurate ? 'success' : 'error'}`;
                resultDiv.innerHTML = `
                    <strong>Viral Coefficient Test:</strong><br>
                    Calculated: ${result.viralCoefficient}<br>
                    Expected: ${expectedCoefficient.toFixed(3)}<br>
                    Accurate: ${accurate ? '✅ PASS' : '❌ FAIL'}<br>
                    Conversion Rate: ${result.conversionRate}<br>
                    Invites Per User: ${result.invitesPerUser}
                `;
            } catch (error) {
                resultDiv.className = 'result error';
                resultDiv.innerHTML = `<strong>Error:</strong> ${error.message}`;
            }
        }

        async function testAttributionModel() {
            const resultDiv = document.getElementById('attribution-result');
            
            try {
                const testSources = [
                    { source: 'email', conversions: 25, cost: 100 },
                    { source: 'social', conversions: 30, cost: 150 },
                    { source: 'referral', conversions: 20, cost: 0 }
                ];
                
                const result = window.calculateAttributionModel(testSources);
                
                resultDiv.className = 'result success';
                resultDiv.innerHTML = `
                    <strong>Attribution Model Test:</strong><br>
                    Total Conversions: ${result.totalConversions}<br>
                    Top Source: ${result.topPerformingSource}<br>
                    Sources: ${result.sources.length}<br>
                    Status: ✅ PASS
                `;
            } catch (error) {
                resultDiv.className = 'result error';
                resultDiv.innerHTML = `<strong>Error:</strong> ${error.message}`;
            }
        }

        async function testGrowthMetrics() {
            const resultDiv = document.getElementById('growth-result');
            
            try {
                const dateRange = {
                    start: new Date('2025-01-01'),
                    end: new Date('2025-01-31')
                };
                
                const result = window.aggregateGrowthMetrics(dateRange);
                const hasDaily = Array.isArray(result.daily) && result.daily.length > 0;
                const hasWeekly = Array.isArray(result.weekly) && result.weekly.length > 0;
                const hasMonthly = Array.isArray(result.monthly) && result.monthly.length > 0;
                
                resultDiv.className = 'result success';
                resultDiv.innerHTML = `
                    <strong>Growth Metrics Test:</strong><br>
                    Daily Data Points: ${result.daily.length}<br>
                    Weekly Data Points: ${result.weekly.length}<br>
                    Monthly Data Points: ${result.monthly.length}<br>
                    All Aggregations Present: ${hasDaily && hasWeekly && hasMonthly ? '✅ PASS' : '❌ FAIL'}
                `;
            } catch (error) {
                resultDiv.className = 'result error';
                resultDiv.innerHTML = `<strong>Error:</strong> ${error.message}`;
            }
        }

        async function testDataPrivacy() {
            const resultDiv = document.getElementById('privacy-result');
            
            try {
                const testData = {
                    newUsers: 100,
                    invitesSent: 250,
                    conversions: 75
                };
                
                const result = window.calculateViralCoefficient(testData);
                
                // Check that no individual data is exposed
                const privacyChecks = [
                    !result.hasOwnProperty('userIds'),
                    !result.hasOwnProperty('individualData'),
                    !result.hasOwnProperty('emails'),
                    !result.hasOwnProperty('phoneNumbers'),
                    !result.hasOwnProperty('personalInfo'),
                    typeof result.viralCoefficient === 'number',
                    typeof result.totalUsers === 'number',
                    typeof result.totalConversions === 'number'
                ];
                
                const allPrivacyChecksPassed = privacyChecks.every(check => check === true);
                
                resultDiv.className = `result ${allPrivacyChecksPassed ? 'success' : 'error'}`;
                resultDiv.innerHTML = `
                    <strong>Data Privacy Test:</strong><br>
                    No Individual Data Exposed: ${privacyChecks.slice(0, 5).every(c => c) ? '✅' : '❌'}<br>
                    Only Aggregated Metrics: ${privacyChecks.slice(5).every(c => c) ? '✅' : '❌'}<br>
                    Privacy Compliance: ${allPrivacyChecksPassed ? '✅ PASS' : '❌ FAIL'}
                `;
            } catch (error) {
                resultDiv.className = 'result error';
                resultDiv.innerHTML = `<strong>Error:</strong> ${error.message}`;
            }
        }
    </script>
</body>
</html>