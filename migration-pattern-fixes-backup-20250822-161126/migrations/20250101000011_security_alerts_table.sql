-- Security Alerts Management System
-- Storage and management for security alerts generated by monitoring system
-- ðŸš¨ SECURITY ALERTS & INCIDENT MANAGEMENT

-- =============================================
-- SECURITY ALERTS TABLE
-- =============================================

-- Create security alerts table
CREATE TABLE IF NOT EXISTS security_alerts (
  id VARCHAR(100) PRIMARY KEY,
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  alert_type VARCHAR(50) NOT NULL,
  severity VARCHAR(20) NOT NULL CHECK (severity IN ('LOW', 'MEDIUM', 'HIGH', 'CRITICAL')),
  title VARCHAR(255) NOT NULL,
  description TEXT,
  event_count INTEGER NOT NULL DEFAULT 0,
  first_seen TIMESTAMP WITH TIME ZONE NOT NULL,
  last_seen TIMESTAMP WITH TIME ZONE NOT NULL,
  affected_users UUID[] DEFAULT '{}',
  source_ips INET[] DEFAULT '{}',
  recommendations TEXT[] DEFAULT '{}',
  status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE' CHECK (status IN ('ACTIVE', 'INVESTIGATING', 'RESOLVED', 'FALSE_POSITIVE')),
  metadata JSONB DEFAULT '{}',
  assigned_to UUID, -- User ID of person investigating
  resolution_notes TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  resolved_at TIMESTAMP WITH TIME ZONE,
  
  -- Constraints
  CONSTRAINT chk_alert_type CHECK (alert_type IN (
    'BRUTE_FORCE_ATTACK', 'MULTIPLE_FAILED_LOGINS', 'PRIVILEGE_ESCALATION',
    'UNAUTHORIZED_DATA_ACCESS', 'SUSPICIOUS_IP_ACTIVITY', 'ACCOUNT_COMPROMISE',
    'DATA_EXFILTRATION', 'API_ABUSE', 'RATE_LIMIT_ABUSE', 'SECURITY_POLICY_VIOLATION',
    'ANOMALOUS_USER_BEHAVIOR', 'SYSTEM_INTRUSION_ATTEMPT'
  ))
);

-- Enable RLS
ALTER TABLE security_alerts ENABLE ROW LEVEL SECURITY;

-- RLS Policies for security alerts
CREATE POLICY "org_security_alerts_access" 
  ON security_alerts FOR ALL 
  USING (organization_id = (SELECT organization_id FROM user_profiles WHERE user_id = auth.uid() LIMIT 1));

-- Admins can see all alerts in their organization
CREATE POLICY "admin_security_alerts_manage" 
  ON security_alerts FOR ALL 
  USING (organization_id = (SELECT organization_id FROM user_profiles WHERE user_id = auth.uid() LIMIT 1) AND (SELECT role IN ('ADMIN', 'OWNER') FROM user_profiles WHERE user_id = auth.uid() LIMIT 1));

-- =============================================
-- ALERT RESPONSE ACTIONS TABLE
-- =============================================

-- Track actions taken in response to alerts
CREATE TABLE IF NOT EXISTS alert_response_actions (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  alert_id VARCHAR(100) NOT NULL REFERENCES security_alerts(id) ON DELETE CASCADE,
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  user_id UUID NOT NULL,
  action_type VARCHAR(50) NOT NULL,
  action_description TEXT NOT NULL,
  action_data JSONB DEFAULT '{}',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  CONSTRAINT chk_action_type CHECK (action_type IN (
    'STATUS_CHANGE', 'ASSIGNMENT', 'INVESTIGATION_NOTE', 'ESCALATION',
    'BLOCK_IP', 'SUSPEND_USER', 'FORCE_PASSWORD_RESET', 'ENABLE_MFA',
    'CUSTOM_ACTION', 'RESOLVED', 'FALSE_POSITIVE'
  ))
);

-- Enable RLS for response actions
ALTER TABLE alert_response_actions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "org_alert_actions_access" 
  ON alert_response_actions FOR ALL 
  USING (organization_id = (SELECT organization_id FROM user_profiles WHERE user_id = auth.uid() LIMIT 1));

-- =============================================
-- SECURITY INCIDENT ESCALATION
-- =============================================

-- Track incident escalations
CREATE TABLE IF NOT EXISTS security_incidents (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  incident_number VARCHAR(50) UNIQUE NOT NULL,
  title VARCHAR(255) NOT NULL,
  description TEXT,
  severity VARCHAR(20) NOT NULL CHECK (severity IN ('LOW', 'MEDIUM', 'HIGH', 'CRITICAL')),
  status VARCHAR(30) NOT NULL DEFAULT 'OPEN' CHECK (status IN ('OPEN', 'INVESTIGATING', 'CONTAINED', 'RESOLVED', 'CLOSED')),
  
  -- Related alerts
  related_alerts VARCHAR(100)[] DEFAULT '{}',
  
  -- Incident details
  incident_type VARCHAR(50),
  impact_assessment TEXT,
  
  -- Assignment and timeline
  assigned_to UUID,
  created_by UUID NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  resolved_at TIMESTAMP WITH TIME ZONE,
  
  -- Escalation
  escalated BOOLEAN DEFAULT FALSE,
  escalated_to UUID,
  escalated_at TIMESTAMP WITH TIME ZONE,
  
  -- Resolution
  resolution_summary TEXT,
  lessons_learned TEXT,
  
  metadata JSONB DEFAULT '{}'
);

-- Generate unique incident numbers
CREATE SEQUENCE IF NOT EXISTS incident_number_seq START 1000;

CREATE OR REPLACE FUNCTION generate_incident_number()
RETURNS TEXT AS $$
BEGIN
  RETURN 'INC-' || TO_CHAR(NOW(), 'YYYY') || '-' || LPAD(nextval('incident_number_seq')::TEXT, 4, '0');
END;
$$ LANGUAGE plpgsql;

-- Trigger to auto-generate incident numbers
CREATE OR REPLACE FUNCTION set_incident_number()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.incident_number IS NULL THEN
    NEW.incident_number := generate_incident_number();
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER incident_number_trigger
  BEFORE INSERT ON security_incidents
  FOR EACH ROW EXECUTE FUNCTION set_incident_number();

-- Enable RLS for incidents
ALTER TABLE security_incidents ENABLE ROW LEVEL SECURITY;

CREATE POLICY "org_security_incidents_access" 
  ON security_incidents FOR ALL 
  USING (organization_id = (SELECT organization_id FROM user_profiles WHERE user_id = auth.uid() LIMIT 1) AND (SELECT role IN ('ADMIN', 'OWNER') FROM user_profiles WHERE user_id = auth.uid() LIMIT 1));

-- =============================================
-- ALERT NOTIFICATION PREFERENCES
-- =============================================

-- Store notification preferences for security alerts
CREATE TABLE IF NOT EXISTS alert_notification_preferences (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  user_id UUID NOT NULL,
  
  -- Alert type preferences
  alert_types VARCHAR(50)[] DEFAULT '{}', -- Empty means all types
  minimum_severity VARCHAR(20) NOT NULL DEFAULT 'MEDIUM',
  
  -- Notification channels
  email_enabled BOOLEAN DEFAULT TRUE,
  slack_enabled BOOLEAN DEFAULT FALSE,
  sms_enabled BOOLEAN DEFAULT FALSE,
  push_enabled BOOLEAN DEFAULT TRUE,
  
  -- Timing preferences
  immediate_notification BOOLEAN DEFAULT TRUE,
  digest_frequency VARCHAR(20) DEFAULT 'DAILY' CHECK (digest_frequency IN ('NONE', 'HOURLY', 'DAILY', 'WEEKLY')),
  quiet_hours_start TIME,
  quiet_hours_end TIME,
  
  -- Contact information
  email_address VARCHAR(255),
  slack_user_id VARCHAR(100),
  phone_number VARCHAR(20),
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  UNIQUE(organization_id, user_id)
);

-- Enable RLS
ALTER TABLE alert_notification_preferences ENABLE ROW LEVEL SECURITY;

CREATE POLICY "user_notification_preferences" 
  ON alert_notification_preferences FOR ALL 
  USING (user_id = auth.uid());

-- =============================================
-- SECURITY METRICS TRACKING
-- =============================================

-- Store historical security metrics for trending
CREATE TABLE IF NOT EXISTS security_metrics_history (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  metric_date DATE NOT NULL,
  metric_hour INTEGER, -- 0-23 for hourly metrics, NULL for daily
  
  -- Event counts
  total_events INTEGER DEFAULT 0,
  critical_events INTEGER DEFAULT 0,
  high_events INTEGER DEFAULT 0,
  medium_events INTEGER DEFAULT 0,
  low_events INTEGER DEFAULT 0,
  
  -- Alert counts
  total_alerts INTEGER DEFAULT 0,
  active_alerts INTEGER DEFAULT 0,
  resolved_alerts INTEGER DEFAULT 0,
  
  -- Security score (0-100)
  security_score INTEGER,
  
  -- Top event types and IPs (stored as JSONB)
  top_event_types JSONB DEFAULT '[]',
  top_source_ips JSONB DEFAULT '[]',
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  UNIQUE(organization_id, metric_date, metric_hour)
);

-- Enable RLS
ALTER TABLE security_metrics_history ENABLE ROW LEVEL SECURITY;

CREATE POLICY "org_metrics_history_access" 
  ON security_metrics_history FOR ALL 
  USING (organization_id = (SELECT organization_id FROM user_profiles WHERE user_id = auth.uid() LIMIT 1));

-- =============================================
-- PERFORMANCE INDEXES
-- =============================================

-- Security alerts indexes
CREATE INDEX IF NOT EXISTS idx_security_alerts_org_status ON security_alerts(organization_id, status, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_security_alerts_severity ON security_alerts(severity, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_security_alerts_type ON security_alerts(alert_type, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_security_alerts_assigned ON security_alerts(assigned_to) WHERE assigned_to IS NOT NULL;

-- Alert response actions indexes
CREATE INDEX IF NOT EXISTS idx_alert_actions_alert_id ON alert_response_actions(alert_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_alert_actions_user ON alert_response_actions(user_id, created_at DESC);

-- Security incidents indexes
CREATE INDEX IF NOT EXISTS idx_security_incidents_org_status ON security_incidents(organization_id, status, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_security_incidents_assigned ON security_incidents(assigned_to) WHERE assigned_to IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_security_incidents_escalated ON security_incidents(escalated, escalated_at) WHERE escalated = TRUE;

-- Metrics history indexes
CREATE INDEX IF NOT EXISTS idx_metrics_history_org_date ON security_metrics_history(organization_id, metric_date DESC, metric_hour DESC);

-- GIN indexes for array and JSONB columns
CREATE INDEX IF NOT EXISTS idx_security_alerts_affected_users_gin ON security_alerts USING GIN(affected_users);
CREATE INDEX IF NOT EXISTS idx_security_alerts_source_ips_gin ON security_alerts USING GIN(source_ips);
CREATE INDEX IF NOT EXISTS idx_security_alerts_metadata_gin ON security_alerts USING GIN(metadata);

-- =============================================
-- ALERT AUTOMATION FUNCTIONS
-- =============================================

-- Function to auto-escalate high-severity alerts
CREATE OR REPLACE FUNCTION auto_escalate_critical_alerts()
RETURNS TRIGGER AS $$
BEGIN
  -- Auto-escalate CRITICAL alerts that are older than 30 minutes and still ACTIVE
  IF NEW.severity = 'CRITICAL' AND NEW.status = 'ACTIVE' THEN
    -- Create incident if alert is critical and unattended
    INSERT INTO security_incidents (
      organization_id,
      title,
      description,
      severity,
      incident_type,
      related_alerts,
      created_by,
      impact_assessment
    ) VALUES (
      NEW.organization_id,
      'Critical Security Alert: ' || NEW.title,
      NEW.description,
      'CRITICAL',
      NEW.alert_type,
      ARRAY[NEW.id],
      NEW.organization_id, -- System generated
      'Auto-escalated critical security alert requiring immediate attention'
    );
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Apply escalation trigger (only for inserts of critical alerts)
CREATE TRIGGER auto_escalate_trigger
  AFTER INSERT ON security_alerts
  FOR EACH ROW
  WHEN (NEW.severity = 'CRITICAL')
  EXECUTE FUNCTION auto_escalate_critical_alerts();

-- Function to update alert status when incident is resolved
CREATE OR REPLACE FUNCTION update_alerts_on_incident_resolution()
RETURNS TRIGGER AS $$
BEGIN
  -- When incident is resolved, mark related alerts as resolved
  IF OLD.status != 'RESOLVED' AND NEW.status = 'RESOLVED' THEN
    UPDATE security_alerts
    SET 
      status = 'RESOLVED',
      resolved_at = NOW(),
      resolution_notes = 'Resolved via incident ' || NEW.incident_number,
      updated_at = NOW()
    WHERE id = ANY(NEW.related_alerts)
      AND status IN ('ACTIVE', 'INVESTIGATING');
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER incident_resolution_trigger
  AFTER UPDATE ON security_incidents
  FOR EACH ROW EXECUTE FUNCTION update_alerts_on_incident_resolution();

-- =============================================
-- SECURITY DASHBOARD FUNCTIONS
-- =============================================

-- Function to get security dashboard data
CREATE OR REPLACE FUNCTION get_security_dashboard(
  org_id UUID,
  time_range_hours INTEGER DEFAULT 24
)
RETURNS TABLE(
  total_alerts BIGINT,
  active_alerts BIGINT,
  critical_alerts BIGINT,
  high_alerts BIGINT,
  recent_incidents BIGINT,
  security_score INTEGER,
  top_alert_types JSONB,
  alert_trend JSONB
) AS $$
DECLARE
  start_time TIMESTAMP WITH TIME ZONE;
BEGIN
  start_time := NOW() - (time_range_hours || ' hours')::INTERVAL;
  
  RETURN QUERY
  SELECT 
    -- Alert counts
    COUNT(*) as total_alerts,
    COUNT(*) FILTER (WHERE sa.status = 'ACTIVE') as active_alerts,
    COUNT(*) FILTER (WHERE sa.severity = 'CRITICAL') as critical_alerts,
    COUNT(*) FILTER (WHERE sa.severity = 'HIGH') as high_alerts,
    
    -- Recent incidents
    (SELECT COUNT(*) FROM security_incidents si 
     WHERE si.organization_id = org_id 
     AND si.created_at >= start_time) as recent_incidents,
    
    -- Security score (calculated based on alert severity and count)
    GREATEST(0, 100 - 
      (COUNT(*) FILTER (WHERE sa.severity = 'CRITICAL') * 15) -
      (COUNT(*) FILTER (WHERE sa.severity = 'HIGH') * 10) -
      (COUNT(*) FILTER (WHERE sa.severity = 'MEDIUM') * 5)
    )::INTEGER as security_score,
    
    -- Top alert types
    (SELECT jsonb_agg(
      jsonb_build_object(
        'alert_type', alert_type,
        'count', count
      ) ORDER BY count DESC
    ) FROM (
      SELECT alert_type, COUNT(*) as count
      FROM security_alerts
      WHERE organization_id = org_id AND created_at >= start_time
      GROUP BY alert_type
      ORDER BY count DESC
      LIMIT 5
    ) top_types) as top_alert_types,
    
    -- Alert trend (hourly counts for the last 24 hours)
    (SELECT jsonb_agg(
      jsonb_build_object(
        'hour', hour,
        'count', COALESCE(count, 0)
      ) ORDER BY hour
    ) FROM (
      SELECT 
        generate_series(
          date_trunc('hour', start_time),
          date_trunc('hour', NOW()),
          '1 hour'::interval
        ) as hour
    ) hours
    LEFT JOIN (
      SELECT 
        date_trunc('hour', created_at) as hour,
        COUNT(*) as count
      FROM security_alerts
      WHERE organization_id = org_id 
        AND created_at >= start_time
      GROUP BY date_trunc('hour', created_at)
    ) alert_counts USING (hour)) as alert_trend
    
  FROM security_alerts sa
  WHERE sa.organization_id = org_id
    AND sa.created_at >= start_time;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================
-- DATA RETENTION AND CLEANUP
-- =============================================

-- Function to cleanup old resolved alerts and incidents
CREATE OR REPLACE FUNCTION cleanup_old_security_data(retention_days INTEGER DEFAULT 90)
RETURNS INTEGER AS $$
DECLARE
  deleted_alerts INTEGER;
  deleted_actions INTEGER;
  deleted_incidents INTEGER;
BEGIN
  -- Delete old resolved alerts
  DELETE FROM security_alerts
  WHERE status IN ('RESOLVED', 'FALSE_POSITIVE')
    AND resolved_at < NOW() - (retention_days || ' days')::INTERVAL;
  GET DIAGNOSTICS deleted_alerts = ROW_COUNT;
  
  -- Delete old response actions (cascade will handle this, but explicit is better)
  DELETE FROM alert_response_actions
  WHERE created_at < NOW() - (retention_days || ' days')::INTERVAL;
  GET DIAGNOSTICS deleted_actions = ROW_COUNT;
  
  -- Delete old closed incidents
  DELETE FROM security_incidents
  WHERE status = 'CLOSED'
    AND resolved_at < NOW() - (retention_days || ' days')::INTERVAL;
  GET DIAGNOSTICS deleted_incidents = ROW_COUNT;
  
  -- Log cleanup activity
  INSERT INTO enhanced_security_audit_logs (
    event_type,
    event_category,
    severity,
    event_data
  ) VALUES (
    'SYSTEM_MAINTENANCE',
    'INFRASTRUCTURE',
    'LOW',
    jsonb_build_object(
      'operation', 'security_data_cleanup',
      'deleted_alerts', deleted_alerts,
      'deleted_actions', deleted_actions,
      'deleted_incidents', deleted_incidents,
      'retention_days', retention_days
    )
  );
  
  RETURN deleted_alerts + deleted_actions + deleted_incidents;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================
-- INITIALIZATION AND VALIDATION
-- =============================================

-- Test the alert system
DO $$
BEGIN
  RAISE NOTICE 'Security alerts and incident management system initialized';
  RAISE NOTICE 'Created security_alerts table with RLS policies';
  RAISE NOTICE 'Created alert_response_actions tracking';
  RAISE NOTICE 'Created security_incidents escalation system';
  RAISE NOTICE 'Created notification preferences management';
  RAISE NOTICE 'Created security metrics history tracking';
  RAISE NOTICE 'Created automated escalation and cleanup functions';
  RAISE NOTICE 'Security monitoring and alerting system ready';
END $$;