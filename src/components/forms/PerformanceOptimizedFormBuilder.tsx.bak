'use client';

import React, { useState, useCallback, useMemo, useEffect, memo } from 'react';
import { FormField, FormSection, FormBuilderState } from '@/types/forms';
import { VirtualizedFormCanvas } from './VirtualizedFormCanvas';
import { ProgressiveSavingProvider, useFormProgressiveSaving } from './ProgressiveSavingProvider';
import { OptimisticUpdateProvider } from '../performance/OptimisticUpdateProvider';
import { IntelligentCacheProvider } from '../performance/IntelligentCacheProvider';
import { usePerformanceMonitor, useMemoryOptimization } from '@/hooks/usePerformanceOptimization';
import { FieldPalette } from './FieldPalette';
import { FieldEditor } from './FieldEditor';
import { FormPreview } from './FormPreview';
import { 
  CloudArrowUpIcon,
  DocumentArrowDownIcon,
  ClockIcon,
  CheckCircleIcon,
  ExclamationCircleIcon,
  EyeIcon,
  Cog6ToothIcon,
  ChartBarIcon
} from '@heroicons/react/24/outline';
import { nanoid } from 'nanoid';

interface PerformanceOptimizedFormBuilderProps {
  formId?: string;
  initialSections?: FormSection[];
  onSave?: (formData: any) => Promise<void>;
  className?: string;
}

// Save status indicator component
const SaveStatusIndicator = memo(function SaveStatusIndicator() {
  const { getFormSaveStatus } = useFormProgressiveSaving();
  const status = getFormSaveStatus();
  const { logMetric } = usePerformanceMonitor('SaveStatusIndicator');

  const getStatusInfo = () => {
    switch (status.status) {
      case 'saving':
        return {
          icon: ClockIcon,
          text: `Saving... ${Math.round(status.percentage)}%`,
          className: 'text-blue-600 bg-blue-50'
        };
      case 'completed':
        return {
          icon: CheckCircleIcon,
          text: 'Saved',
          className: 'text-green-600 bg-green-50'
        };
      case 'offline':
        return {
          icon: ExclamationCircleIcon,
          text: 'Offline - will save when reconnected',
          className: 'text-yellow-600 bg-yellow-50'
        };
      case 'pending':
        return {
          icon: ClockIcon,
          text: `${status.pendingChunks} items to save`,
          className: 'text-orange-600 bg-orange-50'
        };
      default:
        return {
          icon: CheckCircleIcon,
          text: 'Ready',
          className: 'text-gray-600 bg-gray-50'
        };
    }
  };

  const info = getStatusInfo();
  const Icon = info.icon;

  useEffect(() => {
    logMetric('saveStatusCheck', performance.now());
  }, [status, logMetric]);

  return (
    <div className={`inline-flex items-center gap-2 px-3 py-1.5 rounded-full text-sm font-medium ${info.className}`}>
      <Icon className="w-4 h-4" />
      <span>{info.text}</span>
      {status.lastSaveTime && (
        <span className="text-xs opacity-75">
          • {new Date(status.lastSaveTime).toLocaleTimeString()}
        </span>
      )}
    </div>
  );
});

// Performance metrics display (development only)
const PerformanceMetrics = memo(function PerformanceMetrics({ 
  sections 
}: { 
  sections: FormSection[] 
}) {
  const { logMetric } = usePerformanceMonitor('PerformanceMetrics');
  const [renderTime, setRenderTime] = useState<number>(0);
  
  const totalFields = useMemo(() => 
    sections.reduce((total, section) => total + section.fields.length, 0)
  , [sections]);

  const memoryUsage = useMemo(() => {
    if (typeof window !== 'undefined' && 'memory' in performance) {
      const memory = (performance as any).memory;
      return {
        used: Math.round(memory.usedJSHeapSize / 1024 / 1024),
        total: Math.round(memory.totalJSHeapSize / 1024 / 1024)
      };
    }
    return null;
  }, []);

  useEffect(() => {
    const startTime = performance.now();
    setRenderTime(0);
    
    const timer = setTimeout(() => {
      const endTime = performance.now();
      setRenderTime(endTime - startTime);
      logMetric('formBuilderRenderTime', endTime - startTime);
    }, 0);
    
    return () => clearTimeout(timer);
  }, [sections, logMetric]);

  if (process.env.NODE_ENV !== 'development') {
    return null;
  }

  return (
    <div className="fixed bottom-4 right-4 bg-black/90 text-white p-3 rounded-lg text-xs font-mono z-50">
      <div className="flex items-center gap-2 mb-2">
        <ChartBarIcon className="w-4 h-4" />
        <span>Performance Metrics</span>
      </div>
      <div className="space-y-1">
        <div>Fields: {totalFields}</div>
        <div>Sections: {sections.length}</div>
        <div>Render: {renderTime.toFixed(1)}ms</div>
        {memoryUsage && (
          <div>Memory: {memoryUsage.used}/{memoryUsage.total}MB</div>
        )}
      </div>
    </div>
  );
});

// Main form builder component
const FormBuilderCore = memo(function FormBuilderCore({
  formId,
  initialSections = [],
  onSave,
  className = ''
}: PerformanceOptimizedFormBuilderProps) {
  // Form state with optimized structure
  const [state, setState] = useState<{
    sections: FormSection[];
    selectedField: FormField | null;
    activeTab: 'build' | 'preview' | 'settings' | 'analytics';
    formSettings: {
      name: string;
      description: string;
      submitButtonText: string;
      successMessage: string;
      autoSave: boolean;
    };
  }>({
    sections: initialSections.length > 0 ? initialSections : [{
      id: nanoid(),
      title: 'Section 1',
      description: '',
      fields: [],
      order: 0
    }],
    selectedField: null,
    activeTab: 'build',
    formSettings: {
      name: 'Untitled Form',
      description: '',
      submitButtonText: 'Submit',
      successMessage: 'Thank you for your submission!',
      autoSave: true
    }
  });

  const { saveFormData, saveNow, getFormSaveStatus } = useFormProgressiveSaving();
  const { addObserver } = useMemoryOptimization();
  const { logMetric } = usePerformanceMonitor('FormBuilderCore');

  // Performance optimization - debounced save
  const debouncedSave = useCallback(
    (() => {
      let timeoutId: NodeJS.Timeout;
      return (immediate = false) => {
        clearTimeout(timeoutId);
        
        const doSave = () => {
          saveFormData({
            metadata: state.formSettings,
            sections: state.sections,
            fields: state.sections.flatMap(s => s.fields)
          });
          logMetric('formDataSaved', performance.now());
        };

        if (immediate) {
          doSave();
        } else {
          timeoutId = setTimeout(doSave, 2000); // 2 second debounce
        }
      };
    })(),
    [saveFormData, state, logMetric]
  );

  // Auto-save effect
  useEffect(() => {
    if (state.formSettings.autoSave) {
      debouncedSave();
    }
  }, [state.sections, state.formSettings, debouncedSave]);

  // Memory optimization
  useEffect(() => {
    const totalFields = state.sections.reduce((sum, section) => sum + section.fields.length, 0);
    const observer = addObserver('FormBuilder', totalFields);
    return () => observer?.disconnect();
  }, [addObserver, state.sections]);

  // Optimized field handlers
  const handleFieldSelect = useCallback((field: FormField | null) => {
    setState(prev => ({ ...prev, selectedField: field }));
    logMetric('fieldSelected', performance.now());
  }, [logMetric]);

  const handleFieldUpdate = useCallback((fieldId: string, updates: Partial<FormField>) => {
    const startTime = performance.now();
    
    setState(prev => ({
      ...prev,
      sections: prev.sections.map(section => ({
        ...section,
        fields: section.fields.map(field =>
          field.id === fieldId ? { ...field, ...updates } : field
        )
      })),
      selectedField: prev.selectedField?.id === fieldId 
        ? { ...prev.selectedField, ...updates }
        : prev.selectedField
    }));
    
    const updateTime = performance.now() - startTime;
    logMetric('fieldUpdateTime', updateTime);
    debouncedSave();
  }, [logMetric, debouncedSave]);

  const handleFieldDelete = useCallback((fieldId: string) => {
    setState(prev => ({
      ...prev,
      sections: prev.sections.map(section => ({
        ...section,
        fields: section.fields.filter(field => field.id !== fieldId)
      })),
      selectedField: prev.selectedField?.id === fieldId ? null : prev.selectedField
    }));
    
    logMetric('fieldDeleted', 1);
    debouncedSave();
  }, [logMetric, debouncedSave]);

  const handleFieldDuplicate = useCallback((field: FormField) => {
    const newField: FormField = {
      ...field,
      id: nanoid(),
      label: `${field.label} (Copy)`
    };

    setState(prev => ({
      ...prev,
      sections: prev.sections.map(section => {
        const fieldIndex = section.fields.findIndex(f => f.id === field.id);
        if (fieldIndex !== -1) {
          const newFields = [...section.fields];
          newFields.splice(fieldIndex + 1, 0, newField);
          return { ...section, fields: newFields };
        }
        return section;
      }),
      selectedField: newField
    }));
    
    logMetric('fieldDuplicated', 1);
    debouncedSave();
  }, [logMetric, debouncedSave]);

  const handleSave = useCallback(async () => {
    const startTime = performance.now();
    
    try {
      debouncedSave(true); // Immediate save
      await saveNow();
      
      if (onSave) {
        await onSave({
          id: formId,
          ...state.formSettings,
          sections: state.sections,
          updatedAt: new Date().toISOString()
        });
      }
      
      const saveTime = performance.now() - startTime;
      logMetric('fullSaveTime', saveTime);
      logMetric('saveSuccess', 1);
      
    } catch (error) {
      const saveTime = performance.now() - startTime;
      logMetric('fullSaveTime', saveTime);
      logMetric('saveError', 1);
      console.error('Save failed:', error);
    }
  }, [debouncedSave, saveNow, onSave, formId, state, logMetric]);

  // Memoized computed values
  const totalFields = useMemo(() => 
    state.sections.reduce((total, section) => total + section.fields.length, 0)
  , [state.sections]);

  const allFields = useMemo(() => 
    state.sections.flatMap(section => section.fields)
  , [state.sections]);

  return (
    <div className={`h-screen flex flex-col bg-gray-50 ${className}`}>
      {/* Header */}
      <div className="bg-white border-b px-6 py-4 flex-shrink-0">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-4">
            <div>
              <input
                type="text"
                value={state.formSettings.name}
                onChange={(e) => setState(prev => ({ 
                  ...prev, 
                  formSettings: { ...prev.formSettings, name: e.target.value } 
                }))}
                className="text-2xl font-semibold bg-transparent border-none focus:outline-none focus:ring-2 focus:ring-blue-500 rounded px-2 -ml-2"
              />
              <p className="text-sm text-gray-500 mt-1 ml-2">
                {totalFields} fields • {state.sections.length} sections
              </p>
            </div>
            <SaveStatusIndicator />
          </div>
          
          <div className="flex items-center gap-3">
            {/* Tab Switcher */}
            <div className="flex bg-gray-100 rounded-lg p-1">
              {[
                { key: 'build', icon: null, label: 'Build' },
                { key: 'preview' as const, icon: EyeIcon, label: 'Preview' },
                { key: 'settings' as const, icon: Cog6ToothIcon, label: 'Settings' },
                { key: 'analytics' as const, icon: ChartBarIcon, label: 'Analytics' }
              ].map(tab => (
                <button
                  key={tab.key}
                  onClick={() => setState(prev => ({ ...prev, activeTab: tab.key }))}
                  className={`px-4 py-2 rounded-md text-sm font-medium transition-colors flex items-center gap-2 ${
                    state.activeTab === tab.key
                      ? 'bg-white text-blue-600 shadow-sm'
                      : 'text-gray-600 hover:text-gray-900'
                  }`}
                >
                  {tab.icon && <tab.icon className="w-4 h-4" />}
                  {tab.label}
                </button>
              ))}
            </div>

            {/* Action Buttons */}
            <button
              onClick={handleSave}
              className="inline-flex items-center px-4 py-2 bg-blue-600 text-white text-sm font-medium rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors"
            >
              <CloudArrowUpIcon className="w-4 h-4 mr-2" />
              Save & Publish
            </button>
          </div>
        </div>
      </div>

      {/* Main Content */}
      <div className="flex-1 flex min-h-0">
        {state.activeTab === 'build' && (
          <>
            {/* Left Sidebar - Field Palette */}
            <div className="w-80 bg-white border-r flex-shrink-0 overflow-y-auto">
              <FieldPalette />
            </div>

            {/* Center - Virtualized Form Canvas */}
            <div className="flex-1 flex flex-col min-w-0">
              <VirtualizedFormCanvas
                sections={state.sections}
                onFieldSelect={handleFieldSelect}
                onFieldUpdate={handleFieldUpdate}
                onFieldDelete={handleFieldDelete}
                onFieldDuplicate={handleFieldDuplicate}
                selectedFieldId={state.selectedField?.id}
                className="flex-1"
                data-testid="performance-optimized-form-canvas"
              />
            </div>

            {/* Right Sidebar - Field Editor */}
            <div className="w-80 bg-white border-l flex-shrink-0 overflow-y-auto">
              {state.selectedField ? (
                <FieldEditor
                  field={state.selectedField}
                  onUpdate={(updates) => handleFieldUpdate(state.selectedField!.id, updates)}
                  onDelete={() => handleFieldDelete(state.selectedField!.id)}
                />
              ) : (
                <div className="p-6 text-center text-gray-500">
                  <div className="mb-4">
                    <svg className="w-12 h-12 mx-auto text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" />
                    </svg>
                  </div>
                  <h3 className="text-lg font-medium text-gray-900 mb-2">No Field Selected</h3>
                  <p className="text-sm text-gray-500">
                    Select a field from the form canvas to edit its properties, validation rules, and styling options.
                  </p>
                </div>
              )}
            </div>
          </>
        )}

        {state.activeTab === 'preview' && (
          <div className="flex-1 overflow-y-auto p-6">
            <div className="max-w-2xl mx-auto">
              <FormPreview 
                sections={state.sections} 
                settings={state.formSettings}
              />
            </div>
          </div>
        )}

        {state.activeTab === 'settings' && (
          <div className="flex-1 overflow-y-auto p-6">
            <div className="max-w-2xl mx-auto">
              <h2 className="text-xl font-semibold mb-6">Form Settings</h2>
              
              <div className="bg-white rounded-lg p-6 space-y-6">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Form Description
                  </label>
                  <textarea
                    value={state.formSettings.description}
                    onChange={(e) => setState(prev => ({
                      ...prev,
                      formSettings: { ...prev.formSettings, description: e.target.value }
                    }))}
                    className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                    rows={3}
                  />
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Submit Button Text
                  </label>
                  <input
                    type="text"
                    value={state.formSettings.submitButtonText}
                    onChange={(e) => setState(prev => ({
                      ...prev,
                      formSettings: { ...prev.formSettings, submitButtonText: e.target.value }
                    }))}
                    className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                  />
                </div>

                <div>
                  <label className="flex items-center">
                    <input
                      type="checkbox"
                      checked={state.formSettings.autoSave}
                      onChange={(e) => setState(prev => ({
                        ...prev,
                        formSettings: { ...prev.formSettings, autoSave: e.target.checked }
                      }))}
                      className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                    />
                    <span className="ml-2 text-sm text-gray-700">Enable auto-save</span>
                  </label>
                </div>
              </div>
            </div>
          </div>
        )}

        {state.activeTab === 'analytics' && (
          <div className="flex-1 overflow-y-auto p-6">
            <div className="max-w-4xl mx-auto">
              <h2 className="text-xl font-semibold mb-6">Form Analytics</h2>
              
              <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
                <div className="bg-white rounded-lg p-6 border">
                  <h3 className="text-sm font-medium text-gray-500">Total Fields</h3>
                  <p className="text-3xl font-semibold text-gray-900 mt-2">{totalFields}</p>
                </div>
                
                <div className="bg-white rounded-lg p-6 border">
                  <h3 className="text-sm font-medium text-gray-500">Sections</h3>
                  <p className="text-3xl font-semibold text-gray-900 mt-2">{state.sections.length}</p>
                </div>
                
                <div className="bg-white rounded-lg p-6 border">
                  <h3 className="text-sm font-medium text-gray-500">Auto-Save Status</h3>
                  <p className="text-3xl font-semibold text-gray-900 mt-2">
                    {state.formSettings.autoSave ? '✓' : '✗'}
                  </p>
                </div>
              </div>

              <div className="bg-white rounded-lg p-6 border">
                <h3 className="text-lg font-medium text-gray-900 mb-4">Field Types Distribution</h3>
                <div className="space-y-2">
                  {Object.entries(
                    allFields.reduce((acc, field) => {
                      acc[field.type] = (acc[field.type] || 0) + 1;
                      return acc;
                    }, {} as Record<string, number>)
                  ).map(([type, count]) => (
                    <div key={type} className="flex justify-between">
                      <span className="capitalize">{type}</span>
                      <span className="font-medium">{count}</span>
                    </div>
                  ))}
                </div>
              </div>
            </div>
          </div>
        )}
      </div>

      {/* Performance Metrics (dev only) */}
      <PerformanceMetrics sections={state.sections} />
    </div>
  );
});

// Main exported component with providers
export const PerformanceOptimizedFormBuilder: React.FC<PerformanceOptimizedFormBuilderProps> = (props) => {
  const progressiveSavingConfig = {
    maxChunkSize: 64 * 1024, // 64KB chunks for form data
    maxConcurrentSaves: 2,
    autoSaveInterval: 5000, // Auto-save every 5 seconds
    retryAttempts: 3,
    onSaveChunk: async (chunk: any) => {
      // Replace with actual API call
      console.log('Saving chunk:', chunk.type, chunk.size, 'bytes');
      
      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 500));
    },
    onSaveComplete: (success: boolean, totalTime: number) => {
      console.log(`Save ${success ? 'completed' : 'failed'} in ${totalTime}ms`);
    },
    onError: (error: Error, chunk: any) => {
      console.error('Save error for chunk:', chunk.id, error);
    }
  };

  return (
    <IntelligentCacheProvider>
      <OptimisticUpdateProvider>
        <ProgressiveSavingProvider config={progressiveSavingConfig}>
          <FormBuilderCore {...props} />
        </ProgressiveSavingProvider>
      </OptimisticUpdateProvider>
    </IntelligentCacheProvider>
  );
};