import { renderHook, act, waitFor } from '@testing-library/react';
import { toast } from 'sonner';
import { useChurnIntelligence } from '../useChurnIntelligence';
import {
  ChurnRiskLevel,
  RetentionAction,
  AlertUrgency,
  CampaignStatus,
  RetentionCampaignType
} from '@/types/churn-intelligence';

// Mock sonner toast
jest.mock('sonner', () => ({
  toast: {
    success: jest.fn(),
    error: jest.fn(),
    info: jest.fn(),
    warning: jest.fn(),
  }
}));

// Mock WebSocket for real-time updates
const mockWebSocket = {
  send: jest.fn(),
  close: jest.fn(),
  addEventListener: jest.fn(),
  removeEventListener: jest.fn(),
  readyState: WebSocket.OPEN
};

Object.defineProperty(global, 'WebSocket', {
  value: jest.fn(() => mockWebSocket),
  writable: true
});

describe('useChurnIntelligence', () => {
  beforeEach(() => {
    jest.useFakeTimers();
    jest.clearAllMocks();
    
    // Mock localStorage
    const localStorageMock = {
      getItem: jest.fn(),
      setItem: jest.fn(),
      removeItem: jest.fn(),
      clear: jest.fn(),
    };
    Object.defineProperty(window, 'localStorage', {
      value: localStorageMock,
      writable: true
    });
  });

  afterEach(() => {
    jest.useRealTimers();
    jest.restoreAllMocks();
  });

  describe('Initial State', () => {
    it('should initialize with default values', () => {
      const { result } = renderHook(() => useChurnIntelligence({}));

      expect(result.current.atRiskSuppliers).toEqual([]);
      expect(result.current.churnMetrics).toBeNull();
      expect(result.current.retentionCampaigns).toEqual([]);
      expect(result.current.churnTrends).toEqual([]);
      expect(result.current.activeAlerts).toEqual([]);
      expect(result.current.isLoading).toBe(false);
      expect(result.current.error).toBeNull();
    });

    it('should initialize with provided filters', () => {
      const initialFilters = {
        riskLevel: [ChurnRiskLevel.HIGH_RISK, ChurnRiskLevel.CRITICAL],
        supplierType: ['photographer', 'venue']
      };

      const { result } = renderHook(() => 
        useChurnIntelligence({ initialFilters })
      );

      expect(result.current.filters.riskLevel).toEqual(initialFilters.riskLevel);
      expect(result.current.filters.supplierType).toEqual(initialFilters.supplierType);
    });

    it('should load data on mount', async () => {
      const { result } = renderHook(() => useChurnIntelligence({}));

      expect(result.current.isLoading).toBe(true);

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      expect(result.current.atRiskSuppliers.length).toBeGreaterThan(0);
      expect(result.current.churnMetrics).not.toBeNull();
    });
  });

  describe('Data Loading', () => {
    it('should handle loading state correctly', async () => {
      const { result } = renderHook(() => useChurnIntelligence({}));

      expect(result.current.isLoading).toBe(true);

      act(() => {
        jest.advanceTimersByTime(1000);
      });

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      expect(result.current.error).toBeNull();
    });

    it('should refresh data when refreshData is called', async () => {
      const { result } = renderHook(() => useChurnIntelligence({}));

      // Wait for initial load
      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      const initialSupplierCount = result.current.atRiskSuppliers.length;

      act(() => {
        result.current.refreshData();
      });

      expect(result.current.isLoading).toBe(true);

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      // Data should be refreshed (mock data generation might change)
      expect(result.current.lastUpdated).toBeInstanceOf(Date);
    });
  });

  describe('Auto Refresh', () => {
    it('should auto refresh when enabled', async () => {
      const { result } = renderHook(() => 
        useChurnIntelligence({ autoRefresh: true, refreshInterval: 1 })
      );

      // Wait for initial load
      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      const initialUpdateTime = result.current.lastUpdated;

      // Fast forward 1 second (refresh interval)
      act(() => {
        jest.advanceTimersByTime(1000);
      });

      await waitFor(() => {
        expect(result.current.lastUpdated.getTime()).toBeGreaterThan(
          initialUpdateTime.getTime()
        );
      });
    });

    it('should not auto refresh when disabled', async () => {
      const { result } = renderHook(() => 
        useChurnIntelligence({ autoRefresh: false })
      );

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      const initialUpdateTime = result.current.lastUpdated;

      // Fast forward time
      act(() => {
        jest.advanceTimersByTime(10000);
      });

      // Should not have refreshed
      expect(result.current.lastUpdated).toBe(initialUpdateTime);
    });
  });

  describe('Filtering', () => {
    it('should filter suppliers by risk level', async () => {
      const { result } = renderHook(() => useChurnIntelligence({}));

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      act(() => {
        result.current.updateFilters({
          riskLevel: [ChurnRiskLevel.CRITICAL]
        });
      });

      result.current.atRiskSuppliers.forEach(supplier => {
        expect(supplier.churnRiskLevel).toBe(ChurnRiskLevel.CRITICAL);
      });
    });

    it('should filter suppliers by supplier type', async () => {
      const { result } = renderHook(() => useChurnIntelligence({}));

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      act(() => {
        result.current.updateFilters({
          supplierType: ['photographer']
        });
      });

      result.current.atRiskSuppliers.forEach(supplier => {
        expect(supplier.supplierType).toBe('photographer');
      });
    });

    it('should filter suppliers by search term', async () => {
      const { result } = renderHook(() => useChurnIntelligence({}));

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      act(() => {
        result.current.updateFilters({
          search: 'photo'
        });
      });

      result.current.atRiskSuppliers.forEach(supplier => {
        expect(
          supplier.supplierName.toLowerCase().includes('photo') ||
          supplier.supplierType.toLowerCase().includes('photo')
        ).toBe(true);
      });
    });

    it('should clear filters', async () => {
      const { result } = renderHook(() => useChurnIntelligence({}));

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      // Apply filters
      act(() => {
        result.current.updateFilters({
          riskLevel: [ChurnRiskLevel.CRITICAL],
          search: 'test'
        });
      });

      // Clear filters
      act(() => {
        result.current.clearFilters();
      });

      expect(result.current.filters.riskLevel).toBeUndefined();
      expect(result.current.filters.search).toBeUndefined();
    });
  });

  describe('Retention Actions', () => {
    it('should execute retention action successfully', async () => {
      const { result } = renderHook(() => useChurnIntelligence({}));

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      const supplierId = 'test-supplier-1';
      const action = RetentionAction.SEND_EMAIL;

      let actionResult: any;
      await act(async () => {
        actionResult = await result.current.executeRetentionAction(supplierId, action);
      });

      expect(actionResult.success).toBe(true);
      expect(actionResult.action).toBe(action);
      expect(toast.success).toHaveBeenCalledWith('Retention action executed successfully');
    });

    it('should handle retention action failure', async () => {
      const { result } = renderHook(() => useChurnIntelligence({}));

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      // Simulate failure by using invalid supplier ID
      const supplierId = 'invalid-supplier';
      const action = RetentionAction.SEND_EMAIL;

      let actionResult: any;
      await act(async () => {
        actionResult = await result.current.executeRetentionAction(supplierId, action);
      });

      expect(actionResult.success).toBe(false);
      expect(toast.error).toHaveBeenCalled();
    });
  });

  describe('Campaign Management', () => {
    it('should create retention campaign successfully', async () => {
      const { result } = renderHook(() => useChurnIntelligence({}));

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      const campaignData = {
        name: 'Test Campaign',
        campaignType: RetentionCampaignType.RE_ENGAGEMENT,
        targetRiskLevel: [ChurnRiskLevel.HIGH_RISK],
        targetSupplierTypes: ['photographer'],
        campaignContent: {
          emailTemplate: 'Test template'
        },
        executionSettings: {
          startDate: new Date(),
          autoExecute: false,
          frequency: 'once' as const
        }
      };

      let campaign: any;
      await act(async () => {
        campaign = await result.current.createCampaign(campaignData);
      });

      expect(campaign.name).toBe(campaignData.name);
      expect(campaign.campaignType).toBe(campaignData.campaignType);
      expect(toast.success).toHaveBeenCalledWith('Retention campaign created successfully');

      // Campaign should appear in the list
      expect(result.current.retentionCampaigns).toContainEqual(
        expect.objectContaining({ name: campaignData.name })
      );
    });

    it('should pause campaign', async () => {
      const { result } = renderHook(() => useChurnIntelligence({}));

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      // Create a campaign first
      const campaignData = {
        name: 'Test Pause Campaign',
        campaignType: RetentionCampaignType.RE_ENGAGEMENT,
        targetRiskLevel: [ChurnRiskLevel.HIGH_RISK],
        targetSupplierTypes: ['photographer'],
        campaignContent: {},
        executionSettings: {
          startDate: new Date(),
          autoExecute: false,
          frequency: 'once' as const
        }
      };

      let campaign: any;
      await act(async () => {
        campaign = await result.current.createCampaign(campaignData);
      });

      // Pause the campaign
      await act(async () => {
        await result.current.pauseCampaign(campaign.id);
      });

      const updatedCampaign = result.current.retentionCampaigns.find(
        c => c.id === campaign.id
      );
      expect(updatedCampaign?.status).toBe(CampaignStatus.PAUSED);
      expect(toast.info).toHaveBeenCalledWith('Campaign paused');
    });
  });

  describe('Alert Management', () => {
    it('should dismiss alert', async () => {
      const { result } = renderHook(() => useChurnIntelligence({}));

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      // Generate some alerts first
      act(() => {
        result.current.refreshData();
      });

      await waitFor(() => {
        expect(result.current.activeAlerts.length).toBeGreaterThan(0);
      });

      const alertId = result.current.activeAlerts[0].id;

      act(() => {
        result.current.dismissAlert(alertId);
      });

      expect(
        result.current.activeAlerts.find(a => a.id === alertId)?.isDismissed
      ).toBe(true);
    });

    it('should acknowledge alert', async () => {
      const { result } = renderHook(() => useChurnIntelligence({}));

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      // Generate alerts
      act(() => {
        result.current.refreshData();
      });

      await waitFor(() => {
        expect(result.current.activeAlerts.length).toBeGreaterThan(0);
      });

      const alertId = result.current.activeAlerts[0].id;

      act(() => {
        result.current.acknowledgeAlert(alertId);
      });

      const alert = result.current.activeAlerts.find(a => a.id === alertId);
      expect(alert?.acknowledgedAt).toBeInstanceOf(Date);
      expect(alert?.isRead).toBe(true);
    });
  });

  describe('Real-time Updates', () => {
    it('should establish WebSocket connection when realTimeUpdates is true', () => {
      renderHook(() => 
        useChurnIntelligence({ realTimeUpdates: true })
      );

      expect(global.WebSocket).toHaveBeenCalledWith(
        expect.stringContaining('churn-intelligence')
      );
    });

    it('should handle WebSocket connection states', () => {
      const { result } = renderHook(() => 
        useChurnIntelligence({ realTimeUpdates: true })
      );

      expect(result.current.connectionStatus).toBe('connected');
    });

    it('should not create WebSocket when realTimeUpdates is false', () => {
      jest.clearAllMocks();
      
      renderHook(() => 
        useChurnIntelligence({ realTimeUpdates: false })
      );

      expect(global.WebSocket).not.toHaveBeenCalled();
    });
  });

  describe('Error Handling', () => {
    it('should handle network errors gracefully', async () => {
      // Mock fetch to throw an error
      const originalFetch = global.fetch;
      global.fetch = jest.fn().mockRejectedValue(new Error('Network error'));

      const { result } = renderHook(() => useChurnIntelligence({}));

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      expect(result.current.error).toBe('Failed to load churn intelligence data');
      expect(toast.error).toHaveBeenCalledWith('Failed to load data');

      // Restore fetch
      global.fetch = originalFetch;
    });

    it('should retry failed requests', async () => {
      const mockFetch = jest.fn()
        .mockRejectedValueOnce(new Error('Network error'))
        .mockResolvedValue({
          ok: true,
          json: () => Promise.resolve({ data: [] })
        });

      global.fetch = mockFetch;

      const { result } = renderHook(() => useChurnIntelligence({}));

      // First call should fail, second should succeed
      act(() => {
        result.current.refreshData();
      });

      await waitFor(() => {
        expect(mockFetch).toHaveBeenCalledTimes(2);
      });
    });
  });

  describe('Data Persistence', () => {
    it('should save filters to localStorage', async () => {
      const mockSetItem = jest.spyOn(Storage.prototype, 'setItem');
      
      const { result } = renderHook(() => useChurnIntelligence({}));

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      const filters = {
        riskLevel: [ChurnRiskLevel.CRITICAL],
        supplierType: ['photographer']
      };

      act(() => {
        result.current.updateFilters(filters);
      });

      expect(mockSetItem).toHaveBeenCalledWith(
        'churnIntelligence_filters',
        JSON.stringify(filters)
      );
    });

    it('should load filters from localStorage', () => {
      const savedFilters = {
        riskLevel: [ChurnRiskLevel.HIGH_RISK],
        search: 'saved search'
      };

      jest.spyOn(Storage.prototype, 'getItem').mockReturnValue(
        JSON.stringify(savedFilters)
      );

      const { result } = renderHook(() => useChurnIntelligence({}));

      expect(result.current.filters).toEqual(
        expect.objectContaining(savedFilters)
      );
    });
  });

  describe('Performance', () => {
    it('should debounce filter updates', async () => {
      const { result } = renderHook(() => useChurnIntelligence({}));

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      // Apply filters multiple times quickly
      act(() => {
        result.current.updateFilters({ search: 'a' });
        result.current.updateFilters({ search: 'ab' });
        result.current.updateFilters({ search: 'abc' });
      });

      // Should only apply the last filter
      expect(result.current.filters.search).toBe('abc');
    });

    it('should memoize expensive calculations', async () => {
      const { result, rerender } = renderHook(() => useChurnIntelligence({}));

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      const initialMetrics = result.current.churnMetrics;

      // Rerender without changing data
      rerender();

      // Metrics should be the same reference (memoized)
      expect(result.current.churnMetrics).toBe(initialMetrics);
    });
  });

  describe('Cleanup', () => {
    it('should cleanup timers and subscriptions on unmount', () => {
      const clearIntervalSpy = jest.spyOn(global, 'clearInterval');
      const clearTimeoutSpy = jest.spyOn(global, 'clearTimeout');
      
      const { unmount } = renderHook(() => 
        useChurnIntelligence({ 
          autoRefresh: true,
          realTimeUpdates: true 
        })
      );

      unmount();

      expect(clearIntervalSpy).toHaveBeenCalled();
      expect(mockWebSocket.close).toHaveBeenCalled();
      
      clearIntervalSpy.mockRestore();
      clearTimeoutSpy.mockRestore();
    });

    it('should cleanup localStorage on unmount if needed', () => {
      const mockRemoveItem = jest.spyOn(Storage.prototype, 'removeItem');

      const { unmount } = renderHook(() => useChurnIntelligence({}));

      unmount();

      // Should not remove items by default
      expect(mockRemoveItem).not.toHaveBeenCalled();
    });
  });

  describe('Edge Cases', () => {
    it('should handle empty data responses', async () => {
      global.fetch = jest.fn().mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({
          atRiskSuppliers: [],
          churnMetrics: null,
          retentionCampaigns: [],
          churnTrends: [],
          alerts: []
        })
      });

      const { result } = renderHook(() => useChurnIntelligence({}));

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      expect(result.current.atRiskSuppliers).toEqual([]);
      expect(result.current.churnMetrics).toBeNull();
      expect(result.current.error).toBeNull();
    });

    it('should handle malformed data gracefully', async () => {
      global.fetch = jest.fn().mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({ invalid: 'data' })
      });

      const { result } = renderHook(() => useChurnIntelligence({}));

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      expect(result.current.atRiskSuppliers).toEqual([]);
      expect(result.current.error).toBeNull();
    });

    it('should handle concurrent action executions', async () => {
      const { result } = renderHook(() => useChurnIntelligence({}));

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      const supplierId = 'test-supplier';
      
      // Execute multiple actions concurrently
      const promises = [
        result.current.executeRetentionAction(supplierId, RetentionAction.SEND_EMAIL),
        result.current.executeRetentionAction(supplierId, RetentionAction.SCHEDULE_CALL),
        result.current.executeRetentionAction(supplierId, RetentionAction.ASSIGN_CSM)
      ];

      const results = await Promise.all(promises);

      // All should succeed independently
      results.forEach(result => {
        expect(result.success).toBe(true);
      });
    });
  });
});