import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest'
import request from 'supertest'
import { createServer } from 'http'
import { parse } from 'url'
import next from 'next'
import { testSupabase, testCleanup, integrationHelpers, mockServer } from '../../../../tests/integration/setup'
import { http, HttpResponse } from 'msw'

// WS-092: Multi-Factor Authentication Integration Tests
// Critical for securing wedding planner accounts and protecting client data

const app = next({ dev: false })
const handle = app.getRequestHandler()

describe('Multi-Factor Authentication Integration', () => {
  let server: any
  let testUser: any
  let testSession: any

  beforeEach(async () => {
    await app.prepare()
    server = createServer((req, res) => {
      const parsedUrl = parse(req.url!, true)
      handle(req, res, parsedUrl)
    })

    // Create test user with MFA
    testUser = {
      email: 'mfa-test@wedsync.com',
      password: 'SecurePassword123!',
      role: 'planner',
      mfa_enabled: false,
    }
  })

  afterEach(async () => {
    await testCleanup.clearAuthentication()
    await testCleanup.clearTestData()
    if (server) {
      server.close()
    }
  })

  describe('MFA Setup Workflow', () => {
    it('should enable MFA with TOTP successfully', async () => {
      // First, create and authenticate user
      const authContext = await integrationHelpers.createAuthenticatedContext(testUser.email)
      
      // Request MFA setup
      const setupResponse = await request(server)
        .post('/api/auth/mfa/setup')
        .set('Authorization', `Bearer ${authContext.session.access_token}`)
        .expect('Content-Type', /json/)
        .expect(200)

      expect(setupResponse.body).toMatchObject({
        success: true,
        qr_code: expect.stringContaining('data:image/png'),
        secret: expect.any(String),
        backup_codes: expect.arrayContaining([
          expect.stringMatching(/^[A-Z0-9]{8}$/),
        ])
      })
      expect(setupResponse.body.backup_codes).toHaveLength(10)

      // Verify MFA setup in database
      const userProfile = await integrationHelpers.verifyDatabaseState('user_profiles', {
        user_id: authContext.user.id,
      })
      expect(userProfile[0].mfa_pending_setup).toBe(true)

      // Simulate TOTP verification (mock the verification for testing)
      const mockTOTP = '123456'
      mockServer.use(
        http.post('*/auth/mfa/verify-setup', () => {
          return HttpResponse.json({
            success: true,
            verified: true,
          })
        })
      )

      const verifyResponse = await request(server)
        .post('/api/auth/mfa/verify-setup')
        .set('Authorization', `Bearer ${authContext.session.access_token}`)
        .send({
          totp_code: mockTOTP,
          secret: setupResponse.body.secret,
        })
        .expect('Content-Type', /json/)
        .expect(200)

      expect(verifyResponse.body).toMatchObject({
        success: true,
        mfa_enabled: true,
      })

      // Verify MFA is now enabled in database
      const updatedProfile = await integrationHelpers.verifyDatabaseState('user_profiles', {
        user_id: authContext.user.id,
      })
      expect(updatedProfile[0].mfa_enabled).toBe(true)
      expect(updatedProfile[0].mfa_pending_setup).toBe(false)
    })

    it('should enforce MFA for high-privilege operations', async () => {
      // Create user with MFA enabled
      const authContext = await integrationHelpers.createAuthenticatedContext(testUser.email)
      
      // Enable MFA in database
      await testSupabase.from('user_profiles').update({
        mfa_enabled: true,
        mfa_secret: 'test-secret-key',
      }).eq('user_id', authContext.user.id)

      // Attempt sensitive operation without MFA verification
      const response = await request(server)
        .delete('/api/clients/bulk-delete')
        .set('Authorization', `Bearer ${authContext.session.access_token}`)
        .send({ client_ids: ['client-1', 'client-2'] })
        .expect('Content-Type', /json/)
        .expect(403)

      expect(response.body).toMatchObject({
        success: false,
        error: 'MFA verification required',
        mfa_required: true,
      })
    })

    it('should handle backup codes correctly', async () => {
      const authContext = await integrationHelpers.createAuthenticatedContext(testUser.email)
      
      // Setup MFA and get backup codes
      const setupResponse = await request(server)
        .post('/api/auth/mfa/setup')
        .set('Authorization', `Bearer ${authContext.session.access_token}`)
        .expect(200)

      const backupCodes = setupResponse.body.backup_codes

      // Store backup codes in database (hashed)
      await testSupabase.from('mfa_backup_codes').insert(
        backupCodes.map(code => ({
          user_id: authContext.user.id,
          code_hash: Buffer.from(code).toString('base64'), // Simple hash for testing
          used: false,
        }))
      )

      // Use backup code for authentication
      const loginResponse = await request(server)
        .post('/api/auth/login')
        .send({
          email: testUser.email,
          password: 'test-password-123',
          backup_code: backupCodes[0],
        })
        .expect('Content-Type', /json/)
        .expect(200)

      expect(loginResponse.body).toMatchObject({
        success: true,
        session: expect.any(Object),
      })

      // Verify backup code is marked as used
      const usedCode = await integrationHelpers.verifyDatabaseState('mfa_backup_codes', {
        user_id: authContext.user.id,
        code_hash: Buffer.from(backupCodes[0]).toString('base64'),
      })
      expect(usedCode[0].used).toBe(true)

      // Attempt to reuse the same backup code
      const reuseResponse = await request(server)
        .post('/api/auth/login')
        .send({
          email: testUser.email,
          password: 'test-password-123',
          backup_code: backupCodes[0],
        })
        .expect('Content-Type', /json/)
        .expect(401)

      expect(reuseResponse.body).toMatchObject({
        success: false,
        error: expect.stringContaining('Invalid or used backup code'),
      })
    })
  })

  describe('Login Flow with MFA', () => {
    beforeEach(async () => {
      // Create user with MFA enabled
      const authContext = await integrationHelpers.createAuthenticatedContext(testUser.email)
      
      await testSupabase.from('user_profiles').update({
        mfa_enabled: true,
        mfa_secret: 'JBSWY3DPEHPK3PXP', // Test secret
      }).eq('user_id', authContext.user.id)
    })

    it('should require MFA code after initial authentication', async () => {
      // First step: email and password
      const firstStepResponse = await request(server)
        .post('/api/auth/login')
        .send({
          email: testUser.email,
          password: 'test-password-123',
        })
        .expect('Content-Type', /json/)
        .expect(200)

      expect(firstStepResponse.body).toMatchObject({
        success: true,
        mfa_required: true,
        session_token: expect.any(String), // Temporary token
      })

      // Second step: MFA verification
      mockServer.use(
        http.post('*/auth/mfa/verify', () => {
          return HttpResponse.json({
            valid: true,
          })
        })
      )

      const secondStepResponse = await request(server)
        .post('/api/auth/mfa/verify')
        .send({
          session_token: firstStepResponse.body.session_token,
          totp_code: '123456',
        })
        .expect('Content-Type', /json/)
        .expect(200)

      expect(secondStepResponse.body).toMatchObject({
        success: true,
        session: expect.objectContaining({
          access_token: expect.any(String),
          refresh_token: expect.any(String),
        })
      })

      // Verify session is fully authenticated
      const profileResponse = await request(server)
        .get('/api/auth/profile')
        .set('Authorization', `Bearer ${secondStepResponse.body.session.access_token}`)
        .expect(200)

      expect(profileResponse.body.user.email).toBe(testUser.email)
    })

    it('should rate limit MFA attempts', async () => {
      // Get initial session token
      const loginResponse = await request(server)
        .post('/api/auth/login')
        .send({
          email: testUser.email,
          password: 'test-password-123',
        })
        .expect(200)

      const sessionToken = loginResponse.body.session_token

      // Attempt multiple incorrect MFA codes
      const attempts = Array(6).fill(null).map((_, i) => 
        request(server)
          .post('/api/auth/mfa/verify')
          .send({
            session_token: sessionToken,
            totp_code: `00000${i}`,
          })
      )

      const results = await Promise.all(attempts)
      
      // First 5 attempts should fail with invalid code
      results.slice(0, 5).forEach(result => {
        expect(result.status).toBe(401)
        expect(result.body.error).toContain('Invalid')
      })

      // 6th attempt should be rate limited
      expect(results[5].status).toBe(429)
      expect(results[5].body).toMatchObject({
        success: false,
        error: expect.stringContaining('Too many attempts'),
        retry_after: expect.any(Number),
      })
    })

    it('should handle MFA recovery flow', async () => {
      // Request MFA recovery
      const recoveryResponse = await request(server)
        .post('/api/auth/mfa/recovery')
        .send({
          email: testUser.email,
        })
        .expect('Content-Type', /json/)
        .expect(200)

      expect(recoveryResponse.body).toMatchObject({
        success: true,
        message: 'Recovery email sent',
      })

      // Verify recovery token was created
      const recoveryTokens = await integrationHelpers.verifyDatabaseState('mfa_recovery_tokens', {
        email: testUser.email,
      })
      expect(recoveryTokens).toHaveLength(1)
      expect(recoveryTokens[0].expires_at).toBeTruthy()

      // Simulate clicking recovery link
      const recoveryToken = recoveryTokens[0].token
      const resetResponse = await request(server)
        .post('/api/auth/mfa/reset')
        .send({
          token: recoveryToken,
          password: 'NewSecurePassword456!',
        })
        .expect('Content-Type', /json/)
        .expect(200)

      expect(resetResponse.body).toMatchObject({
        success: true,
        mfa_disabled: true,
      })

      // Verify MFA is disabled
      const userProfile = await integrationHelpers.verifyDatabaseState('user_profiles', {
        email: testUser.email,
      })
      expect(userProfile[0].mfa_enabled).toBe(false)
    })
  })

  describe('Session Management with MFA', () => {
    it('should require re-authentication for sensitive operations', async () => {
      const authContext = await integrationHelpers.createAuthenticatedContext(testUser.email)
      
      // Enable MFA
      await testSupabase.from('user_profiles').update({
        mfa_enabled: true,
        last_mfa_verification: new Date(Date.now() - 3700000).toISOString(), // 61 minutes ago
      }).eq('user_id', authContext.user.id)

      // Attempt sensitive operation (should require re-authentication)
      const response = await request(server)
        .put('/api/settings/security')
        .set('Authorization', `Bearer ${authContext.session.access_token}`)
        .send({
          two_factor_required_for_team: true,
        })
        .expect('Content-Type', /json/)
        .expect(403)

      expect(response.body).toMatchObject({
        success: false,
        error: 'Re-authentication required',
        mfa_challenge: true,
      })
    })

    it('should maintain MFA session with proper timeout', async () => {
      const authContext = await integrationHelpers.createAuthenticatedContext(testUser.email)
      
      // Set recent MFA verification
      await testSupabase.from('user_profiles').update({
        mfa_enabled: true,
        last_mfa_verification: new Date().toISOString(),
      }).eq('user_id', authContext.user.id)

      // Should allow sensitive operation within timeout
      const response = await request(server)
        .put('/api/settings/security')
        .set('Authorization', `Bearer ${authContext.session.access_token}`)
        .send({
          two_factor_required_for_team: true,
        })
        .expect('Content-Type', /json/)
        .expect(200)

      expect(response.body).toMatchObject({
        success: true,
        settings_updated: true,
      })
    })

    it('should handle device trust for MFA', async () => {
      const authContext = await integrationHelpers.createAuthenticatedContext(testUser.email)
      
      // Register trusted device
      const deviceId = 'device-123-abc'
      const trustResponse = await request(server)
        .post('/api/auth/mfa/trust-device')
        .set('Authorization', `Bearer ${authContext.session.access_token}`)
        .send({
          device_id: deviceId,
          device_name: 'Test Browser',
          trust_duration_days: 30,
        })
        .expect('Content-Type', /json/)
        .expect(200)

      expect(trustResponse.body).toMatchObject({
        success: true,
        device_trusted: true,
        expires_at: expect.any(String),
      })

      // Verify device trust in database
      const trustedDevices = await integrationHelpers.verifyDatabaseState('trusted_devices', {
        user_id: authContext.user.id,
        device_id: deviceId,
      })
      expect(trustedDevices).toHaveLength(1)
      expect(trustedDevices[0].trusted).toBe(true)

      // Login from trusted device should skip MFA
      const trustedLoginResponse = await request(server)
        .post('/api/auth/login')
        .set('X-Device-ID', deviceId)
        .send({
          email: testUser.email,
          password: 'test-password-123',
        })
        .expect('Content-Type', /json/)
        .expect(200)

      expect(trustedLoginResponse.body).toMatchObject({
        success: true,
        mfa_required: false, // Skipped due to trusted device
        session: expect.any(Object),
      })
    })
  })

  describe('MFA Audit and Compliance', () => {
    it('should log all MFA-related events', async () => {
      const authContext = await integrationHelpers.createAuthenticatedContext(testUser.email)
      
      // Enable MFA
      await request(server)
        .post('/api/auth/mfa/setup')
        .set('Authorization', `Bearer ${authContext.session.access_token}`)
        .expect(200)

      // Verify audit log entry
      const auditLogs = await integrationHelpers.verifyDatabaseState('audit_logs', {
        user_id: authContext.user.id,
        event_type: 'mfa_setup_initiated',
      })
      expect(auditLogs).toHaveLength(1)
      expect(auditLogs[0].metadata).toMatchObject({
        ip_address: expect.any(String),
        user_agent: expect.any(String),
      })

      // Failed MFA attempt
      await request(server)
        .post('/api/auth/mfa/verify')
        .send({
          session_token: 'invalid-token',
          totp_code: '000000',
        })
        .expect(401)

      // Verify failed attempt logged
      const failedLogs = await integrationHelpers.verifyDatabaseState('audit_logs', {
        event_type: 'mfa_verification_failed',
      })
      expect(failedLogs.length).toBeGreaterThan(0)
    })

    it('should enforce organization-wide MFA policies', async () => {
      // Create organization with MFA requirement
      const { data: org } = await testSupabase.from('organizations').insert({
        name: 'Secure Wedding Planners',
        settings: {
          require_mfa: true,
          mfa_grace_period_days: 7,
        }
      }).select().single()

      // Create user in organization
      const authContext = await integrationHelpers.createAuthenticatedContext('org-user@wedsync.com')
      await testSupabase.from('user_profiles').update({
        organization_id: org.id,
        mfa_enabled: false,
      }).eq('user_id', authContext.user.id)

      // User should be prompted to enable MFA
      const response = await request(server)
        .get('/api/auth/profile')
        .set('Authorization', `Bearer ${authContext.session.access_token}`)
        .expect('Content-Type', /json/)
        .expect(200)

      expect(response.body).toMatchObject({
        user: expect.any(Object),
        mfa_required_by_org: true,
        grace_period_remaining_days: 7,
      })

      // After grace period, should enforce MFA
      await testSupabase.from('user_profiles').update({
        created_at: new Date(Date.now() - 8 * 86400000).toISOString(), // 8 days ago
      }).eq('user_id', authContext.user.id)

      const enforcedResponse = await request(server)
        .get('/api/clients')
        .set('Authorization', `Bearer ${authContext.session.access_token}`)
        .expect('Content-Type', /json/)
        .expect(403)

      expect(enforcedResponse.body).toMatchObject({
        success: false,
        error: 'MFA setup required by organization policy',
        redirect: '/auth/mfa/setup',
      })
    })
  })
})