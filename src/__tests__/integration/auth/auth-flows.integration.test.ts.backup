import { describe, it, expect, beforeEach } from 'vitest'
import request from 'supertest'
import { createServer } from 'http'
import { parse } from 'url'
import next from 'next'
import { testSupabase, testCleanup, integrationHelpers } from '../../../tests/integration/setup'

// WS-092: Authentication Flow Integration Tests
// Critical for preventing unauthorized access to wedding data

const app = next({ dev: false })
const handle = app.getRequestHandler()

describe('Authentication Flow Integration', () => {
  let server: any

  beforeEach(async () => {
    await app.prepare()
    server = createServer((req, res) => {
      const parsedUrl = parse(req.url!, true)
      handle(req, res, parsedUrl)
    })
  })

  describe('User Registration Flow', () => {
    it('should complete full signup workflow with email verification', async () => {
      const userData = {
        email: 'newplanner@wedsync.com',
        password: 'SecurePassword123!',
        first_name: 'New',
        last_name: 'Planner',
        role: 'planner',
        business_name: 'Wedding Dreams LLC',
      }

      // Step 1: Submit signup request
      const signupResponse = await request(server)
        .post('/api/auth/signup')
        .send(userData)
        .expect('Content-Type', /json/)
        .expect(201)

      expect(signupResponse.body).toMatchObject({
        success: true,
        message: expect.stringContaining('verification'),
        user: expect.objectContaining({
          email: userData.email,
          id: expect.any(String),
        })
      })

      // Step 2: Verify email confirmation was triggered
      await integrationHelpers.waitFor(async () => {
        const user = await testSupabase.auth.admin.getUserById(signupResponse.body.user.id)
        return user.data.user?.email_confirmed_at !== null
      }, 10000)

      // Step 3: Verify user profile was created
      const userProfile = await integrationHelpers.verifyDatabaseState('user_profiles', {
        email: userData.email
      })
      expect(userProfile).toHaveLength(1)
      expect(userProfile[0]).toMatchObject({
        email: userData.email,
        first_name: userData.first_name,
        last_name: userData.last_name,
        role: userData.role,
      })
    })

    it('should reject signup with invalid email format', async () => {
      const invalidData = {
        email: 'invalid-email-format',
        password: 'SecurePassword123!',
        first_name: 'Test',
        last_name: 'User',
      }

      const response = await request(server)
        .post('/api/auth/signup')
        .send(invalidData)
        .expect('Content-Type', /json/)
        .expect(400)

      expect(response.body).toMatchObject({
        success: false,
        errors: expect.arrayContaining([
          expect.objectContaining({
            field: 'email',
            message: expect.stringContaining('valid email'),
          })
        ])
      })
    })

    it('should enforce password security requirements', async () => {
      const weakPasswordData = {
        email: 'test@wedsync.com',
        password: '123456', // Too weak
        first_name: 'Test',
        last_name: 'User',
      }

      const response = await request(server)
        .post('/api/auth/signup')
        .send(weakPasswordData)
        .expect('Content-Type', /json/)
        .expect(400)

      expect(response.body).toMatchObject({
        success: false,
        errors: expect.arrayContaining([
          expect.objectContaining({
            field: 'password',
            message: expect.stringContaining('requirements'),
          })
        ])
      })
    })

    it('should prevent duplicate email registration', async () => {
      const userData = {
        email: 'duplicate@wedsync.com',
        password: 'SecurePassword123!',
        first_name: 'First',
        last_name: 'User',
      }

      // First registration
      await request(server)
        .post('/api/auth/signup')
        .send(userData)
        .expect(201)

      // Duplicate registration attempt
      const duplicateResponse = await request(server)
        .post('/api/auth/signup')
        .send({ ...userData, first_name: 'Second' })
        .expect('Content-Type', /json/)
        .expect(400)

      expect(duplicateResponse.body).toMatchObject({
        success: false,
        error: expect.stringContaining('already exists'),
      })
    })
  })

  describe('User Login Flow', () => {
    let testUser: any

    beforeEach(async () => {
      testUser = await testCleanup.createTestUser('login-test@wedsync.com', 'planner')
    })

    it('should authenticate user with valid credentials', async () => {
      const loginData = {
        email: 'login-test@wedsync.com',
        password: 'test-password-123',
      }

      const response = await request(server)
        .post('/api/auth/login')
        .send(loginData)
        .expect('Content-Type', /json/)
        .expect(200)

      expect(response.body).toMatchObject({
        success: true,
        user: expect.objectContaining({
          id: testUser.id,
          email: testUser.email,
        }),
        session: expect.objectContaining({
          access_token: expect.any(String),
          refresh_token: expect.any(String),
          expires_at: expect.any(Number),
        })
      })

      // Verify session is valid
      const { data: sessionUser, error } = await testSupabase.auth.getUser(
        response.body.session.access_token
      )
      expect(error).toBeNull()
      expect(sessionUser.user?.id).toBe(testUser.id)
    })

    it('should reject invalid credentials', async () => {
      const invalidLoginData = {
        email: 'login-test@wedsync.com',
        password: 'wrong-password',
      }

      const response = await request(server)
        .post('/api/auth/login')
        .send(invalidLoginData)
        .expect('Content-Type', /json/)
        .expect(401)

      expect(response.body).toMatchObject({
        success: false,
        error: expect.stringContaining('Invalid credentials'),
      })
    })

    it('should handle rate limiting for failed attempts', async () => {
      const invalidLoginData = {
        email: 'login-test@wedsync.com',
        password: 'wrong-password',
      }

      // Make multiple failed attempts
      const failedAttempts = Array(5).fill(null).map(() =>
        request(server)
          .post('/api/auth/login')
          .send(invalidLoginData)
          .expect(401)
      )

      await Promise.all(failedAttempts)

      // Next attempt should be rate limited
      const rateLimitedResponse = await request(server)
        .post('/api/auth/login')
        .send(invalidLoginData)
        .expect('Content-Type', /json/)
        .expect(429)

      expect(rateLimitedResponse.body).toMatchObject({
        success: false,
        error: expect.stringContaining('rate limit'),
      })
    })

    it('should create user session and set secure cookies', async () => {
      const loginData = {
        email: 'login-test@wedsync.com',
        password: 'test-password-123',
      }

      const response = await request(server)
        .post('/api/auth/login')
        .send(loginData)
        .expect(200)

      // Check for secure session cookies
      const cookies = response.headers['set-cookie']
      expect(cookies).toEqual(
        expect.arrayContaining([
          expect.stringContaining('sb-access-token'),
          expect.stringContaining('sb-refresh-token'),
          expect.stringContaining('HttpOnly'),
          expect.stringContaining('Secure'),
          expect.stringContaining('SameSite'),
        ])
      )
    })
  })

  describe('Password Reset Flow', () => {
    let testUser: any

    beforeEach(async () => {
      testUser = await testCleanup.createTestUser('reset-test@wedsync.com', 'planner')
    })

    it('should initiate password reset flow', async () => {
      const resetData = {
        email: 'reset-test@wedsync.com',
      }

      const response = await request(server)
        .post('/api/auth/forgot-password')
        .send(resetData)
        .expect('Content-Type', /json/)
        .expect(200)

      expect(response.body).toMatchObject({
        success: true,
        message: expect.stringContaining('reset link'),
      })

      // Verify reset token was created (in real app, this would be sent via email)
      await integrationHelpers.waitFor(async () => {
        const { data: user } = await testSupabase.auth.admin.getUserById(testUser.id)
        return user.user?.last_sign_in_at !== user.user?.created_at
      }, 5000)
    })

    it('should complete password reset with valid token', async () => {
      // First, initiate reset
      await request(server)
        .post('/api/auth/forgot-password')
        .send({ email: 'reset-test@wedsync.com' })
        .expect(200)

      // In real scenario, token would come from email
      // For testing, we'll simulate the reset completion
      const newPassword = 'NewSecurePassword123!'
      
      const resetResponse = await request(server)
        .post('/api/auth/reset-password')
        .send({
          token: 'test-reset-token', // Mock token
          password: newPassword,
        })
        .expect('Content-Type', /json/)
        .expect(200)

      expect(resetResponse.body).toMatchObject({
        success: true,
        message: expect.stringContaining('password updated'),
      })

      // Verify user can login with new password
      const loginResponse = await request(server)
        .post('/api/auth/login')
        .send({
          email: 'reset-test@wedsync.com',
          password: newPassword,
        })
        .expect(200)

      expect(loginResponse.body.success).toBe(true)
    })

    it('should reject password reset for non-existent email', async () => {
      const response = await request(server)
        .post('/api/auth/forgot-password')
        .send({ email: 'nonexistent@wedsync.com' })
        .expect('Content-Type', /json/)
        .expect(400)

      expect(response.body).toMatchObject({
        success: false,
        error: expect.stringContaining('not found'),
      })
    })
  })

  describe('Session Management', () => {
    let authenticatedUser: any
    let userSession: any

    beforeEach(async () => {
      const authContext = await integrationHelpers.createAuthenticatedContext('session-test@wedsync.com')
      authenticatedUser = authContext.user
      userSession = authContext.session
    })

    it('should validate active session', async () => {
      const response = await request(server)
        .get('/api/auth/session')
        .set('Authorization', `Bearer ${userSession.access_token}`)
        .expect('Content-Type', /json/)
        .expect(200)

      expect(response.body).toMatchObject({
        success: true,
        user: expect.objectContaining({
          id: authenticatedUser.id,
          email: authenticatedUser.email,
        }),
        session: expect.objectContaining({
          expires_at: expect.any(Number),
        })
      })
    })

    it('should refresh expired tokens', async () => {
      const response = await request(server)
        .post('/api/auth/refresh')
        .send({ refresh_token: userSession.refresh_token })
        .expect('Content-Type', /json/)
        .expect(200)

      expect(response.body).toMatchObject({
        success: true,
        session: expect.objectContaining({
          access_token: expect.any(String),
          refresh_token: expect.any(String),
          expires_at: expect.any(Number),
        })
      })

      // New tokens should be different from original
      expect(response.body.session.access_token).not.toBe(userSession.access_token)
      expect(response.body.session.refresh_token).not.toBe(userSession.refresh_token)
    })

    it('should logout and invalidate session', async () => {
      const logoutResponse = await request(server)
        .post('/api/auth/logout')
        .set('Authorization', `Bearer ${userSession.access_token}`)
        .expect('Content-Type', /json/)
        .expect(200)

      expect(logoutResponse.body).toMatchObject({
        success: true,
        message: expect.stringContaining('logged out'),
      })

      // Verify session is now invalid
      const sessionResponse = await request(server)
        .get('/api/auth/session')
        .set('Authorization', `Bearer ${userSession.access_token}`)
        .expect('Content-Type', /json/)
        .expect(401)

      expect(sessionResponse.body).toMatchObject({
        success: false,
        error: expect.stringContaining('Invalid session'),
      })
    })

    it('should handle concurrent sessions', async () => {
      // Create second session for same user
      const secondSession = await testCleanup.authenticateAs('session-test@wedsync.com')

      // Both sessions should be valid
      const firstSessionCheck = await request(server)
        .get('/api/auth/session')
        .set('Authorization', `Bearer ${userSession.access_token}`)
        .expect(200)

      const secondSessionCheck = await request(server)
        .get('/api/auth/session')
        .set('Authorization', `Bearer ${secondSession.access_token}`)
        .expect(200)

      expect(firstSessionCheck.body.success).toBe(true)
      expect(secondSessionCheck.body.success).toBe(true)
    })
  })

  describe('Role-Based Access Control', () => {
    let plannerUser: any
    let clientUser: any
    let vendorUser: any
    let plannerSession: any
    let clientSession: any
    let vendorSession: any

    beforeEach(async () => {
      const plannerContext = await integrationHelpers.createAuthenticatedContext('planner@rbac.test')
      const clientContext = await integrationHelpers.createAuthenticatedContext('client@rbac.test')
      const vendorContext = await integrationHelpers.createAuthenticatedContext('vendor@rbac.test')

      plannerUser = plannerContext.user
      clientUser = clientContext.user
      vendorUser = vendorContext.user
      plannerSession = plannerContext.session
      clientSession = clientContext.session
      vendorSession = vendorContext.session

      // Update user roles in database
      await testSupabase.from('user_profiles').upsert([
        { user_id: plannerUser.id, role: 'planner', email: plannerUser.email },
        { user_id: clientUser.id, role: 'client', email: clientUser.email },
        { user_id: vendorUser.id, role: 'vendor', email: vendorUser.email },
      ])
    })

    it('should restrict admin endpoints to planners only', async () => {
      const adminEndpoint = '/api/admin/rate-limits'

      // Planner should have access
      const plannerResponse = await request(server)
        .get(adminEndpoint)
        .set('Authorization', `Bearer ${plannerSession.access_token}`)
        .expect(200)

      expect(plannerResponse.body.success).toBe(true)

      // Client should be denied
      const clientResponse = await request(server)
        .get(adminEndpoint)
        .set('Authorization', `Bearer ${clientSession.access_token}`)
        .expect(403)

      expect(clientResponse.body).toMatchObject({
        success: false,
        error: expect.stringContaining('insufficient privileges'),
      })

      // Vendor should be denied
      const vendorResponse = await request(server)
        .get(adminEndpoint)
        .set('Authorization', `Bearer ${vendorSession.access_token}`)
        .expect(403)
    })

    it('should allow vendors access to vendor portal endpoints', async () => {
      const vendorEndpoint = '/api/vendor-portal/weddings'

      // Vendor should have access
      const vendorResponse = await request(server)
        .get(vendorEndpoint)
        .set('Authorization', `Bearer ${vendorSession.access_token}`)
        .expect(200)

      expect(vendorResponse.body.success).toBe(true)

      // Client should be denied
      const clientResponse = await request(server)
        .get(vendorEndpoint)
        .set('Authorization', `Bearer ${clientSession.access_token}`)
        .expect(403)
    })

    it('should validate role changes require elevated privileges', async () => {
      const roleChangeData = {
        user_id: clientUser.id,
        new_role: 'planner',
      }

      // Client cannot change their own role
      const selfChangeResponse = await request(server)
        .put('/api/auth/change-role')
        .set('Authorization', `Bearer ${clientSession.access_token}`)
        .send(roleChangeData)
        .expect(403)

      // Planner can change user roles
      const plannerChangeResponse = await request(server)
        .put('/api/auth/change-role')
        .set('Authorization', `Bearer ${plannerSession.access_token}`)
        .send(roleChangeData)
        .expect(200)

      expect(plannerChangeResponse.body.success).toBe(true)
    })
  })

  describe('Multi-Factor Authentication (MFA)', () => {
    let mfaUser: any
    let mfaSession: any

    beforeEach(async () => {
      const authContext = await integrationHelpers.createAuthenticatedContext('mfa-test@wedsync.com')
      mfaUser = authContext.user
      mfaSession = authContext.session
    })

    it('should enroll user in MFA', async () => {
      const enrollResponse = await request(server)
        .post('/api/auth/mfa/enroll')
        .set('Authorization', `Bearer ${mfaSession.access_token}`)
        .send({ type: 'totp' })
        .expect('Content-Type', /json/)
        .expect(200)

      expect(enrollResponse.body).toMatchObject({
        success: true,
        qr_code: expect.any(String),
        secret: expect.any(String),
        backup_codes: expect.any(Array),
      })

      // Verify MFA enrollment in database
      const mfaRecord = await integrationHelpers.verifyDatabaseState('user_mfa', {
        user_id: mfaUser.id
      })
      expect(mfaRecord).toHaveLength(1)
      expect(mfaRecord[0].status).toBe('pending_verification')
    })

    it('should verify MFA enrollment', async () => {
      // First enroll
      const enrollResponse = await request(server)
        .post('/api/auth/mfa/enroll')
        .set('Authorization', `Bearer ${mfaSession.access_token}`)
        .send({ type: 'totp' })
        .expect(200)

      // Then verify with TOTP code (mocked)
      const verifyResponse = await request(server)
        .post('/api/auth/mfa/verify')
        .set('Authorization', `Bearer ${mfaSession.access_token}`)
        .send({ code: '123456' }) // Mock TOTP code
        .expect('Content-Type', /json/)
        .expect(200)

      expect(verifyResponse.body).toMatchObject({
        success: true,
        message: expect.stringContaining('MFA enabled'),
      })

      // Verify MFA is now active
      const mfaRecord = await integrationHelpers.verifyDatabaseState('user_mfa', {
        user_id: mfaUser.id
      })
      expect(mfaRecord[0].status).toBe('active')
    })

    it('should require MFA challenge for MFA-enabled users', async () => {
      // Enable MFA for user
      await testSupabase.from('user_mfa').insert({
        user_id: mfaUser.id,
        type: 'totp',
        status: 'active',
      })

      // Login should trigger MFA challenge
      const loginResponse = await request(server)
        .post('/api/auth/login')
        .send({
          email: 'mfa-test@wedsync.com',
          password: 'test-password-123',
        })
        .expect('Content-Type', /json/)
        .expect(200)

      expect(loginResponse.body).toMatchObject({
        success: true,
        mfa_required: true,
        challenge_id: expect.any(String),
      })

      // Complete MFA challenge
      const mfaResponse = await request(server)
        .post('/api/auth/mfa/challenge')
        .send({
          challenge_id: loginResponse.body.challenge_id,
          code: '123456', // Mock TOTP code
        })
        .expect('Content-Type', /json/)
        .expect(200)

      expect(mfaResponse.body).toMatchObject({
        success: true,
        session: expect.objectContaining({
          access_token: expect.any(String),
        })
      })
    })
  })
})