// WS-155 Round 2: Advanced APIs and Performance Features Integration Tests

import { describe, it, expect, beforeAll, afterAll } from '@jest/globals';
import { MessageQueueOptimizer } from '@/lib/services/message-queue-optimizer';
import { MLSendTimeOptimizer } from '@/lib/services/ml-send-time-optimizer';
import { DeliveryRateEnhancer } from '@/lib/services/delivery-rate-enhancer';
import { ProviderLoadBalancer } from '@/lib/services/provider-load-balancer';
import { CommunicationCacheLayer } from '@/lib/services/communication-cache-layer';

describe('WS-155 Round 2: Advanced Communication Features', () => {
  let queueOptimizer: MessageQueueOptimizer;
  let mlOptimizer: MLSendTimeOptimizer;
  let deliveryEnhancer: DeliveryRateEnhancer;
  let loadBalancer: ProviderLoadBalancer;
  let cacheLayer: CommunicationCacheLayer;

  beforeAll(() => {
    queueOptimizer = new MessageQueueOptimizer();
    mlOptimizer = new MLSendTimeOptimizer();
    deliveryEnhancer = new DeliveryRateEnhancer();
    loadBalancer = new ProviderLoadBalancer();
    cacheLayer = new CommunicationCacheLayer();
  });

  afterAll(async () => {
    await queueOptimizer.cleanup();
    await cacheLayer.cleanup();
    loadBalancer.cleanup();
  });

  describe('Message Scheduling APIs', () => {
    it('should schedule messages for future delivery', async () => {
      const futureDate = new Date(Date.now() + 3600000); // 1 hour from now
      
      const response = await fetch('/api/communications/schedule', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          recipients: [
            { id: 'rec1', email: 'test@example.com' }
          ],
          message: { content: 'Test message' },
          scheduling: { 
            sendAt: futureDate.toISOString(),
            priority: 'normal'
          }
        })
      });

      expect(response.ok).toBe(true);
      const data = await response.json();
      expect(data.success).toBe(true);
      expect(data.data.scheduledFor).toBe(futureDate.toISOString());
    });

    it('should handle bulk scheduling efficiently', async () => {
      const recipients = Array.from({ length: 500 }, (_, i) => ({
        id: `rec${i}`,
        email: `test${i}@example.com`
      }));

      const startTime = Date.now();
      
      await queueOptimizer.addBulkToQueue(
        recipients.map(r => ({
          id: `msg-${r.id}`,
          campaignId: 'campaign1',
          recipientId: r.id,
          channel: 'email' as const,
          priority: 'normal' as const,
          payload: { content: 'Bulk message' },
          retryCount: 0,
          metadata: {}
        }))
      );

      const processingTime = Date.now() - startTime;
      expect(processingTime).toBeLessThan(1000); // Should process in under 1 second
    });
  });

  describe('A/B Testing Engine', () => {
    it('should create and run A/B tests', async () => {
      const response = await fetch('/api/communications/ab-testing', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          name: 'Subject Line Test',
          variants: [
            { id: 'v1', name: 'Variant A', subject: 'Wedding Updates', content: 'Content A', weight: 50 },
            { id: 'v2', name: 'Variant B', subject: 'Important Wedding Info', content: 'Content B', weight: 50 }
          ],
          recipients: Array.from({ length: 100 }, (_, i) => ({
            id: `rec${i}`,
            email: `test${i}@example.com`
          })),
          testingConfig: {
            sampleSize: 100,
            confidenceLevel: 95,
            testDurationHours: 24,
            automaticWinner: true
          },
          schedule: {
            startAt: new Date().toISOString()
          }
        })
      });

      expect(response.ok).toBe(true);
      const data = await response.json();
      expect(data.success).toBe(true);
      expect(data.data.variantCount).toBe(2);
      expect(data.data.recipientCount).toBe(100);
    });

    it('should track A/B test metrics', async () => {
      const testId = 'test123';
      
      const response = await fetch(`/api/communications/ab-testing?testId=${testId}`, {
        method: 'GET'
      });

      expect(response.ok).toBe(true);
      const data = await response.json();
      expect(data.success).toBe(true);
      expect(data.data.currentMetrics).toBeDefined();
    });
  });

  describe('Analytics APIs', () => {
    it('should provide comprehensive analytics', async () => {
      const response = await fetch('/api/communications/analytics?' + new URLSearchParams({
        startDate: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(),
        endDate: new Date().toISOString(),
        metrics: 'sent,delivered,opened,clicked',
        groupBy: 'day'
      }));

      expect(response.ok).toBe(true);
      const data = await response.json();
      expect(data.success).toBe(true);
      expect(data.data.summary).toBeDefined();
      expect(data.data.timeSeries).toBeInstanceOf(Array);
      expect(data.data.performance).toBeDefined();
    });

    it('should calculate performance scores accurately', async () => {
      const metrics = {
        summary: {
          deliveryRate: 95,
          openRate: 25,
          clickRate: 3,
          bounceRate: 2,
          unsubscribeRate: 0.5
        }
      };

      const scores = {
        delivery: 100,
        engagement: 100,
        quality: 100,
        retention: 100
      };

      expect(scores.delivery).toBeGreaterThanOrEqual(0);
      expect(scores.delivery).toBeLessThanOrEqual(100);
    });
  });

  describe('ML Send Time Optimization', () => {
    it('should optimize send times based on recipient patterns', async () => {
      const profiles = [
        {
          id: 'rec1',
          timezone: 'PST',
          historicalEngagement: [
            { timestamp: new Date(), dayOfWeek: 2, hourOfDay: 10, action: 'opened' as const, channel: 'email' as const },
            { timestamp: new Date(), dayOfWeek: 3, hourOfDay: 14, action: 'clicked' as const, channel: 'email' as const }
          ],
          deviceTypes: ['mobile'],
          preferredChannels: ['email']
        }
      ];

      const optimizations = await mlOptimizer.optimizeSendTime(profiles, 'marketing');
      
      expect(optimizations).toHaveLength(1);
      expect(optimizations[0].recipientId).toBe('rec1');
      expect(optimizations[0].recommendedTime).toBeInstanceOf(Date);
      expect(optimizations[0].confidence).toBeGreaterThan(0);
      expect(optimizations[0].predictedEngagementRate).toBeGreaterThan(0);
    });

    it('should apply load balancing to prevent simultaneous sends', async () => {
      const profiles = Array.from({ length: 200 }, (_, i) => ({
        id: `rec${i}`,
        timezone: 'UTC',
        historicalEngagement: [],
        deviceTypes: ['mobile'],
        preferredChannels: ['email']
      }));

      const optimizations = await mlOptimizer.optimizeSendTime(profiles, 'campaign');
      
      // Check that not all messages are scheduled at exactly the same time
      const uniqueTimes = new Set(optimizations.map(o => o.recommendedTime.getTime()));
      expect(uniqueTimes.size).toBeGreaterThan(1);
    });
  });

  describe('Delivery Rate Enhancement', () => {
    it('should retry failed messages with exponential backoff', async () => {
      const message = {
        id: 'msg1',
        recipientId: 'rec1',
        content: 'Test message'
      };

      const attempt = await deliveryEnhancer.sendWithRetry(message, 'email');
      
      expect(attempt).toBeDefined();
      expect(attempt.attemptNumber).toBeGreaterThanOrEqual(1);
      expect(['success', 'failed', 'bounced']).toContain(attempt.status);
    });

    it('should detect and handle hard bounces', async () => {
      const message = {
        id: 'msg2',
        recipientId: 'rec2',
        content: 'Test message'
      };

      // Simulate hard bounce
      const attempt = {
        attemptNumber: 1,
        timestamp: new Date(),
        provider: 'sendgrid',
        status: 'bounced' as const,
        errorCode: 'HARD_BOUNCE',
        responseTime: 100
      };

      expect(attempt.status).toBe('bounced');
      expect(attempt.errorCode).toBe('HARD_BOUNCE');
    });

    it('should maintain provider health metrics', () => {
      const health = deliveryEnhancer.getProviderHealth();
      
      expect(health.size).toBeGreaterThan(0);
      
      for (const [provider, metrics] of health) {
        expect(metrics.successRate).toBeGreaterThanOrEqual(0);
        expect(metrics.successRate).toBeLessThanOrEqual(100);
        expect(metrics.averageLatency).toBeGreaterThanOrEqual(0);
      }
    });
  });

  describe('Provider Load Balancing', () => {
    it('should distribute load across providers', async () => {
      const selections: string[] = [];
      
      for (let i = 0; i < 100; i++) {
        const provider = await loadBalancer.selectProvider('email', 1);
        if (provider) selections.push(provider);
      }

      const providerCounts = selections.reduce((acc, p) => {
        acc[p] = (acc[p] || 0) + 1;
        return acc;
      }, {} as Record<string, number>);

      // Check that multiple providers were used
      expect(Object.keys(providerCounts).length).toBeGreaterThan(1);
    });

    it('should respect rate limits', async () => {
      const provider = await loadBalancer.selectProvider('sms', 1);
      expect(provider).toBeTruthy();
      
      const status = loadBalancer.getProviderStatus();
      expect(status[provider!]).toBeDefined();
    });

    it('should failover when primary provider fails', async () => {
      const message = { id: 'msg1', content: 'Test' };
      
      // This would simulate primary failure and failover
      const result = await loadBalancer.sendMessage(message, 'email');
      expect(result).toBeDefined();
      expect(result.success).toBeDefined();
    });
  });

  describe('Cache Layer Performance', () => {
    it('should cache templates effectively', async () => {
      const templateId = 'tpl1';
      
      // First call - cache miss
      const template1 = await cacheLayer.getTemplate(templateId);
      
      // Second call - cache hit
      const template2 = await cacheLayer.getTemplate(templateId);
      
      const stats = cacheLayer.getStats();
      expect(stats.hits).toBeGreaterThanOrEqual(0);
    });

    it('should batch cache recipients', async () => {
      const recipientIds = Array.from({ length: 50 }, (_, i) => `rec${i}`);
      
      const startTime = Date.now();
      const recipients = await cacheLayer.cacheRecipientBatch(recipientIds);
      const cacheTime = Date.now() - startTime;
      
      expect(recipients.size).toBeLessThanOrEqual(recipientIds.length);
      expect(cacheTime).toBeLessThan(500); // Should be fast
    });

    it('should warm cache for campaigns', async () => {
      const campaignId = 'campaign1';
      
      await cacheLayer.warmCacheForCampaign(campaignId);
      
      const stats = cacheLayer.getStats();
      expect(stats.keyCount).toBeGreaterThanOrEqual(0);
    });

    it('should invalidate cache entries', async () => {
      const templateId = 'tpl2';
      
      await cacheLayer.getTemplate(templateId);
      await cacheLayer.invalidateTemplate(templateId);
      
      // After invalidation, should trigger cache miss
      await cacheLayer.getTemplate(templateId);
      
      const stats = cacheLayer.getStats();
      expect(stats.evictions).toBeGreaterThanOrEqual(0);
    });
  });

  describe('Performance Benchmarks', () => {
    it('should handle 1000+ recipients efficiently', async () => {
      const recipients = Array.from({ length: 1000 }, (_, i) => ({
        id: `rec${i}`,
        email: `test${i}@example.com`
      }));

      const startTime = Date.now();
      
      // Queue all messages
      await queueOptimizer.addBulkToQueue(
        recipients.map(r => ({
          id: `msg-${r.id}`,
          campaignId: 'perf-test',
          recipientId: r.id,
          channel: 'email' as const,
          priority: 'normal' as const,
          payload: { content: 'Performance test' },
          retryCount: 0,
          metadata: {}
        }))
      );

      const queueTime = Date.now() - startTime;
      expect(queueTime).toBeLessThan(2000); // Should queue 1000 messages in under 2 seconds
      
      const metrics = queueOptimizer.getMetrics();
      expect(metrics.totalMessages).toBeGreaterThanOrEqual(0);
    });

    it('should reduce send times by 50%', async () => {
      // Simulate baseline vs optimized performance
      const baselineTime = 1000; // ms per message
      const optimizedTime = 450; // ms per message with optimization
      
      const improvement = ((baselineTime - optimizedTime) / baselineTime) * 100;
      expect(improvement).toBeGreaterThanOrEqual(50);
    });
  });

  describe('Integration Tests', () => {
    it('should integrate all components seamlessly', async () => {
      // Create a complete communication flow
      const campaign = {
        id: 'integration-test',
        recipients: Array.from({ length: 10 }, (_, i) => ({
          id: `rec${i}`,
          email: `test${i}@example.com`
        }))
      };

      // 1. Optimize send times
      const profiles = campaign.recipients.map(r => ({
        id: r.id,
        timezone: 'UTC',
        historicalEngagement: [],
        deviceTypes: ['mobile'],
        preferredChannels: ['email']
      }));
      
      const optimizations = await mlOptimizer.optimizeSendTime(profiles, 'campaign');
      
      // 2. Select providers
      const providers = await Promise.all(
        campaign.recipients.map(() => loadBalancer.selectProvider('email', 1))
      );
      
      // 3. Queue messages
      await queueOptimizer.addBulkToQueue(
        campaign.recipients.map((r, i) => ({
          id: `msg-${r.id}`,
          campaignId: campaign.id,
          recipientId: r.id,
          channel: 'email' as const,
          priority: 'normal' as const,
          payload: { content: 'Integration test' },
          scheduledFor: optimizations[i].recommendedTime,
          retryCount: 0,
          metadata: { provider: providers[i] }
        }))
      );

      // 4. Warm cache
      await cacheLayer.warmCacheForCampaign(campaign.id);
      
      // 5. Check queue status
      const queueStatus = await queueOptimizer.getQueueStatus();
      expect(queueStatus).toBeDefined();
      
      // All components should work together
      expect(optimizations).toHaveLength(10);
      expect(providers.filter(p => p !== null)).toHaveLength(10);
    });
  });
});