/**
 * WS-152: Dietary Requirements Integration Tests
 * Team D - Batch 13
 * 
 * Tests for medical data security, performance, and compliance
 */

import { describe, it, expect, beforeEach, afterEach, jest } from '@jest/globals'
import { describe, it, expect, vi, beforeEach, afterEach, beforeAll, afterAll, Mock } from 'vitest';
import { createClient } from '@supabase/supabase-js'
import dietaryRequirementsService from '@/lib/services/dietary-requirements-service'
// Mock Supabase client
const mockSupabase = {
  from: jest.fn(),
  auth: {
    getUser: jest.fn().mockResolvedValue({ 
      data: { user: { id: 'test-user-123' } } 
    })
  },
  rpc: jest.fn()
}
jest.mock('@/lib/supabase/client', () => ({
  createClient: () => mockSupabase
}))
describe('WS-152: Dietary Requirements Management', () => {
  const testCoupleId = 'couple-123'
  const testGuestId = 'guest-456'
  const testUserId = 'test-user-123'
  
  beforeEach(() => {
    jest.clearAllMocks()
  })
  describe('Medical Data Security', () => {
    it('should encrypt life-threatening allergy data', async () => {
      const medicalData = {
        details: 'Severe peanut allergy - anaphylaxis risk',
        emergencyContact: 'Dr. Smith: 555-0123',
        emergencyMedication: 'EpiPen required',
        hospitalPreference: 'City General Hospital'
      }
      const mockInsert = jest.fn().mockReturnValue({
        select: jest.fn().mockReturnValue({
          single: jest.fn().mockResolvedValue({
            data: {
              id: 'req-123',
              guest_id: testGuestId,
              severity: 'life_threatening',
              medical_details_encrypted: 'encrypted_data_here',
              emergency_contact_encrypted: 'encrypted_contact',
              emergency_medication_encrypted: 'encrypted_med',
              hospital_preference_encrypted: 'encrypted_hospital'
            },
            error: null
          })
        })
      })
      mockSupabase.from.mockReturnValue({
        insert: mockInsert
      const result = await dietaryRequirementsService.addDietaryRequirement(
        testGuestId,
        {
          dietaryTypeId: 'type-123',
          severity: 'life_threatening',
          medicalData
        }
      )
      // Verify encryption was applied
      const insertCall = mockInsert.mock.calls[0][0]
      expect(insertCall.medical_details_encrypted).toBeDefined()
      expect(insertCall.emergency_contact_encrypted).toBeDefined()
      expect(insertCall).not.toContain('Severe peanut allergy') // Should not contain plain text
    it('should not encrypt data for non-medical preferences', async () => {
              id: 'req-124',
              severity: 'preference',
              description: 'Vegetarian'
      await dietaryRequirementsService.addDietaryRequirement(
          dietaryTypeId: 'type-124',
          severity: 'preference',
          description: 'Vegetarian preference'
      expect(insertCall.medical_details_encrypted).toBeUndefined()
      expect(insertCall.description).toBe('Vegetarian preference')
    it('should log all data access in audit trail', async () => {
      const mockAuditInsert = jest.fn().mockResolvedValue({ error: null })
      
      mockSupabase.from.mockImplementation((table) => {
        if (table === 'dietary_audit_log') {
          return { insert: mockAuditInsert }
        return {
          select: jest.fn().mockReturnValue({
            eq: jest.fn().mockReturnValue({
              order: jest.fn().mockResolvedValue({
                data: [],
                error: null
              })
            })
      await dietaryRequirementsService.getGuestDietaryRequirements(testGuestId)
      // Verify audit log was created
      expect(mockAuditInsert).toHaveBeenCalledWith(
        expect.objectContaining({
          guest_id: testGuestId,
          action: 'viewed',
          performed_by: testUserId,
          legitimate_access: true
    it('should enforce Row Level Security policies', async () => {
          eq: jest.fn().mockReturnValue({
            order: jest.fn().mockResolvedValue({
              data: null,
              error: { message: 'RLS policy violation' }
      await expect(
        dietaryRequirementsService.getGuestDietaryRequirements(testGuestId)
      ).rejects.toThrow('Failed to fetch dietary requirements')
  describe('Performance Optimization', () => {
    it('should generate dietary matrix in under 2 seconds', async () => {
      const startTime = performance.now()
      mockSupabase.rpc.mockResolvedValue({
        data: {
          summary: { by_category: {} },
          allergens: [],
          severity: {},
          cached: false,
          totalRequirements: 10,
          criticalAllergies: [],
          kitchenRequirements: {},
          generatedAt: new Date()
        },
        error: null
      const result = await dietaryRequirementsService.generateDietaryMatrix(testCoupleId)
      const endTime = performance.now()
      const executionTime = endTime - startTime
      expect(executionTime).toBeLessThan(2000) // Must be under 2 seconds
      expect(result).toHaveProperty('summary')
      expect(result).toHaveProperty('allergens')
    it('should use cache for dietary matrix when available', async () => {
      // First call - no cache
      mockSupabase.from.mockReturnValueOnce({
              eq: jest.fn().mockReturnValue({
                gt: jest.fn().mockReturnValue({
                  single: jest.fn().mockResolvedValue({
                    data: null, // No cache
                    error: { message: 'Not found' }
                  })
                })
      // RPC call for fresh generation
      mockSupabase.rpc.mockResolvedValueOnce({
          summary: { test: 'data' },
          cached: false
      // Second call - cache hit
                    data: {
                      dietary_summary: { test: 'cached_data' },
                      allergen_matrix: [],
                      severity_breakdown: {},
                      generated_at: new Date().toISOString()
                    },
                    error: null
      const result1 = await dietaryRequirementsService.generateDietaryMatrix(testCoupleId, 'event-123')
      expect(result1.cached).toBeFalsy()
      const result2 = await dietaryRequirementsService.generateDietaryMatrix(testCoupleId, 'event-123')
      expect(result2.cached).toBeTruthy()
    it('should have proper indexes for dietary queries', async () => {
      // This test verifies that the proper indexes are in place
      // In a real environment, this would check actual database indexes
      const indexQueries = [
        'idx_dietary_req_guest',
        'idx_dietary_req_severity',
        'idx_dietary_req_medical',
        'idx_dietary_matrix_valid'
      ]
      // Mock checking indexes
      for (const indexName of indexQueries) {
        expect(indexName).toBeTruthy() // Placeholder - would check actual DB
  describe('Compliance and Audit', () => {
    it('should track all CRUD operations in audit log', async () => {
      const operations = ['created', 'updated', 'deleted', 'viewed']
          insert: jest.fn().mockReturnValue({
            select: jest.fn().mockReturnValue({
              single: jest.fn().mockResolvedValue({
                data: { id: 'req-123' },
          }),
          update: jest.fn().mockReturnValue({
              select: jest.fn().mockReturnValue({
                single: jest.fn().mockResolvedValue({
                  data: { id: 'req-123' },
                  error: null
          delete: jest.fn().mockReturnValue({
            eq: jest.fn().mockResolvedValue({ error: null })
      // Test each operation
      await dietaryRequirementsService.addDietaryRequirement(testGuestId, {
        dietaryTypeId: 'type-123',
        severity: 'allergy'
        expect.objectContaining({ action: 'created' })
      await dietaryRequirementsService.updateDietaryRequirement('req-123', {
        severity: 'severe_allergy'
        expect.objectContaining({ action: 'updated' })
      await dietaryRequirementsService.deleteDietaryRequirement('req-123')
        expect.objectContaining({ action: 'deleted' })
    it('should track emergency data access separately', async () => {
              in: jest.fn().mockResolvedValue({
                data: [{
                  id: 'req-123',
                  severity: 'life_threatening'
                }],
      // Access critical allergies (emergency data)
      await dietaryRequirementsService['getCriticalAllergies'](testCoupleId)
          action: 'emergency_accessed',
          emergency_override: true
    it('should support compliance report generation', async () => {
          order: jest.fn().mockReturnValue({
            eq: jest.fn().mockResolvedValue({
              data: [
                {
                  id: 'log-1',
                  action: 'viewed',
                  performed_by: 'user-123',
                  created_at: new Date().toISOString()
                },
                  id: 'log-2',
                  action: 'updated',
                  performed_by: 'user-456',
                }
              ],
              error: null
      const auditLog = await dietaryRequirementsService.getAuditLog({
        startDate: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),
        endDate: new Date()
      expect(auditLog).toHaveLength(2)
      expect(auditLog[0]).toHaveProperty('action')
      expect(auditLog[0]).toHaveProperty('performed_by')
  describe('Catering Integration', () => {
    it('should generate secure catering reports', async () => {
          summary: { by_category: { allergen: [] } },
          allergens: ['peanuts', 'shellfish'],
          severity: { life_threatening: { count: 2, guests: 2 } },
          criticalAllergies: ['peanuts', 'shellfish'],
          kitchenRequirements: {
            allergenFreeZone: true,
            separatePrepNeeded: true
          }
        insert: jest.fn().mockReturnValue({
            single: jest.fn().mockResolvedValue({
              data: {
                id: 'report-123',
                couple_id: testCoupleId,
                dietary_breakdown: {},
                allergen_list: ['peanuts', 'shellfish']
              },
      const report = await dietaryRequirementsService.generateCateringReport(
        testCoupleId,
        new Date(),
        true // Include emergency info
      expect(report).toHaveProperty('allergenList')
      expect(report.allergenList).toContain('peanuts')
      expect(report).toHaveProperty('specialInstructions')
    it('should validate cross-contamination requirements', async () => {
                  id: 'req-1',
                  severity: 'life_threatening',
                  kitchen_separation_required: true,
                  cross_contamination_severity: 'severe_allergy',
                  dietary_types: {
                    name: 'Peanut Allergy',
                    cross_contamination_risk: true
                  }
      const requirements = await dietaryRequirementsService.getGuestDietaryRequirements(testGuestId)
      const criticalReq = requirements[0]
      expect(criticalReq.kitchenSeparationRequired).toBe(true)
      expect(criticalReq.dietaryType?.crossContaminationRisk).toBe(true)
  describe('Data Integrity', () => {
    it('should prevent duplicate dietary requirements', async () => {
              error: { 
                message: 'duplicate key value violates unique constraint'
              }
        dietaryRequirementsService.addDietaryRequirement(testGuestId, {
          severity: 'allergy'
      ).rejects.toThrow('Failed to add dietary requirement')
    it('should validate severity levels', async () => {
      const invalidSeverity = 'invalid_severity' as any
                message: 'invalid input value for enum dietary_severity'
          severity: invalidSeverity
      ).rejects.toThrow()
    it('should handle cache invalidation on data changes', async () => {
      // Simulate cache invalidation trigger
      const mockUpdate = jest.fn().mockReturnValue({
        set: jest.fn().mockReturnValue({
          where: jest.fn().mockResolvedValue({
      // Add a requirement (should invalidate cache)
              data: { id: 'req-new' },
        }),
        update: mockUpdate
      // In real implementation, this would trigger cache invalidation
      // Here we verify the structure is in place
      expect(mockSupabase.from).toHaveBeenCalled()
  describe('Search and Filtering', () => {
    it('should search dietary requirements by severity', async () => {
          eq: jest.fn((field, value) => {
            if (field === 'severity' && value === 'life_threatening') {
              return {
                eq: jest.fn().mockReturnValue({
                  or: jest.fn().mockResolvedValue({
                    data: [
                      {
                        id: 'req-1',
                        severity: 'life_threatening',
                        dietary_types: { name: 'Peanut Allergy' }
                      }
                    ],
            }
            return {
                or: jest.fn().mockResolvedValue({
                  data: [],
      const results = await dietaryRequirementsService.searchDietaryRequirements(
        undefined,
        'life_threatening'
      expect(results).toHaveLength(1)
      expect(results[0].severity).toBe('life_threatening')
    it('should search by dietary category', async () => {
              or: jest.fn().mockResolvedValue({
                data: [
                  {
                    id: 'req-1',
                    dietary_types: { 
                      name: 'Vegan',
                      category: 'ethical'
                    }
                  },
                    id: 'req-2',
                    dietary_types: {
                      name: 'Vegetarian',
                ],
        'ethical'
      expect(results).toHaveLength(2)
      expect(results.every(r => r.dietaryType?.category === 'ethical')).toBe(true)
  describe('Verification System', () => {
    it('should allow dietary requirement verification', async () => {
      const verifierName = 'Dr. Johnson'
              data: { id: 'req-123' },
        update: jest.fn().mockReturnValue({
                data: {
                  verified_by: verifierName,
                  verified_at: new Date().toISOString()
      const result = await dietaryRequirementsService.verifyDietaryRequirement(
        'req-123',
        verifierName
      expect(result.verifiedBy).toBe(verifierName)
      expect(result.verifiedAt).toBeDefined()
  describe('Error Handling', () => {
    it('should handle database connection errors gracefully', async () => {
          eq: jest.fn().mockRejectedValue(new Error('Connection refused'))
    it('should handle encryption errors securely', async () => {
      mockSupabase.rpc.mockRejectedValue(new Error('Encryption key not found'))
        dietaryRequirementsService.generateDietaryMatrix(testCoupleId)
      ).rejects.toThrow('Failed to generate dietary matrix')
    it('should log failed decryption attempts', async () => {
          select: jest.fn().mockRejectedValue(new Error('Decryption failed'))
      try {
        await dietaryRequirementsService.getGuestDietaryRequirements(testGuestId)
      } catch (error) {
        // Expected to fail
      // In real implementation, failed decryption would trigger audit log
      // This is handled at the database level in our design
})
describe('Performance Benchmarks', () => {
  it('should meet performance targets for common operations', async () => {
    const benchmarks = {
      getDietaryTypes: 500, // ms
      getGuestRequirements: 1000, // ms
      generateMatrix: 2000, // ms
      addRequirement: 500, // ms
      searchRequirements: 1000 // ms
    }
    // Mock fast responses
    mockSupabase.from.mockReturnValue({
      select: jest.fn().mockReturnValue({
        eq: jest.fn().mockReturnValue({
          order: jest.fn().mockResolvedValue({
            data: [],
    mockSupabase.rpc.mockResolvedValue({
      data: { summary: {} },
      error: null
    // Test each operation
    for (const [operation, maxTime] of Object.entries(benchmarks)) {
      switch (operation) {
        case 'getDietaryTypes':
          await dietaryRequirementsService.getDietaryTypes()
          break
        case 'getGuestRequirements':
          await dietaryRequirementsService.getGuestDietaryRequirements('guest-123')
        case 'generateMatrix':
          await dietaryRequirementsService.generateDietaryMatrix('couple-123')
        case 'searchRequirements':
          await dietaryRequirementsService.searchDietaryRequirements('couple-123')
      expect(executionTime).toBeLessThan(maxTime)
