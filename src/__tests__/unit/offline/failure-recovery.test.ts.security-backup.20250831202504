import { 
import { describe, it, expect, vi, beforeEach, afterEach, beforeAll, afterAll, Mock } from 'vitest';
  FailureRecoveryManager, 
  RetryStrategyManager, 
  DataIntegrityValidator, 
  EscalationManager,
  FailureType,
  RetryStrategy,
  OperationContext,
  EscalationLevel
} from '@/lib/offline/failure-recovery';
import { SyncEventType, SyncPriority } from '@/lib/offline/background-sync';

describe('FailureRecoveryManager', () => {
  let failureRecoveryManager: FailureRecoveryManager;
  beforeEach(() => {
    failureRecoveryManager = new FailureRecoveryManager();
    jest.clearAllMocks();
  });
  afterEach(() => {
    failureRecoveryManager.destroy();
  describe('failure classification', () => {
    it('should classify network timeout errors correctly', () => {
      const error = new Error('Request timeout after 30 seconds');
      const context: OperationContext = {
        operationId: 'op-1',
        operationType: SyncEventType.CLIENT_DATA_SYNC,
        priority: SyncPriority.MEDIUM,
        attemptCount: 1,
        weddingId: 'wedding-123',
      };
      const failureType = failureRecoveryManager.classifyFailure(error, context);
      expect(failureType).toBe(FailureType.NETWORK_TIMEOUT);
    });
    it('should classify server errors correctly', () => {
      const error = new Error('500 Internal Server Error');
        operationId: 'op-2',
        operationType: SyncEventType.VENDOR_COMMUNICATION,
        priority: SyncPriority.HIGH,
        attemptCount: 2,
      expect(failureType).toBe(FailureType.SERVER_ERROR);
    it('should classify data validation errors correctly', () => {
      const error = new Error('Validation failed: Invalid email format');
        operationId: 'op-3',
        operationType: SyncEventType.GUEST_LIST_UPDATE,
      expect(failureType).toBe(FailureType.DATA_VALIDATION);
    it('should classify authentication errors correctly', () => {
      const error = new Error('401 Unauthorized: Token expired');
        operationId: 'op-4',
        priority: SyncPriority.LOW,
      expect(failureType).toBe(FailureType.AUTH_ERROR);
    it('should classify storage quota errors correctly', () => {
      const error = new Error('QuotaExceededError: Storage limit reached');
        operationId: 'op-5',
        operationType: SyncEventType.MEDIA_UPLOAD,
      expect(failureType).toBe(FailureType.STORAGE_QUOTA);
    it('should classify unknown errors as generic failure', () => {
      const error = new Error('Some unknown error occurred');
        operationId: 'op-6',
      expect(failureType).toBe(FailureType.UNKNOWN);
  describe('recovery strategy determination', () => {
    it('should determine retry strategy for network timeouts', () => {
      const strategy = failureRecoveryManager.determineRecoveryStrategy(
        FailureType.NETWORK_TIMEOUT,
        {
          operationId: 'op-1',
          operationType: SyncEventType.CLIENT_DATA_SYNC,
          priority: SyncPriority.MEDIUM,
          attemptCount: 2,
        }
      );
      expect(strategy.shouldRetry).toBe(true);
      expect(strategy.retryStrategy).toBe(RetryStrategy.EXPONENTIAL_BACKOFF);
      expect(strategy.maxRetries).toBeGreaterThan(0);
    it('should not retry authentication errors', () => {
        FailureType.AUTH_ERROR,
          operationId: 'op-2',
          operationType: SyncEventType.VENDOR_COMMUNICATION,
          priority: SyncPriority.HIGH,
          attemptCount: 1,
      expect(strategy.shouldRetry).toBe(false);
      expect(strategy.requiresUserAction).toBe(true);
      expect(strategy.userAction).toContain('authentication');
    it('should escalate high priority failures faster', () => {
      const highPriorityStrategy = failureRecoveryManager.determineRecoveryStrategy(
        FailureType.SERVER_ERROR,
          operationId: 'op-high',
          operationType: SyncEventType.GUEST_LIST_UPDATE,
          priority: SyncPriority.CRITICAL,
      const lowPriorityStrategy = failureRecoveryManager.determineRecoveryStrategy(
          operationId: 'op-low',
          priority: SyncPriority.LOW,
      expect(highPriorityStrategy.escalationLevel).toBeGreaterThan(lowPriorityStrategy.escalationLevel || 0);
    it('should apply wedding-specific recovery logic', () => {
      const eventDayStrategy = failureRecoveryManager.determineRecoveryStrategy(
          operationId: 'op-event-day',
          weddingId: 'wedding-123',
          isEventDay: true,
      expect(eventDayStrategy.maxRetries).toBeGreaterThan(3);
      expect(eventDayStrategy.escalationLevel).toBe(EscalationLevel.HIGH);
    it('should handle storage quota issues with cleanup', () => {
        FailureType.STORAGE_QUOTA,
          operationId: 'op-storage',
          operationType: SyncEventType.MEDIA_UPLOAD,
      expect(strategy.requiresCleanup).toBe(true);
      expect(strategy.cleanupActions).toContain('clear_cache');
  describe('recovery execution', () => {
    it('should execute successful recovery', async () => {
      const error = new Error('Network timeout');
        operationId: 'recovery-op-1',
        retryOperation: jest.fn().mockResolvedValue({ success: true, data: 'recovered' }),
      const result = await failureRecoveryManager.handleFailure(error, context);
      expect(result.recovered).toBe(true);
      expect(result.result?.data).toBe('recovered');
      expect(context.retryOperation).toHaveBeenCalled();
    it('should handle recovery failure after max retries', async () => {
      const error = new Error('Persistent server error');
        operationId: 'recovery-op-2',
        attemptCount: 5, // Exceeds max retries
        retryOperation: jest.fn().mockRejectedValue(new Error('Still failing')),
      expect(result.recovered).toBe(false);
      expect(result.escalated).toBe(true);
      expect(result.escalationLevel).toBeDefined();
    it('should execute cleanup actions for storage issues', async () => {
      const error = new Error('QuotaExceededError');
        operationId: 'cleanup-op',
        retryOperation: jest.fn().mockResolvedValue({ success: true }),
        clearCache: jest.fn().mockResolvedValue(undefined),
      expect(context.clearCache).toHaveBeenCalled();
      expect(result.cleanupPerformed).toBe(true);
    it('should handle authentication errors with user action required', async () => {
      const error = new Error('401 Unauthorized');
        operationId: 'auth-op',
      expect(result.requiresUserAction).toBe(true);
      expect(result.userActionRequired).toContain('authentication');
    it('should emit recovery events', (done) => {
      const error = new Error('Test error');
        operationId: 'event-op',
      failureRecoveryManager.on('recovery-attempted', (data) => {
        expect(data.operationId).toBe('event-op');
        expect(data.failureType).toBe(FailureType.UNKNOWN);
        done();
      });
      failureRecoveryManager.handleFailure(error, context);
  describe('wedding-specific recovery logic', () => {
    it('should apply event day escalation procedures', async () => {
      const error = new Error('Critical wedding day failure');
        operationId: 'event-day-critical',
        priority: SyncPriority.CRITICAL,
        isEventDay: true,
        eventTime: Date.now() + 3600000, // 1 hour from now
      expect(result.escalationLevel).toBe(EscalationLevel.EMERGENCY);
      expect(result.weddingSpecificActions).toContain('coordinator_notification');
    it('should handle vendor communication failures gracefully', async () => {
      const error = new Error('Vendor API unavailable');
        operationId: 'vendor-comm-fail',
        weddingId: 'wedding-456',
        vendorCritical: true,
      expect(result.weddingSpecificActions).toContain('fallback_communication');
      expect(result.alternativeActions).toBeDefined();
    it('should prioritize guest-impacting operations', async () => {
      const error = new Error('Guest list sync failed');
        operationId: 'guest-impact-op',
        weddingId: 'wedding-789',
        guestImpact: true,
      expect(result.priorityBoosted).toBe(true);
      expect(result.recoveryStrategy?.maxRetries).toBeGreaterThan(3);
  describe('recovery statistics and monitoring', () => {
    it('should track recovery statistics', async () => {
      const operations = [
        { id: 'stat-op-1', shouldSucceed: true },
        { id: 'stat-op-2', shouldSucceed: false },
        { id: 'stat-op-3', shouldSucceed: true },
      ];
      for (const op of operations) {
        const error = new Error('Test error');
        const context: OperationContext = {
          operationId: op.id,
          retryOperation: jest.fn().mockImplementation(() => 
            op.shouldSucceed 
              ? Promise.resolve({ success: true }) 
              : Promise.reject(new Error('Retry failed'))
          ),
        };
        await failureRecoveryManager.handleFailure(error, context);
      }
      const stats = failureRecoveryManager.getRecoveryStats();
      expect(stats.totalFailures).toBe(3);
      expect(stats.successfulRecoveries).toBe(2);
      expect(stats.failedRecoveries).toBe(1);
      expect(stats.recoveryRate).toBeCloseTo(0.67, 2);
    it('should provide failure type statistics', async () => {
      const failures = [
        { error: new Error('Timeout'), type: FailureType.NETWORK_TIMEOUT },
        { error: new Error('500 Server Error'), type: FailureType.SERVER_ERROR },
        { error: new Error('Timeout again'), type: FailureType.NETWORK_TIMEOUT },
      for (const failure of failures) {
          operationId: `type-stat-${failures.indexOf(failure)}`,
        await failureRecoveryManager.handleFailure(failure.error, context);
      expect(stats.failureTypeBreakdown).toBeDefined();
      expect(stats.failureTypeBreakdown[FailureType.NETWORK_TIMEOUT]).toBe(2);
      expect(stats.failureTypeBreakdown[FailureType.SERVER_ERROR]).toBe(1);
  describe('error handling and edge cases', () => {
    it('should handle null or undefined errors gracefully', async () => {
        operationId: 'null-error-op',
      const result = await failureRecoveryManager.handleFailure(null as any, context);
      expect(result).toBeDefined();
      expect(result.failureType).toBe(FailureType.UNKNOWN);
    it('should handle invalid context gracefully', async () => {
      const invalidContext = {} as OperationContext;
      const result = await failureRecoveryManager.handleFailure(error, invalidContext);
    it('should handle retry operation failures', async () => {
      const error = new Error('Initial error');
        operationId: 'retry-fail-op',
        retryOperation: jest.fn().mockImplementation(() => {
          throw new Error('Retry operation implementation error');
        }),
      expect(result.error).toBeDefined();
    it('should handle concurrent recovery attempts', async () => {
      const error = new Error('Concurrent test error');
      const contexts = [
          operationId: 'concurrent-1',
          retryOperation: jest.fn().mockResolvedValue({ success: true }),
        },
          operationId: 'concurrent-2',
      const promises = contexts.map(context => 
        failureRecoveryManager.handleFailure(error, context)
      const results = await Promise.all(promises);
      expect(results).toHaveLength(2);
      expect(results.every(result => result.recovered)).toBe(true);
  describe('cleanup and resource management', () => {
    it('should cleanup resources on destroy', () => {
      const removeAllListenersSpy = jest.spyOn(failureRecoveryManager, 'removeAllListeners');
      failureRecoveryManager.destroy();
      expect(removeAllListenersSpy).toHaveBeenCalled();
    it('should handle operations gracefully after destroy', async () => {
      const error = new Error('Post-destroy error');
        operationId: 'post-destroy-op',
      expect(async () => {
      }).not.toThrow();
});
describe('RetryStrategyManager', () => {
  let retryStrategyManager: RetryStrategyManager;
    retryStrategyManager = new RetryStrategyManager();
  describe('delay calculation', () => {
    it('should calculate exponential backoff delays correctly', () => {
      const delays = [1, 2, 3, 4, 5].map(attempt =>
        retryStrategyManager.calculateDelay(RetryStrategy.EXPONENTIAL_BACKOFF, attempt)
      expect(delays[0]).toBe(1000); // Base delay
      expect(delays[1]).toBe(2000); // 2^1 * 1000
      expect(delays[2]).toBe(4000); // 2^2 * 1000
      expect(delays[3]).toBe(8000); // 2^3 * 1000
      expect(delays[4]).toBe(16000); // 2^4 * 1000
    it('should calculate linear backoff delays correctly', () => {
        retryStrategyManager.calculateDelay(RetryStrategy.LINEAR_BACKOFF, attempt)
      expect(delays[1]).toBe(2000); // 2 * 1000
      expect(delays[2]).toBe(3000); // 3 * 1000
      expect(delays[3]).toBe(4000); // 4 * 1000
      expect(delays[4]).toBe(5000); // 5 * 1000
    it('should calculate Fibonacci backoff delays correctly', () => {
      const delays = [1, 2, 3, 4, 5, 6].map(attempt =>
        retryStrategyManager.calculateDelay(RetryStrategy.FIBONACCI_BACKOFF, attempt)
      expect(delays[0]).toBe(1000); // 1 * 1000
      expect(delays[1]).toBe(1000); // 1 * 1000
      expect(delays[2]).toBe(2000); // 2 * 1000
      expect(delays[3]).toBe(3000); // 3 * 1000
      expect(delays[5]).toBe(8000); // 8 * 1000
    it('should apply maximum delay caps', () => {
      const longDelay = retryStrategyManager.calculateDelay(
        RetryStrategy.EXPONENTIAL_BACKOFF, 
        10, // This would normally result in a very large delay
        { maxDelay: 30000 }
      expect(longDelay).toBeLessThanOrEqual(30000);
    it('should apply jitter to delays', () => {
      const delays = Array(10).fill(null).map(() =>
        retryStrategyManager.calculateDelay(
          RetryStrategy.EXPONENTIAL_BACKOFF,
          3,
          { jitter: true }
        )
      // With jitter, delays should vary
      const uniqueDelays = new Set(delays);
      expect(uniqueDelays.size).toBeGreaterThan(1);
      
      // But should still be within reasonable bounds of base calculation
      const baseDelay = 8000; // 2^3 * 1000
      delays.forEach(delay => {
        expect(delay).toBeGreaterThan(baseDelay * 0.5);
        expect(delay).toBeLessThan(baseDelay * 1.5);
  describe('strategy selection', () => {
    it('should recommend exponential backoff for network errors', () => {
      const strategy = retryStrategyManager.recommendStrategy(
        { priority: SyncPriority.MEDIUM, attemptCount: 1 }
      expect(strategy).toBe(RetryStrategy.EXPONENTIAL_BACKOFF);
    it('should recommend immediate retry for high priority operations', () => {
        { priority: SyncPriority.CRITICAL, attemptCount: 1, isEventDay: true }
      expect(strategy).toBe(RetryStrategy.IMMEDIATE);
describe('DataIntegrityValidator', () => {
  let validator: DataIntegrityValidator;
    validator = new DataIntegrityValidator();
  describe('data validation', () => {
    it('should validate client data structure', () => {
      const validClientData = {
        clientId: 'client-123',
        name: 'John & Jane Doe',
        email: 'john.jane@example.com',
        weddingDate: '2024-06-15',
        timeline: [],
      const result = validator.validateData(validClientData, 'client');
      expect(result.isValid).toBe(true);
    it('should detect invalid data structures', () => {
      const invalidData = {
        clientId: '', // Invalid empty ID
        name: null, // Invalid null name
        email: 'invalid-email', // Invalid email format
      const result = validator.validateData(invalidData, 'client');
      expect(result.isValid).toBe(false);
      expect(result.errors).toBeDefined();
      expect(result.errors.length).toBeGreaterThan(0);
    it('should calculate and verify checksums', () => {
      const data = { test: 'data', value: 123 };
      const checksum = validator.calculateChecksum(data);
      expect(checksum).toBeDefined();
      expect(typeof checksum).toBe('string');
      const isValid = validator.verifyChecksum(data, checksum);
      expect(isValid).toBe(true);
      // Modified data should fail checksum verification
      const modifiedData = { test: 'modified', value: 123 };
      const isModifiedValid = validator.verifyChecksum(modifiedData, checksum);
      expect(isModifiedValid).toBe(false);
describe('EscalationManager', () => {
  let escalationManager: EscalationManager;
    escalationManager = new EscalationManager();
  describe('escalation procedures', () => {
    it('should escalate critical event day failures', async () => {
      const escalationData = {
        operationId: 'critical-event-day-op',
        failureType: FailureType.SERVER_ERROR,
        attemptCount: 3,
        errorMessage: 'Server unavailable during critical operation',
      const result = await escalationManager.escalate(escalationData);
      expect(result.actionsTriggered).toContain('coordinator_notification');
      expect(result.actionsTriggered).toContain('emergency_protocol');
    it('should handle vendor communication escalations', async () => {
        operationId: 'vendor-comm-escalation',
        failureType: FailureType.NETWORK_TIMEOUT,
        attemptCount: 5,
        errorMessage: 'Cannot reach vendor API',
      expect(result.escalationLevel).toBe(EscalationLevel.HIGH);
      expect(result.actionsTriggered).toContain('fallback_communication');
