import { SyncCoordinator, NetworkQualityLevel } from '@/lib/offline/sync-coordinator';
import { NetworkMonitor } from '@/lib/offline/network-monitor';
import { StorageOptimizer } from '@/lib/pwa/storage-optimizer';
import { SyncEventType, SyncPriority } from '@/lib/offline/background-sync';

// Mock dependencies
jest.mock('@/lib/offline/network-monitor');
jest.mock('@/lib/pwa/storage-optimizer');
jest.mock('@/lib/offline/background-sync');

const mockNetworkMonitor = {
  getCurrentState: jest.fn(),
  startMonitoring: jest.fn(),
  stopMonitoring: jest.fn(),
  on: jest.fn(),
  removeAllListeners: jest.fn(),
  testCurrentConnection: jest.fn(),
};

const mockStorageOptimizer = {
  analyzeStorage: jest.fn(),
  optimizeStorage: jest.fn(),
  clearCache: jest.fn(),
};

const mockSyncEventManager = {
  scheduleSync: jest.fn(),
  processEvent: jest.fn(),
  getQueuedEvents: jest.fn().mockReturnValue([]),
  on: jest.fn(),
  removeAllListeners: jest.fn(),
};

(NetworkMonitor as jest.Mock).mockImplementation(() => mockNetworkMonitor);
(StorageOptimizer as jest.Mock).mockImplementation(() => mockStorageOptimizer);

describe('SyncCoordinator', () => {
  let syncCoordinator: SyncCoordinator;

  beforeEach(() => {
    syncCoordinator = new SyncCoordinator();
    jest.clearAllMocks();
    
    // Default network state
    mockNetworkMonitor.getCurrentState.mockReturnValue({
      isOnline: true,
      quality: 'excellent' as NetworkQualityLevel,
      metrics: {
        bandwidth: 10,
        latency: 50,
        packetLoss: 0,
        stability: 0.95,
      },
      venueProfile: null,
      lastUpdated: Date.now(),
    });

    // Mock storage analysis
    mockStorageOptimizer.analyzeStorage.mockResolvedValue({
      totalSize: 1000000,
      usedSize: 500000,
      availableSize: 500000,
      categories: {
        images: 200000,
        documents: 150000,
        cache: 100000,
        userData: 50000,
      },
      recommendations: [],
    });
  });

  afterEach(() => {
    syncCoordinator.destroy();
  });

  describe('initialization', () => {
    it('should initialize with network monitoring', () => {
      expect(mockNetworkMonitor.startMonitoring).toHaveBeenCalled();
      expect(mockNetworkMonitor.on).toHaveBeenCalledWith('state-change', expect.any(Function));
    });

    it('should set initial sync strategy based on network quality', () => {
      const strategy = syncCoordinator.getCurrentStrategy();
      expect(strategy.maxConcurrentSyncs).toBe(5);
      expect(strategy.batchSize).toBe(50);
      expect(strategy.compressionLevel).toBe(6);
    });
  });

  describe('coordinateSync', () => {
    it('should coordinate sync with excellent network quality', async () => {
      const syncOperation = {
        id: 'test-sync-1',
        type: SyncEventType.CLIENT_DATA_SYNC,
        data: { clientId: 'client-1', updates: ['timeline', 'vendors'] },
        priority: SyncPriority.MEDIUM,
        weddingId: 'wedding-123',
      };

      mockSyncEventManager.scheduleSync.mockResolvedValue('sync-event-1');

      const result = await syncCoordinator.coordinateSync(syncOperation);

      expect(result.success).toBe(true);
      expect(result.syncEventId).toBe('sync-event-1');
      expect(result.strategy).toEqual(expect.objectContaining({
        maxConcurrentSyncs: 5,
        batchSize: 50,
      }));
    });

    it('should adapt strategy for poor network conditions', async () => {
      mockNetworkMonitor.getCurrentState.mockReturnValue({
        isOnline: true,
        quality: 'poor' as NetworkQualityLevel,
        metrics: {
          bandwidth: 0.5,
          latency: 800,
          packetLoss: 5,
          stability: 0.6,
        },
        venueProfile: {
          name: 'Remote Barn Venue',
          averageBandwidth: 1,
          reliabilityScore: 0.6,
          peakHours: ['18:00-22:00'],
        },
        lastUpdated: Date.now(),
      });

      const syncOperation = {
        id: 'test-sync-2',
        type: SyncEventType.VENDOR_COMMUNICATION,
        data: { vendorId: 'vendor-1' },
        priority: SyncPriority.HIGH,
        weddingId: 'wedding-123',
      };

      const result = await syncCoordinator.coordinateSync(syncOperation);

      expect(result.success).toBe(true);
      expect(result.strategy.maxConcurrentSyncs).toBe(1);
      expect(result.strategy.batchSize).toBe(5);
      expect(result.strategy.compressionLevel).toBe(9);
    });

    it('should handle offline scenarios', async () => {
      mockNetworkMonitor.getCurrentState.mockReturnValue({
        isOnline: false,
        quality: 'offline' as NetworkQualityLevel,
        metrics: {
          bandwidth: 0,
          latency: Infinity,
          packetLoss: 100,
          stability: 0,
        },
        venueProfile: null,
        lastUpdated: Date.now(),
      });

      const syncOperation = {
        id: 'test-sync-3',
        type: SyncEventType.CLIENT_DATA_SYNC,
        data: { clientId: 'client-1' },
        priority: SyncPriority.LOW,
      };

      const result = await syncCoordinator.coordinateSync(syncOperation);

      expect(result.success).toBe(true);
      expect(result.strategy.enableOfflineMode).toBe(true);
      expect(result.delayUntilOnline).toBe(true);
    });

    it('should apply wedding context optimizations', async () => {
      const eventDayOperation = {
        id: 'event-day-sync',
        type: SyncEventType.GUEST_LIST_UPDATE,
        data: { guestId: 'guest-1', status: 'arrived' },
        priority: SyncPriority.CRITICAL,
        weddingId: 'wedding-123',
        isEventDay: true,
      };

      const result = await syncCoordinator.coordinateSync(eventDayOperation);

      expect(result.success).toBe(true);
      expect(result.strategy.priorityBoost).toBe(true);
      expect(result.weddingOptimizations).toEqual(
        expect.objectContaining({
          isEventDay: true,
          optimizations: expect.arrayContaining(['priority_boost', 'reduced_batching']),
        })
      );
    });

    it('should handle coordination errors gracefully', async () => {
      mockSyncEventManager.scheduleSync.mockRejectedValue(new Error('Scheduling failed'));

      const syncOperation = {
        id: 'failing-sync',
        type: SyncEventType.CLIENT_DATA_SYNC,
        data: { clientId: 'client-1' },
        priority: SyncPriority.MEDIUM,
      };

      const result = await syncCoordinator.coordinateSync(syncOperation);

      expect(result.success).toBe(false);
      expect(result.error).toBe('Scheduling failed');
    });
  });

  describe('optimizeForWeddingContext', () => {
    it('should optimize for event day scenarios', () => {
      const baseStrategy = {
        maxConcurrentSyncs: 3,
        batchSize: 20,
        retryDelay: 1000,
        compressionLevel: 6,
      };

      const optimized = syncCoordinator.optimizeForWeddingContext(
        baseStrategy,
        SyncEventType.GUEST_LIST_UPDATE,
        SyncPriority.HIGH,
        { weddingId: 'wedding-123', isEventDay: true }
      );

      expect(optimized.strategy.maxConcurrentSyncs).toBeGreaterThan(baseStrategy.maxConcurrentSyncs);
      expect(optimized.strategy.retryDelay).toBeLessThan(baseStrategy.retryDelay);
      expect(optimized.weddingOptimizations?.isEventDay).toBe(true);
    });

    it('should optimize for vendor communications', () => {
      const baseStrategy = {
        maxConcurrentSyncs: 3,
        batchSize: 20,
        retryDelay: 1000,
        compressionLevel: 6,
      };

      const optimized = syncCoordinator.optimizeForWeddingContext(
        baseStrategy,
        SyncEventType.VENDOR_COMMUNICATION,
        SyncPriority.HIGH,
        { weddingId: 'wedding-123', vendorCritical: true }
      );

      expect(optimized.strategy.prioritizeRealTime).toBe(true);
      expect(optimized.weddingOptimizations?.optimizations).toContain('vendor_priority');
    });

    it('should handle guest-impact scenarios', () => {
      const baseStrategy = {
        maxConcurrentSyncs: 3,
        batchSize: 20,
        retryDelay: 1000,
        compressionLevel: 6,
      };

      const optimized = syncCoordinator.optimizeForWeddingContext(
        baseStrategy,
        SyncEventType.GUEST_LIST_UPDATE,
        SyncPriority.MEDIUM,
        { weddingId: 'wedding-123', guestImpact: true }
      );

      expect(optimized.weddingOptimizations?.optimizations).toContain('guest_impact_handling');
    });
  });

  describe('determineQualityLevel', () => {
    it('should correctly identify excellent network quality', () => {
      const metrics = {
        bandwidth: 10,
        latency: 100,
        packetLoss: 0.5,
        stability: 0.95,
      };

      const quality = syncCoordinator.determineQualityLevel(metrics);
      expect(quality).toBe('excellent');
    });

    it('should correctly identify poor network quality', () => {
      const metrics = {
        bandwidth: 0.5,
        latency: 800,
        packetLoss: 8,
        stability: 0.5,
      };

      const quality = syncCoordinator.determineQualityLevel(metrics);
      expect(quality).toBe('poor');
    });

    it('should handle edge cases in network metrics', () => {
      const metrics = {
        bandwidth: 0,
        latency: Infinity,
        packetLoss: 100,
        stability: 0,
      };

      const quality = syncCoordinator.determineQualityLevel(metrics);
      expect(quality).toBe('offline');
    });
  });

  describe('storage optimization integration', () => {
    it('should check storage before large sync operations', async () => {
      const largeOperation = {
        id: 'large-sync',
        type: SyncEventType.MEDIA_UPLOAD,
        data: { files: new Array(100).fill({ size: 5000000 }) }, // 100 x 5MB files
        priority: SyncPriority.MEDIUM,
      };

      await syncCoordinator.coordinateSync(largeOperation);

      expect(mockStorageOptimizer.analyzeStorage).toHaveBeenCalled();
    });

    it('should trigger storage optimization when space is low', async () => {
      mockStorageOptimizer.analyzeStorage.mockResolvedValue({
        totalSize: 1000000,
        usedSize: 950000,
        availableSize: 50000,
        categories: {
          images: 500000,
          documents: 300000,
          cache: 100000,
          userData: 50000,
        },
        recommendations: ['clear_old_cache', 'compress_images'],
      });

      const operation = {
        id: 'storage-heavy-sync',
        type: SyncEventType.MEDIA_UPLOAD,
        data: { fileSize: 100000 },
        priority: SyncPriority.MEDIUM,
      };

      const result = await syncCoordinator.coordinateSync(operation);

      expect(mockStorageOptimizer.optimizeStorage).toHaveBeenCalled();
      expect(result.storageOptimizations).toBeDefined();
    });
  });

  describe('network state change handling', () => {
    it('should update strategy when network quality changes', () => {
      const networkStateChangeCallback = mockNetworkMonitor.on.mock.calls
        .find(call => call[0] === 'state-change')?.[1];

      expect(networkStateChangeCallback).toBeDefined();

      // Simulate network quality change
      const newNetworkState = {
        isOnline: true,
        quality: 'good' as NetworkQualityLevel,
        metrics: {
          bandwidth: 3,
          latency: 200,
          packetLoss: 2,
          stability: 0.8,
        },
        venueProfile: null,
        lastUpdated: Date.now(),
      };

      networkStateChangeCallback(newNetworkState);

      const currentStrategy = syncCoordinator.getCurrentStrategy();
      expect(currentStrategy.maxConcurrentSyncs).toBe(3);
      expect(currentStrategy.batchSize).toBe(30);
    });

    it('should pause sync operations when going offline', () => {
      const networkStateChangeCallback = mockNetworkMonitor.on.mock.calls
        .find(call => call[0] === 'state-change')?.[1];

      const offlineState = {
        isOnline: false,
        quality: 'offline' as NetworkQualityLevel,
        metrics: {
          bandwidth: 0,
          latency: Infinity,
          packetLoss: 100,
          stability: 0,
        },
        venueProfile: null,
        lastUpdated: Date.now(),
      };

      networkStateChangeCallback(offlineState);

      const currentStrategy = syncCoordinator.getCurrentStrategy();
      expect(currentStrategy.enableOfflineMode).toBe(true);
    });
  });

  describe('getCurrentStrategy', () => {
    it('should return current sync strategy', () => {
      const strategy = syncCoordinator.getCurrentStrategy();

      expect(strategy).toEqual(expect.objectContaining({
        maxConcurrentSyncs: expect.any(Number),
        batchSize: expect.any(Number),
        retryDelay: expect.any(Number),
        compressionLevel: expect.any(Number),
      }));
    });
  });

  describe('getCoordinationStats', () => {
    it('should return coordination statistics', async () => {
      // Coordinate a few sync operations
      await syncCoordinator.coordinateSync({
        id: 'sync-1',
        type: SyncEventType.CLIENT_DATA_SYNC,
        data: {},
        priority: SyncPriority.MEDIUM,
      });

      await syncCoordinator.coordinateSync({
        id: 'sync-2',
        type: SyncEventType.VENDOR_COMMUNICATION,
        data: {},
        priority: SyncPriority.HIGH,
      });

      const stats = syncCoordinator.getCoordinationStats();

      expect(stats).toEqual(expect.objectContaining({
        totalCoordinated: expect.any(Number),
        successfulCoordinations: expect.any(Number),
        failedCoordinations: expect.any(Number),
        averageCoordinationTime: expect.any(Number),
        currentNetworkQuality: expect.any(String),
        activeStrategy: expect.any(Object),
      }));

      expect(stats.totalCoordinated).toBeGreaterThan(0);
    });
  });

  describe('destroy', () => {
    it('should cleanup resources on destroy', () => {
      syncCoordinator.destroy();

      expect(mockNetworkMonitor.stopMonitoring).toHaveBeenCalled();
      expect(mockNetworkMonitor.removeAllListeners).toHaveBeenCalled();
    });

    it('should handle multiple destroy calls gracefully', () => {
      syncCoordinator.destroy();
      syncCoordinator.destroy(); // Should not throw

      expect(mockNetworkMonitor.stopMonitoring).toHaveBeenCalledTimes(1);
    });
  });

  describe('error handling and edge cases', () => {
    it('should handle network monitor failures', async () => {
      mockNetworkMonitor.getCurrentState.mockImplementation(() => {
        throw new Error('Network monitor error');
      });

      const operation = {
        id: 'test-sync',
        type: SyncEventType.CLIENT_DATA_SYNC,
        data: {},
        priority: SyncPriority.MEDIUM,
      };

      const result = await syncCoordinator.coordinateSync(operation);

      // Should use fallback strategy
      expect(result.success).toBe(true);
      expect(result.strategy).toBeDefined();
    });

    it('should handle storage analyzer failures', async () => {
      mockStorageOptimizer.analyzeStorage.mockRejectedValue(new Error('Storage analysis failed'));

      const operation = {
        id: 'test-sync',
        type: SyncEventType.MEDIA_UPLOAD,
        data: { fileSize: 1000000 },
        priority: SyncPriority.MEDIUM,
      };

      const result = await syncCoordinator.coordinateSync(operation);

      expect(result.success).toBe(true);
      expect(result.storageOptimizations?.error).toBe('Storage analysis failed');
    });

    it('should handle invalid sync operations', async () => {
      const invalidOperation = {
        id: '',
        type: null as any,
        data: undefined,
        priority: 'invalid' as any,
      };

      const result = await syncCoordinator.coordinateSync(invalidOperation);

      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
    });
  });
});