/**
 * Unit tests for AI usage tracking API endpoint
 * WS-131 Pricing Strategy System - Team D Round 1
 * Integration point for Teams A, B, C AI services
 */

import { NextRequest } from 'next/server';
import { describe, it, expect, vi, beforeEach, afterEach, beforeAll, afterAll, Mock } from 'vitest';
import { POST, GET } from '@/app/api/billing/usage/ai/route';
import { createMocks } from 'node-mocks-http';
// Mock SubscriptionService
const mockSubscriptionService = {
  trackUsage: jest.fn(),
  getUserUsage: jest.fn()
};
jest.mock('@/lib/services/subscriptionService', () => ({
  SubscriptionService: jest.fn().mockImplementation(() => mockSubscriptionService)
}));
// Mock Supabase
const mockSupabaseClient = {
  from: jest.fn(() => ({
    select: jest.fn(() => ({
      eq: jest.fn(() => ({
        gte: jest.fn(() => ({
          order: jest.fn(() => ({
            data: [],
            error: null
          }))
        })),
        single: jest.fn(() => ({
          data: null,
          error: null
        }))
      }))
    })),
    insert: jest.fn(() => ({
      data: { id: 'usage-123' },
      error: null
    }))
  })),
  rpc: jest.fn(),
  auth: {
    getUser: jest.fn()
  }
jest.mock('@supabase/supabase-js', () => ({
  createClient: jest.fn(() => mockSupabaseClient)
const mockUser = {
  id: 'user-123',
  email: 'test@example.com',
  user_metadata: { role: 'user' }
const mockAdminUser = {
  id: 'admin-123',
  email: 'admin@example.com',
  user_metadata: { role: 'admin' }
const mockSubscriptionDetails = {
  plan: {
    tier: 'professional'
  },
  usage: {
    ai_photo_processing_count: 25,
    ai_music_recommendations_count: 10,
    ai_floral_suggestions_count: 5,
    ai_faq_extractions_count: 2,
    chatbot_interactions_count: 100
const mockAccessCheck = {
  hasAccess: true,
  usageLimit: 100,
  reason: null,
  requiredPlan: null,
  userPlan: 'professional'
describe('/api/billing/usage/ai', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    
    // Mock authentication
    mockSupabaseClient.auth.getUser.mockResolvedValue({
      data: { user: mockUser },
    });
    // Mock default subscription details
    mockSupabaseClient.rpc.mockImplementation((functionName: string) => {
      if (functionName === 'get_user_subscription_details') {
        return Promise.resolve({ data: mockSubscriptionDetails });
      }
      if (functionName === 'check_feature_access') {
        return Promise.resolve({ data: mockAccessCheck });
      return Promise.resolve({ data: null });
  });
  describe('POST /api/billing/usage/ai - Track Usage', () => {
    it('should track photo processing usage successfully', async () => {
      mockSubscriptionService.trackUsage.mockResolvedValue(true);
      mockSubscriptionService.getUserUsage.mockResolvedValue({
        ai_photo_processing_count: 26
      });
      const { req } = createMocks({
        method: 'POST',
        headers: {
          'authorization': 'Bearer valid-token',
          'content-type': 'application/json'
        },
        body: {
          service: 'photo_processing',
          operation: 'enhance_photo',
          increment: 1,
          metadata: {
            operation_type: 'enhance',
            processing_time_ms: 1500,
            file_size_mb: 2.5,
            quality_level: 'high',
            success: true
          }
        }
      const request = req as unknown as NextRequest;
      const response = await POST(request);
      const data = await response.json();
      expect(response.status).toBe(200);
      expect(data.success).toBe(true);
      expect(data.service).toBe('photo_processing');
      expect(data.operation).toBe('enhance_photo');
      expect(data.usage_tracked).toBe(1);
      expect(data.current_usage).toBe(25); // From mock data
      expect(data.plan).toBe('professional');
      
      expect(mockSubscriptionService.trackUsage).toHaveBeenCalledWith(
        'user-123',
        'ai_photo_processing',
        1
      );
    it('should track music recommendations usage', async () => {
        ai_music_recommendations_count: 11
          service: 'music_recommendations',
          operation: 'generate_playlist',
            operation_type: 'playlist_generation',
            processing_time_ms: 800,
      expect(data.service).toBe('music_recommendations');
      expect(data.operation).toBe('generate_playlist');
        'ai_music_recommendations',
    it('should track multiple increments', async () => {
        chatbot_interactions_count: 105
          service: 'chatbot_interactions',
          operation: 'message_exchange',
          increment: 5,
            operation_type: 'conversation',
      await POST(request);
        'ai_chatbot_interactions',
        5
    it('should allow admin users to track usage for other users', async () => {
      mockSupabaseClient.auth.getUser.mockResolvedValue({
        data: { user: mockAdminUser },
        error: null
        ai_floral_suggestions_count: 6
          'authorization': 'Bearer admin-token',
          service: 'floral_suggestions',
          operation: 'generate_arrangement',
          userId: 'user-123',
          increment: 1
        'user-123', // Target user ID
        'ai_floral_suggestions',
    it('should deny access when feature is not available', async () => {
      mockSupabaseClient.rpc.mockImplementation((functionName: string) => {
        if (functionName === 'get_user_subscription_details') {
          return Promise.resolve({ 
            data: { 
              plan: { tier: 'starter' },
              usage: {}
            }
          });
        if (functionName === 'check_feature_access') {
            data: {
              hasAccess: false,
              reason: 'Plan upgrade required',
              requiredPlan: 'professional',
              userPlan: 'starter'
        return Promise.resolve({ data: null });
      expect(response.status).toBe(403);
      expect(data.error).toBe('AI service access denied');
      expect(data.reason).toBe('Plan upgrade required');
      expect(data.required_plan).toBe('professional');
      expect(data.current_plan).toBe('starter');
      expect(data.upgrade_required).toBe(true);
    it('should include usage warnings when approaching limits', async () => {
              ...mockAccessCheck,
              usageLimit: 100
        ai_photo_processing_count: 90 // 90% of limit
      expect(data.warnings).toContain('Approaching usage limit - consider upgrading plan');
      // Check rate limiting headers
      expect(response.headers.get('X-RateLimit-Limit')).toBe('100');
      expect(response.headers.get('X-RateLimit-Remaining')).toBe('10');
      expect(response.headers.get('X-RateLimit-Reset')).toBeDefined();
    it('should return 401 for unauthenticated requests', async () => {
        data: { user: null },
        error: new Error('Invalid token')
          'authorization': 'Bearer invalid-token',
          operation: 'enhance_photo'
      expect(response.status).toBe(401);
      expect(data.error).toBe('Unauthorized');
    it('should return 403 for non-admin trying to track other user usage', async () => {
          userId: 'other-user-123' // Different user
      expect(data.error).toBe('Forbidden');
    it('should return 400 for missing required fields', async () => {
          service: 'photo_processing'
          // Missing operation
      expect(response.status).toBe(400);
      expect(data.error).toBe('service and operation are required');
    it('should return 400 for invalid AI service type', async () => {
          service: 'invalid_service',
          operation: 'test_operation'
      expect(data.error).toBe('Invalid AI service type');
    it('should record detailed usage history', async () => {
      expect(mockSupabaseClient.from).toHaveBeenCalledWith('usage_history');
  describe('GET /api/billing/usage/ai - Retrieve Analytics', () => {
    beforeEach(() => {
              plan: { tier: 'professional' },
              usage: {
                ai_photo_processing_count: 25,
                ai_music_recommendations_count: 10,
                ai_floral_suggestions_count: 5,
                ai_faq_extractions_count: 2,
                chatbot_interactions_count: 100,
                last_updated: '2025-01-24T00:00:00Z'
              }
    it('should return AI services usage overview', async () => {
        method: 'GET',
        url: '/api/billing/usage/ai',
          'authorization': 'Bearer valid-token'
      const response = await GET(request);
      expect(data.user_id).toBe('user-123');
      expect(data.ai_services).toHaveProperty('photo_processing');
      expect(data.ai_services).toHaveProperty('music_recommendations');
      expect(data.ai_services).toHaveProperty('floral_suggestions');
      expect(data.ai_services).toHaveProperty('faq_extraction');
      expect(data.ai_services).toHaveProperty('chatbot_interactions');
      expect(data.total_ai_usage).toBe(142); // Sum of all usage
      expect(data.last_updated).toBe('2025-01-24T00:00:00Z');
    it('should return specific service analytics with history', async () => {
      const mockHistoryData = [
        {
          id: 1,
          metric_value: 5,
          recorded_at: '2025-01-20T00:00:00Z',
          metadata: { operation: 'enhance_photo' }
          id: 2,
          metric_value: 3,
          recorded_at: '2025-01-21T00:00:00Z',
          metadata: { operation: 'color_correction' }
      ];
      mockSupabaseClient.from.mockReturnValue({
        select: jest.fn().mockReturnValue({
          eq: jest.fn().mockReturnValue({
            eq: jest.fn().mockReturnValue({
              gte: jest.fn().mockReturnValue({
                order: jest.fn().mockResolvedValue({
                  data: mockHistoryData,
                  error: null
                })
              })
            })
          })
        })
        url: '/api/billing/usage/ai?service=photo_processing&period=current_month',
      expect(data.current_usage).toBe(25);
      expect(data.usage_limit).toBe(100); // Professional plan limit
      expect(data.usage_percentage).toBe(25); // 25/100 * 100
      expect(data.history).toEqual(mockHistoryData);
    it('should handle different time periods', async () => {
                  data: [],
        url: '/api/billing/usage/ai?service=photo_processing&period=last_7_days',
    it('should allow admin to view other user analytics', async () => {
        url: '/api/billing/usage/ai?userId=user-123',
          'authorization': 'Bearer admin-token'
    it('should return 403 for non-admin trying to view other user analytics', async () => {
        url: '/api/billing/usage/ai?userId=other-user-123',
    it('should return 401 for unauthenticated GET requests', async () => {
          'authorization': 'Bearer invalid-token'
  describe('Helper functions', () => {
    it('should map services to feature keys correctly', () => {
      // These test the helper functions indirectly through API behavior
      const serviceFeatureMap = {
        'photo_processing': 'ai:photo_processing',
        'music_recommendations': 'ai:music_recommendations', 
        'floral_suggestions': 'ai:floral_suggestions',
        'faq_extraction': 'ai:faq_extraction',
        'chatbot_interactions': 'ai:chatbot'
      };
      expect(Object.keys(serviceFeatureMap)).toContain('photo_processing');
      expect(Object.keys(serviceFeatureMap)).toContain('music_recommendations');
      expect(Object.keys(serviceFeatureMap)).toContain('floral_suggestions');
      expect(Object.keys(serviceFeatureMap)).toContain('faq_extraction');
      expect(Object.keys(serviceFeatureMap)).toContain('chatbot_interactions');
    it('should calculate service limits for different plans', () => {
      const professionalLimits = {
        photo_processing: 100,
        music_recommendations: 50,
        floral_suggestions: 50,
        faq_extraction: 20,
        chatbot_interactions: 500
      expect(professionalLimits.photo_processing).toBe(100);
      expect(professionalLimits.music_recommendations).toBe(50);
      expect(professionalLimits.chatbot_interactions).toBe(500);
    it('should calculate usage warnings at different thresholds', () => {
      const getWarningLevel = (current: number, limit: number) => {
        const percentage = (current / limit) * 100;
        if (percentage >= 90) return 'critical';
        if (percentage >= 75) return 'warning';
        return 'normal';
      expect(getWarningLevel(90, 100)).toBe('critical');
      expect(getWarningLevel(75, 100)).toBe('warning');
      expect(getWarningLevel(50, 100)).toBe('normal');
});
