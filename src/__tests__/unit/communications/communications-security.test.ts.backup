import { describe, it, expect, jest, beforeEach, afterEach } from '@jest/globals';
import { CommunicationsSecurity } from '@/lib/security/communications-security';
import { CreateBulkMessageRequest } from '@/types/communications';

// Mock dependencies
const mockFetch = jest.fn();
global.fetch = mockFetch;

// Mock console methods
const consoleSpy = {
  error: jest.spyOn(console, 'error').mockImplementation(() => {}),
  warn: jest.spyOn(console, 'warn').mockImplementation(() => {})
};

describe('CommunicationsSecurity', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  afterEach(() => {
    jest.resetAllMocks();
  });

  describe('validateGuestOwnership', () => {
    const coupleId = 'couple-123';
    const recipientIds = ['guest-1', 'guest-2', 'guest-3'];

    it('should validate guest ownership successfully', async () => {
      const mockResponse = {
        isValid: true,
        invalidGuestIds: []
      };

      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: jest.fn().mockResolvedValue(mockResponse)
      });

      const result = await CommunicationsSecurity.validateGuestOwnership(coupleId, recipientIds);

      expect(mockFetch).toHaveBeenCalledWith('/api/guests/validate-ownership', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ couple_id: coupleId, guest_ids: recipientIds })
      });
      expect(result).toEqual(mockResponse);
    });

    it('should return invalid result when API call fails', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: false,
        status: 500
      });

      const result = await CommunicationsSecurity.validateGuestOwnership(coupleId, recipientIds);

      expect(result).toEqual({
        isValid: false,
        invalidGuestIds: recipientIds
      });
      expect(consoleSpy.error).toHaveBeenCalled();
    });

    it('should return invalid result when fetch throws error', async () => {
      mockFetch.mockRejectedValueOnce(new Error('Network error'));

      const result = await CommunicationsSecurity.validateGuestOwnership(coupleId, recipientIds);

      expect(result).toEqual({
        isValid: false,
        invalidGuestIds: recipientIds
      });
      expect(consoleSpy.error).toHaveBeenCalled();
    });

    it('should return invalid guests when some guests are invalid', async () => {
      const mockResponse = {
        isValid: false,
        invalidGuestIds: ['guest-2']
      };

      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: jest.fn().mockResolvedValue(mockResponse)
      });

      const result = await CommunicationsSecurity.validateGuestOwnership(coupleId, recipientIds);

      expect(result.isValid).toBe(false);
      expect(result.invalidGuestIds).toEqual(['guest-2']);
    });
  });

  describe('validateEmailAddresses', () => {
    it('should validate correct email addresses', () => {
      const emails = [
        'test@example.com',
        'user.name@domain.co.uk',
        'firstname+lastname@example.org'
      ];

      const result = CommunicationsSecurity.validateEmailAddresses(emails);

      expect(result.valid).toEqual(emails);
      expect(result.invalid).toEqual([]);
    });

    it('should identify invalid email addresses', () => {
      const emails = [
        'valid@example.com',
        'invalid.email',
        '@domain.com',
        'user@',
        'user name@example.com'
      ];

      const result = CommunicationsSecurity.validateEmailAddresses(emails);

      expect(result.valid).toEqual(['valid@example.com']);
      expect(result.invalid).toEqual([
        'invalid.email',
        '@domain.com',
        'user@',
        'user name@example.com'
      ]);
    });

    it('should handle empty email array', () => {
      const result = CommunicationsSecurity.validateEmailAddresses([]);

      expect(result.valid).toEqual([]);
      expect(result.invalid).toEqual([]);
    });
  });

  describe('validatePhoneNumbers', () => {
    it('should validate correct phone numbers', () => {
      const phones = [
        '+1234567890',
        '(555) 123-4567',
        '+44 20 1234 5678',
        '1-800-123-4567'
      ];

      const result = CommunicationsSecurity.validatePhoneNumbers(phones);

      expect(result.valid.length).toBe(4);
      expect(result.invalid).toEqual([]);
    });

    it('should identify invalid phone numbers', () => {
      const phones = [
        '+1234567890', // valid
        '123', // too short
        'abc-def-ghij', // non-numeric
        '+1 (555) 123-4567' // valid
      ];

      const result = CommunicationsSecurity.validatePhoneNumbers(phones);

      expect(result.valid).toEqual(['+1234567890', '+1 (555) 123-4567']);
      expect(result.invalid).toEqual(['123', 'abc-def-ghij']);
    });

    it('should handle empty phone array', () => {
      const result = CommunicationsSecurity.validatePhoneNumbers([]);

      expect(result.valid).toEqual([]);
      expect(result.invalid).toEqual([]);
    });
  });

  describe('validateBulkMessageRequest', () => {
    let validRequest: CreateBulkMessageRequest;

    beforeEach(() => {
      validRequest = {
        couple_id: '123e4567-e89b-12d3-a456-426614174000',
        recipient_ids: ['223e4567-e89b-12d3-a456-426614174001'],
        segmentation_criteria: {
          rsvp_status: ['pending'],
          dietary_restrictions: [],
          age_groups: ['adult'],
          categories: ['family'],
          sides: ['partner1'],
          has_plus_one: false,
          has_dietary_restrictions: false,
          has_special_needs: false,
          table_numbers: [],
          tags: [],
          custom_filters: {}
        },
        message_content: {
          subject: 'Test Subject',
          html_content: '<p>Hello {{guest_name}}!</p>',
          text_content: 'Hello {{guest_name}}!'
        },
        delivery_options: {
          channels: ['email'],
          send_immediately: true,
          scheduled_for: undefined,
          test_mode: false,
          batch_size: 50,
          delay_between_batches: 60
        },
        personalization_tokens: [
          {
            token: '{{guest_name}}',
            display_name: 'Guest Name',
            description: 'The guest\'s full name',
            example_value: 'John Doe',
            required: true,
            type: 'text'
          }
        ]
      };

      // Mock successful guest ownership validation
      const mockValidateGuestOwnership = jest.spyOn(CommunicationsSecurity, 'validateGuestOwnership')
        .mockResolvedValue({ isValid: true, invalidGuestIds: [] });

      // Mock successful rate limiting
      const mockRateLimitMessaging = jest.spyOn(CommunicationsSecurity, 'rateLimitMessaging')
        .mockResolvedValue({
          allowed: true,
          remaining: 4,
          resetTime: new Date(Date.now() + 3600000),
          dailyLimit: 5
        });
    });

    it('should validate correct request successfully', async () => {
      const result = await CommunicationsSecurity.validateBulkMessageRequest(validRequest);

      expect(result.isValid).toBe(true);
      expect(result.errors.filter(e => e.severity === 'error')).toHaveLength(0);
      expect(result.sanitizedRequest).toBeDefined();
    });

    it('should reject request with invalid UUID format', async () => {
      const invalidRequest = {
        ...validRequest,
        couple_id: 'invalid-uuid'
      };

      const result = await CommunicationsSecurity.validateBulkMessageRequest(invalidRequest);

      expect(result.isValid).toBe(false);
      expect(result.errors).toContainEqual(
        expect.objectContaining({
          field: 'couple_id',
          message: expect.stringContaining('Invalid'),
          severity: 'error'
        })
      );
    });

    it('should reject request with no recipients', async () => {
      const invalidRequest = {
        ...validRequest,
        recipient_ids: []
      };

      const result = await CommunicationsSecurity.validateBulkMessageRequest(invalidRequest);

      expect(result.isValid).toBe(false);
      expect(result.errors).toContainEqual(
        expect.objectContaining({
          field: 'recipient_ids',
          message: 'At least one recipient is required',
          severity: 'error'
        })
      );
    });

    it('should reject request with too many recipients', async () => {
      const invalidRequest = {
        ...validRequest,
        recipient_ids: Array(501).fill('123e4567-e89b-12d3-a456-426614174001')
      };

      const result = await CommunicationsSecurity.validateBulkMessageRequest(invalidRequest);

      expect(result.isValid).toBe(false);
      expect(result.errors).toContainEqual(
        expect.objectContaining({
          field: 'recipient_ids',
          message: 'Too many recipients',
          severity: 'error'
        })
      );
    });

    it('should reject request with empty message content', async () => {
      const invalidRequest = {
        ...validRequest,
        message_content: {
          ...validRequest.message_content,
          html_content: '',
          text_content: ''
        }
      };

      const result = await CommunicationsSecurity.validateBulkMessageRequest(invalidRequest);

      expect(result.isValid).toBe(false);
      expect(result.errors).toContainEqual(
        expect.objectContaining({
          field: 'message_content.html_content',
          message: 'Message content is required',
          severity: 'error'
        })
      );
    });

    it('should reject request with invalid guest ownership', async () => {
      jest.spyOn(CommunicationsSecurity, 'validateGuestOwnership')
        .mockResolvedValueOnce({
          isValid: false,
          invalidGuestIds: ['invalid-guest-1']
        });

      const result = await CommunicationsSecurity.validateBulkMessageRequest(validRequest);

      expect(result.isValid).toBe(false);
      expect(result.errors).toContainEqual(
        expect.objectContaining({
          field: 'recipient_ids',
          message: expect.stringContaining('Invalid guest IDs: invalid-guest-1'),
          severity: 'error'
        })
      );
    });

    it('should reject request when rate limit exceeded', async () => {
      jest.spyOn(CommunicationsSecurity, 'rateLimitMessaging')
        .mockResolvedValueOnce({
          allowed: false,
          remaining: 0,
          resetTime: new Date(Date.now() + 3600000),
          dailyLimit: 5
        });

      const result = await CommunicationsSecurity.validateBulkMessageRequest(validRequest);

      expect(result.isValid).toBe(false);
      expect(result.errors).toContainEqual(
        expect.objectContaining({
          field: 'couple_id',
          message: expect.stringContaining('Rate limit exceeded'),
          severity: 'error'
        })
      );
    });

    it('should validate scheduled messages with correct timing', async () => {
      const futureDate = new Date(Date.now() + 20 * 60 * 1000); // 20 minutes from now
      const scheduledRequest = {
        ...validRequest,
        delivery_options: {
          ...validRequest.delivery_options,
          send_immediately: false,
          scheduled_for: futureDate.toISOString()
        }
      };

      const result = await CommunicationsSecurity.validateBulkMessageRequest(scheduledRequest);

      expect(result.isValid).toBe(true);
    });

    it('should reject scheduled messages too close to current time', async () => {
      const nearFutureDate = new Date(Date.now() + 5 * 60 * 1000); // 5 minutes from now
      const scheduledRequest = {
        ...validRequest,
        delivery_options: {
          ...validRequest.delivery_options,
          send_immediately: false,
          scheduled_for: nearFutureDate.toISOString()
        }
      };

      const result = await CommunicationsSecurity.validateBulkMessageRequest(scheduledRequest);

      expect(result.isValid).toBe(false);
      expect(result.errors).toContainEqual(
        expect.objectContaining({
          field: 'scheduled_for',
          message: 'Scheduled time must be at least 15 minutes in the future',
          severity: 'error'
        })
      );
    });

    it('should add warnings for long content', async () => {
      const longContentRequest = {
        ...validRequest,
        message_content: {
          ...validRequest.message_content,
          html_content: 'x'.repeat(15000),
          text_content: 'x'.repeat(2000)
        }
      };

      const result = await CommunicationsSecurity.validateBulkMessageRequest(longContentRequest);

      expect(result.isValid).toBe(true);
      expect(result.warnings).toContain(
        'Message is quite long and may be truncated in some email clients'
      );
      expect(result.warnings).toContain(
        'SMS content exceeds recommended length and may be split into multiple messages'
      );
    });

    it('should add warnings for large recipient lists without batching', async () => {
      const largeRecipientRequest = {
        ...validRequest,
        recipient_ids: Array(150).fill('123e4567-e89b-12d3-a456-426614174001'),
        delivery_options: {
          ...validRequest.delivery_options,
          batch_size: undefined
        }
      };

      const result = await CommunicationsSecurity.validateBulkMessageRequest(largeRecipientRequest);

      expect(result.isValid).toBe(true);
      expect(result.warnings).toContain(
        'Consider using smaller batch sizes for large recipient lists to improve deliverability'
      );
    });
  });

  describe('generateUnsubscribeToken', () => {
    it('should generate valid unsubscribe token', () => {
      const coupleId = 'couple-123';
      const guestId = 'guest-456';

      const token = CommunicationsSecurity.generateUnsubscribeToken(coupleId, guestId);

      expect(token).toBeDefined();
      expect(typeof token).toBe('string');
      expect(token.length).toBeGreaterThan(0);

      // Should be valid base64url
      expect(() => Buffer.from(token, 'base64url')).not.toThrow();
    });

    it('should generate different tokens for different inputs', () => {
      const token1 = CommunicationsSecurity.generateUnsubscribeToken('couple-1', 'guest-1');
      const token2 = CommunicationsSecurity.generateUnsubscribeToken('couple-2', 'guest-2');

      expect(token1).not.toBe(token2);
    });
  });

  describe('validateUnsubscribeToken', () => {
    it('should validate correct unsubscribe token', () => {
      const coupleId = 'couple-123';
      const guestId = 'guest-456';
      
      const token = CommunicationsSecurity.generateUnsubscribeToken(coupleId, guestId);
      const result = CommunicationsSecurity.validateUnsubscribeToken(token);

      expect(result.isValid).toBe(true);
      expect(result.coupleId).toBe(coupleId);
      expect(result.guestId).toBe(guestId);
    });

    it('should reject invalid token format', () => {
      const result = CommunicationsSecurity.validateUnsubscribeToken('invalid-token');

      expect(result.isValid).toBe(false);
      expect(result.coupleId).toBeUndefined();
      expect(result.guestId).toBeUndefined();
    });

    it('should reject expired tokens', () => {
      // Mock an old timestamp (older than 30 days)
      const oldTimestamp = Date.now() - (31 * 24 * 60 * 60 * 1000);
      const oldPayload = JSON.stringify({
        coupleId: 'couple-123',
        guestId: 'guest-456',
        timestamp: oldTimestamp
      });
      const oldToken = Buffer.from(oldPayload).toString('base64url');

      const result = CommunicationsSecurity.validateUnsubscribeToken(oldToken);

      expect(result.isValid).toBe(false);
    });
  });

  describe('logSecurityEvent', () => {
    it('should log security events', async () => {
      await CommunicationsSecurity.logSecurityEvent(
        'rate_limit_exceeded',
        'couple-123',
        { requestCount: 6 }
      );

      expect(consoleSpy.warn).toHaveBeenCalledWith(
        'Security Event:',
        expect.objectContaining({
          event: 'rate_limit_exceeded',
          coupleId: 'couple-123',
          details: { requestCount: 6 },
          timestamp: expect.any(String),
          userAgent: expect.any(String)
        })
      );
    });

    it('should handle logging errors gracefully', async () => {
      const originalConsoleWarn = console.warn;
      console.warn = jest.fn().mockImplementation(() => {
        throw new Error('Logging failed');
      });

      // Should not throw
      await expect(
        CommunicationsSecurity.logSecurityEvent(
          'invalid_guest_ownership',
          'couple-123',
          {}
        )
      ).resolves.toBeUndefined();

      expect(consoleSpy.error).toHaveBeenCalledWith(
        'Failed to log security event:',
        expect.any(Error)
      );

      console.warn = originalConsoleWarn;
    });
  });
});