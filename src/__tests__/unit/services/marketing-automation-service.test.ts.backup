import { describe, it, expect, jest, beforeEach, afterEach } from '@jest/globals';
import { MarketingAutomationService } from '@/lib/services/marketing-automation-service';

// Mock dependencies
jest.mock('@supabase/auth-helpers-nextjs');
jest.mock('next/headers');
jest.mock('@/lib/services/email-service');
jest.mock('@/lib/services/ab-testing-service');
jest.mock('@/lib/services/ai-email-generator');

const mockSupabase = {
  from: jest.fn().mockReturnThis(),
  select: jest.fn().mockReturnThis(),
  insert: jest.fn().mockReturnThis(),
  update: jest.fn().mockReturnThis(),
  delete: jest.fn().mockReturnThis(),
  eq: jest.fn().mockReturnThis(),
  single: jest.fn(),
  rpc: jest.fn()
};

const mockEmailService = {
  sendEmail: jest.fn()
};

const mockABTestingService = {
  getVariantForClient: jest.fn(),
  recordEvent: jest.fn()
};

const mockAIEmailGenerator = {
  generateEmailTemplate: jest.fn()
};

describe('MarketingAutomationService', () => {
  let service: MarketingAutomationService;

  beforeEach(() => {
    jest.clearAllMocks();
    
    // Setup mocks
    (require('@supabase/auth-helpers-nextjs').createServerComponentClient as jest.Mock)
      .mockReturnValue(mockSupabase);
    
    (require('@/lib/services/email-service').EmailService as jest.Mock)
      .mockImplementation(() => mockEmailService);
    
    (require('@/lib/services/ab-testing-service').ABTestingService as jest.Mock)
      .mockImplementation(() => mockABTestingService);
    
    (require('@/lib/services/ai-email-generator').aiEmailGenerator as any) = mockAIEmailGenerator;

    service = MarketingAutomationService.getInstance();
  });

  afterEach(() => {
    jest.resetAllMocks();
  });

  describe('startCampaignExecution', () => {
    const mockCampaign = {
      id: 'campaign-1',
      name: 'Test Campaign',
      status: 'active',
      enable_ab_testing: false,
      steps: [
        {
          id: 'step-1',
          step_order: 1,
          step_type: 'email',
          step_name: 'Welcome Email'
        }
      ]
    };

    const mockClient = {
      id: 'client-1',
      name: 'John Doe',
      email: 'john@example.com'
    };

    it('should start campaign execution for a client', async () => {
      // Mock database responses
      mockSupabase.single
        .mockResolvedValueOnce({ data: mockCampaign, error: null })
        .mockResolvedValueOnce({ data: null, error: null }) // No existing execution
        .mockResolvedValueOnce({ 
          data: { 
            id: 'execution-1',
            campaign_id: 'campaign-1',
            client_id: 'client-1',
            status: 'pending'
          }, 
          error: null 
        });

      const result = await service.startCampaignExecution('campaign-1', 'client-1');

      expect(result).toBeTruthy();
      expect(result?.campaign_id).toBe('campaign-1');
      expect(result?.client_id).toBe('client-1');
      expect(mockSupabase.insert).toHaveBeenCalledWith(
        expect.objectContaining({
          campaign_id: 'campaign-1',
          client_id: 'client-1',
          status: 'pending'
        })
      );
    });

    it('should return null for non-active campaigns', async () => {
      const inactiveCampaign = { ...mockCampaign, status: 'draft' };
      mockSupabase.single.mockResolvedValueOnce({ data: inactiveCampaign, error: null });

      const result = await service.startCampaignExecution('campaign-1', 'client-1');

      expect(result).toBeNull();
    });

    it('should return null if campaign not found', async () => {
      mockSupabase.single.mockResolvedValueOnce({ data: null, error: { code: 'PGRST116' } });

      const result = await service.startCampaignExecution('campaign-1', 'client-1');

      expect(result).toBeNull();
    });

    it('should handle A/B testing variant assignment', async () => {
      const abTestCampaign = { ...mockCampaign, enable_ab_testing: true, ab_test_id: 'test-1' };
      const mockVariant = {
        id: 'variant-1',
        metadata: { variantId: 'variant-1', testId: 'test-1' }
      };

      mockSupabase.single
        .mockResolvedValueOnce({ data: abTestCampaign, error: null })
        .mockResolvedValueOnce({ data: null, error: null })
        .mockResolvedValueOnce({ data: { id: 'execution-1' }, error: null });

      mockABTestingService.getVariantForClient.mockResolvedValue(mockVariant);

      const result = await service.startCampaignExecution('campaign-1', 'client-1');

      expect(mockABTestingService.getVariantForClient).toHaveBeenCalledWith({
        testId: 'test-1',
        clientId: 'client-1',
        messageType: 'email',
        campaignId: 'campaign-1'
      });
      expect(result?.variant_id).toBe('variant-1');
    });
  });

  describe('processExecutionStep', () => {
    const mockExecution = {
      id: 'execution-1',
      campaign_id: 'campaign-1',
      client_id: 'client-1',
      status: 'pending',
      steps_completed: 0,
      execution_data: {},
      campaign: {
        id: 'campaign-1',
        name: 'Test Campaign'
      },
      client: {
        id: 'client-1',
        name: 'John Doe',
        email: 'john@example.com',
        wedding_date: '2024-06-15'
      },
      current_step: {
        id: 'step-1',
        campaign_id: 'campaign-1',
        step_type: 'email',
        step_name: 'Welcome Email',
        step_order: 1,
        config: {},
        template_id: null
      }
    };

    it('should process email step successfully', async () => {
      mockSupabase.single.mockResolvedValueOnce({ data: mockExecution, error: null });
      mockSupabase.update.mockResolvedValue({ data: {}, error: null });
      mockSupabase.insert.mockResolvedValue({ data: {}, error: null });
      mockSupabase.rpc.mockResolvedValue({ data: {}, error: null });
      
      mockAIEmailGenerator.generateEmailTemplate.mockResolvedValue({
        success: true,
        generated_template: {
          subject: 'Welcome to WedSync!',
          body_html: '<p>Welcome {{client_name}}!</p>',
          body_text: 'Welcome {{client_name}}!'
        }
      });

      mockEmailService.sendEmail.mockResolvedValue('message-123');

      await service.processExecutionStep('execution-1');

      expect(mockAIEmailGenerator.generateEmailTemplate).toHaveBeenCalled();
      expect(mockEmailService.sendEmail).toHaveBeenCalledWith(
        expect.objectContaining({
          to: 'john@example.com',
          subject: 'Welcome to WedSync!',
          html_content: '<p>Welcome John Doe!</p>'
        })
      );
      expect(mockSupabase.insert).toHaveBeenCalledWith(
        expect.objectContaining({
          campaign_id: 'campaign-1',
          execution_id: 'execution-1',
          step_id: 'step-1',
          message_type: 'email',
          recipient: 'john@example.com',
          status: 'sent',
          external_id: 'message-123'
        })
      );
    });

    it('should process delay step and schedule next execution', async () => {
      const delayExecution = {
        ...mockExecution,
        current_step: {
          ...mockExecution.current_step,
          step_type: 'delay',
          config: { delay_minutes: 120 }
        }
      };

      mockSupabase.single.mockResolvedValueOnce({ data: delayExecution, error: null });
      mockSupabase.update.mockResolvedValue({ data: {}, error: null });
      mockSupabase.rpc.mockResolvedValue({ data: {}, error: null });

      await service.processExecutionStep('execution-1');

      expect(mockSupabase.update).toHaveBeenCalledWith(
        expect.objectContaining({
          status: 'pending',
          next_execution_at: expect.any(String)
        })
      );
    });

    it('should process condition step and route correctly', async () => {
      const conditionExecution = {
        ...mockExecution,
        current_step: {
          ...mockExecution.current_step,
          step_type: 'condition',
          conditions: { wedding_date_within_days: 30 },
          true_next_step_id: 'step-2',
          false_next_step_id: 'step-3'
        }
      };

      mockSupabase.single.mockResolvedValueOnce({ data: conditionExecution, error: null });
      mockSupabase.update.mockResolvedValue({ data: {}, error: null });
      mockSupabase.rpc.mockResolvedValue({ data: {}, error: null });

      await service.processExecutionStep('execution-1');

      expect(mockSupabase.update).toHaveBeenCalledWith(
        expect.objectContaining({
          current_step_id: expect.any(String),
          steps_completed: 1,
          execution_data: expect.objectContaining({
            condition_result: expect.any(Boolean)
          })
        })
      );
    });

    it('should mark execution as failed on step error', async () => {
      const failingExecution = { ...mockExecution };
      mockSupabase.single.mockResolvedValueOnce({ data: failingExecution, error: null });
      mockSupabase.update.mockResolvedValue({ data: {}, error: null });
      mockSupabase.rpc.mockResolvedValue({ data: {}, error: null });
      
      mockAIEmailGenerator.generateEmailTemplate.mockResolvedValue({
        success: false,
        error: 'AI generation failed'
      });

      await service.processExecutionStep('execution-1');

      expect(mockSupabase.update).toHaveBeenCalledWith(
        expect.objectContaining({
          status: 'failed',
          error_message: expect.any(String),
          completed_at: expect.any(String)
        })
      );
    });
  });

  describe('launchCampaign', () => {
    const mockCampaignWithSegments = {
      id: 'campaign-1',
      name: 'Test Campaign',
      segments: [
        { client: { id: 'client-1', name: 'John Doe' } },
        { client: { id: 'client-2', name: 'Jane Smith' } }
      ]
    };

    it('should launch campaign for all target clients', async () => {
      mockSupabase.single.mockResolvedValueOnce({ 
        data: mockCampaignWithSegments, 
        error: null 
      });
      mockSupabase.update.mockResolvedValue({ data: {}, error: null });

      // Mock successful execution starts
      const serviceSpy = jest.spyOn(service, 'startCampaignExecution')
        .mockResolvedValueOnce({ id: 'exec-1' } as any)
        .mockResolvedValueOnce({ id: 'exec-2' } as any);

      const result = await service.launchCampaign('campaign-1');

      expect(result.success).toBe(true);
      expect(result.executions_started).toBe(2);
      expect(serviceSpy).toHaveBeenCalledTimes(2);
      expect(mockSupabase.update).toHaveBeenCalledWith({
        status: 'active',
        started_at: expect.any(String)
      });
    });

    it('should handle partial failures when launching campaign', async () => {
      mockSupabase.single.mockResolvedValueOnce({ 
        data: mockCampaignWithSegments, 
        error: null 
      });
      mockSupabase.update.mockResolvedValue({ data: {}, error: null });

      // Mock mixed results
      const serviceSpy = jest.spyOn(service, 'startCampaignExecution')
        .mockResolvedValueOnce({ id: 'exec-1' } as any)
        .mockResolvedValueOnce(null);

      const result = await service.launchCampaign('campaign-1');

      expect(result.success).toBe(true);
      expect(result.executions_started).toBe(1);
      expect(result.errors).toHaveLength(1);
    });

    it('should return error if campaign not found', async () => {
      mockSupabase.single.mockResolvedValueOnce({ 
        data: null, 
        error: { code: 'PGRST116' }
      });

      const result = await service.launchCampaign('campaign-1');

      expect(result.success).toBe(false);
      expect(result.executions_started).toBe(0);
      expect(result.errors).toContain('Campaign not found');
    });
  });

  describe('processScheduledExecutions', () => {
    it('should process all scheduled executions', async () => {
      const scheduledExecutions = [
        { id: 'exec-1' },
        { id: 'exec-2' },
        { id: 'exec-3' }
      ];

      mockSupabase.select.mockResolvedValue({ 
        data: scheduledExecutions, 
        error: null 
      });

      const processSpy = jest.spyOn(service, 'processExecutionStep')
        .mockResolvedValue();

      await service.processScheduledExecutions();

      expect(processSpy).toHaveBeenCalledTimes(3);
      expect(processSpy).toHaveBeenCalledWith('exec-1');
      expect(processSpy).toHaveBeenCalledWith('exec-2');
      expect(processSpy).toHaveBeenCalledWith('exec-3');
    });

    it('should handle errors in scheduled execution processing', async () => {
      mockSupabase.select.mockResolvedValue({ 
        data: null, 
        error: { message: 'Database error' }
      });

      // Should not throw
      await expect(service.processScheduledExecutions()).resolves.toBeUndefined();
    });
  });

  describe('personalizeTemplate', () => {
    it('should replace template variables with client data', () => {
      const template = 'Hello {{client_name}}, your wedding is on {{wedding_date}}!';
      const client = {
        name: 'John Doe',
        email: 'john@example.com',
        wedding_date: '2024-06-15'
      };
      const campaign = {
        name: 'Welcome Campaign'
      };

      // Access private method through any casting for testing
      const result = (service as any).personalizeTemplate(template, client, campaign);

      expect(result).toBe('Hello John Doe, your wedding is on 6/15/2024!');
    });

    it('should handle missing client data gracefully', () => {
      const template = 'Hello {{client_name}}, your wedding is on {{wedding_date}}!';
      const client = {
        name: null,
        wedding_date: null
      };
      const campaign = {};

      const result = (service as any).personalizeTemplate(template, client, campaign);

      expect(result).toBe('Hello Valued Client, your wedding is on !');
    });
  });

  describe('convertHtmlToText', () => {
    it('should strip HTML tags and convert entities', () => {
      const html = '<p>Hello <strong>John</strong>!</p><br>&nbsp;Welcome to <a href="#">WedSync</a>.';
      
      const result = (service as any).convertHtmlToText(html);

      expect(result).toBe('Hello John! Welcome to WedSync.');
    });
  });
});