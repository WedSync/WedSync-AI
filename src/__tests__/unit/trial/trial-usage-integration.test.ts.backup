import { describe, it, expect, jest, beforeEach, afterEach } from '@jest/globals';
import { TrialUsageIntegration } from '@/lib/trial/TrialUsageIntegration';

// Mock the AI services
jest.mock('@/lib/services/music-ai-service');
jest.mock('@/lib/ml/floral-ai-service');
jest.mock('@/lib/ml/photo-ai-service');
jest.mock('@/lib/services/subscriptionService');

// Mock Supabase client
const mockSupabase = {
  from: jest.fn(() => ({
    select: jest.fn(() => ({
      eq: jest.fn(() => ({
        single: jest.fn(),
      })),
      gte: jest.fn(() => ({
        lte: jest.fn(() => ({})),
      })),
    })),
    insert: jest.fn(() => ({
      single: jest.fn(),
    })),
    update: jest.fn(() => ({
      eq: jest.fn(() => ({
        single: jest.fn(),
      })),
    })),
  })),
  rpc: jest.fn(),
};

jest.mock('@/lib/supabase/client', () => ({
  createClient: () => mockSupabase,
}));

describe('TrialUsageIntegration', () => {
  let trialIntegration: TrialUsageIntegration;

  beforeEach(() => {
    trialIntegration = new TrialUsageIntegration();
    jest.clearAllMocks();
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  describe('Service Integration Tracking', () => {
    it('should track Music AI service usage correctly', async () => {
      const mockUsageData = {
        recommendations_generated: 5,
        playlists_created: 2,
        mood_analyses: 8,
        processing_time_ms: 1200,
        api_calls: 15,
      };

      // Mock successful database operations
      mockSupabase.from.mockReturnValue({
        insert: jest.fn().mockReturnValue({
          single: jest.fn().mockResolvedValue({ data: mockUsageData, error: null }),
        }),
      });

      const result = await trialIntegration.trackMusicAIUsage(
        'test-trial-id',
        'test-session-id',
        mockUsageData
      );

      expect(result).toBeDefined();
      expect(mockSupabase.from).toHaveBeenCalledWith('trial_music_ai_usage');
    });

    it('should track Floral AI service usage with TensorFlow metrics', async () => {
      const mockUsageData = {
        arrangements_generated: 3,
        style_analyses: 6,
        color_recommendations: 12,
        ml_model_calls: 9,
        inference_time_ms: 850,
      };

      mockSupabase.from.mockReturnValue({
        insert: jest.fn().mockReturnValue({
          single: jest.fn().mockResolvedValue({ data: mockUsageData, error: null }),
        }),
      });

      const result = await trialIntegration.trackFloralAIUsage(
        'test-trial-id',
        'test-session-id',
        mockUsageData
      );

      expect(result).toBeDefined();
      expect(mockSupabase.from).toHaveBeenCalledWith('trial_floral_ai_usage');
    });

    it('should track Photo AI service with OpenAI Vision API metrics', async () => {
      const mockUsageData = {
        photos_analyzed: 15,
        enhancements_applied: 8,
        categorizations_performed: 22,
        openai_api_calls: 15,
        vision_processing_time_ms: 2400,
      };

      mockSupabase.from.mockReturnValue({
        insert: jest.fn().mockReturnValue({
          single: jest.fn().mockResolvedValue({ data: mockUsageData, error: null }),
        }),
      });

      const result = await trialIntegration.trackPhotoAIUsage(
        'test-trial-id',
        'test-session-id',
        mockUsageData
      );

      expect(result).toBeDefined();
      expect(mockSupabase.from).toHaveBeenCalledWith('trial_photo_ai_usage');
    });

    it('should track Subscription Service integration metrics', async () => {
      const mockUsageData = {
        billing_calculations: 12,
        tier_evaluations: 5,
        usage_predictions: 8,
        stripe_api_calls: 7,
        processing_time_ms: 600,
      };

      mockSupabase.from.mockReturnValue({
        insert: jest.fn().mockReturnValue({
          single: jest.fn().mockResolvedValue({ data: mockUsageData, error: null }),
        }),
      });

      const result = await trialIntegration.trackSubscriptionUsage(
        'test-trial-id',
        'test-session-id',
        mockUsageData
      );

      expect(result).toBeDefined();
      expect(mockSupabase.from).toHaveBeenCalledWith('trial_subscription_usage');
    });
  });

  describe('Cross-Team ROI Analysis', () => {
    it('should calculate weighted ROI correctly across all services', async () => {
      // Mock database responses for each service
      const mockMusicData = {
        data: [{ 
          recommendations_generated: 10,
          processing_time_ms: 1500,
          api_calls: 20
        }],
        error: null
      };

      const mockFloralData = {
        data: [{ 
          arrangements_generated: 6,
          inference_time_ms: 900,
          ml_model_calls: 15
        }],
        error: null
      };

      const mockPhotoData = {
        data: [{ 
          photos_analyzed: 25,
          vision_processing_time_ms: 3000,
          openai_api_calls: 25
        }],
        error: null
      };

      const mockSubscriptionData = {
        data: [{ 
          billing_calculations: 15,
          processing_time_ms: 500,
          stripe_api_calls: 10
        }],
        error: null
      };

      // Chain the mock returns for different table queries
      mockSupabase.from
        .mockReturnValueOnce({
          select: jest.fn().mockReturnValue({
            eq: jest.fn().mockResolvedValue(mockMusicData)
          })
        })
        .mockReturnValueOnce({
          select: jest.fn().mockReturnValue({
            eq: jest.fn().mockResolvedValue(mockFloralData)
          })
        })
        .mockReturnValueOnce({
          select: jest.fn().mockReturnValue({
            eq: jest.fn().mockResolvedValue(mockPhotoData)
          })
        })
        .mockReturnValueOnce({
          select: jest.fn().mockReturnValue({
            eq: jest.fn().mockResolvedValue(mockSubscriptionData)
          })
        });

      const result = await trialIntegration.generateCrossTeamROI('test-trial-id');

      expect(result).toBeDefined();
      expect(result.totalWeightedROI).toBeGreaterThan(0);
      expect(result.serviceBreakdown).toHaveLength(4);
      
      // Verify each service is represented
      const serviceNames = result.serviceBreakdown.map(s => s.serviceName);
      expect(serviceNames).toContain('music_ai');
      expect(serviceNames).toContain('floral_ai');
      expect(serviceNames).toContain('photo_ai');
      expect(serviceNames).toContain('subscription_management');

      // Verify weighted calculations are applied
      result.serviceBreakdown.forEach(service => {
        expect(service.weightedROI).toBeGreaterThan(0);
        expect(service.timeMultiplier).toBeGreaterThan(0);
        expect(service.costMultiplier).toBeGreaterThan(0);
      });
    });

    it('should handle missing service data gracefully', async () => {
      // Mock scenario where some services have no data
      mockSupabase.from
        .mockReturnValueOnce({
          select: jest.fn().mockReturnValue({
            eq: jest.fn().mockResolvedValue({ data: [], error: null })
          })
        })
        .mockReturnValueOnce({
          select: jest.fn().mockReturnValue({
            eq: jest.fn().mockResolvedValue({ data: [], error: null })
          })
        })
        .mockReturnValueOnce({
          select: jest.fn().mockReturnValue({
            eq: jest.fn().mockResolvedValue({ 
              data: [{ photos_analyzed: 5, vision_processing_time_ms: 1000 }], 
              error: null 
            })
          })
        })
        .mockReturnValueOnce({
          select: jest.fn().mockReturnValue({
            eq: jest.fn().mockResolvedValue({ data: [], error: null })
          })
        });

      const result = await trialIntegration.generateCrossTeamROI('test-trial-id');

      expect(result).toBeDefined();
      expect(result.serviceBreakdown.length).toBeLessThanOrEqual(4);
      
      // Should only include services with actual data
      const servicesWithData = result.serviceBreakdown.filter(s => s.totalUsage > 0);
      expect(servicesWithData.length).toBeGreaterThanOrEqual(1);
    });

    it('should apply correct weight multipliers for each service type', () => {
      const weights = (trialIntegration as any).serviceWeights;

      // Verify Music AI weights (time-efficient, cost-effective)
      expect(weights.music_ai.time_multiplier).toBe(1.2);
      expect(weights.music_ai.cost_multiplier).toBe(0.8);
      expect(weights.music_ai.engagement_weight).toBe(0.9);

      // Verify Floral AI weights (time-intensive, higher cost)
      expect(weights.floral_ai.time_multiplier).toBe(1.5);
      expect(weights.floral_ai.cost_multiplier).toBe(1.2);
      expect(weights.floral_ai.engagement_weight).toBe(1.0);

      // Verify Photo AI weights (moderate processing)
      expect(weights.photo_ai.time_multiplier).toBe(1.3);
      expect(weights.photo_ai.cost_multiplier).toBe(0.9);
      expect(weights.photo_ai.engagement_weight).toBe(1.1);

      // Verify Subscription weights (lightweight processing)
      expect(weights.subscription_management.time_multiplier).toBe(0.8);
      expect(weights.subscription_management.cost_multiplier).toBe(1.0);
      expect(weights.subscription_management.engagement_weight).toBe(0.7);
    });
  });

  describe('Business Intelligence Metrics Generation', () => {
    it('should generate comprehensive business intelligence metrics', async () => {
      // Mock aggregated data from multiple sources
      const mockAggregatedData = {
        data: [{
          total_trial_users: 1247,
          active_users_30d: 945,
          conversion_rate: 23.8,
          avg_session_duration: 24.5,
          total_ai_interactions: 15420,
          cross_service_usage_rate: 67.3
        }],
        error: null
      };

      mockSupabase.rpc.mockResolvedValue(mockAggregatedData);

      const result = await trialIntegration.generateBusinessIntelligence();

      expect(result).toBeDefined();
      expect(result.totalTrialUsers).toBe(1247);
      expect(result.conversionMetrics.conversionRate).toBe(23.8);
      expect(result.engagementMetrics.crossServiceUsageRate).toBe(67.3);
      expect(result.performanceMetrics.avgSessionDuration).toBe(24.5);
      expect(mockSupabase.rpc).toHaveBeenCalledWith('get_trial_business_intelligence');
    });

    it('should calculate conversion funnel stages correctly', async () => {
      const mockFunnelData = {
        data: [{
          trial_signups: 2847,
          ai_feature_usage: 2156,
          multiple_services: 1823,
          extension_requests: 945,
          converted_to_paid: 678
        }],
        error: null
      };

      mockSupabase.rpc.mockResolvedValue(mockFunnelData);

      const result = await trialIntegration.generateBusinessIntelligence();

      expect(result.conversionFunnel).toBeDefined();
      expect(result.conversionFunnel.length).toBeGreaterThan(0);
      
      // Verify funnel stages are in descending order (typical conversion pattern)
      const values = result.conversionFunnel.map(stage => stage.value);
      for (let i = 0; i < values.length - 1; i++) {
        expect(values[i]).toBeGreaterThanOrEqual(values[i + 1]);
      }
    });

    it('should handle database errors gracefully in BI generation', async () => {
      mockSupabase.rpc.mockResolvedValue({ data: null, error: { message: 'Database error' } });

      const result = await trialIntegration.generateBusinessIntelligence();

      // Should return default/fallback values instead of throwing
      expect(result).toBeDefined();
      expect(result.totalTrialUsers).toBe(0);
      expect(result.conversionMetrics.conversionRate).toBe(0);
    });
  });

  describe('Helper Methods', () => {
    it('should categorize usage levels correctly', () => {
      const categorizeUsage = (trialIntegration as any).categorizeUsageLevel;

      expect(categorizeUsage(0)).toBe('inactive');
      expect(categorizeUsage(5)).toBe('low');
      expect(categorizeUsage(15)).toBe('medium');
      expect(categorizeUsage(35)).toBe('high');
      expect(categorizeUsage(100)).toBe('very_high');
    });

    it('should calculate conversion indicators correctly', () => {
      const calculateConversionIndicator = (trialIntegration as any).calculateConversionIndicator;

      // Mock usage data for calculation
      const usageData = {
        totalInteractions: 45,
        avgSessionDuration: 18.5,
        servicesUsed: 3,
        daysActive: 12,
        extensionRequests: 1
      };

      const indicator = calculateConversionIndicator(usageData);

      expect(indicator).toBeGreaterThan(0);
      expect(indicator).toBeLessThanOrEqual(100);
    });

    it('should calculate weighted ROI correctly for individual services', () => {
      const calculateServiceROI = (trialIntegration as any).calculateServiceROI;

      const serviceData = {
        totalUsage: 25,
        processingTime: 1500,
        apiCalls: 30,
        serviceName: 'floral_ai'
      };

      const roi = calculateServiceROI(serviceData);

      expect(roi).toBeGreaterThan(0);
      // Floral AI should have higher ROI due to weight multipliers
      expect(roi).toBeGreaterThan(1000); // Base expectation
    });
  });

  describe('Error Handling and Edge Cases', () => {
    it('should handle null trial IDs gracefully', async () => {
      await expect(
        trialIntegration.generateCrossTeamROI('')
      ).rejects.toThrow('Trial ID is required');
    });

    it('should handle database connection errors', async () => {
      mockSupabase.from.mockImplementation(() => {
        throw new Error('Database connection failed');
      });

      await expect(
        trialIntegration.trackMusicAIUsage('trial-id', 'session-id', {})
      ).rejects.toThrow('Database connection failed');
    });

    it('should handle malformed usage data', async () => {
      const malformedData = {
        invalid_field: 'not a number',
        null_value: null,
        undefined_value: undefined
      };

      // Should sanitize data before database insertion
      mockSupabase.from.mockReturnValue({
        insert: jest.fn().mockReturnValue({
          single: jest.fn().mockResolvedValue({ data: {}, error: null }),
        }),
      });

      const result = await trialIntegration.trackMusicAIUsage(
        'test-trial-id',
        'test-session-id',
        malformedData as any
      );

      expect(result).toBeDefined();
    });

    it('should handle concurrent access safely', async () => {
      const promises = Array.from({ length: 10 }, (_, i) =>
        trialIntegration.trackMusicAIUsage(
          `trial-${i}`,
          `session-${i}`,
          { recommendations_generated: i }
        )
      );

      // Mock successful responses for all concurrent calls
      mockSupabase.from.mockReturnValue({
        insert: jest.fn().mockReturnValue({
          single: jest.fn().mockResolvedValue({ data: {}, error: null }),
        }),
      });

      const results = await Promise.all(promises);
      expect(results).toHaveLength(10);
      results.forEach(result => {
        expect(result).toBeDefined();
      });
    });
  });

  describe('Performance Validation', () => {
    it('should complete ROI analysis within performance threshold', async () => {
      // Mock fast database responses
      mockSupabase.from.mockReturnValue({
        select: jest.fn().mockReturnValue({
          eq: jest.fn().mockResolvedValue({ data: [{ usage: 10 }], error: null })
        })
      });

      const startTime = Date.now();
      await trialIntegration.generateCrossTeamROI('test-trial-id');
      const duration = Date.now() - startTime;

      // Should complete within 200ms (as per Round 2 specs)
      expect(duration).toBeLessThan(200);
    });

    it('should handle large datasets efficiently', async () => {
      // Mock large dataset
      const largeDataset = Array.from({ length: 1000 }, (_, i) => ({
        usage_metric: i,
        processing_time: i * 10,
        api_calls: i * 2
      }));

      mockSupabase.from.mockReturnValue({
        select: jest.fn().mockReturnValue({
          eq: jest.fn().mockResolvedValue({ data: largeDataset, error: null })
        })
      });

      const startTime = Date.now();
      const result = await trialIntegration.generateCrossTeamROI('test-trial-id');
      const duration = Date.now() - startTime;

      expect(result).toBeDefined();
      expect(duration).toBeLessThan(1000); // Should handle large datasets within 1 second
    });
  });
});