/**
 * WS-140 Trial Management System - useTrialStatus Hook Unit Tests
 * Comprehensive test suite for useTrialStatus custom hook
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { renderHook, waitFor, cleanup } from '@testing-library/react';
import { useTrialStatus } from '@/hooks/useTrialStatus';
import { TrialStatusResponse, TrialStatus } from '@/types/trial';

// Mock SWR
vi.mock('swr', () => ({
  default: vi.fn()
}));

// Mock Supabase client
vi.mock('@/lib/supabase/client', () => ({
  createClient: vi.fn(() => ({
    channel: vi.fn(() => ({
      on: vi.fn().mockReturnThis(),
      subscribe: vi.fn(() => 'SUBSCRIBED')
    })),
    removeChannel: vi.fn()
  }))
}));

// Mock fetch globally
global.fetch = vi.fn();

const mockTrialData: TrialStatusResponse = {
  success: true,
  trial: {
    id: 'trial-123',
    user_id: 'user-123',
    business_type: 'wedding_planner',
    business_goals: ['save_time', 'grow_business'],
    current_workflow_pain_points: ['manual_tasks', 'communication'],
    expected_time_savings_hours: 10,
    hourly_rate: 75,
    trial_start: new Date('2025-01-01'),
    trial_end: new Date('2025-01-31'),
    status: 'active' as TrialStatus,
    onboarding_completed: true,
    created_at: new Date('2025-01-01'),
    updated_at: new Date('2025-01-01')
  },
  progress: {
    trial_id: 'trial-123',
    days_remaining: 15,
    days_elapsed: 15,
    progress_percentage: 50,
    milestones_achieved: [
      {
        id: 'milestone-1',
        trial_id: 'trial-123',
        milestone_type: 'first_client_connected',
        milestone_name: 'First Client Connected',
        description: 'Successfully add your first client',
        achieved: true,
        achieved_at: new Date('2025-01-10'),
        time_to_achieve_hours: 2,
        value_impact_score: 8,
        created_at: new Date('2025-01-01')
      }
    ],
    milestones_remaining: [
      {
        id: 'milestone-2',
        trial_id: 'trial-123',
        milestone_type: 'initial_journey_created',
        milestone_name: 'Initial Journey Created',
        description: 'Create your first automated journey',
        achieved: false,
        value_impact_score: 9,
        created_at: new Date('2025-01-01')
      }
    ],
    feature_usage_summary: [],
    roi_metrics: {
      trial_id: 'trial-123',
      total_time_saved_hours: 3.5,
      estimated_cost_savings: 262.5,
      productivity_improvement_percent: 25,
      features_adopted_count: 4,
      milestones_achieved_count: 1,
      workflow_efficiency_gain: 30,
      projected_monthly_savings: 500,
      roi_percentage: 125,
      calculated_at: new Date('2025-01-15')
    },
    conversion_recommendation: 'Strong candidate for conversion',
    urgency_score: 3
  },
  recommendations: {
    next_actions: ['Create your first journey', 'Add a vendor partner'],
    upgrade_benefits: ['Unlimited clients', 'Advanced automation'],
    urgency_message: '15 days remaining to continue your progress'
  }
};

// Mock SWR implementation
const mockSWR = vi.fn();
const mockMutate = vi.fn();

describe('useTrialStatus', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    
    // Reset SWR mock to return successful data by default
    mockSWR.mockReturnValue({
      data: mockTrialData,
      error: null,
      isLoading: false,
      mutate: mockMutate
    });
    
    const swrModule = require('swr');
    swrModule.default = mockSWR;
  });

  afterEach(() => {
    cleanup();
  });

  describe('Basic Hook Behavior', () => {
    it('returns trial data when available', () => {
      const { result } = renderHook(() => useTrialStatus());

      expect(result.current.data).toEqual(mockTrialData);
      expect(result.current.progress).toEqual(mockTrialData.progress);
      expect(result.current.status).toBe('active');
      expect(result.current.isLoading).toBe(false);
      expect(result.current.error).toBeNull();
    });

    it('returns derived values correctly', () => {
      const { result } = renderHook(() => useTrialStatus());

      expect(result.current.daysRemaining).toBe(15);
      expect(result.current.progressPercentage).toBe(50);
      expect(result.current.urgencyScore).toBe(3);
      expect(result.current.isTrialActive).toBe(true);
      expect(result.current.isTrialExpired).toBe(false);
      expect(result.current.shouldShowUpgrade).toBe(true); // urgency 3 >= 3
    });

    it('calls SWR with correct parameters', () => {
      renderHook(() => useTrialStatus());

      expect(mockSWR).toHaveBeenCalledWith(
        ['/api/trial/status', 0],
        expect.any(Function),
        expect.objectContaining({
          refreshInterval: 300000, // 5 minutes
          revalidateOnFocus: true,
          revalidateOnReconnect: true,
          errorRetryInterval: 30000,
          dedupingInterval: 10000
        })
      );
    });
  });

  describe('Loading States', () => {
    it('returns loading state when SWR is loading', () => {
      mockSWR.mockReturnValue({
        data: undefined,
        error: null,
        isLoading: true,
        mutate: mockMutate
      });

      const { result } = renderHook(() => useTrialStatus());

      expect(result.current.isLoading).toBe(true);
      expect(result.current.data).toBeNull();
    });

    it('returns default values during loading', () => {
      mockSWR.mockReturnValue({
        data: undefined,
        error: null,
        isLoading: true,
        mutate: mockMutate
      });

      const { result } = renderHook(() => useTrialStatus());

      expect(result.current.daysRemaining).toBe(0);
      expect(result.current.progressPercentage).toBe(0);
      expect(result.current.urgencyScore).toBe(1);
      expect(result.current.status).toBeNull();
      expect(result.current.progress).toBeNull();
    });
  });

  describe('Error States', () => {
    it('returns error when SWR has error', () => {
      const errorMessage = 'Failed to fetch trial status';
      mockSWR.mockReturnValue({
        data: null,
        error: new Error(errorMessage),
        isLoading: false,
        mutate: mockMutate
      });

      const { result } = renderHook(() => useTrialStatus());

      expect(result.current.error).toBe(errorMessage);
      expect(result.current.isLoading).toBe(false);
      expect(result.current.data).toBeNull();
    });

    it('handles error without message', () => {
      const error = {};
      mockSWR.mockReturnValue({
        data: null,
        error,
        isLoading: false,
        mutate: mockMutate
      });

      const { result } = renderHook(() => useTrialStatus());

      expect(result.current.error).toBeNull(); // No message property
    });
  });

  describe('Hook Options', () => {
    it('respects enabled option when false', () => {
      renderHook(() => useTrialStatus({ enabled: false }));

      expect(mockSWR).toHaveBeenCalledWith(
        null, // Should be null when disabled
        expect.any(Function),
        expect.any(Object)
      );
    });

    it('uses custom refresh interval when provided', () => {
      renderHook(() => useTrialStatus({ refreshInterval: 60000 }));

      expect(mockSWR).toHaveBeenCalledWith(
        expect.any(Array),
        expect.any(Function),
        expect.objectContaining({
          refreshInterval: 60000
        })
      );
    });

    it('can disable realtime updates', () => {
      const { result } = renderHook(() => useTrialStatus({ realtimeUpdates: false }));

      // Should still return data but not set up realtime subscriptions
      expect(result.current.data).toEqual(mockTrialData);
    });
  });

  describe('Trial Status Indicators', () => {
    it('identifies active trial correctly', () => {
      const { result } = renderHook(() => useTrialStatus());

      expect(result.current.isTrialActive).toBe(true);
      expect(result.current.isTrialExpired).toBe(false);
    });

    it('identifies expired trial by status', () => {
      const expiredTrialData = {
        ...mockTrialData,
        trial: { ...mockTrialData.trial, status: 'expired' as TrialStatus }
      };

      mockSWR.mockReturnValue({
        data: expiredTrialData,
        error: null,
        isLoading: false,
        mutate: mockMutate
      });

      const { result } = renderHook(() => useTrialStatus());

      expect(result.current.isTrialActive).toBe(false);
      expect(result.current.isTrialExpired).toBe(true);
    });

    it('identifies expired trial by days remaining', () => {
      const expiredTrialData = {
        ...mockTrialData,
        progress: { ...mockTrialData.progress, days_remaining: 0 }
      };

      mockSWR.mockReturnValue({
        data: expiredTrialData,
        error: null,
        isLoading: false,
        mutate: mockMutate
      });

      const { result } = renderHook(() => useTrialStatus());

      expect(result.current.isTrialExpired).toBe(true);
      expect(result.current.daysRemaining).toBe(0);
    });

    it('determines upgrade prompts correctly for high urgency', () => {
      const urgentTrialData = {
        ...mockTrialData,
        progress: { ...mockTrialData.progress, urgency_score: 4 }
      };

      mockSWR.mockReturnValue({
        data: urgentTrialData,
        error: null,
        isLoading: false,
        mutate: mockMutate
      });

      const { result } = renderHook(() => useTrialStatus());

      expect(result.current.shouldShowUpgrade).toBe(true);
      expect(result.current.urgencyScore).toBe(4);
    });

    it('determines upgrade prompts correctly for low days remaining', () => {
      const lowDaysTrialData = {
        ...mockTrialData,
        progress: { 
          ...mockTrialData.progress, 
          days_remaining: 5, 
          urgency_score: 2 
        }
      };

      mockSWR.mockReturnValue({
        data: lowDaysTrialData,
        error: null,
        isLoading: false,
        mutate: mockMutate
      });

      const { result } = renderHook(() => useTrialStatus());

      expect(result.current.shouldShowUpgrade).toBe(true); // 5 days <= 7
      expect(result.current.daysRemaining).toBe(5);
    });

    it('does not show upgrade for low urgency and sufficient days', () => {
      const normalTrialData = {
        ...mockTrialData,
        progress: { 
          ...mockTrialData.progress, 
          days_remaining: 20, 
          urgency_score: 1 
        }
      };

      mockSWR.mockReturnValue({
        data: normalTrialData,
        error: null,
        isLoading: false,
        mutate: mockMutate
      });

      const { result } = renderHook(() => useTrialStatus());

      expect(result.current.shouldShowUpgrade).toBe(false);
    });
  });

  describe('Refresh Functionality', () => {
    it('provides refresh function that calls mutate', () => {
      const { result } = renderHook(() => useTrialStatus());

      expect(typeof result.current.refresh).toBe('function');

      result.current.refresh();

      expect(mockMutate).toHaveBeenCalledTimes(1);
    });

    it('increments realtime updates counter when refresh is called', () => {
      const { result } = renderHook(() => useTrialStatus());

      // Call refresh multiple times
      result.current.refresh();
      result.current.refresh();

      // Should trigger SWR with different counter values
      expect(mockSWR).toHaveBeenCalledTimes(3); // Initial + 2 refreshes
    });
  });

  describe('Data Handling Edge Cases', () => {
    it('handles missing progress data', () => {
      const incompleteData = {
        ...mockTrialData,
        progress: null
      };

      mockSWR.mockReturnValue({
        data: incompleteData,
        error: null,
        isLoading: false,
        mutate: mockMutate
      });

      const { result } = renderHook(() => useTrialStatus());

      expect(result.current.progress).toBeNull();
      expect(result.current.daysRemaining).toBe(0);
      expect(result.current.progressPercentage).toBe(0);
      expect(result.current.urgencyScore).toBe(1);
    });

    it('handles missing trial data', () => {
      const incompleteData = {
        ...mockTrialData,
        trial: null
      };

      mockSWR.mockReturnValue({
        data: incompleteData,
        error: null,
        isLoading: false,
        mutate: mockMutate
      });

      const { result } = renderHook(() => useTrialStatus());

      expect(result.current.status).toBeNull();
      expect(result.current.isTrialActive).toBe(false);
      expect(result.current.isTrialExpired).toBe(true); // No status means expired
    });

    it('handles completely null data', () => {
      mockSWR.mockReturnValue({
        data: null,
        error: null,
        isLoading: false,
        mutate: mockMutate
      });

      const { result } = renderHook(() => useTrialStatus());

      expect(result.current.data).toBeNull();
      expect(result.current.progress).toBeNull();
      expect(result.current.status).toBeNull();
      expect(result.current.daysRemaining).toBe(0);
    });

    it('handles undefined progress fields', () => {
      const incompleteProgress = {
        ...mockTrialData,
        progress: {
          ...mockTrialData.progress,
          days_remaining: undefined,
          progress_percentage: undefined,
          urgency_score: undefined
        }
      };

      mockSWR.mockReturnValue({
        data: incompleteProgress,
        error: null,
        isLoading: false,
        mutate: mockMutate
      });

      const { result } = renderHook(() => useTrialStatus());

      expect(result.current.daysRemaining).toBe(0);
      expect(result.current.progressPercentage).toBe(0);
      expect(result.current.urgencyScore).toBe(1);
    });
  });

  describe('SWR Configuration', () => {
    it('configures SWR with proper error handling', () => {
      renderHook(() => useTrialStatus());

      const swrConfig = mockSWR.mock.calls[0][2];
      expect(swrConfig.errorRetryInterval).toBe(30000);
      expect(swrConfig.dedupingInterval).toBe(10000);
      expect(swrConfig.revalidateOnFocus).toBe(true);
      expect(swrConfig.revalidateOnReconnect).toBe(true);
    });

    it('uses proper cache key with realtime updates', () => {
      const { result } = renderHook(() => useTrialStatus());

      // Call refresh to increment counter
      result.current.refresh();

      // Should have been called with incremented counter
      const lastCall = mockSWR.mock.calls[mockSWR.mock.calls.length - 1];
      expect(lastCall[0]).toEqual(['/api/trial/status', expect.any(Number)]);
    });
  });

  describe('Fetch Function', () => {
    it('creates proper fetch function for SWR', () => {
      renderHook(() => useTrialStatus());

      const fetchFunction = mockSWR.mock.calls[0][1];
      expect(typeof fetchFunction).toBe('function');

      // Test that it extracts URL correctly from array
      const result = fetchFunction(['/api/trial/status', 0]);
      expect(global.fetch).toHaveBeenCalledWith('/api/trial/status');
    });

    it('handles fetch errors properly', async () => {
      (global.fetch as any).mockResolvedValue({
        ok: false,
        json: () => Promise.resolve({ message: 'API Error' })
      });

      renderHook(() => useTrialStatus());

      const fetchFunction = mockSWR.mock.calls[0][1];
      
      await expect(fetchFunction(['/api/trial/status', 0])).rejects.toThrow('API Error');
    });

    it('handles fetch network errors', async () => {
      (global.fetch as any).mockResolvedValue({
        ok: false,
        json: () => Promise.resolve({})
      });

      renderHook(() => useTrialStatus());

      const fetchFunction = mockSWR.mock.calls[0][1];
      
      await expect(fetchFunction(['/api/trial/status', 0])).rejects.toThrow('Failed to fetch trial status');
    });
  });
});