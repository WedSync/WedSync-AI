/**
 * @jest-environment node
 */

import { NextRequest } from 'next/server'
import { GET, POST } from '@/app/api/contracts/route'
import { createClient } from '@/lib/supabase/server'

// Mock Supabase client
jest.mock('@/lib/supabase/server', () => ({
  createClient: jest.fn()
}))

describe('/api/contracts', () => {
  let mockSupabase: any
  let mockUser: any
  let mockProfile: any

  beforeEach(() => {
    mockUser = {
      id: 'user-123',
      email: 'test@example.com'
    }
    
    mockProfile = {
      organization_id: 'org-123'
    }

    mockSupabase = {
      auth: {
        getUser: jest.fn().mockResolvedValue({
          data: { user: mockUser }
        })
      },
      from: jest.fn().mockReturnThis(),
      select: jest.fn().mockReturnThis(),
      eq: jest.fn().mockReturnThis(),
      single: jest.fn().mockResolvedValue({ data: mockProfile }),
      insert: jest.fn().mockReturnThis(),
      range: jest.fn().mockReturnThis(),
      order: jest.fn().mockReturnThis(),
      or: jest.fn().mockReturnThis()
    }

    ;(createClient as jest.Mock).mockResolvedValue(mockSupabase)
  })

  afterEach(() => {
    jest.clearAllMocks()
  })

  describe('GET /api/contracts', () => {
    it('should return contracts for authenticated user', async () => {
      const mockContracts = [
        {
          id: 'contract-1',
          title: 'Wedding Photography',
          contract_number: 'CON-2025-001',
          total_amount: 2500.00,
          status: 'active'
        }
      ]

      // Mock the contracts query chain
      mockSupabase.single = jest.fn()
        .mockResolvedValueOnce({ data: mockProfile })
        .mockResolvedValue({ data: mockContracts, error: null, count: 1 })

      const request = new NextRequest('http://localhost/api/contracts?page=1&limit=10')
      const response = await GET(request)
      const data = await response.json()

      expect(response.status).toBe(200)
      expect(data.contracts).toEqual(mockContracts)
      expect(data.total).toBe(1)
      expect(data.page).toBe(1)
      expect(data.totalPages).toBe(1)
    })

    it('should filter contracts by status', async () => {
      const mockContracts = [
        {
          id: 'contract-1',
          status: 'active',
          title: 'Test Contract'
        }
      ]

      mockSupabase.single = jest.fn()
        .mockResolvedValueOnce({ data: mockProfile })
        .mockResolvedValue({ data: mockContracts, error: null, count: 1 })

      const request = new NextRequest('http://localhost/api/contracts?status=active')
      const response = await GET(request)

      expect(response.status).toBe(200)
      expect(mockSupabase.eq).toHaveBeenCalledWith('status', 'active')
    })

    it('should handle search queries', async () => {
      mockSupabase.single = jest.fn()
        .mockResolvedValueOnce({ data: mockProfile })
        .mockResolvedValue({ data: [], error: null, count: 0 })

      const request = new NextRequest('http://localhost/api/contracts?search=photography')
      const response = await GET(request)

      expect(response.status).toBe(200)
      expect(mockSupabase.or).toHaveBeenCalledWith('title.ilike.%photography%,contract_number.ilike.%photography%')
    })

    it('should return 401 for unauthenticated requests', async () => {
      mockSupabase.auth.getUser.mockResolvedValue({
        data: { user: null }
      })

      const request = new NextRequest('http://localhost/api/contracts')
      const response = await GET(request)
      const data = await response.json()

      expect(response.status).toBe(401)
      expect(data.error).toBe('Unauthorized')
    })

    it('should return 404 when profile not found', async () => {
      mockSupabase.single.mockResolvedValue({ data: null })

      const request = new NextRequest('http://localhost/api/contracts')
      const response = await GET(request)
      const data = await response.json()

      expect(response.status).toBe(404)
      expect(data.error).toBe('Profile not found')
    })

    it('should handle database errors gracefully', async () => {
      mockSupabase.single = jest.fn()
        .mockResolvedValueOnce({ data: mockProfile })
        .mockResolvedValue({ data: null, error: { message: 'Database error' }, count: null })

      const request = new NextRequest('http://localhost/api/contracts')
      const response = await GET(request)
      const data = await response.json()

      expect(response.status).toBe(500)
      expect(data.error).toBe('Failed to fetch contracts')
    })
  })

  describe('POST /api/contracts', () => {
    const validContractData = {
      client_id: 'client-123',
      supplier_id: 'supplier-123',
      category_id: 'category-123',
      title: 'Wedding Photography Contract',
      description: 'Professional wedding photography services',
      contract_type: 'vendor_service',
      total_amount: 2500.00,
      currency: 'GBP',
      deposit_amount: 500.00,
      deposit_percentage: 20,
      contract_date: '2025-01-15T00:00:00.000Z',
      service_start_date: '2025-06-15T00:00:00.000Z',
      service_end_date: '2025-06-15T23:59:59.000Z',
      terms_conditions: 'Standard terms and conditions',
      privacy_policy_accepted: true,
      gdpr_consent: true
    }

    beforeEach(() => {
      // Mock successful contract creation
      mockSupabase.single = jest.fn()
        .mockResolvedValueOnce({ data: mockProfile }) // Profile lookup
        .mockResolvedValueOnce({ // Contract creation
          data: { 
            id: 'contract-123',
            ...validContractData,
            contract_number: 'CON-2025-001',
            organization_id: 'org-123'
          }
        })

      mockSupabase.insert = jest.fn().mockReturnValue({
        select: jest.fn().mockReturnValue({
          single: jest.fn().mockResolvedValue({
            data: { 
              id: 'contract-123',
              ...validContractData,
              contract_number: 'CON-2025-001'
            }
          })
        })
      })
    })

    it('should create a contract successfully', async () => {
      const request = new NextRequest('http://localhost/api/contracts', {
        method: 'POST',
        body: JSON.stringify(validContractData)
      })

      const response = await POST(request)
      const data = await response.json()

      expect(response.status).toBe(201)
      expect(data.contract).toBeDefined()
      expect(data.contract.title).toBe(validContractData.title)
      expect(data.contract.total_amount).toBe(validContractData.total_amount)
    })

    it('should create payment milestones when deposit amount provided', async () => {
      const request = new NextRequest('http://localhost/api/contracts', {
        method: 'POST',
        body: JSON.stringify(validContractData)
      })

      await POST(request)

      // Verify milestone creation calls
      expect(mockSupabase.from).toHaveBeenCalledWith('contract_payment_milestones')
      expect(mockSupabase.insert).toHaveBeenCalledWith(
        expect.objectContaining({
          milestone_name: 'Deposit Payment',
          milestone_type: 'deposit',
          amount: validContractData.deposit_amount,
          sequence_order: 1
        })
      )
      expect(mockSupabase.insert).toHaveBeenCalledWith(
        expect.objectContaining({
          milestone_name: 'Final Payment',
          milestone_type: 'final_payment',
          sequence_order: 2
        })
      )
    })

    it('should validate required fields', async () => {
      const invalidData = { ...validContractData }
      delete invalidData.client_id
      delete invalidData.title

      const request = new NextRequest('http://localhost/api/contracts', {
        method: 'POST',
        body: JSON.stringify(invalidData)
      })

      const response = await POST(request)
      const data = await response.json()

      expect(response.status).toBe(400)
      expect(data.error).toBe('Invalid input')
      expect(data.details).toBeDefined()
    })

    it('should validate contract type enum', async () => {
      const invalidData = { ...validContractData, contract_type: 'invalid_type' }

      const request = new NextRequest('http://localhost/api/contracts', {
        method: 'POST',
        body: JSON.stringify(invalidData)
      })

      const response = await POST(request)
      const data = await response.json()

      expect(response.status).toBe(400)
      expect(data.error).toBe('Invalid input')
    })

    it('should validate positive amounts', async () => {
      const invalidData = { ...validContractData, total_amount: -100 }

      const request = new NextRequest('http://localhost/api/contracts', {
        method: 'POST',
        body: JSON.stringify(invalidData)
      })

      const response = await POST(request)
      const data = await response.json()

      expect(response.status).toBe(400)
      expect(data.error).toBe('Invalid input')
    })

    it('should validate currency format', async () => {
      const invalidData = { ...validContractData, currency: 'GBPX' }

      const request = new NextRequest('http://localhost/api/contracts', {
        method: 'POST',
        body: JSON.stringify(invalidData)
      })

      const response = await POST(request)
      const data = await response.json()

      expect(response.status).toBe(400)
      expect(data.error).toBe('Invalid input')
    })

    it('should return 401 for unauthenticated requests', async () => {
      mockSupabase.auth.getUser.mockResolvedValue({
        data: { user: null }
      })

      const request = new NextRequest('http://localhost/api/contracts', {
        method: 'POST',
        body: JSON.stringify(validContractData)
      })

      const response = await POST(request)
      const data = await response.json()

      expect(response.status).toBe(401)
      expect(data.error).toBe('Unauthorized')
    })

    it('should handle database insertion errors', async () => {
      mockSupabase.insert = jest.fn().mockReturnValue({
        select: jest.fn().mockReturnValue({
          single: jest.fn().mockResolvedValue({
            error: { message: 'Database constraint violation' }
          })
        })
      })

      const request = new NextRequest('http://localhost/api/contracts', {
        method: 'POST',
        body: JSON.stringify(validContractData)
      })

      const response = await POST(request)
      const data = await response.json()

      expect(response.status).toBe(500)
      expect(data.error).toBe('Failed to create contract')
    })

    it('should calculate balance amount correctly', async () => {
      const request = new NextRequest('http://localhost/api/contracts', {
        method: 'POST',
        body: JSON.stringify(validContractData)
      })

      await POST(request)

      expect(mockSupabase.insert).toHaveBeenCalledWith(
        expect.objectContaining({
          balance_amount: validContractData.total_amount - validContractData.deposit_amount!
        })
      )
    })

    it('should handle missing deposit amount', async () => {
      const dataWithoutDeposit = { ...validContractData }
      delete dataWithoutDeposit.deposit_amount
      delete dataWithoutDeposit.deposit_percentage

      const request = new NextRequest('http://localhost/api/contracts', {
        method: 'POST',
        body: JSON.stringify(dataWithoutDeposit)
      })

      await POST(request)

      expect(mockSupabase.insert).toHaveBeenCalledWith(
        expect.objectContaining({
          balance_amount: validContractData.total_amount
        })
      )
    })
  })
})