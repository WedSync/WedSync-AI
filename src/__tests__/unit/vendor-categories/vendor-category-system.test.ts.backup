import { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest'
import { createClient } from '@supabase/supabase-js'

// Mock environment variables for testing
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || 'http://localhost:54321'
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY || 'mock-service-key'

// Test database client
const supabase = createClient(supabaseUrl, supabaseServiceKey)

interface VendorCategory {
  id: string
  name: string
  slug: string
  display_name: string
  description: string
  icon: string
  color?: string
  parent_id?: string
  category_level: number
  full_path: string
  sort_order: number
  is_active: boolean
  is_featured: boolean
  search_keywords: string[]
  created_at: string
  updated_at: string
}

describe('Vendor Category System', () => {
  let testCategoryIds: string[] = []

  beforeAll(async () => {
    // Ensure test database is clean
    await cleanupTestData()
  })

  afterAll(async () => {
    // Clean up test data
    await cleanupTestData()
  })

  beforeEach(() => {
    testCategoryIds = []
  })

  const cleanupTestData = async () => {
    // Clean up test categories
    if (testCategoryIds.length > 0) {
      await supabase
        .from('vendor_categories')
        .delete()
        .in('id', testCategoryIds)
    }
  }

  describe('Category Hierarchy Structure', () => {
    it('should create top-level category correctly', async () => {
      const categoryData = {
        name: 'test_photography',
        slug: 'test-photography',
        display_name: 'Test Photography',
        description: 'Test photography services',
        icon: 'camera',
        color: '#3B82F6',
        sort_order: 100,
        is_active: true,
        is_featured: false,
        search_keywords: ['test', 'photography']
      }

      const { data, error } = await supabase
        .from('vendor_categories')
        .insert([categoryData])
        .select()
        .single()

      expect(error).toBeNull()
      expect(data).toBeDefined()
      expect(data.name).toBe('test_photography')
      expect(data.category_level).toBe(1)
      expect(data.full_path).toBe('test_photography')
      expect(data.parent_id).toBeNull()

      testCategoryIds.push(data.id)
    })

    it('should create subcategory correctly', async () => {
      // First create parent category
      const parentData = {
        name: 'test_parent',
        slug: 'test-parent',
        display_name: 'Test Parent',
        description: 'Test parent category',
        icon: 'folder',
        sort_order: 101
      }

      const { data: parent, error: parentError } = await supabase
        .from('vendor_categories')
        .insert([parentData])
        .select()
        .single()

      expect(parentError).toBeNull()
      testCategoryIds.push(parent.id)

      // Create subcategory
      const subcategoryData = {
        name: 'test_subcategory',
        slug: 'test-subcategory',
        display_name: 'Test Subcategory',
        description: 'Test subcategory',
        icon: 'camera',
        parent_id: parent.id,
        sort_order: 1
      }

      const { data: sub, error: subError } = await supabase
        .from('vendor_categories')
        .insert([subcategoryData])
        .select()
        .single()

      expect(subError).toBeNull()
      expect(sub.parent_id).toBe(parent.id)
      expect(sub.category_level).toBe(2)
      expect(sub.full_path).toBe('test_parent > test_subcategory')

      testCategoryIds.push(sub.id)
    })
  })

  describe('Category Search Functionality', () => {
    let searchTestCategoryId: string

    beforeEach(async () => {
      // Create test category for search
      const categoryData = {
        name: 'search_test_category',
        slug: 'search-test-category',
        display_name: 'Search Test Photography',
        description: 'Professional wedding photography services for testing search',
        icon: 'camera',
        search_keywords: ['wedding', 'professional', 'portrait', 'ceremony']
      }

      const { data, error } = await supabase
        .from('vendor_categories')
        .insert([categoryData])
        .select()
        .single()

      expect(error).toBeNull()
      searchTestCategoryId = data.id
      testCategoryIds.push(data.id)
    })

    it('should search by name', async () => {
      const { data, error } = await supabase
        .rpc('search_vendor_categories', { search_term: 'Search Test' })

      expect(error).toBeNull()
      expect(data).toBeDefined()
      expect(data.length).toBeGreaterThan(0)
      
      const found = data.find((cat: any) => cat.id === searchTestCategoryId)
      expect(found).toBeDefined()
      expect(found.relevance_score).toBeGreaterThan(0)
    })

    it('should search by keywords', async () => {
      const { data, error } = await supabase
        .rpc('search_vendor_categories', { search_term: 'wedding' })

      expect(error).toBeNull()
      expect(data).toBeDefined()
      
      const found = data.find((cat: any) => cat.id === searchTestCategoryId)
      expect(found).toBeDefined()
      expect(found.relevance_score).toBeGreaterThan(0)
    })

    it('should search by description', async () => {
      const { data, error } = await supabase
        .rpc('search_vendor_categories', { search_term: 'professional' })

      expect(error).toBeNull()
      expect(data).toBeDefined()
      
      const found = data.find((cat: any) => cat.id === searchTestCategoryId)
      expect(found).toBeDefined()
    })

    it('should return results in relevance order', async () => {
      const { data, error } = await supabase
        .rpc('search_vendor_categories', { search_term: 'photography' })

      expect(error).toBeNull()
      expect(data).toBeDefined()
      
      // Results should be ordered by relevance_score DESC
      for (let i = 1; i < data.length; i++) {
        expect(data[i - 1].relevance_score).toBeGreaterThanOrEqual(data[i].relevance_score)
      }
    })
  })

  describe('Category Hierarchy Functions', () => {
    let hierarchyTestIds: string[] = []

    beforeEach(async () => {
      // Create hierarchy for testing
      const parentData = {
        name: 'hierarchy_test_parent',
        slug: 'hierarchy-test-parent',
        display_name: 'Hierarchy Test Parent',
        description: 'Parent category for hierarchy testing',
        icon: 'folder',
        sort_order: 200
      }

      const { data: parent, error: parentError } = await supabase
        .from('vendor_categories')
        .insert([parentData])
        .select()
        .single()

      expect(parentError).toBeNull()
      hierarchyTestIds.push(parent.id)
      testCategoryIds.push(parent.id)

      // Create subcategories
      const subcategories = [
        {
          name: 'hierarchy_sub1',
          slug: 'hierarchy-sub1',
          display_name: 'Hierarchy Sub 1',
          description: 'First subcategory',
          icon: 'camera',
          parent_id: parent.id,
          sort_order: 1
        },
        {
          name: 'hierarchy_sub2',
          slug: 'hierarchy-sub2',
          display_name: 'Hierarchy Sub 2',
          description: 'Second subcategory',
          icon: 'video',
          parent_id: parent.id,
          sort_order: 2
        }
      ]

      for (const subData of subcategories) {
        const { data: sub, error: subError } = await supabase
          .from('vendor_categories')
          .insert([subData])
          .select()
          .single()

        expect(subError).toBeNull()
        hierarchyTestIds.push(sub.id)
        testCategoryIds.push(sub.id)
      }
    })

    it('should return proper hierarchy structure', async () => {
      const { data, error } = await supabase
        .rpc('get_category_hierarchy')

      expect(error).toBeNull()
      expect(data).toBeDefined()

      // Find our test parent category
      const parent = data.find((cat: any) => 
        cat.name === 'hierarchy_test_parent'
      )

      expect(parent).toBeDefined()
      expect(parent.subcategories).toBeDefined()
      expect(parent.subcategories.length).toBe(2)
      
      // Check subcategories are properly nested
      const sub1 = parent.subcategories.find((sub: any) => sub.name === 'hierarchy_sub1')
      const sub2 = parent.subcategories.find((sub: any) => sub.name === 'hierarchy_sub2')
      
      expect(sub1).toBeDefined()
      expect(sub2).toBeDefined()
      
      // Check sort order
      expect(sub1.sort_order).toBeLessThan(sub2.sort_order)
    })
  })

  describe('Category Filtering', () => {
    let filterTestIds: string[] = []

    beforeEach(async () => {
      // Create test categories with different properties
      const testCategories = [
        {
          name: 'filter_active',
          slug: 'filter-active',
          display_name: 'Filter Active',
          description: 'Active category for filtering',
          icon: 'camera',
          is_active: true,
          is_featured: false,
          sort_order: 300
        },
        {
          name: 'filter_inactive',
          slug: 'filter-inactive',
          display_name: 'Filter Inactive',
          description: 'Inactive category for filtering',
          icon: 'video',
          is_active: false,
          is_featured: false,
          sort_order: 301
        },
        {
          name: 'filter_featured',
          slug: 'filter-featured',
          display_name: 'Filter Featured',
          description: 'Featured category for filtering',
          icon: 'star',
          is_active: true,
          is_featured: true,
          sort_order: 302
        }
      ]

      for (const categoryData of testCategories) {
        const { data, error } = await supabase
          .from('vendor_categories')
          .insert([categoryData])
          .select()
          .single()

        expect(error).toBeNull()
        filterTestIds.push(data.id)
        testCategoryIds.push(data.id)
      }
    })

    it('should filter by active status', async () => {
      const { data, error } = await supabase
        .from('vendor_categories')
        .select('*')
        .eq('is_active', true)
        .in('id', filterTestIds)

      expect(error).toBeNull()
      expect(data).toBeDefined()
      expect(data.length).toBe(2) // Active and featured categories
      
      data.forEach((cat: any) => {
        expect(cat.is_active).toBe(true)
      })
    })

    it('should filter by featured status', async () => {
      const { data, error } = await supabase
        .from('vendor_categories')
        .select('*')
        .eq('is_featured', true)
        .in('id', filterTestIds)

      expect(error).toBeNull()
      expect(data).toBeDefined()
      expect(data.length).toBe(1)
      expect(data[0].name).toBe('filter_featured')
    })

    it('should filter by category level', async () => {
      const { data, error } = await supabase
        .from('vendor_categories')
        .select('*')
        .eq('category_level', 1)
        .in('id', filterTestIds)

      expect(error).toBeNull()
      expect(data).toBeDefined()
      
      data.forEach((cat: any) => {
        expect(cat.category_level).toBe(1)
        expect(cat.parent_id).toBeNull()
      })
    })
  })

  describe('Category Attributes System', () => {
    let attributeTestCategoryId: string

    beforeEach(async () => {
      // Create test category
      const categoryData = {
        name: 'attribute_test_category',
        slug: 'attribute-test-category',
        display_name: 'Attribute Test Category',
        description: 'Category for testing attributes',
        icon: 'camera',
        sort_order: 400
      }

      const { data, error } = await supabase
        .from('vendor_categories')
        .insert([categoryData])
        .select()
        .single()

      expect(error).toBeNull()
      attributeTestCategoryId = data.id
      testCategoryIds.push(data.id)
    })

    it('should create category attributes', async () => {
      const attributeData = {
        category_id: attributeTestCategoryId,
        attribute_name: 'photography_style',
        attribute_type: 'select',
        is_required: true,
        options: ['traditional', 'modern', 'artistic', 'documentary'],
        sort_order: 1
      }

      const { data, error } = await supabase
        .from('vendor_category_attributes')
        .insert([attributeData])
        .select()
        .single()

      expect(error).toBeNull()
      expect(data).toBeDefined()
      expect(data.category_id).toBe(attributeTestCategoryId)
      expect(data.attribute_name).toBe('photography_style')
      expect(data.attribute_type).toBe('select')
      expect(data.is_required).toBe(true)
      expect(data.options).toEqual(['traditional', 'modern', 'artistic', 'documentary'])
    })

    it('should prevent duplicate attribute names per category', async () => {
      // Create first attribute
      const attributeData1 = {
        category_id: attributeTestCategoryId,
        attribute_name: 'duplicate_test',
        attribute_type: 'text',
        sort_order: 1
      }

      const { error: error1 } = await supabase
        .from('vendor_category_attributes')
        .insert([attributeData1])

      expect(error1).toBeNull()

      // Try to create duplicate
      const attributeData2 = {
        category_id: attributeTestCategoryId,
        attribute_name: 'duplicate_test',
        attribute_type: 'number',
        sort_order: 2
      }

      const { error: error2 } = await supabase
        .from('vendor_category_attributes')
        .insert([attributeData2])

      expect(error2).toBeDefined()
      expect(error2?.code).toBe('23505') // Unique constraint violation
    })
  })

  describe('Database Performance', () => {
    it('should use indexes for category search', async () => {
      // Test that search keywords index is being used
      const { data, error } = await supabase
        .from('vendor_categories')
        .select('*')
        .contains('search_keywords', ['photography'])

      expect(error).toBeNull()
      expect(data).toBeDefined()
    })

    it('should use indexes for parent-child relationships', async () => {
      // Create parent and multiple children to test index usage
      const parentData = {
        name: 'performance_parent',
        slug: 'performance-parent',
        display_name: 'Performance Parent',
        icon: 'folder',
        sort_order: 500
      }

      const { data: parent, error: parentError } = await supabase
        .from('vendor_categories')
        .insert([parentData])
        .select()
        .single()

      expect(parentError).toBeNull()
      testCategoryIds.push(parent.id)

      // Create multiple children
      const children = Array.from({ length: 10 }, (_, i) => ({
        name: `performance_child_${i}`,
        slug: `performance-child-${i}`,
        display_name: `Performance Child ${i}`,
        icon: 'camera',
        parent_id: parent.id,
        sort_order: i
      }))

      const { data: childrenData, error: childrenError } = await supabase
        .from('vendor_categories')
        .insert(children)
        .select()

      expect(childrenError).toBeNull()
      testCategoryIds.push(...childrenData.map(c => c.id))

      // Query children - should use parent_id index
      const { data: queriedChildren, error: queryError } = await supabase
        .from('vendor_categories')
        .select('*')
        .eq('parent_id', parent.id)
        .order('sort_order')

      expect(queryError).toBeNull()
      expect(queriedChildren).toBeDefined()
      expect(queriedChildren.length).toBe(10)
    })
  })
})