/**
 * Unit Tests for GDPR Data Processor
 * WS-176 - GDPR Compliance System
 * 
 * Comprehensive test suite for data subject access requests,
 * data export, portability, and rectification operations.
 */

import { describe, it, expect, beforeEach, jest, afterEach } from '@jest/globals';
import { DataProcessor } from '@/lib/gdpr/data-processor';
import { 
  DataSubjectRights,
  RequestStatus,
  SecurityContext 
} from '@/types/gdpr';

// Mock Supabase client
const mockSupabaseClient = {
  from: jest.fn().mockReturnThis(),
  select: jest.fn().mockReturnThis(),
  insert: jest.fn().mockReturnThis(),
  update: jest.fn().mockReturnThis(),
  upsert: jest.fn().mockReturnThis(),
  eq: jest.fn().mockReturnThis(),
  match: jest.fn().mockReturnThis(),
  single: jest.fn(),
};

jest.mock('@/lib/supabase/server', () => ({
  createClient: () => mockSupabaseClient
}));

describe('DataProcessor', () => {
  let dataProcessor: DataProcessor;
  let mockSecurityContext: SecurityContext;

  beforeEach(() => {
    jest.clearAllMocks();
    dataProcessor = new DataProcessor();
    
    mockSecurityContext = {
      user_id: 'test-user-id',
      session_id: 'test-session-id',
      ip_address_hash: 'hashed-ip',
      user_agent_hash: 'hashed-user-agent',
      timestamp: new Date(),
      api_endpoint: '/api/gdpr/data-request',
      rate_limit_key: 'test-rate-limit-key'
    };
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  describe('submitDataSubjectRequest', () => {
    it('should submit data access request successfully', async () => {
      // Mock user existence check
      mockSupabaseClient.single.mockResolvedValueOnce({
        data: { id: 'test-user-id', email: 'test@example.com' },
        error: null
      });

      // Mock successful request insertion
      const mockRequest = {
        id: 'request-id',
        user_id: 'test-user-id',
        request_type: DataSubjectRights.ACCESS,
        status: RequestStatus.SUBMITTED,
        submitted_at: new Date().toISOString(),
        verification_token: 'mock-token',
        verification_expires_at: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };

      mockSupabaseClient.single.mockResolvedValueOnce({
        data: mockRequest,
        error: null
      });

      const result = await dataProcessor.submitDataSubjectRequest(
        'test-user-id',
        DataSubjectRights.ACCESS,
        mockSecurityContext,
        { reason: 'Want to see my data' }
      );

      expect(result.success).toBe(true);
      expect(result.data?.request_type).toBe(DataSubjectRights.ACCESS);
      expect(result.data?.status).toBe(RequestStatus.SUBMITTED);
      expect(result.data?.verification_token).toBeDefined();
    });

    it('should handle non-existent user', async () => {
      mockSupabaseClient.single.mockResolvedValueOnce({
        data: null,
        error: { message: 'User not found' }
      });

      const result = await dataProcessor.submitDataSubjectRequest(
        'non-existent-user',
        DataSubjectRights.ACCESS,
        mockSecurityContext
      );

      expect(result.success).toBe(false);
      expect(result.error?.code).toBe('USER_NOT_FOUND');
    });

    it('should handle database insertion errors', async () => {
      mockSupabaseClient.single.mockResolvedValueOnce({
        data: { id: 'test-user-id', email: 'test@example.com' },
        error: null
      });

      mockSupabaseClient.single.mockResolvedValueOnce({
        data: null,
        error: { message: 'Database constraint violation' }
      });

      const result = await dataProcessor.submitDataSubjectRequest(
        'test-user-id',
        DataSubjectRights.ACCESS,
        mockSecurityContext
      );

      expect(result.success).toBe(false);
      expect(result.error?.code).toBe('DATABASE_ERROR');
    });

    it('should generate unique verification tokens', async () => {
      mockSupabaseClient.single.mockResolvedValueOnce({
        data: { id: 'test-user-id', email: 'test@example.com' },
        error: null
      });

      const insertMock = jest.fn().mockResolvedValue({
        data: { id: 'request-id' },
        error: null
      });
      
      mockSupabaseClient.insert.mockImplementation(insertMock);
      mockSupabaseClient.single.mockResolvedValueOnce({
        data: { id: 'request-id' },
        error: null
      });

      await dataProcessor.submitDataSubjectRequest(
        'test-user-id',
        DataSubjectRights.ACCESS,
        mockSecurityContext
      );

      const insertCall = insertMock.mock.calls[0][0];
      expect(insertCall.verification_token).toMatch(/^[a-f0-9]{64}$/); // 64-char hex string
      expect(insertCall.verification_expires_at).toBeDefined();
    });
  });

  describe('verifyAndProcessRequest', () => {
    it('should verify and process valid request', async () => {
      const validRequest = {
        id: 'request-id',
        user_id: 'test-user-id',
        request_type: DataSubjectRights.ACCESS,
        verification_token: 'valid-token',
        verification_expires_at: new Date(Date.now() + 60 * 60 * 1000).toISOString(), // 1 hour from now
        submitted_at: new Date().toISOString()
      };

      mockSupabaseClient.single.mockResolvedValueOnce({
        data: validRequest,
        error: null
      });

      mockSupabaseClient.single.mockResolvedValueOnce({
        data: { ...validRequest, status: RequestStatus.IN_PROGRESS },
        error: null
      });

      // Mock data collection methods
      jest.spyOn(dataProcessor as any, 'processDataSubjectRequest').mockResolvedValue(undefined);

      const result = await dataProcessor.verifyAndProcessRequest(
        'request-id',
        'valid-token',
        mockSecurityContext
      );

      expect(result.success).toBe(true);
      expect(result.data?.status).toBe(RequestStatus.IN_PROGRESS);
    });

    it('should reject invalid verification token', async () => {
      mockSupabaseClient.single.mockResolvedValueOnce({
        data: null,
        error: { message: 'No matching request' }
      });

      const result = await dataProcessor.verifyAndProcessRequest(
        'request-id',
        'invalid-token',
        mockSecurityContext
      );

      expect(result.success).toBe(false);
      expect(result.error?.code).toBe('VERIFICATION_FAILED');
    });

    it('should reject expired verification token', async () => {
      const expiredRequest = {
        id: 'request-id',
        user_id: 'test-user-id',
        request_type: DataSubjectRights.ACCESS,
        verification_token: 'expired-token',
        verification_expires_at: new Date(Date.now() - 60 * 60 * 1000).toISOString() // 1 hour ago
      };

      mockSupabaseClient.single.mockResolvedValueOnce({
        data: expiredRequest,
        error: null
      });

      const result = await dataProcessor.verifyAndProcessRequest(
        'request-id',
        'expired-token',
        mockSecurityContext
      );

      expect(result.success).toBe(false);
      expect(result.error?.code).toBe('VERIFICATION_EXPIRED');
    });

    it('should clear verification token after successful verification', async () => {
      const validRequest = {
        id: 'request-id',
        user_id: 'test-user-id',
        request_type: DataSubjectRights.ACCESS,
        verification_token: 'valid-token',
        verification_expires_at: new Date(Date.now() + 60 * 60 * 1000).toISOString()
      };

      mockSupabaseClient.single.mockResolvedValueOnce({
        data: validRequest,
        error: null
      });

      const updateMock = jest.fn().mockResolvedValue({
        data: { ...validRequest, verification_token: null },
        error: null
      });
      
      mockSupabaseClient.update.mockImplementation(updateMock);
      mockSupabaseClient.single.mockResolvedValueOnce({
        data: { ...validRequest, verification_token: null },
        error: null
      });

      jest.spyOn(dataProcessor as any, 'processDataSubjectRequest').mockResolvedValue(undefined);

      await dataProcessor.verifyAndProcessRequest(
        'request-id',
        'valid-token',
        mockSecurityContext
      );

      const updateCall = updateMock.mock.calls[0][0];
      expect(updateCall.verification_token).toBeNull();
      expect(updateCall.verification_expires_at).toBeNull();
    });
  });

  describe('processAccessRequest', () => {
    it('should collect comprehensive user data', async () => {
      // Mock data collection methods
      jest.spyOn(dataProcessor as any, 'collectPersonalData').mockResolvedValue({
        name: 'Test User',
        email: 'test@example.com',
        phone: '+1234567890'
      });

      jest.spyOn(dataProcessor as any, 'collectContactData').mockResolvedValue({
        emails: [],
        phone_numbers: [],
        addresses: []
      });

      jest.spyOn(dataProcessor as any, 'collectWeddingData').mockResolvedValue({
        weddings: []
      });

      jest.spyOn(dataProcessor as any, 'collectCommunicationData').mockResolvedValue({
        messages: [],
        notifications: []
      });

      jest.spyOn(dataProcessor as any, 'collectUsageData').mockResolvedValue({
        sessions: [],
        feature_usage: {}
      });

      jest.spyOn(dataProcessor as any, 'collectTechnicalData').mockResolvedValue({
        device_info: [],
        api_usage: []
      });

      const result = await (dataProcessor as any).processAccessRequest('test-user-id');

      expect(result).toBeDefined();
      expect(result.user_id).toBe('test-user-id');
      expect(result.export_date).toBeInstanceOf(Date);
      expect(result.data).toBeDefined();
      expect(result.data.personal_details).toBeDefined();
      expect(result.metadata).toBeDefined();
      expect(result.metadata.export_version).toBe('1.0');
    });

    it('should handle missing data categories gracefully', async () => {
      // Mock some data collection methods returning null
      jest.spyOn(dataProcessor as any, 'collectPersonalData').mockResolvedValue(null);
      jest.spyOn(dataProcessor as any, 'collectContactData').mockResolvedValue(null);
      jest.spyOn(dataProcessor as any, 'collectWeddingData').mockResolvedValue({
        weddings: [{ id: 'wedding-1', title: 'Test Wedding' }]
      });
      jest.spyOn(dataProcessor as any, 'collectCommunicationData').mockResolvedValue(null);
      jest.spyOn(dataProcessor as any, 'collectUsageData').mockResolvedValue(null);
      jest.spyOn(dataProcessor as any, 'collectTechnicalData').mockResolvedValue(null);

      const result = await (dataProcessor as any).processAccessRequest('test-user-id');

      expect(result.data_categories).toContain('wedding_info');
      expect(result.data_categories).not.toContain('personal_details');
      expect(result.data.wedding_info).toBeDefined();
      expect(result.data.personal_details).toBeNull();
    });
  });

  describe('processPortabilityRequest', () => {
    it('should return structured data suitable for portability', async () => {
      jest.spyOn(dataProcessor as any, 'processAccessRequest').mockResolvedValue({
        user_id: 'test-user-id',
        export_date: new Date(),
        data_categories: ['personal_details'],
        data: {
          personal_details: { name: 'Test User' }
        },
        metadata: { export_version: '1.0' }
      });

      const result = await (dataProcessor as any).processPortabilityRequest('test-user-id');

      expect(result).toBeDefined();
      expect(result.user_id).toBe('test-user-id');
    });
  });

  describe('processRestrictionRequest', () => {
    it('should add processing restriction', async () => {
      mockSupabaseClient.single.mockResolvedValueOnce({
        data: { id: 'restriction-id' },
        error: null
      });

      const result = await (dataProcessor as any).processRestrictionRequest('test-user-id');

      expect(result).toBeDefined();
      expect(result.message).toContain('Processing restriction applied');
    });
  });

  describe('getRequestStatus', () => {
    it('should return request status for valid request', async () => {
      const mockRequest = {
        id: 'request-id',
        user_id: 'test-user-id',
        request_type: DataSubjectRights.ACCESS,
        status: RequestStatus.COMPLETED,
        submitted_at: new Date().toISOString(),
        completed_at: new Date().toISOString(),
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };

      mockSupabaseClient.single.mockResolvedValueOnce({
        data: mockRequest,
        error: null
      });

      const result = await dataProcessor.getRequestStatus(
        'request-id',
        'test-user-id'
      );

      expect(result.success).toBe(true);
      expect(result.data?.status).toBe(RequestStatus.COMPLETED);
    });

    it('should return error for unauthorized access', async () => {
      mockSupabaseClient.single.mockResolvedValueOnce({
        data: null,
        error: { message: 'Not found' }
      });

      const result = await dataProcessor.getRequestStatus(
        'request-id',
        'wrong-user-id'
      );

      expect(result.success).toBe(false);
      expect(result.error?.code).toBe('REQUEST_NOT_FOUND');
    });
  });

  describe('Data collection methods', () => {
    it('should collect personal data properly', async () => {
      const mockProfile = {
        id: 'test-user-id',
        name: 'John Doe',
        email: 'john@example.com',
        phone: '+1234567890',
        date_of_birth: '1990-01-01',
        address: {
          street: '123 Main St',
          city: 'Anytown',
          postal_code: '12345',
          country: 'US'
        },
        preferences: { theme: 'dark' },
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };

      mockSupabaseClient.single.mockResolvedValueOnce({
        data: mockProfile,
        error: null
      });

      const result = await (dataProcessor as any).collectPersonalData('test-user-id');

      expect(result).toBeDefined();
      expect(result.name).toBe('John Doe');
      expect(result.email).toBe('john@example.com');
      expect(result.address).toBeDefined();
    });

    it('should collect wedding data properly', async () => {
      const mockWeddings = [
        {
          id: 'wedding-1',
          title: 'John & Jane Wedding',
          wedding_date: '2024-06-15',
          venue_name: 'Beautiful Venue',
          guest_count: 150,
          budget_total: 50000,
          budget_spent: 30000,
          budget_categories: { venue: 20000, catering: 15000 },
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        }
      ];

      mockSupabaseClient.single.mockResolvedValueOnce({
        data: mockWeddings,
        error: null
      });

      const result = await (dataProcessor as any).collectWeddingData('test-user-id');

      expect(result).toBeDefined();
      expect(result.weddings).toHaveLength(1);
      expect(result.weddings[0].title).toBe('John & Jane Wedding');
    });

    it('should handle data collection errors gracefully', async () => {
      mockSupabaseClient.single.mockResolvedValueOnce({
        data: null,
        error: { message: 'Database error' }
      });

      const result = await (dataProcessor as any).collectPersonalData('test-user-id');

      expect(result).toBeNull();
    });
  });

  describe('Error handling and edge cases', () => {
    it('should handle malformed request types', async () => {
      mockSupabaseClient.single.mockResolvedValueOnce({
        data: { id: 'test-user-id', email: 'test@example.com' },
        error: null
      });

      const result = await dataProcessor.submitDataSubjectRequest(
        'test-user-id',
        'invalid-type' as DataSubjectRights,
        mockSecurityContext
      );

      expect(result.success).toBe(false);
    });

    it('should handle concurrent request processing', async () => {
      // This would test handling of concurrent verification attempts
      // In practice, this would involve database-level concurrency controls
      expect(true).toBe(true); // Placeholder for concurrency test
    });

    it('should validate security context in all operations', async () => {
      const invalidSecurityContext = {
        ...mockSecurityContext,
        user_id: '',
        ip_address_hash: ''
      };

      mockSupabaseClient.single.mockResolvedValueOnce({
        data: { id: 'test-user-id', email: 'test@example.com' },
        error: null
      });

      // The system should still process the request but audit the invalid context
      const result = await dataProcessor.submitDataSubjectRequest(
        'test-user-id',
        DataSubjectRights.ACCESS,
        invalidSecurityContext
      );

      // Request should still be processed, but security context logged
      expect(result.success).toBe(true);
    });
  });

  describe('Request type handling', () => {
    it('should handle all request types', async () => {
      const requestTypes = Object.values(DataSubjectRights);
      
      for (const requestType of requestTypes) {
        mockSupabaseClient.single.mockResolvedValueOnce({
          data: { id: 'test-user-id', email: 'test@example.com' },
          error: null
        });
        
        mockSupabaseClient.single.mockResolvedValueOnce({
          data: {
            id: 'request-id',
            request_type: requestType,
            status: RequestStatus.SUBMITTED
          },
          error: null
        });

        const result = await dataProcessor.submitDataSubjectRequest(
          'test-user-id',
          requestType,
          mockSecurityContext
        );

        expect(result.success).toBe(true);
        expect(result.data?.request_type).toBe(requestType);
      }
    });
  });

  describe('Audit logging', () => {
    it('should log all operations for audit trail', async () => {
      mockSupabaseClient.single.mockResolvedValueOnce({
        data: { id: 'test-user-id', email: 'test@example.com' },
        error: null
      });

      mockSupabaseClient.single.mockResolvedValueOnce({
        data: { id: 'request-id' },
        error: null
      });

      // Count audit log insertions
      let auditLogCount = 0;
      const originalInsert = mockSupabaseClient.insert;
      mockSupabaseClient.insert = jest.fn().mockImplementation((data) => {
        if (typeof data === 'object' && data.action) {
          auditLogCount++;
        }
        return originalInsert.call(mockSupabaseClient, data);
      });

      await dataProcessor.submitDataSubjectRequest(
        'test-user-id',
        DataSubjectRights.ACCESS,
        mockSecurityContext
      );

      expect(auditLogCount).toBeGreaterThan(0);
    });
  });
});