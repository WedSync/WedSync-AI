import { adminAuditLogger } from '@/lib/admin/auditLogger';
import { createClient } from '@/lib/supabase/server';

// Mock Supabase client
jest.mock('@/lib/supabase/server', () => ({
  createClient: jest.fn()
}));

describe('AdminAuditLogger', () => {
  let mockSupabase: any;
  let consoleSpy: jest.SpyInstance;
  let consoleErrorSpy: jest.SpyInstance;
  let consoleWarnSpy: jest.SpyInstance;

  beforeEach(() => {
    mockSupabase = {
      from: jest.fn().mockReturnThis(),
      insert: jest.fn().mockReturnThis(),
      select: jest.fn().mockReturnThis(),
      single: jest.fn().mockReturnThis(),
      eq: jest.fn().mockReturnThis(),
      gte: jest.fn().mockReturnThis(),
      lte: jest.fn().mockReturnThis(),
      in: jest.fn().mockReturnThis(),
      range: jest.fn().mockReturnThis(),
      order: jest.fn().mockReturnThis(),
      limit: jest.fn().mockReturnThis(),
      delete: jest.fn().mockReturnThis(),
      lt: jest.fn().mockReturnThis()
    };

    (createClient as jest.Mock).mockReturnValue(mockSupabase);
    
    consoleSpy = jest.spyOn(console, 'log').mockImplementation(() => {});
    consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation(() => {});
    consoleWarnSpy = jest.spyOn(console, 'warn').mockImplementation(() => {});
  });

  afterEach(() => {
    jest.clearAllMocks();
    consoleSpy.mockRestore();
    consoleErrorSpy.mockRestore();
    consoleWarnSpy.mockRestore();
  });

  describe('logAction', () => {
    it('should successfully log an audit action', async () => {
      mockSupabase.from.mockImplementation(() => ({
        insert: jest.fn().mockResolvedValue({ error: null })
      }));

      const entry = {
        adminId: 'admin123',
        adminEmail: 'admin@example.com',
        action: 'user_created',
        status: 'success' as const,
        details: { userId: 'user123' },
        timestamp: '2024-01-01T00:00:00.000Z',
        clientIP: '192.168.1.1',
        requiresMFA: false,
        userAgent: 'Mozilla/5.0'
      };

      await adminAuditLogger.logAction(entry);

      expect(mockSupabase.from).toHaveBeenCalledWith('admin_audit_log');
      expect(consoleErrorSpy).not.toHaveBeenCalled();
    });

    it('should handle database insertion errors gracefully', async () => {
      const dbError = new Error('Database connection failed');
      mockSupabase.from.mockImplementation(() => ({
        insert: jest.fn().mockResolvedValue({ error: dbError })
      }));

      const entry = {
        adminId: 'admin123',
        adminEmail: 'admin@example.com',
        action: 'user_created',
        status: 'success' as const,
        details: { userId: 'user123' },
        timestamp: '2024-01-01T00:00:00.000Z',
        clientIP: '192.168.1.1',
        requiresMFA: false
      };

      await adminAuditLogger.logAction(entry);

      expect(consoleErrorSpy).toHaveBeenCalledWith('Failed to log admin audit entry:', dbError);
      expect(consoleWarnSpy).toHaveBeenCalledWith(
        'AUDIT LOG (DB FAILED):',
        expect.stringContaining(JSON.stringify(entry.action))
      );
    });

    it('should fallback to console logging on unexpected errors', async () => {
      mockSupabase.from.mockImplementation(() => {
        throw new Error('Unexpected error');
      });

      const entry = {
        adminId: 'admin123',
        adminEmail: 'admin@example.com',
        action: 'user_created',
        status: 'success' as const,
        details: { userId: 'user123' },
        timestamp: '2024-01-01T00:00:00.000Z',
        clientIP: '192.168.1.1',
        requiresMFA: false
      };

      await adminAuditLogger.logAction(entry);

      expect(consoleErrorSpy).toHaveBeenCalledWith('Error in audit logger:', expect.any(Error));
      expect(consoleWarnSpy).toHaveBeenCalledWith('AUDIT LOG (ERROR):', entry);
    });
  });

  describe('getAuditEntries', () => {
    it('should retrieve audit entries with filters', async () => {
      const mockData = [
        {
          id: '1',
          admin_id: 'admin123',
          admin_email: 'admin@example.com',
          action: 'user_created',
          status: 'success',
          details: { userId: 'user123' },
          timestamp: '2024-01-01T00:00:00.000Z',
          client_ip: '192.168.1.1',
          requires_mfa: false,
          user_agent: 'Mozilla/5.0'
        }
      ];

      mockSupabase.from.mockImplementation(() => ({
        select: jest.fn().mockReturnThis(),
        order: jest.fn().mockReturnThis(),
        eq: jest.fn().mockReturnThis(),
        gte: jest.fn().mockReturnThis(),
        lte: jest.fn().mockReturnThis(),
        range: jest.fn().mockResolvedValue({ data: mockData, error: null })
      }));

      const options = {
        adminId: 'admin123',
        action: 'user_created',
        status: 'success' as const,
        startDate: '2024-01-01T00:00:00.000Z',
        endDate: '2024-01-02T00:00:00.000Z',
        limit: 10,
        offset: 0
      };

      const result = await adminAuditLogger.getAuditEntries(options);

      expect(result).toHaveLength(1);
      expect(result[0]).toMatchObject({
        adminId: 'admin123',
        adminEmail: 'admin@example.com',
        action: 'user_created',
        status: 'success'
      });
    });

    it('should handle database query errors', async () => {
      const dbError = new Error('Query failed');
      mockSupabase.from.mockImplementation(() => ({
        select: jest.fn().mockReturnThis(),
        order: jest.fn().mockReturnThis(),
        range: jest.fn().mockResolvedValue({ data: null, error: dbError })
      }));

      const result = await adminAuditLogger.getAuditEntries();

      expect(result).toEqual([]);
      expect(consoleErrorSpy).toHaveBeenCalledWith('Failed to fetch audit entries:', dbError);
    });
  });

  describe('getAuditSummary', () => {
    it('should generate audit summary statistics', async () => {
      mockSupabase.from.mockImplementation((table: string) => ({
        select: jest.fn().mockImplementation((columns: string, options?: any) => {
          if (options?.count === 'exact') {
            return Promise.resolve({ count: 100 });
          }
          return Promise.resolve({
            data: [
              { action: 'user_created' },
              { action: 'user_created' },
              { action: 'user_deleted' }
            ]
          });
        }),
        eq: jest.fn().mockReturnThis(),
        in: jest.fn().mockReturnThis(),
        gte: jest.fn().mockReturnThis(),
        limit: jest.fn().mockReturnThis()
      }));

      const summary = await adminAuditLogger.getAuditSummary(7);

      expect(summary).toMatchObject({
        totalActions: expect.any(Number),
        successfulActions: expect.any(Number),
        failedActions: expect.any(Number),
        mfaRequiredActions: expect.any(Number),
        topActions: expect.any(Array),
        topAdmins: expect.any(Array)
      });
    });
  });

  describe('createAuditAlert', () => {
    it('should create audit alerts for security violations', async () => {
      mockSupabase.from.mockImplementation(() => ({
        insert: jest.fn().mockResolvedValue({ error: null })
      }));

      await adminAuditLogger.createAuditAlert(
        'Suspicious activity detected',
        'security',
        { details: 'Multiple failed login attempts' }
      );

      expect(mockSupabase.from).toHaveBeenCalledWith('system_alerts');
    });
  });

  describe('logSecurityViolation', () => {
    it('should log security violations and create alerts', async () => {
      mockSupabase.from.mockImplementation(() => ({
        insert: jest.fn().mockResolvedValue({ error: null })
      }));

      await adminAuditLogger.logSecurityViolation(
        'admin123',
        'admin@example.com',
        'unauthorized_access',
        { resource: '/admin/users' },
        '192.168.1.1'
      );

      expect(mockSupabase.from).toHaveBeenCalledWith('admin_audit_log');
      expect(mockSupabase.from).toHaveBeenCalledWith('system_alerts');
    });
  });

  describe('logMfaFailure', () => {
    it('should log MFA failures', async () => {
      mockSupabase.from.mockImplementation(() => ({
        insert: jest.fn().mockResolvedValue({ error: null })
      }));

      await adminAuditLogger.logMfaFailure(
        'admin123',
        'admin@example.com',
        'user_delete',
        '192.168.1.1',
        1
      );

      expect(mockSupabase.from).toHaveBeenCalledWith('admin_audit_log');
    });

    it('should create alert after multiple MFA failures', async () => {
      mockSupabase.from.mockImplementation(() => ({
        insert: jest.fn().mockResolvedValue({ error: null })
      }));

      await adminAuditLogger.logMfaFailure(
        'admin123',
        'admin@example.com',
        'user_delete',
        '192.168.1.1',
        3
      );

      // Should create both audit log and alert
      expect(mockSupabase.from).toHaveBeenCalledWith('admin_audit_log');
      expect(mockSupabase.from).toHaveBeenCalledWith('system_alerts');
    });
  });

  describe('cleanupOldEntries', () => {
    it('should cleanup old audit entries', async () => {
      mockSupabase.from.mockImplementation(() => ({
        delete: jest.fn().mockReturnThis(),
        lt: jest.fn().mockResolvedValue({ error: null })
      }));

      await adminAuditLogger.cleanupOldEntries(30);

      expect(mockSupabase.from).toHaveBeenCalledWith('admin_audit_log');
      expect(consoleSpy).toHaveBeenCalledWith('Cleaned up audit entries older than 30 days');
    });

    it('should handle cleanup errors', async () => {
      const dbError = new Error('Delete failed');
      mockSupabase.from.mockImplementation(() => ({
        delete: jest.fn().mockReturnThis(),
        lt: jest.fn().mockResolvedValue({ error: dbError })
      }));

      await adminAuditLogger.cleanupOldEntries(30);

      expect(consoleErrorSpy).toHaveBeenCalledWith('Failed to cleanup old audit entries:', dbError);
    });
  });
});