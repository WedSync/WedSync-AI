import { tagService } from '@/lib/services/tagService'
import { supabase } from '@/lib/supabase'
import { TagColor, TagCategory } from '@/components/tags/TagManager'

// Mock Supabase
jest.mock('@/lib/supabase', () => ({
  supabase: {
    from: jest.fn()
  }
}))

const mockSupabase = supabase as jest.Mocked<typeof supabase>

describe('TagService', () => {
  const mockSupplierId = 'supplier-123'
  
  beforeEach(() => {
    jest.clearAllMocks()
  })

  describe('createTag', () => {
    const mockTagInput = {
      name: 'VIP Client',
      description: 'High priority client',
      color: 'purple' as TagColor,
      category: 'relationship' as TagCategory
    }

    it('creates a tag successfully', async () => {
      const mockResponse = {
        data: {
          id: 'tag-123',
          ...mockTagInput,
          supplier_id: mockSupplierId,
          usage_count: 0,
          created_at: '2023-01-01T00:00:00Z',
          updated_at: '2023-01-01T00:00:00Z'
        },
        error: null
      }

      const mockQuery = {
        insert: jest.fn().mockReturnThis(),
        select: jest.fn().mockReturnThis(),
        single: jest.fn().mockResolvedValue(mockResponse)
      }

      mockSupabase.from.mockReturnValue(mockQuery as any)

      const result = await tagService.createTag(mockTagInput, mockSupplierId)

      expect(mockSupabase.from).toHaveBeenCalledWith('tags')
      expect(mockQuery.insert).toHaveBeenCalledWith([{
        name: 'VIP Client',
        description: 'High priority client',
        color: 'purple',
        category: 'relationship',
        supplier_id: mockSupplierId,
        usage_count: 0
      }])
      expect(result).toEqual(mockResponse.data)
    })

    it('validates tag name with invalid characters', async () => {
      const invalidInput = {
        ...mockTagInput,
        name: '<script>alert("xss")</script>'
      }

      await expect(tagService.createTag(invalidInput, mockSupplierId))
        .rejects.toThrow('Tag name contains invalid characters')
    })

    it('sanitizes tag input for XSS prevention', async () => {
      const xssInput = {
        ...mockTagInput,
        name: 'VIP<script>',
        description: 'Description"with"quotes'
      }

      const mockResponse = {
        data: { id: 'tag-123' },
        error: null
      }

      const mockQuery = {
        insert: jest.fn().mockReturnThis(),
        select: jest.fn().mockReturnThis(),
        single: jest.fn().mockResolvedValue(mockResponse)
      }

      mockSupabase.from.mockReturnValue(mockQuery as any)

      await tagService.createTag(xssInput, mockSupplierId)

      expect(mockQuery.insert).toHaveBeenCalledWith([
        expect.objectContaining({
          name: 'VIP&lt;script&gt;',
          description: 'Description&quot;with&quot;quotes'
        })
      ])
    })

    it('handles database errors', async () => {
      const mockError = { message: 'Database error' }
      const mockQuery = {
        insert: jest.fn().mockReturnThis(),
        select: jest.fn().mockReturnThis(),
        single: jest.fn().mockResolvedValue({ data: null, error: mockError })
      }

      mockSupabase.from.mockReturnValue(mockQuery as any)

      await expect(tagService.createTag(mockTagInput, mockSupplierId))
        .rejects.toThrow('Failed to create tag')
    })
  })

  describe('getTags', () => {
    it('retrieves tags with filters', async () => {
      const mockTags = [
        { id: '1', name: 'luxury', category: 'style' },
        { id: '2', name: 'outdoor', category: 'venue' }
      ]

      const mockQuery = {
        select: jest.fn().mockReturnThis(),
        eq: jest.fn().mockReturnThis(),
        or: jest.fn().mockReturnThis(),
        order: jest.fn().mockReturnThis(),
        limit: jest.fn().mockReturnThis(),
        range: jest.fn().mockResolvedValue({ data: mockTags, error: null })
      }

      mockSupabase.from.mockReturnValue(mockQuery as any)

      const options = {
        category: 'style' as TagCategory,
        searchQuery: 'lux',
        sortBy: 'name' as const,
        sortOrder: 'asc' as const,
        limit: 10,
        offset: 0
      }

      const result = await tagService.getTags(mockSupplierId, options)

      expect(mockSupabase.from).toHaveBeenCalledWith('tags')
      expect(mockQuery.eq).toHaveBeenCalledWith('supplier_id', mockSupplierId)
      expect(mockQuery.eq).toHaveBeenCalledWith('category', 'style')
      expect(mockQuery.or).toHaveBeenCalledWith('name.ilike.%lux%,description.ilike.%lux%')
      expect(mockQuery.order).toHaveBeenCalledWith('name', { ascending: true })
      expect(result).toEqual(mockTags)
    })
  })

  describe('deleteTag', () => {
    const tagId = 'tag-123'

    it('deletes tag and associations successfully', async () => {
      // Mock client_tags deletion
      const mockClientTagsQuery = {
        delete: jest.fn().mockReturnThis(),
        eq: jest.fn().mockResolvedValue({ error: null })
      }

      // Mock tags deletion
      const mockTagsQuery = {
        delete: jest.fn().mockReturnThis(),
        eq: jest.fn().mockReturnThis().mockResolvedValue({ error: null })
      }

      mockSupabase.from
        .mockReturnValueOnce(mockClientTagsQuery as any) // client_tags
        .mockReturnValueOnce(mockTagsQuery as any) // tags

      await tagService.deleteTag(tagId, mockSupplierId)

      expect(mockSupabase.from).toHaveBeenCalledWith('client_tags')
      expect(mockClientTagsQuery.delete).toHaveBeenCalled()
      expect(mockClientTagsQuery.eq).toHaveBeenCalledWith('tag_id', tagId)

      expect(mockSupabase.from).toHaveBeenCalledWith('tags')
      expect(mockTagsQuery.delete).toHaveBeenCalled()
      expect(mockTagsQuery.eq).toHaveBeenCalledWith('id', tagId)
      expect(mockTagsQuery.eq).toHaveBeenCalledWith('supplier_id', mockSupplierId)
    })

    it('handles association deletion error', async () => {
      const mockError = { message: 'Foreign key constraint' }
      const mockQuery = {
        delete: jest.fn().mockReturnThis(),
        eq: jest.fn().mockResolvedValue({ error: mockError })
      }

      mockSupabase.from.mockReturnValue(mockQuery as any)

      await expect(tagService.deleteTag(tagId, mockSupplierId))
        .rejects.toThrow('Failed to remove tag associations')
    })
  })

  describe('addTagsToClient', () => {
    const clientId = 'client-123'
    const tagIds = ['tag-1', 'tag-2']

    it('adds tags to client successfully', async () => {
      // Mock tag validation query
      const mockValidationQuery = {
        select: jest.fn().mockReturnThis(),
        eq: jest.fn().mockReturnThis(),
        in: jest.fn().mockResolvedValue({
          data: [{ id: 'tag-1' }, { id: 'tag-2' }],
          error: null
        })
      }

      // Mock association creation query
      const mockAssociationQuery = {
        upsert: jest.fn().mockResolvedValue({ error: null })
      }

      // Mock usage count update
      const mockUsageQuery = {
        select: jest.fn().mockReturnThis(),
        eq: jest.fn().mockResolvedValue({ data: [1, 2], error: null })
      }

      const mockUpdateQuery = {
        update: jest.fn().mockReturnThis(),
        eq: jest.fn().mockResolvedValue({ error: null })
      }

      mockSupabase.from
        .mockReturnValueOnce(mockValidationQuery as any) // validation
        .mockReturnValueOnce(mockAssociationQuery as any) // associations
        .mockReturnValue(mockUsageQuery as any) // usage counts (multiple calls)

      await tagService.addTagsToClient(clientId, tagIds, mockSupplierId)

      expect(mockSupabase.from).toHaveBeenCalledWith('tags')
      expect(mockSupabase.from).toHaveBeenCalledWith('client_tags')
      expect(mockAssociationQuery.upsert).toHaveBeenCalledWith(
        [
          { client_id: clientId, tag_id: 'tag-1', supplier_id: mockSupplierId },
          { client_id: clientId, tag_id: 'tag-2', supplier_id: mockSupplierId }
        ],
        { onConflict: 'client_id,tag_id' }
      )
    })

    it('validates tag ownership', async () => {
      const mockQuery = {
        select: jest.fn().mockReturnThis(),
        eq: jest.fn().mockReturnThis(),
        in: jest.fn().mockResolvedValue({
          data: [{ id: 'tag-1' }], // Only one tag returned
          error: null
        })
      }

      mockSupabase.from.mockReturnValue(mockQuery as any)

      await expect(tagService.addTagsToClient(clientId, tagIds, mockSupplierId))
        .rejects.toThrow('Some tags are invalid or do not belong to this supplier')
    })
  })

  describe('getClientsByTags', () => {
    const tagIds = ['tag-1', 'tag-2']

    it('gets clients with OR logic', async () => {
      const mockClients = [
        { client_id: 'client-1' },
        { client_id: 'client-2' }
      ]

      const mockQuery = {
        select: jest.fn().mockReturnThis(),
        eq: jest.fn().mockReturnThis(),
        in: jest.fn().mockResolvedValue({ data: mockClients, error: null })
      }

      mockSupabase.from.mockReturnValue(mockQuery as any)

      const result = await tagService.getClientsByTags(tagIds, 'OR', mockSupplierId)

      expect(mockSupabase.from).toHaveBeenCalledWith('client_tags')
      expect(mockQuery.eq).toHaveBeenCalledWith('supplier_id', mockSupplierId)
      expect(mockQuery.in).toHaveBeenCalledWith('tag_id', tagIds)
      expect(result).toEqual(['client-1', 'client-2'])
    })

    it('gets clients with AND logic using RPC', async () => {
      const mockClientIds = ['client-1']

      const mockRpc = jest.fn().mockResolvedValue({
        data: mockClientIds,
        error: null
      })

      mockSupabase.rpc = mockRpc

      const result = await tagService.getClientsByTags(tagIds, 'AND', mockSupplierId)

      expect(mockRpc).toHaveBeenCalledWith('get_clients_with_all_tags', {
        tag_ids: tagIds,
        supplier_id: mockSupplierId
      })
      expect(result).toEqual(mockClientIds)
    })
  })

  describe('bulkTagOperation', () => {
    const operation = {
      action: 'add' as const,
      tagIds: ['tag-1', 'tag-2'],
      clientIds: ['client-1', 'client-2']
    }

    it('performs bulk add operation', async () => {
      const mockQuery = {
        upsert: jest.fn().mockResolvedValue({ error: null })
      }

      const mockUsageQuery = {
        select: jest.fn().mockReturnThis(),
        eq: jest.fn().mockResolvedValue({ data: [], error: null })
      }

      mockSupabase.from
        .mockReturnValueOnce(mockQuery as any)
        .mockReturnValue(mockUsageQuery as any)

      await tagService.bulkTagOperation(operation, mockSupplierId)

      expect(mockSupabase.from).toHaveBeenCalledWith('client_tags')
      expect(mockQuery.upsert).toHaveBeenCalledWith(
        [
          { client_id: 'client-1', tag_id: 'tag-1', supplier_id: mockSupplierId },
          { client_id: 'client-1', tag_id: 'tag-2', supplier_id: mockSupplierId },
          { client_id: 'client-2', tag_id: 'tag-1', supplier_id: mockSupplierId },
          { client_id: 'client-2', tag_id: 'tag-2', supplier_id: mockSupplierId }
        ],
        { onConflict: 'client_id,tag_id' }
      )
    })

    it('performs bulk remove operation', async () => {
      const removeOperation = {
        ...operation,
        action: 'remove' as const
      }

      const mockQuery = {
        delete: jest.fn().mockReturnThis(),
        eq: jest.fn().mockReturnThis(),
        in: jest.fn().mockResolvedValue({ error: null })
      }

      const mockUsageQuery = {
        select: jest.fn().mockReturnThis(),
        eq: jest.fn().mockResolvedValue({ data: [], error: null })
      }

      mockSupabase.from
        .mockReturnValueOnce(mockQuery as any)
        .mockReturnValue(mockUsageQuery as any)

      await tagService.bulkTagOperation(removeOperation, mockSupplierId)

      expect(mockSupabase.from).toHaveBeenCalledWith('client_tags')
      expect(mockQuery.delete).toHaveBeenCalled()
      expect(mockQuery.eq).toHaveBeenCalledWith('supplier_id', mockSupplierId)
      expect(mockQuery.in).toHaveBeenCalledWith('client_id', operation.clientIds)
      expect(mockQuery.in).toHaveBeenCalledWith('tag_id', operation.tagIds)
    })
  })

  describe('exportTagAnalytics', () => {
    it('exports analytics as CSV', async () => {
      const mockAnalytics = [
        {
          tag: { name: 'luxury', category: 'style' },
          usage_count: 15,
          growth_rate: 5.2,
          last_used: '2023-01-01'
        }
      ]

      // Mock the RPC call for analytics
      mockSupabase.rpc = jest.fn().mockResolvedValue({
        data: mockAnalytics,
        error: null
      })

      const result = await tagService.exportTagAnalytics(mockSupplierId, '30d', 'csv')

      expect(result).toBeInstanceOf(Blob)
      expect(result.type).toBe('text/csv')

      // Check CSV content
      const text = await result.text()
      expect(text).toContain('Tag Name,Category,Usage Count,Growth Rate,Last Used')
      expect(text).toContain('"luxury","style","15","5.2","2023-01-01"')
    })

    it('exports analytics as JSON', async () => {
      const mockAnalytics = [
        {
          tag: { name: 'luxury', category: 'style' },
          usage_count: 15,
          growth_rate: 5.2,
          last_used: '2023-01-01'
        }
      ]

      mockSupabase.rpc = jest.fn().mockResolvedValue({
        data: mockAnalytics,
        error: null
      })

      const result = await tagService.exportTagAnalytics(mockSupplierId, '30d', 'json')

      expect(result).toBeInstanceOf(Blob)
      expect(result.type).toBe('application/json')

      // Check JSON content
      const text = await result.text()
      const parsed = JSON.parse(text)
      expect(parsed).toEqual(mockAnalytics)
    })
  })
})