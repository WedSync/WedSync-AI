import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { IntegrationGateway } from '../../middleware/integration-gateway';
import Redis from 'ioredis';

// Mock Redis
vi.mock('ioredis');
const mockRedis = {
  incr: vi.fn(),
  expire: vi.fn(),
  hset: vi.fn(),
  hgetall: vi.fn(),
  hincrby: vi.fn(),
  hget: vi.fn(),
  lrem: vi.fn(),
  disconnect: vi.fn()
};

// Mock fetch
global.fetch = vi.fn();

describe('IntegrationGateway', () => {
  let gateway: IntegrationGateway;

  beforeEach(() => {
    vi.clearAllMocks();
    (Redis as any).mockImplementation(() => mockRedis);
    gateway = new IntegrationGateway();
  });

  afterEach(async () => {
    await gateway.disconnect();
  });

  describe('Constructor and Initialization', () => {
    it('should initialize with default service configurations', () => {
      expect(gateway).toBeInstanceOf(IntegrationGateway);
    });

    it('should set up circuit breakers for all services', () => {
      // Circuit breakers are set up internally - we verify by checking service health
      expect(gateway.getServiceHealth('stripe_payments')).toBeDefined();
    });
  });

  describe('Request Routing', () => {
    beforeEach(() => {
      // Mock rate limiting to allow requests
      mockRedis.incr.mockResolvedValue(1);
      mockRedis.expire.mockResolvedValue(1);
      
      // Mock successful fetch response
      (global.fetch as any).mockResolvedValue({
        ok: true,
        status: 200,
        json: () => Promise.resolve({ id: 'test-payment', status: 'succeeded' }),
        headers: new Headers({ 'content-type': 'application/json' })
      });
    });

    it('should route request successfully to Stripe payments', async () => {
      const response = await gateway.routeRequest(
        'stripe_payments',
        '/v1/payments',
        {
          method: 'POST',
          body: JSON.stringify({ amount: 1000 })
        },
        { requestId: 'test-request', clientId: 'test-client' }
      );

      expect(response).toEqual({
        id: 'test-payment',
        object: undefined,
        status: 'succeeded',
        amount: undefined,
        currency: undefined,
        metadata: undefined,
        created: undefined,
        createdAt: expect.any(String),
        provider: 'stripe'
      });

      expect(global.fetch).toHaveBeenCalledWith(
        'https://api.stripe.com/v1/payments',
        expect.objectContaining({
          method: 'POST',
          body: JSON.stringify({ amount: 1000 }),
          headers: expect.any(Headers)
        })
      );
    });

    it('should handle rate limiting correctly', async () => {
      // Mock rate limit exceeded
      mockRedis.incr.mockResolvedValue(101); // Exceeds limit of 100

      await expect(
        gateway.routeRequest(
          'stripe_payments',
          '/v1/payments',
          { method: 'GET' },
          { requestId: 'test-request', clientId: 'test-client' }
        )
      ).rejects.toThrow('Rate limit exceeded');

      expect(global.fetch).not.toHaveBeenCalled();
    });

    it('should throw error for unknown service', async () => {
      await expect(
        gateway.routeRequest(
          'unknown_service',
          '/test',
          { method: 'GET' },
          { requestId: 'test-request', clientId: 'test-client' }
        )
      ).rejects.toThrow('Service configuration not found: unknown_service');
    });

    it('should add correct authentication headers for different auth types', async () => {
      // Test API key authentication (email service)
      await gateway.routeRequest(
        'email_service',
        '/emails',
        { method: 'POST' },
        { requestId: 'test-request', clientId: 'test-client' }
      );

      expect(global.fetch).toHaveBeenCalledWith(
        expect.stringContaining('/emails'),
        expect.objectContaining({
          headers: expect.any(Headers)
        })
      );

      // Verify Authorization header was set
      const lastCall = (global.fetch as any).mock.calls[0][1];
      const authHeader = lastCall.headers.get('Authorization');
      expect(authHeader).toMatch(/^Bearer/);
    });
  });

  describe('Circuit Breaker Functionality', () => {
    it('should open circuit breaker after consecutive failures', async () => {
      // Mock failing fetch requests
      (global.fetch as any).mockRejectedValue(new Error('Service unavailable'));
      mockRedis.incr.mockResolvedValue(1); // Allow through rate limiting

      // Make multiple requests to trigger circuit breaker
      const requests = Array(6).fill(null).map(() =>
        gateway.routeRequest(
          'email_service',
          '/test',
          { method: 'GET' },
          { requestId: `test-${Math.random()}`, clientId: 'test-client' }
        ).catch(() => {}) // Ignore errors for this test
      );

      await Promise.all(requests);

      // Circuit breaker should now be open
      const healthMetrics = await gateway.getServiceHealth('email_service');
      expect(healthMetrics?.status).toBe('down');
    });
  });

  describe('Response Normalization', () => {
    it('should normalize Stripe responses correctly', async () => {
      const stripeResponse = {
        id: 'pi_test123',
        object: 'payment_intent',
        status: 'succeeded',
        amount: 2000,
        currency: 'usd',
        created: 1234567890,
        metadata: { wedding_id: 'wed_123' }
      };

      (global.fetch as any).mockResolvedValue({
        ok: true,
        json: () => Promise.resolve(stripeResponse),
        headers: new Headers({ 'content-type': 'application/json' })
      });

      mockRedis.incr.mockResolvedValue(1);

      const response = await gateway.routeRequest(
        'stripe_payments',
        '/v1/payment_intents/pi_test123',
        { method: 'GET' },
        { requestId: 'test-request', clientId: 'test-client' }
      );

      expect(response).toEqual({
        id: 'pi_test123',
        object: 'payment_intent',
        status: 'succeeded',
        amount: 2000,
        currency: 'usd',
        metadata: { wedding_id: 'wed_123' },
        created: 1234567890,
        createdAt: '2009-02-13T23:31:30.000Z',
        provider: 'stripe'
      });
    });

    it('should normalize email service responses correctly', async () => {
      const emailResponse = {
        id: 'email_123',
        status: 'delivered',
        to: 'bride@example.com',
        subject: 'Wedding Confirmation',
        created_at: '2025-01-20T10:00:00Z'
      };

      (global.fetch as any).mockResolvedValue({
        ok: true,
        json: () => Promise.resolve(emailResponse),
        headers: new Headers({ 'content-type': 'application/json' })
      });

      mockRedis.incr.mockResolvedValue(1);

      const response = await gateway.routeRequest(
        'email_service',
        '/emails/email_123',
        { method: 'GET' },
        { requestId: 'test-request', clientId: 'test-client' }
      );

      expect(response).toEqual({
        id: 'email_123',
        status: 'delivered',
        recipient: 'bride@example.com',
        subject: 'Wedding Confirmation',
        createdAt: '2025-01-20T10:00:00Z',
        provider: 'resend'
      });
    });
  });

  describe('Health Metrics', () => {
    it('should track service health metrics', async () => {
      const healthMetrics = await gateway.getServiceHealth('stripe_payments');
      
      expect(healthMetrics).toEqual({
        serviceId: 'stripe_payments',
        status: 'healthy',
        responseTime: expect.any(Number),
        errorRate: expect.any(Number),
        lastCheck: expect.any(Date),
        consecutiveFailures: 0
      });
    });

    it('should return all services health status', async () => {
      const allHealth = await gateway.getAllServicesHealth();
      
      expect(Array.isArray(allHealth)).toBe(true);
      expect(allHealth.length).toBeGreaterThan(0);
      
      allHealth.forEach(health => {
        expect(health).toHaveProperty('serviceId');
        expect(health).toHaveProperty('status');
        expect(['healthy', 'degraded', 'down']).toContain(health.status);
      });
    });
  });

  describe('Metrics Recording', () => {
    it('should record success metrics', async () => {
      (global.fetch as any).mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({ success: true }),
        headers: new Headers({ 'content-type': 'application/json' })
      });

      mockRedis.incr.mockResolvedValue(1);
      mockRedis.hincrby.mockResolvedValue(1);
      mockRedis.hset.mockResolvedValue(1);
      mockRedis.hget.mockResolvedValue('1');

      await gateway.routeRequest(
        'email_service',
        '/test',
        { method: 'GET' },
        { requestId: 'test-request', clientId: 'test-client' }
      );

      // Verify metrics were recorded
      expect(mockRedis.hincrby).toHaveBeenCalledWith(
        expect.stringContaining('metrics:email_service:'),
        'success_count',
        1
      );
      expect(mockRedis.hincrby).toHaveBeenCalledWith(
        expect.stringContaining('metrics:email_service:'),
        'total_requests',
        1
      );
    });

    it('should record error metrics on failure', async () => {
      (global.fetch as any).mockRejectedValue(new Error('Network error'));
      mockRedis.incr.mockResolvedValue(1);
      mockRedis.hincrby.mockResolvedValue(1);
      mockRedis.hset.mockResolvedValue(1);

      await expect(
        gateway.routeRequest(
          'email_service',
          '/test',
          { method: 'GET' },
          { requestId: 'test-request', clientId: 'test-client' }
        )
      ).rejects.toThrow();

      // Verify error metrics were recorded
      expect(mockRedis.hincrby).toHaveBeenCalledWith(
        expect.stringContaining('metrics:email_service:'),
        'error_count',
        1
      );
    });
  });

  describe('Performance Requirements', () => {
    it('should handle requests within performance thresholds', async () => {
      (global.fetch as any).mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({ success: true }),
        headers: new Headers({ 'content-type': 'application/json' })
      });

      mockRedis.incr.mockResolvedValue(1);

      const startTime = Date.now();
      
      await gateway.routeRequest(
        'stripe_payments',
        '/test',
        { method: 'GET' },
        { requestId: 'test-request', clientId: 'test-client' }
      );

      const duration = Date.now() - startTime;
      
      // Should complete within reasonable time (less than 1 second for mock)
      expect(duration).toBeLessThan(1000);
    });

    it('should handle concurrent requests', async () => {
      (global.fetch as any).mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({ success: true }),
        headers: new Headers({ 'content-type': 'application/json' })
      });

      mockRedis.incr.mockResolvedValue(1);

      const concurrentRequests = Array(10).fill(null).map((_, i) =>
        gateway.routeRequest(
          'email_service',
          `/test/${i}`,
          { method: 'GET' },
          { requestId: `test-${i}`, clientId: 'test-client' }
        )
      );

      const startTime = Date.now();
      const results = await Promise.all(concurrentRequests);
      const duration = Date.now() - startTime;

      expect(results).toHaveLength(10);
      results.forEach(result => {
        expect(result).toHaveProperty('provider', 'resend');
      });

      // All requests should complete reasonably quickly
      expect(duration).toBeLessThan(2000);
    });
  });

  describe('Wedding-Specific Context', () => {
    it('should handle wedding-related metadata in requests', async () => {
      const weddingPaymentRequest = {
        method: 'POST',
        body: JSON.stringify({
          amount: 500000, // $5000 for wedding photography
          currency: 'usd',
          metadata: {
            wedding_id: 'wed_12345',
            supplier_id: 'sup_photo_789',
            service_type: 'photography',
            payment_type: 'deposit'
          }
        })
      };

      (global.fetch as any).mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({
          id: 'pi_wedding_payment',
          status: 'succeeded',
          amount: 500000,
          metadata: {
            wedding_id: 'wed_12345',
            supplier_id: 'sup_photo_789',
            service_type: 'photography',
            payment_type: 'deposit'
          }
        }),
        headers: new Headers({ 'content-type': 'application/json' })
      });

      mockRedis.incr.mockResolvedValue(1);

      const response = await gateway.routeRequest(
        'stripe_payments',
        '/v1/payment_intents',
        weddingPaymentRequest,
        { 
          requestId: 'wedding-payment-req', 
          clientId: 'photographer-client' 
        }
      );

      expect(response.metadata).toEqual({
        wedding_id: 'wed_12345',
        supplier_id: 'sup_photo_789',
        service_type: 'photography',
        payment_type: 'deposit'
      });
    });
  });
});