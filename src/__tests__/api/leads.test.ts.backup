import { describe, it, expect, jest, beforeEach, afterEach } from '@jest/globals'
import { NextRequest } from 'next/server'
import { GET, PATCH } from '@/app/api/leads/route'

// Mock Supabase
const mockSupabaseClient = {
  auth: {
    getUser: jest.fn()
  },
  from: jest.fn(() => mockSupabaseClient),
  select: jest.fn(() => mockSupabaseClient),
  eq: jest.fn(() => mockSupabaseClient),
  neq: jest.fn(() => mockSupabaseClient),
  gte: jest.fn(() => mockSupabaseClient),
  lte: jest.fn(() => mockSupabaseClient),
  or: jest.fn(() => mockSupabaseClient),
  order: jest.fn(() => mockSupabaseClient),
  range: jest.fn(() => mockSupabaseClient),
  single: jest.fn(),
  update: jest.fn(() => mockSupabaseClient),
  insert: jest.fn(() => mockSupabaseClient),
  rpc: jest.fn()
}

jest.mock('@/lib/supabase/server', () => ({
  createClient: jest.fn(() => mockSupabaseClient)
}))

jest.mock('@/lib/rate-limit', () => ({
  rateLimit: jest.fn(() => Promise.resolve(null)),
  rateLimitConfigs: {
    api: { requests: 100, window: 60000 }
  }
}))

describe('/api/leads', () => {
  const mockUser = { id: 'user-123', email: 'test@example.com' }
  const mockProfile = { organization_id: 'org-123' }

  beforeEach(() => {
    jest.clearAllMocks()
    
    mockSupabaseClient.auth.getUser.mockResolvedValue({
      data: { user: mockUser },
      error: null
    })
    
    mockSupabaseClient.single.mockResolvedValue({
      data: mockProfile,
      error: null
    })
  })

  afterEach(() => {
    jest.clearAllMocks()
  })

  describe('GET /api/leads', () => {
    it('should return leads with default parameters', async () => {
      const mockLeads = [
        {
          id: 'lead-1',
          first_name: 'John',
          last_name: 'Doe',
          email: 'john@example.com',
          status: 'new',
          lead_score: 75,
          lead_grade: 'B',
          created_at: '2024-01-01T00:00:00Z',
          lead_scores: {
            total_score: 75,
            score_grade: 'B',
            last_calculated_at: '2024-01-01T00:00:00Z'
          }
        }
      ]

      // Mock the query chain for leads
      mockSupabaseClient.from.mockReturnValueOnce({
        ...mockSupabaseClient,
        data: mockLeads,
        error: null,
        count: 1
      })

      // Mock the query chain for stats
      mockSupabaseClient.from.mockReturnValueOnce({
        ...mockSupabaseClient,
        data: mockLeads,
        error: null
      })

      const request = new NextRequest('http://localhost:3000/api/leads')
      const response = await GET(request)
      const data = await response.json()

      expect(response.status).toBe(200)
      expect(data.leads).toHaveLength(1)
      expect(data.leads[0].id).toBe('lead-1')
      expect(data.summary.totalLeads).toBe(1)
      expect(data.pagination.total).toBe(1)
    })

    it('should apply status filter', async () => {
      const request = new NextRequest('http://localhost:3000/api/leads?status=qualified')
      
      mockSupabaseClient.from.mockReturnValue({
        ...mockSupabaseClient,
        data: [],
        error: null,
        count: 0
      })

      await GET(request)

      expect(mockSupabaseClient.eq).toHaveBeenCalledWith('status', 'qualified')
    })

    it('should apply search filter', async () => {
      const request = new NextRequest('http://localhost:3000/api/leads?search=john')
      
      mockSupabaseClient.from.mockReturnValue({
        ...mockSupabaseClient,
        data: [],
        error: null,
        count: 0
      })

      await GET(request)

      expect(mockSupabaseClient.or).toHaveBeenCalledWith(
        expect.stringContaining('first_name.ilike.%john%')
      )
    })

    it('should apply score range filters', async () => {
      const request = new NextRequest('http://localhost:3000/api/leads?minScore=50&maxScore=90')
      
      mockSupabaseClient.from.mockReturnValue({
        ...mockSupabaseClient,
        data: [],
        error: null,
        count: 0
      })

      await GET(request)

      expect(mockSupabaseClient.gte).toHaveBeenCalledWith('lead_score', 50)
      expect(mockSupabaseClient.lte).toHaveBeenCalledWith('lead_score', 90)
    })

    it('should handle unauthorized user', async () => {
      mockSupabaseClient.auth.getUser.mockResolvedValue({
        data: { user: null },
        error: null
      })

      const request = new NextRequest('http://localhost:3000/api/leads')
      const response = await GET(request)

      expect(response.status).toBe(401)
    })

    it('should handle missing organization', async () => {
      mockSupabaseClient.single.mockResolvedValue({
        data: null,
        error: null
      })

      const request = new NextRequest('http://localhost:3000/api/leads')
      const response = await GET(request)

      expect(response.status).toBe(400)
    })

    it('should handle database errors', async () => {
      mockSupabaseClient.from.mockReturnValue({
        ...mockSupabaseClient,
        data: null,
        error: new Error('Database error'),
        count: null
      })

      const request = new NextRequest('http://localhost:3000/api/leads')
      const response = await GET(request)

      expect(response.status).toBe(500)
    })

    it('should validate invalid parameters', async () => {
      const request = new NextRequest('http://localhost:3000/api/leads?minScore=150&maxScore=-10')
      const response = await GET(request)

      expect(response.status).toBe(400)
      const data = await response.json()
      expect(data.error).toBe('Validation error')
    })
  })

  describe('PATCH /api/leads', () => {
    const validUpdateData = {
      clientIds: ['client-1', 'client-2'],
      updates: {
        status: 'qualified',
        priority: 'high',
        followUpDate: '2024-02-01T10:00:00Z'
      }
    }

    it('should update multiple leads successfully', async () => {
      const mockClient = {
        id: 'client-1',
        status: 'new',
        organization_id: 'org-123'
      }

      const mockUpdatedClient = {
        ...mockClient,
        status: 'qualified',
        lead_priority: 'high'
      }

      // Mock client lookup
      mockSupabaseClient.single.mockResolvedValueOnce({
        data: mockClient,
        error: null
      })

      // Mock update operation
      mockSupabaseClient.update.mockReturnValueOnce({
        ...mockSupabaseClient,
        data: mockUpdatedClient,
        error: null
      })

      // Mock RPC calls
      mockSupabaseClient.rpc.mockResolvedValue({
        data: true,
        error: null
      })

      // Mock activity logging
      mockSupabaseClient.insert.mockResolvedValue({
        data: {},
        error: null
      })

      const request = new NextRequest('http://localhost:3000/api/leads', {
        method: 'PATCH',
        body: JSON.stringify(validUpdateData)
      })

      const response = await PATCH(request)
      const data = await response.json()

      expect(response.status).toBe(200)
      expect(data.summary.successful).toBeGreaterThan(0)
      expect(mockSupabaseClient.rpc).toHaveBeenCalledWith('update_lead_status', expect.any(Object))
    })

    it('should handle partial failures', async () => {
      const mockClient1 = { id: 'client-1', status: 'new', organization_id: 'org-123' }
      
      // Mock successful client lookup for first client
      mockSupabaseClient.single
        .mockResolvedValueOnce({ data: mockClient1, error: null })
        .mockResolvedValueOnce({ data: null, error: new Error('Client not found') })

      mockSupabaseClient.update.mockReturnValue({
        ...mockSupabaseClient,
        data: mockClient1,
        error: null
      })

      mockSupabaseClient.rpc.mockResolvedValue({
        data: true,
        error: null
      })

      mockSupabaseClient.insert.mockResolvedValue({
        data: {},
        error: null
      })

      const request = new NextRequest('http://localhost:3000/api/leads', {
        method: 'PATCH',
        body: JSON.stringify(validUpdateData)
      })

      const response = await PATCH(request)
      const data = await response.json()

      expect(response.status).toBe(200)
      expect(data.summary.successful).toBe(1)
      expect(data.summary.failed).toBe(1)
      expect(data.errors).toHaveLength(1)
    })

    it('should validate request body', async () => {
      const invalidData = {
        clientIds: ['invalid-uuid'],
        updates: {
          priority: 'invalid-priority'
        }
      }

      const request = new NextRequest('http://localhost:3000/api/leads', {
        method: 'PATCH',
        body: JSON.stringify(invalidData)
      })

      const response = await PATCH(request)

      expect(response.status).toBe(400)
      const data = await response.json()
      expect(data.error).toBe('Validation error')
    })

    it('should handle unauthorized user', async () => {
      mockSupabaseClient.auth.getUser.mockResolvedValue({
        data: { user: null },
        error: null
      })

      const request = new NextRequest('http://localhost:3000/api/leads', {
        method: 'PATCH',
        body: JSON.stringify(validUpdateData)
      })

      const response = await PATCH(request)

      expect(response.status).toBe(401)
    })

    it('should only update clients belonging to user organization', async () => {
      mockSupabaseClient.single.mockResolvedValueOnce({
        data: null, // Client not found due to organization filter
        error: null
      })

      const request = new NextRequest('http://localhost:3000/api/leads', {
        method: 'PATCH',
        body: JSON.stringify({
          clientIds: ['client-1'],
          updates: { status: 'qualified' }
        })
      })

      const response = await PATCH(request)
      const data = await response.json()

      expect(response.status).toBe(200)
      expect(data.summary.successful).toBe(0)
      expect(data.summary.failed).toBe(1)
    })

    it('should update lead score after status change', async () => {
      const mockClient = {
        id: 'client-1',
        status: 'new',
        organization_id: 'org-123'
      }

      mockSupabaseClient.single.mockResolvedValueOnce({
        data: mockClient,
        error: null
      })

      mockSupabaseClient.update.mockReturnValue({
        ...mockSupabaseClient,
        data: mockClient,
        error: null
      })

      mockSupabaseClient.rpc
        .mockResolvedValueOnce({ data: true, error: null }) // update_lead_status
        .mockResolvedValueOnce({ data: 85, error: null })   // calculate_lead_score

      mockSupabaseClient.insert.mockResolvedValue({
        data: {},
        error: null
      })

      const request = new NextRequest('http://localhost:3000/api/leads', {
        method: 'PATCH',
        body: JSON.stringify({
          clientIds: ['client-1'],
          updates: { status: 'qualified' }
        })
      })

      await PATCH(request)

      expect(mockSupabaseClient.rpc).toHaveBeenCalledWith('calculate_lead_score', {
        client_uuid: 'client-1'
      })
    })
  })
})