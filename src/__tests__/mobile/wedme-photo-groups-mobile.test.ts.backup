/**
 * Comprehensive Mobile Testing Suite for WedMe Photo Groups Integration
 * WS-153 Team D Round 2 - Mobile Testing Implementation
 */

import { render, screen, fireEvent, waitFor, act } from '@testing-library/react';
import { jest } from '@jest/globals';
import userEvent from '@testing-library/user-event';
import '@testing-library/jest-dom';

// Mock Next.js router
jest.mock('next/navigation', () => ({
  useRouter: () => ({
    push: jest.fn(),
    back: jest.fn(),
  }),
  usePathname: () => '/wedme/test-wedding/photo-groups',
}));

// Mock hooks
jest.mock('@/hooks/useWeddingDayOffline', () => ({
  useWeddingDayOffline: () => ({
    isOnline: true,
    syncStatus: { hasUnsyncedData: false, pendingCount: 0 },
    preCache: { isPreCached: true },
  }),
}));

jest.mock('@/components/ui/use-toast', () => ({
  useToast: () => ({
    toast: jest.fn(),
  }),
}));

// Import components to test
import { PhotoGroupsMobile } from '@/components/wedme/PhotoGroupsMobile';
import { MobileGroupBuilder } from '@/components/wedme/MobileGroupBuilder';
import { MobileGuestAssignment } from '@/components/wedme/MobileGuestAssignment';
import { QuickShareModal } from '@/components/wedme/QuickShareModal';
import { OfflinePhotoGroupEditor } from '@/components/wedme/OfflinePhotoGroupEditor';
import { MobileConflictDetection } from '@/components/wedme/MobileConflictDetection';
import { useMobilePerformance } from '@/lib/performance/mobile-performance-optimizer';
import { useSwipeGesture, PullToRefresh, SwipeableCard } from '@/components/mobile/MobileEnhancedFeatures';

describe('WedMe Photo Groups Mobile Integration - Comprehensive Test Suite', () => {
  
  // Test Data
  const mockWeddingId = 'test-wedding-123';
  const mockPhotoGroups = [
    {
      id: '1',
      name: 'Family Portraits',
      description: 'Immediate family group shots',
      photoCount: 12,
      guestCount: 8,
      status: 'incomplete' as const,
      priority: 'high' as const,
      estimatedTime: '30 min',
      venue: 'Main Garden',
      conflicts: [],
      assignedGuests: [
        { id: 'g1', name: 'John Doe', relationship: 'Father' },
        { id: 'g2', name: 'Jane Doe', relationship: 'Mother' },
      ],
    },
    {
      id: '2',
      name: 'Wedding Party',
      description: 'Bridal party and groomsmen shots',
      photoCount: 24,
      guestCount: 12,
      status: 'complete' as const,
      priority: 'high' as const,
      estimatedTime: '45 min',
      venue: 'Rose Pavilion',
      conflicts: ['time-overlap-ceremony'],
      assignedGuests: [
        { id: 'g3', name: 'Maid of Honor', relationship: 'Best Friend' },
        { id: 'g4', name: 'Best Man', relationship: 'Brother' },
      ],
    },
  ];

  const mockGuests = [
    { id: 'g1', name: 'John Doe', relationship: 'Father', group: 'family' as const },
    { id: 'g2', name: 'Jane Doe', relationship: 'Mother', group: 'family' as const },
    { id: 'g3', name: 'Maid of Honor', relationship: 'Best Friend', group: 'wedding-party' as const },
    { id: 'g4', name: 'Best Man', relationship: 'Brother', group: 'wedding-party' as const },
    { id: 'g5', name: 'Uncle Bob', relationship: 'Uncle', group: 'family' as const },
  ];

  beforeEach(() => {
    // Reset all mocks
    jest.clearAllMocks();
    
    // Mock viewport for mobile testing
    Object.defineProperty(window, 'innerWidth', {
      writable: true,
      configurable: true,
      value: 375, // iPhone viewport width
    });
    
    Object.defineProperty(window, 'innerHeight', {
      writable: true,
      configurable: true,
      value: 667, // iPhone viewport height
    });

    // Mock touch support
    Object.defineProperty(window, 'ontouchstart', {
      writable: true,
      configurable: true,
      value: {},
    });

    // Mock navigator vibrate
    Object.defineProperty(navigator, 'vibrate', {
      writable: true,
      configurable: true,
      value: jest.fn(),
    });

    // Mock navigator share
    Object.defineProperty(navigator, 'share', {
      writable: true,
      configurable: true,
      value: jest.fn(() => Promise.resolve()),
    });

    // Mock clipboard
    Object.defineProperty(navigator, 'clipboard', {
      writable: true,
      configurable: true,
      value: {
        writeText: jest.fn(() => Promise.resolve()),
      },
    });
  });

  describe('1. PhotoGroupsMobile Component Tests', () => {
    test('renders mobile dashboard with photo groups', async () => {
      render(
        <PhotoGroupsMobile 
          weddingId={mockWeddingId} 
          onShare={jest.fn()} 
          onCreateGroup={jest.fn()} 
        />
      );

      expect(screen.getByText('Photo Groups')).toBeInTheDocument();
      expect(screen.getByText('Total Groups')).toBeInTheDocument();
      expect(screen.getByPlaceholderText('Search photo groups...')).toBeInTheDocument();
    });

    test('displays offline status indicator when offline', () => {
      // Mock offline state
      jest.mocked(require('@/hooks/useWeddingDayOffline').useWeddingDayOffline).mockReturnValue({
        isOnline: false,
        syncStatus: { hasUnsyncedData: true, pendingCount: 3 },
        preCache: { isPreCached: true },
      });

      render(<PhotoGroupsMobile weddingId={mockWeddingId} />);

      expect(screen.getByText('Offline')).toBeInTheDocument();
      expect(screen.getByText('3 pending')).toBeInTheDocument();
    });

    test('handles touch interactions on mobile', async () => {
      const user = userEvent.setup();
      render(<PhotoGroupsMobile weddingId={mockWeddingId} />);

      const searchInput = screen.getByPlaceholderText('Search photo groups...');
      
      // Simulate touch typing
      await user.type(searchInput, 'family');
      expect(searchInput).toHaveValue('family');
    });

    test('shows empty state with create button', () => {
      const onCreateGroup = jest.fn();
      render(
        <PhotoGroupsMobile 
          weddingId={mockWeddingId} 
          onCreateGroup={onCreateGroup}
        />
      );

      const createButton = screen.getByText('Create Photo Group');
      fireEvent.click(createButton);
      expect(onCreateGroup).toHaveBeenCalled();
    });

    test('handles native sharing on mobile', async () => {
      const onShare = jest.fn();
      render(<PhotoGroupsMobile weddingId={mockWeddingId} onShare={onShare} />);

      // Mock photo groups data would be needed here for actual share testing
      // This tests the component structure for share functionality
    });
  });

  describe('2. MobileGroupBuilder Component Tests', () => {
    test('renders step-by-step wizard interface', () => {
      render(
        <MobileGroupBuilder 
          weddingId={mockWeddingId}
          isOpen={true}
          onClose={jest.fn()}
          onComplete={jest.fn()}
        />
      );

      expect(screen.getByText('Create Photo Group')).toBeInTheDocument();
      expect(screen.getByText('Step 1 of 6')).toBeInTheDocument();
    });

    test('navigates through wizard steps', async () => {
      const user = userEvent.setup();
      render(
        <MobileGroupBuilder 
          weddingId={mockWeddingId}
          isOpen={true}
          onClose={jest.fn()}
          onComplete={jest.fn()}
        />
      );

      // Fill out first step
      const nameInput = screen.getByPlaceholderText('e.g., Family Portraits');
      await user.type(nameInput, 'Test Group');

      const nextButton = screen.getByText('Next');
      await user.click(nextButton);

      expect(screen.getByText('Step 2 of 6')).toBeInTheDocument();
    });

    test('validates required fields before proceeding', async () => {
      const user = userEvent.setup();
      render(
        <MobileGroupBuilder 
          weddingId={mockWeddingId}
          isOpen={true}
          onClose={jest.fn()}
          onComplete={jest.fn()}
        />
      );

      const nextButton = screen.getByText('Next');
      await user.click(nextButton);

      // Should still be on step 1 due to validation
      expect(screen.getByText('Step 1 of 6')).toBeInTheDocument();
    });

    test('auto-saves draft data', async () => {
      jest.useFakeTimers();
      
      const user = userEvent.setup({ advanceTimers: jest.advanceTimersByTime });
      render(
        <MobileGroupBuilder 
          weddingId={mockWeddingId}
          isOpen={true}
          onClose={jest.fn()}
          onComplete={jest.fn()}
        />
      );

      const nameInput = screen.getByPlaceholderText('e.g., Family Portraits');
      await user.type(nameInput, 'Auto Save Test');

      // Advance timers to trigger auto-save
      act(() => {
        jest.advanceTimersByTime(3000);
      });

      // Auto-save should have been triggered (would need to mock localStorage)
      jest.useRealTimers();
    });
  });

  describe('3. MobileGuestAssignment Component Tests', () => {
    test('renders guest assignment interface', () => {
      render(
        <MobileGuestAssignment 
          weddingId={mockWeddingId}
          photoGroups={mockPhotoGroups}
          availableGuests={mockGuests}
          onAssignGuest={jest.fn()}
          onUnassignGuest={jest.fn()}
          onUpdateGroups={jest.fn()}
        />
      );

      expect(screen.getByText('Guest Assignment')).toBeInTheDocument();
      expect(screen.getByText('Total Guests')).toBeInTheDocument();
    });

    test('displays guest cards with drag handles', () => {
      render(
        <MobileGuestAssignment 
          weddingId={mockWeddingId}
          photoGroups={mockPhotoGroups}
          availableGuests={mockGuests}
          onAssignGuest={jest.fn()}
          onUnassignGuest={jest.fn()}
          onUpdateGroups={jest.fn()}
        />
      );

      mockGuests.forEach(guest => {
        expect(screen.getByText(guest.name)).toBeInTheDocument();
      });
    });

    test('handles guest assignment via drag and drop', async () => {
      const onAssignGuest = jest.fn();
      render(
        <MobileGuestAssignment 
          weddingId={mockWeddingId}
          photoGroups={mockPhotoGroups}
          availableGuests={mockGuests}
          onAssignGuest={onAssignGuest}
          onUnassignGuest={jest.fn()}
          onUpdateGroups={jest.fn()}
        />
      );

      // Would need to simulate drag and drop events for full testing
      // This tests the component structure
    });

    test('filters guests by search query', async () => {
      const user = userEvent.setup();
      render(
        <MobileGuestAssignment 
          weddingId={mockWeddingId}
          photoGroups={mockPhotoGroups}
          availableGuests={mockGuests}
          onAssignGuest={jest.fn()}
          onUnassignGuest={jest.fn()}
          onUpdateGroups={jest.fn()}
        />
      );

      const searchInput = screen.getByPlaceholderText('Search guests...');
      await user.type(searchInput, 'John');

      // Should filter to show only John Doe
      expect(screen.getByText('John Doe')).toBeInTheDocument();
    });
  });

  describe('4. QuickShareModal Component Tests', () => {
    const mockPhotoGroup = mockPhotoGroups[0];

    test('renders share modal with options', () => {
      render(
        <QuickShareModal 
          isOpen={true}
          onClose={jest.fn()}
          photoGroup={mockPhotoGroup}
          weddingId={mockWeddingId}
          onShare={jest.fn()}
        />
      );

      expect(screen.getByText('Quick Share')).toBeInTheDocument();
      expect(screen.getByText('Link')).toBeInTheDocument();
      expect(screen.getByText('Contacts')).toBeInTheDocument();
      expect(screen.getByText('QR Code')).toBeInTheDocument();
    });

    test('generates and displays share link', async () => {
      render(
        <QuickShareModal 
          isOpen={true}
          onClose={jest.fn()}
          photoGroup={mockPhotoGroup}
          weddingId={mockWeddingId}
          onShare={jest.fn()}
        />
      );

      await waitFor(() => {
        expect(screen.getByText('Share')).toBeInTheDocument();
      });
    });

    test('handles native share API', async () => {
      const user = userEvent.setup();
      render(
        <QuickShareModal 
          isOpen={true}
          onClose={jest.fn()}
          photoGroup={mockPhotoGroup}
          weddingId={mockWeddingId}
          onShare={jest.fn()}
        />
      );

      await waitFor(() => {
        const shareButton = screen.getByText('Share');
        user.click(shareButton);
      });

      expect(navigator.share).toHaveBeenCalled();
    });

    test('falls back to clipboard when native share unavailable', async () => {
      // Remove native share support
      delete (navigator as any).share;
      
      const user = userEvent.setup();
      render(
        <QuickShareModal 
          isOpen={true}
          onClose={jest.fn()}
          photoGroup={mockPhotoGroup}
          weddingId={mockWeddingId}
          onShare={jest.fn()}
        />
      );

      await waitFor(async () => {
        const shareButton = screen.getByText('Share');
        await user.click(shareButton);
      });

      expect(navigator.clipboard.writeText).toHaveBeenCalled();
    });
  });

  describe('5. OfflinePhotoGroupEditor Component Tests', () => {
    test('renders offline editor interface', () => {
      render(
        <OfflinePhotoGroupEditor 
          photoGroupId="test-group"
          weddingId={mockWeddingId}
        />
      );

      expect(screen.getByText('Edit Photo Group')).toBeInTheDocument();
    });

    test('displays offline status indicator', () => {
      // Mock offline state
      jest.mocked(require('@/hooks/useWeddingDayOffline').useWeddingDayOffline).mockReturnValue({
        isOnline: false,
        syncStatus: { hasUnsyncedData: true, pendingCount: 2 },
        preCache: { isPreCached: true },
      });

      render(
        <OfflinePhotoGroupEditor 
          photoGroupId="test-group"
          weddingId={mockWeddingId}
        />
      );

      expect(screen.getByText('Offline')).toBeInTheDocument();
    });

    test('auto-saves changes locally', async () => {
      jest.useFakeTimers();
      
      const user = userEvent.setup({ advanceTimers: jest.advanceTimersByTime });
      render(
        <OfflinePhotoGroupEditor 
          photoGroupId="test-group"
          weddingId={mockWeddingId}
        />
      );

      // Wait for component to load
      await waitFor(() => {
        expect(screen.getByDisplayValue('Family Portraits')).toBeInTheDocument();
      });

      const nameInput = screen.getByDisplayValue('Family Portraits');
      await user.clear(nameInput);
      await user.type(nameInput, 'Updated Group Name');

      // Trigger auto-save
      act(() => {
        jest.advanceTimersByTime(3000);
      });

      expect(screen.getByText('Unsaved')).toBeInTheDocument();
      
      jest.useRealTimers();
    });

    test('handles undo/redo functionality', async () => {
      const user = userEvent.setup();
      render(
        <OfflinePhotoGroupEditor 
          photoGroupId="test-group"
          weddingId={mockWeddingId}
        />
      );

      await waitFor(() => {
        expect(screen.getByDisplayValue('Family Portraits')).toBeInTheDocument();
      });

      // Make a change
      const nameInput = screen.getByDisplayValue('Family Portraits');
      await user.clear(nameInput);
      await user.type(nameInput, 'Changed Name');

      // Test undo functionality would require more complex setup
      // This tests the component structure
    });
  });

  describe('6. MobileConflictDetection Component Tests', () => {
    test('renders conflict detection interface', () => {
      render(
        <MobileConflictDetection 
          photoGroups={mockPhotoGroups}
          weddingId={mockWeddingId}
          onResolveConflict={jest.fn()}
          onDismissConflict={jest.fn()}
          onAcknowledgeConflict={jest.fn()}
        />
      );

      expect(screen.getByText('Conflict Detection')).toBeInTheDocument();
    });

    test('detects and displays conflicts', () => {
      const conflictingGroups = [
        {
          ...mockPhotoGroups[0],
          startTime: '14:00',
          endTime: '14:30',
          venue: 'Garden',
        },
        {
          ...mockPhotoGroups[1],
          startTime: '14:15',
          endTime: '14:45',
          venue: 'Garden',
        },
      ];

      render(
        <MobileConflictDetection 
          photoGroups={conflictingGroups}
          weddingId={mockWeddingId}
          onResolveConflict={jest.fn()}
          onDismissConflict={jest.fn()}
          onAcknowledgeConflict={jest.fn()}
        />
      );

      // Should detect venue and time conflicts
      // Actual conflict detection logic would be tested here
    });

    test('handles conflict resolution', async () => {
      const onResolveConflict = jest.fn();
      const user = userEvent.setup();
      
      render(
        <MobileConflictDetection 
          photoGroups={mockPhotoGroups}
          weddingId={mockWeddingId}
          onResolveConflict={onResolveConflict}
          onDismissConflict={jest.fn()}
          onAcknowledgeConflict={jest.fn()}
        />
      );

      // Test conflict resolution interactions
      // Would need mock conflicts for full testing
    });
  });

  describe('7. Mobile Performance Tests', () => {
    test('mobile performance optimizer initializes correctly', () => {
      const { result } = renderHook(() => useMobilePerformance());
      
      expect(result.current.isOptimized).toBeDefined();
      expect(result.current.preloadResource).toBeDefined();
      expect(result.current.loadComponent).toBeDefined();
    });

    test('detects mobile device capabilities', () => {
      const { result } = renderHook(() => useMobilePerformance());
      
      // Mock mobile device detection
      expect(result.current.config).toBeDefined();
      expect(result.current.config.enableLazyLoading).toBe(true);
    });

    test('adapts to network conditions', () => {
      // Mock slow network
      Object.defineProperty(navigator, 'connection', {
        writable: true,
        configurable: true,
        value: {
          effectiveType: '2g',
          type: 'cellular'
        }
      });

      const { result } = renderHook(() => useMobilePerformance());
      
      expect(result.current.shouldLoadResource(500000)).toBe(false); // Large resource on slow network
      expect(result.current.shouldLoadResource(50000)).toBe(true);   // Small resource should load
    });
  });

  describe('8. Mobile Gesture Tests', () => {
    test('swipe gesture detection works', async () => {
      const onSwipe = jest.fn();
      const TestComponent = () => {
        const swipeProps = useSwipeGesture(onSwipe);
        return <div {...swipeProps} data-testid="swipe-area">Swipe me</div>;
      };

      render(<TestComponent />);
      
      const swipeArea = screen.getByTestId('swipe-area');
      
      // Simulate swipe gesture
      fireEvent.touchStart(swipeArea, {
        touches: [{ clientX: 100, clientY: 100 }]
      });
      
      fireEvent.touchEnd(swipeArea, {
        changedTouches: [{ clientX: 200, clientY: 100 }] // Swipe right
      });

      expect(onSwipe).toHaveBeenCalledWith('right');
    });

    test('pull to refresh functionality', async () => {
      const onRefresh = jest.fn(() => Promise.resolve());
      
      render(
        <PullToRefresh onRefresh={onRefresh}>
          <div>Content to refresh</div>
        </PullToRefresh>
      );

      const container = screen.getByText('Content to refresh').parentElement;
      
      // Simulate pull gesture
      fireEvent.touchStart(container!, {
        touches: [{ clientY: 100 }]
      });
      
      fireEvent.touchMove(container!, {
        touches: [{ clientY: 200 }] // Pull down 100px
      });
      
      fireEvent.touchEnd(container!);

      await waitFor(() => {
        expect(onRefresh).toHaveBeenCalled();
      });
    });

    test('swipeable card actions', async () => {
      const leftAction = jest.fn();
      const rightAction = jest.fn();
      
      render(
        <SwipeableCard 
          leftAction={{
            icon: <span>❤️</span>,
            color: 'bg-green-500',
            onAction: leftAction,
            label: 'Like'
          }}
          rightAction={{
            icon: <span>📤</span>,
            color: 'bg-blue-500', 
            onAction: rightAction,
            label: 'Share'
          }}
        >
          <div>Swipeable content</div>
        </SwipeableCard>
      );

      const card = screen.getByText('Swipeable content').parentElement;
      
      // Simulate left swipe for right action
      fireEvent.touchStart(card!, {
        touches: [{ clientX: 200 }]
      });
      
      fireEvent.touchMove(card!, {
        touches: [{ clientX: 50 }] // Swipe left 150px
      });
      
      fireEvent.touchEnd(card!);

      // Would need more complex simulation for actual swipe detection
      // This tests the component structure
    });
  });

  describe('9. Accessibility Tests', () => {
    test('components have proper ARIA labels', () => {
      render(<PhotoGroupsMobile weddingId={mockWeddingId} />);
      
      const createButton = screen.getByLabelText('Create new photo group');
      expect(createButton).toBeInTheDocument();
    });

    test('touch targets meet minimum size requirements', () => {
      render(<PhotoGroupsMobile weddingId={mockWeddingId} />);
      
      // All interactive elements should have minimum 44px touch targets
      const buttons = screen.getAllByRole('button');
      buttons.forEach(button => {
        const styles = window.getComputedStyle(button);
        const minHeight = parseInt(styles.minHeight) || parseInt(styles.height);
        expect(minHeight).toBeGreaterThanOrEqual(44);
      });
    });

    test('supports screen reader navigation', () => {
      render(
        <MobileGroupBuilder 
          weddingId={mockWeddingId}
          isOpen={true}
          onClose={jest.fn()}
          onComplete={jest.fn()}
        />
      );

      // Check for proper heading structure
      expect(screen.getByRole('heading', { level: 1 })).toBeInTheDocument();
    });
  });

  describe('10. Integration Tests', () => {
    test('components work together in complete workflow', async () => {
      const user = userEvent.setup();
      
      // Start with dashboard
      const onCreateGroup = jest.fn();
      const { rerender } = render(
        <PhotoGroupsMobile 
          weddingId={mockWeddingId} 
          onCreateGroup={onCreateGroup}
        />
      );

      // Click create button
      const createButton = screen.getByText('Create Photo Group');
      await user.click(createButton);
      expect(onCreateGroup).toHaveBeenCalled();

      // Switch to group builder
      const onComplete = jest.fn();
      rerender(
        <MobileGroupBuilder 
          weddingId={mockWeddingId}
          isOpen={true}
          onClose={jest.fn()}
          onComplete={onComplete}
        />
      );

      expect(screen.getByText('Create Photo Group')).toBeInTheDocument();
    });

    test('offline sync works across components', () => {
      // Mock offline state with pending changes
      jest.mocked(require('@/hooks/useWeddingDayOffline').useWeddingDayOffline).mockReturnValue({
        isOnline: false,
        syncStatus: { hasUnsyncedData: true, pendingCount: 5 },
        preCache: { isPreCached: true },
      });

      render(<PhotoGroupsMobile weddingId={mockWeddingId} />);
      expect(screen.getByText('5 pending')).toBeInTheDocument();

      render(<OfflinePhotoGroupEditor photoGroupId="test" weddingId={mockWeddingId} />);
      expect(screen.getByText('Offline')).toBeInTheDocument();
    });
  });
});

// Helper function to render hooks
function renderHook<T>(hook: () => T) {
  let result: { current: T } = { current: undefined as any };
  
  function TestComponent() {
    result.current = hook();
    return null;
  }
  
  render(<TestComponent />);
  
  return { result };
}