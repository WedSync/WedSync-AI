/**
 * Apple Calendar Integration Penetration Testing Suite
 * Team E Implementation - WS-218
 * Security validation and vulnerability assessment
 */

import {
  describe,
  test,
  expect,
  beforeEach,
  afterEach,
  jest,
} from '@jest/globals';
import AppleCalendarSecurityManager from '../../lib/security/apple-calendar-security';

describe('Apple Calendar Security Penetration Tests', () => {
  let securityManager: AppleCalendarSecurityManager;

  beforeEach(() => {
    securityManager = new AppleCalendarSecurityManager({
      maxFailedAttempts: 3,
      lockoutDuration: 900000,
      auditLogEnabled: true,
    });
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('Authentication Security Tests', () => {
    test('should reject malformed Apple ID attempts', async () => {
      const maliciousAttempts = [
        'admin@apple.com', // Potential impersonation
        "test@icloud.com'OR'1'='1", // SQL injection attempt
        'user@domain.com<script>alert(1)</script>', // XSS attempt
        'a'.repeat(1000) + '@domain.com', // Buffer overflow attempt
        '../../../etc/passwd@domain.com', // Path traversal attempt
      ];

      for (const maliciousId of maliciousAttempts) {
        const result = await securityManager.validateCalDAVAuth({
          appleId: maliciousId,
          appSpecificPassword: 'test-test-test-test',
          serverUrl: 'https://caldav.icloud.com',
        });

        expect(result.isValid).toBe(false);
        expect(result.riskAssessment).toBeOneOf(['HIGH', 'CRITICAL']);
        expect(result.securityIssues.length).toBeGreaterThan(0);
      }
    });

    test('should enforce app-specific password format', async () => {
      const invalidPasswords = [
        'password123', // Regular password
        'abcd-efgh-ijkl', // Too short
        'abcd-efgh-ijkl-mnop-qrst', // Too long
        'ABCD-EFGH-IJKL-MNOP', // Uppercase (should be lowercase)
        'abcd-efgh-ijkl-mn0p', // Contains numbers
        'abcd-efgh-ijkl-mn@p', // Contains special characters
      ];

      for (const password of invalidPasswords) {
        const result = await securityManager.validateCalDAVAuth({
          appleId: 'test@icloud.com',
          appSpecificPassword: password,
          serverUrl: 'https://caldav.icloud.com',
        });

        expect(result.isValid).toBe(false);
        expect(result.securityIssues).toContain(
          'Invalid app-specific password format',
        );
      }
    });

    test('should enforce HTTPS-only connections', async () => {
      const insecureUrls = [
        'http://caldav.icloud.com', // HTTP instead of HTTPS
        'ftp://caldav.icloud.com', // Wrong protocol
        'caldav.icloud.com', // Missing protocol
        'https://malicious-site.com/caldav', // Suspicious domain
      ];

      for (const url of insecureUrls) {
        const result = await securityManager.validateCalDAVAuth({
          appleId: 'test@icloud.com',
          appSpecificPassword: 'abcd-efgh-ijkl-mnop',
          serverUrl: url,
        });

        expect(result.isValid).toBe(false);
        expect(result.riskAssessment).toBeOneOf(['HIGH', 'CRITICAL']);
      }
    });

    test('should implement rate limiting and account lockout', async () => {
      const credentials = {
        appleId: 'test@icloud.com',
        appSpecificPassword: 'invalid-pass-word',
        serverUrl: 'https://caldav.icloud.com',
      };

      // Make multiple failed attempts
      for (let i = 0; i < 5; i++) {
        const result = await securityManager.validateCalDAVAuth(credentials);

        if (i < 3) {
          // First 3 attempts should process normally
          expect(result.securityIssues).not.toContain(
            'Account temporarily locked',
          );
        } else {
          // After 3 failed attempts, account should be locked
          expect(result.securityIssues).toContain('Account temporarily locked');
          expect(result.riskAssessment).toBe('HIGH');
        }
      }
    });
  });

  describe('Data Encryption Security Tests', () => {
    test('should encrypt sensitive calendar data', () => {
      const sensitiveData = JSON.stringify({
        weddingDate: '2024-06-15',
        venue: 'Secret Garden Resort',
        guests: ['John Doe', 'Jane Smith'],
        budget: 50000,
        vendors: ['photographer@example.com', 'caterer@example.com'],
      });

      const encrypted = securityManager.encryptCalendarData(sensitiveData);

      expect(encrypted.encrypted).toBeDefined();
      expect(encrypted.iv).toBeDefined();
      expect(encrypted.tag).toBeDefined();
      expect(encrypted.encrypted).not.toContain('Secret Garden Resort');
      expect(encrypted.encrypted).not.toContain('50000');
    });

    test('should decrypt data correctly', () => {
      const originalData = 'Wedding at Sunset Venue on 2024-06-15 at 4:00 PM';

      const encrypted = securityManager.encryptCalendarData(originalData);
      const decrypted = securityManager.decryptCalendarData(
        encrypted.encrypted,
        encrypted.iv,
        encrypted.tag,
      );

      expect(decrypted).toBe(originalData);
    });

    test('should fail decryption with tampered data', () => {
      const originalData = 'Confidential wedding information';
      const encrypted = securityManager.encryptCalendarData(originalData);

      // Tamper with encrypted data
      const tamperedData = encrypted.encrypted.slice(0, -2) + '00';

      expect(() => {
        securityManager.decryptCalendarData(
          tamperedData,
          encrypted.iv,
          encrypted.tag,
        );
      }).toThrow();
    });
  });

  describe('Wedding Context Security Tests', () => {
    test('should secure wedding day data with highest priority', async () => {
      const weddingDayCredentials = {
        appleId: 'photographer@weddingpro.com',
        appSpecificPassword: 'abcd-efgh-ijkl-mnop',
        serverUrl: 'https://caldav.icloud.com',
      };

      const result = await securityManager.validateCalDAVAuth(
        weddingDayCredentials,
      );

      // Wedding professional accounts should have enhanced security
      expect(result.auditId).toBeDefined();
      expect(result.recommendations).toBeDefined();

      // Verify audit logging is active
      expect(result.auditId.startsWith('audit_')).toBe(true);
    });

    test('should validate vendor email formats', async () => {
      const vendorEmails = [
        'photographer@invalid', // Missing TLD
        'caterer@.com', // Missing domain
        'florist@domain.', // Missing TLD
        'venue@domain..com', // Double dots
        'dj@domain.c', // TLD too short
        'band@' + 'a'.repeat(250) + '.com', // Domain too long
      ];

      for (const email of vendorEmails) {
        const result = await securityManager.validateCalDAVAuth({
          appleId: email,
          appSpecificPassword: 'abcd-efgh-ijkl-mnop',
          serverUrl: 'https://caldav.icloud.com',
        });

        expect(result.isValid).toBe(false);
        expect(result.securityIssues).toContain('Invalid Apple ID format');
      }
    });
  });

  describe('Production Environment Security Tests', () => {
    test('should never log sensitive credentials', async () => {
      const consoleSpy = jest.spyOn(console, 'log');
      const errorSpy = jest.spyOn(console, 'error');

      const credentials = {
        appleId: 'sensitive@icloud.com',
        appSpecificPassword: 'abcd-efgh-ijkl-mnop',
        serverUrl: 'https://caldav.icloud.com',
      };

      await securityManager.validateCalDAVAuth(credentials);

      // Check that no sensitive data was logged
      const allLogs = [
        ...consoleSpy.mock.calls.flat(),
        ...errorSpy.mock.calls.flat(),
      ].join(' ');

      expect(allLogs).not.toContain(credentials.appleId);
      expect(allLogs).not.toContain(credentials.appSpecificPassword);

      consoleSpy.mockRestore();
      errorSpy.mockRestore();
    });

    test('should validate environment variable security', () => {
      // Ensure encryption key is not exposed
      expect(process.env.APPLE_CALENDAR_ENCRYPTION_KEY).toBeDefined();

      // Key should be hex format and proper length
      const encryptionKey = process.env.APPLE_CALENDAR_ENCRYPTION_KEY;
      if (encryptionKey) {
        expect(encryptionKey).toMatch(/^[0-9a-f]{64}$/i); // 32 bytes in hex
      }
    });

    test('should handle network timeouts securely', async () => {
      // Mock network timeout scenario
      const timeoutCredentials = {
        appleId: 'timeout-test@icloud.com',
        appSpecificPassword: 'abcd-efgh-ijkl-mnop',
        serverUrl: 'https://timeout-test-server.com',
      };

      const result =
        await securityManager.validateCalDAVAuth(timeoutCredentials);

      // Should handle timeouts gracefully without exposing system information
      expect(result.isValid).toBe(false);
      expect(result.securityIssues).not.toContain('ECONNREFUSED');
      expect(result.securityIssues).not.toContain('ETIMEDOUT');
      expect(
        result.securityIssues.some(
          (issue) => issue.includes('connection') || issue.includes('network'),
        ),
      ).toBe(true);
    });
  });

  describe('iOS/macOS Specific Security Tests', () => {
    test('should validate Apple ecosystem integration points', async () => {
      const appleServers = [
        'https://caldav.icloud.com',
        'https://p01-caldav.icloud.com',
        'https://p02-caldav.icloud.com',
        'https://p03-caldav.icloud.com',
      ];

      for (const server of appleServers) {
        const result = await securityManager.validateCalDAVAuth({
          appleId: 'test@icloud.com',
          appSpecificPassword: 'abcd-efgh-ijkl-mnop',
          serverUrl: server,
        });

        // Apple servers should not be flagged as security issues
        const hasServerIssues = result.securityIssues.some((issue) =>
          issue.includes('Invalid Apple CalDAV server'),
        );
        expect(hasServerIssues).toBe(false);
      }
    });

    test('should validate Keychain integration security', async () => {
      // Test that credentials are properly formatted for Apple Keychain storage
      const keychainTestData = {
        appleId: 'keychain-test@icloud.com',
        appSpecificPassword: 'abcd-efgh-ijkl-mnop',
        serverUrl: 'https://caldav.icloud.com',
      };

      const result = await securityManager.validateCalDAVAuth(keychainTestData);

      // Should pass basic validation for Keychain storage
      if (result.isValid) {
        expect(result.riskAssessment).toBeOneOf(['LOW', 'MEDIUM']);
      }
    });
  });

  describe('Wedding Industry Compliance Tests', () => {
    test('should comply with wedding data protection standards', async () => {
      // Test GDPR-like compliance for wedding data
      const weddingVendorCredentials = {
        appleId: 'gdpr-test@weddingvendor.eu',
        appSpecificPassword: 'abcd-efgh-ijkl-mnop',
        serverUrl: 'https://caldav.icloud.com',
      };

      const result = await securityManager.validateCalDAVAuth(
        weddingVendorCredentials,
      );

      // Audit ID should be generated for compliance tracking
      expect(result.auditId).toBeDefined();
      expect(result.auditId.length).toBeGreaterThan(10);
    });

    test('should handle multi-vendor authentication scenarios', async () => {
      const vendorTypes = [
        'photographer@studio.com',
        'venue@gardens.com',
        'catering@delicious.com',
        'florist@blooms.com',
        'dj@music.com',
      ];

      const results = await Promise.all(
        vendorTypes.map((vendorEmail) =>
          securityManager.validateCalDAVAuth({
            appleId: vendorEmail,
            appSpecificPassword: 'abcd-efgh-ijkl-mnop',
            serverUrl: 'https://caldav.icloud.com',
          }),
        ),
      );

      // Each vendor should be processed independently
      expect(results).toHaveLength(5);
      results.forEach((result, index) => {
        expect(result.auditId).toBeDefined();
        expect(result.auditId).not.toBe(results[(index + 1) % 5]?.auditId);
      });
    });
  });
});

// Test utilities
expect.extend({
  toBeOneOf(received: any, expected: any[]) {
    const pass = expected.includes(received);
    if (pass) {
      return {
        message: () =>
          `expected ${received} not to be one of ${expected.join(', ')}`,
        pass: true,
      };
    } else {
      return {
        message: () =>
          `expected ${received} to be one of ${expected.join(', ')}`,
        pass: false,
      };
    }
  },
});
