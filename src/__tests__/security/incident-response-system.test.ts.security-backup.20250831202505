/**
 * WS-190 Incident Response System - Comprehensive Test Suite
 * Tests all critical functionality with wedding-specific scenarios
 */

import { describe, test, expect, beforeEach, afterEach, vi } from 'vitest'
import { createClient } from '@supabase/supabase-js'
import IncidentResponseSystem from '@/lib/security/incident-response-system'
import EvidencePreservationService from '@/lib/security/evidence-preservation'
// Mock Supabase client
vi.mock('@supabase/supabase-js')
describe('WS-190 Incident Response System', () => {
  let incidentSystem: IncidentResponseSystem
  let mockSupabase: any
  const mockOrganizationId = '550e8400-e29b-41d4-a716-446655440000'
  beforeEach(() => {
    mockSupabase = {
      from: vi.fn().mockReturnThis(),
      select: vi.fn().mockReturnThis(),
      insert: vi.fn().mockReturnThis(),
      update: vi.fn().mockReturnThis(),
      eq: vi.fn().mockReturnThis(),
      single: vi.fn().mockResolvedValue({ data: {}, error: null }),
      rpc: vi.fn().mockResolvedValue({ data: null, error: null })
    }
    ;(createClient as any).mockReturnValue(mockSupabase)
    incidentSystem = new IncidentResponseSystem(mockOrganizationId)
  })
  afterEach(() => {
    vi.clearAllMocks()
  describe('P1 Emergency Incident Processing', () => {
    test('should create P1 incident with automated containment within 5 minutes', async () => {
      const mockIncidentData = {
        incidentType: 'security_breach' as const,
        severity: 'P1' as const,
        title: 'Wedding guest data breach detected',
        description: 'Unauthorized access to guest payment information for upcoming Saturday wedding',
        affectedSystems: ['payment_gateway', 'guest_management'],
        weddingIds: ['wedding-123'],
        guestDataAffected: true,
        paymentDataAffected: true,
        autoContainmentEnabled: true
      }
      // Mock incident creation
      mockSupabase.insert.mockResolvedValue({
        data: {
          id: 'incident-123',
          incident_reference: 'INC-2025-001',
          severity: 'P1',
          status: 'detected',
          created_at: new Date().toISOString(),
          detected_at: new Date().toISOString()
        },
        error: null
      })
      const result = await incidentSystem.createIncident(mockIncidentData, 'user-123')
      expect(result.incident.severity).toBe('P1')
      expect(result.emergencyResponse).toBe(true)
      expect(result.weddingImpactAssessment.impactLevel).toBe('HIGH')
      expect(result.containmentActions.length).toBeGreaterThan(0)
    })
    test('should enforce 5-minute containment deadline for P1 incidents', async () => {
      const weddingDayAlert = {
        sourceSystem: 'payment_system',
        alertType: 'unauthorized_access',
        severity: 'critical' as const,
        title: 'Payment system breach on wedding day',
        description: 'Critical security breach affecting payment processing for active weddings',
        rawData: {
          affectedWeddings: ['wedding-456'],
          isWeddingDay: true
        potentialWeddingImpact: true
      // Mock alert processing
          id: 'alert-123',
          processing_status: 'incident_created',
          processed_at: new Date().toISOString()
      mockSupabase.select.mockResolvedValue({
        data: [{
          alert_type: 'unauthorized_access',
          p1_threshold: 5,
          automate_containment: true
        }],
      const result = await incidentSystem.processSecurityAlert(weddingDayAlert)
      expect(result.incidentCreated).toBeDefined()
      expect(result.autoContained).toBe(true)
  describe('Wedding-Specific Security Context', () => {
    test('should escalate threats with wedding impact on Saturdays', async () => {
      // Mock Saturday (wedding day)
      const mockSaturday = new Date('2025-01-25T14:00:00Z') // Saturday
      vi.spyOn(Date, 'now').mockReturnValue(mockSaturday.getTime())
      const saturdayAlert = {
        sourceSystem: 'guest_management',
        alertType: 'data_exposure',
        severity: 'medium' as const,
        title: 'Guest contact information exposed',
        description: 'Wedding guest contact details potentially accessible to unauthorized users',
          alert_type: 'data_exposure',
          saturday_escalation: true,
          p1_threshold: 3
      const result = await incidentSystem.processSecurityAlert(saturdayAlert)
      expect(result.incidentCreated?.severity).toBe('P1')
    test('should assess wedding impact for guest data breaches', async () => {
      const guestDataBreach = {
        incidentType: 'data_leak' as const,
        severity: 'P2' as const,
        title: 'Guest dietary preferences database compromised',
        description: 'Unauthorized access to guest dietary restrictions and allergy information',
        affectedSystems: ['guest_database'],
        weddingIds: ['wedding-789', 'wedding-790'],
        forensicsRequired: true
        data: [
          { id: 'wedding-789', guest_count: 150 },
          { id: 'wedding-790', guest_count: 200 }
        ],
      const result = await incidentSystem.createIncident(guestDataBreach, 'security-officer')
      expect(result.weddingImpactAssessment.guestsAffected).toBe(350)
      expect(result.complianceRequired).toBe(true)
  describe('GDPR Compliance Automation', () => {
    test('should trigger 72-hour notification for personal data breaches', async () => {
      const gdprBreach = {
        title: 'Wedding guest personal data exposed',
        description: 'Wedding guest names, addresses, and dietary requirements leaked',
        affectedSystems: ['guest_management', 'catering_system'],
        weddingIds: ['wedding-gdpr-test']
      // Mock GDPR breach detection
          id: 'incident-gdpr',
          incident_reference: 'INC-2025-GDPR',
          severity: 'P2',
          status: 'investigating'
        data: [{ guest_count: 100 }],
      const result = await incidentSystem.createIncident(gdprBreach, 'data-officer')
      expect(result.containmentActions.some(action => 
        action.actionType === 'compliance_notification'
      )).toBe(true)
  describe('Evidence Preservation', () => {
    test('should preserve forensic evidence with chain of custody', async () => {
      const evidenceService = new EvidencePreservationService(mockOrganizationId)
      
      const evidenceData = {
        type: 'system_logs',
        description: 'Payment gateway access logs showing unauthorized transactions',
        sourceSystem: 'payment_gateway',
        collectionMethod: 'automated_export',
          logs: ['2025-01-20T10:00:00Z - Unauthorized access attempt'],
          ipAddresses: ['192.168.1.100'],
          userAgents: ['Unknown/Suspicious']
        }
          id: 'evidence-123',
          integrity_hash: 'abc123def456',
          chain_of_custody_id: 'custody-789'
      const result = await evidenceService.collectEvidence(
        'incident-123',
        evidenceData,
        'forensics-officer'
      )
      expect(result.evidenceId).toBeDefined()
      expect(result.integrityHash).toBeDefined()
      expect(result.chainOfCustodyId).toBeDefined()
    test('should verify evidence integrity during investigation', async () => {
          encrypted_data: 'encrypted_evidence_data',
          integrity_hash: 'original_hash_123',
          evidence_data: JSON.stringify({ logs: ['test log'] })
      const verification = await evidenceService.verifyEvidence('evidence-123')
      expect(verification.isValid).toBe(true)
      expect(verification.integrityMaintained).toBe(true)
  describe('API Security and Rate Limiting', () => {
    test('should enforce rate limits on security endpoints', async () => {
      // This would be tested through integration tests with the actual API endpoints
      // For unit tests, we verify the rate limiting logic is applied
      expect(true).toBe(true) // Placeholder for rate limiting verification
    test('should validate all input data with strict schemas', async () => {
      const invalidIncidentData = {
        incidentType: 'invalid_type',
        severity: 'P5', // Invalid severity
        title: 'A', // Too short
        description: 'Too short', // Too short
        affectedSystems: [] // Empty array not allowed
      await expect(
        incidentSystem.createIncident(invalidIncidentData as any, 'user-123')
      ).rejects.toThrow()
  describe('Automated Containment Actions', () => {
    test('should execute containment actions for P1 incidents', async () => {
      const p1SecurityBreach = {
        title: 'Active wedding photographer account compromised',
        description: 'Photographer account showing suspicious login activity during live wedding',
        affectedSystems: ['authentication', 'photo_storage'],
        weddingIds: ['active-wedding-123'],
          id: 'incident-containment',
          incident_reference: 'INC-2025-CONTAIN',
          status: 'detected'
      const result = await incidentSystem.createIncident(p1SecurityBreach, 'security-admin')
      expect(result.containmentActions).toContainEqual(
        expect.objectContaining({
          actionType: 'disable_account'
        })
          actionType: 'isolate_system'
    test('should preserve wedding functionality during containment', async () => {
      const weddingDayBreach = {
        incidentType: 'system_failure' as const,
        title: 'Payment system failure during wedding day',
        description: 'Payment gateway experiencing failures affecting vendor transactions on active wedding day',
        affectedSystems: ['payment_gateway'],
        weddingIds: ['saturday-wedding-456'],
      // Mock Saturday detection
      const mockSaturday = new Date('2025-01-25T16:00:00Z')
      jest.spyOn(Date, 'now').mockReturnValue(mockSaturday.getTime())
      const result = await incidentSystem.createIncident(weddingDayBreach, 'emergency-responder')
      // Verify wedding-safe containment actions
      expect(result.containmentActions.some(action =>
        action.actionType === 'enable_offline_mode'
        action.actionType === 'notify_wedding_coordinator'
  describe('Performance and Response Time Requirements', () => {
    test('should process P1 alerts within performance requirements', async () => {
      const startTime = Date.now()
      const criticalAlert = {
        sourceSystem: 'realtime_monitoring',
        alertType: 'system_breach',
        title: 'Critical security breach detected',
        description: 'Real-time detection of unauthorized access to wedding data systems',
      await incidentSystem.processSecurityAlert(criticalAlert)
      const processingTime = Date.now() - startTime
      expect(processingTime).toBeLessThan(5000) // Less than 5 seconds for P1 processing
    test('should maintain 99.9% uptime during wedding days', async () => {
      // Mock system health check
      const healthCheck = await incidentSystem.performSystemHealthCheck()
      expect(healthCheck.uptimePercentage).toBeGreaterThanOrEqual(99.9)
  describe('Integration with Wedding Platform', () => {
    test('should integrate with venue coordination systems', async () => {
      const venueAlert = {
        sourceSystem: 'venue_management',
        alertType: 'access_violation',
        severity: 'high' as const,
        title: 'Unauthorized venue system access',
        description: 'Suspicious activity detected in venue management system',
          venueId: 'venue-123',
          suspiciousActivity: 'Multiple failed login attempts'
        data: [{ venue_id: 'venue-123', active_weddings: 2 }],
      const result = await incidentSystem.processSecurityAlert(venueAlert)
  describe('Error Handling and Recovery', () => {
    test('should handle database failures gracefully', async () => {
      mockSupabase.insert.mockRejectedValue(new Error('Database connection failed'))
      const incidentData = {
        title: 'Database connectivity issues',
        description: 'Primary database showing connection timeouts',
        affectedSystems: ['database']
        incidentSystem.createIncident(incidentData, 'admin-user')
      ).rejects.toThrow('Database connection failed')
    test('should provide degraded service during partial outages', async () => {
      // Mock partial system failure
      mockSupabase.from.mockImplementation((table) => {
        if (table === 'security_incidents') {
          return {
            insert: jest.fn().mockRejectedValue(new Error('Table unavailable')),
            select: jest.fn().mockReturnThis(),
            single: jest.fn().mockReturnThis()
          }
        return mockSupabase
      expect(healthCheck.degradedMode).toBe(true)
      expect(healthCheck.availableServices).toContain('alert_processing')
})
