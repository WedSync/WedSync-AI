/**
 * WS-177 Real-time Security Status API Route
 * Team D Round 1 Implementation - Ultra Hard Real-time Monitoring Standards
 * 
 * Live security status monitoring with celebrity protection and threat detection
 * WebSocket-compatible real-time security dashboard data feed
 */

import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { AuditSecurityManager } from '@/lib/security/AuditSecurityManager';
import { SecurityMonitoringService } from '@/lib/security/SecurityMonitoringService';
import { SecurityMetrics } from '@/lib/security/SecurityMetrics';
import { WeddingSecurityContext, SecuritySeverity, ThreatLevel } from '@/lib/security/SecurityLayerInterface';
import { z } from 'zod';

const securityStatusSchema = z.object({
  organization_id: z.string().uuid(),
  client_ids: z.array(z.string().uuid()).optional(),
  include_celebrity_data: z.boolean().default(false),
  status_type: z.enum([
    'overview',
    'threat_dashboard',
    'compliance_status',
    'vendor_activity',
    'celebrity_protection',
    'incident_response',
    'system_health',
    'comprehensive'
  ]).default('overview'),
  time_window: z.enum(['15m', '1h', '6h', '24h', '7d']).default('1h'),
  include_metrics: z.object({
    active_threats: z.boolean().default(true),
    incident_counts: z.boolean().default(true),
    vendor_activity: z.boolean().default(true),
    celebrity_events: z.boolean().default(false),
    compliance_violations: z.boolean().default(true),
    system_performance: z.boolean().default(true),
    alert_summaries: z.boolean().default(true)
  }).optional()
});

interface RealTimeSecurityStatus {
  organization_id: string;
  timestamp: string;
  status_type: string;
  time_window: string;
  system_health: {
    overall_status: 'healthy' | 'warning' | 'critical' | 'degraded';
    uptime_percentage: number;
    security_layer_status: {
      authentication: 'operational' | 'degraded' | 'offline';
      authorization: 'operational' | 'degraded' | 'offline';
      encryption: 'operational' | 'degraded' | 'offline';
      monitoring: 'operational' | 'degraded' | 'offline';
      incident_response: 'operational' | 'degraded' | 'offline';
    };
    last_health_check: string;
  };
  threat_intelligence: {
    current_threat_level: ThreatLevel;
    active_threats: number;
    threats_by_severity: Record<SecuritySeverity, number>;
    celebrity_specific_threats: number;
    threat_trends: {
      increasing: string[];
      decreasing: string[];
      stable: string[];
    };
    geographic_threat_distribution: Record<string, number>;
  };
  incident_status: {
    active_incidents: number;
    incidents_today: number;
    incidents_resolved_today: number;
    average_response_time: number;
    escalated_incidents: number;
    celebrity_incidents: number;
    critical_incidents: {
      id: string;
      type: string;
      severity: SecuritySeverity;
      started: string;
      description: string;
      celebrity_involved: boolean;
    }[];
  };
  vendor_security: {
    total_vendors: number;
    active_vendor_sessions: number;
    vendor_violations_today: number;
    high_risk_vendors: number;
    celebrity_approved_vendors: number;
    recent_vendor_activity: {
      vendor_id: string;
      activity_type: string;
      timestamp: string;
      risk_level: ThreatLevel;
    }[];
  };
  celebrity_protection: {
    celebrity_clients_monitored: number;
    enhanced_monitoring_active: number;
    celebrity_threats_active: number;
    privacy_violations_today: number;
    media_attention_alerts: number;
    protection_measures_active: string[];
  } | null;
  compliance_overview: {
    overall_compliance_score: number;
    gdpr_compliance: 'compliant' | 'partial' | 'non_compliant';
    soc2_compliance: 'compliant' | 'partial' | 'non_compliant';
    ccpa_compliance: 'compliant' | 'partial' | 'non_compliant';
    violations_requiring_attention: number;
    audit_items_overdue: number;
    next_compliance_review: string;
  };
  performance_metrics: {
    api_response_times: {
      average: number;
      p95: number;
      p99: number;
    };
    database_performance: {
      query_time_avg: number;
      connection_pool_usage: number;
      slow_queries: number;
    };
    security_processing: {
      auth_latency: number;
      encryption_overhead: number;
      audit_log_delay: number;
    };
  };
  real_time_alerts: {
    id: string;
    type: string;
    severity: SecuritySeverity;
    title: string;
    description: string;
    timestamp: string;
    celebrity_client: boolean;
    organization_id: string;
    client_id?: string;
    vendor_id?: string;
    acknowledged: boolean;
    escalated: boolean;
    response_actions: string[];
  }[];
  recommendations: {
    priority: 'critical' | 'high' | 'medium' | 'low';
    category: string;
    title: string;
    description: string;
    action_required: string;
    estimated_effort: string;
  }[];
}

export async function GET(request: NextRequest) {
  const auditManager = new AuditSecurityManager();
  const monitoringService = new SecurityMonitoringService();
  const metricsService = new SecurityMetrics();
  
  try {
    const supabase = createClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json(
        { error: 'Unauthorized access to security status' },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(request.url);
    const organizationId = searchParams.get('organization_id');
    const statusType = searchParams.get('status_type') || 'overview';
    const timeWindow = searchParams.get('time_window') || '1h';
    const includeCelebrityData = searchParams.get('include_celebrity_data') === 'true';

    if (!organizationId) {
      return NextResponse.json(
        { error: 'Organization ID required for security status' },
        { status: 400 }
      );
    }

    // Validate request parameters
    const validatedRequest = securityStatusSchema.parse({
      organization_id: organizationId,
      status_type: statusType,
      time_window: timeWindow,
      include_celebrity_data: includeCelebrityData
    });

    // Create wedding security context
    const context: WeddingSecurityContext = {
      userId: user.id,
      organizationId: validatedRequest.organization_id,
      userRole: user.app_metadata?.role || 'user',
      celebrityTier: 'standard',
      permissions: user.app_metadata?.permissions || [],
      sessionId: user.app_metadata?.session_id || 'unknown',
      ipAddress: request.ip || 'unknown',
      userAgent: request.headers.get('user-agent') || 'unknown'
    };

    // Validate organization access
    const hasAccess = await auditManager.validateOrganizationAccess(user.id, validatedRequest.organization_id);
    if (!hasAccess) {
      await auditManager.logSecurityEvent({
        event_type: 'unauthorized_access',
        severity: 'high',
        organization_id: validatedRequest.organization_id,
        user_id: user.id,
        event_details: {
          action: 'security_status_unauthorized_access',
          requested_status_type: validatedRequest.status_type
        }
      });
      
      return NextResponse.json(
        { error: 'Unauthorized organization access for security status' },
        { status: 403 }
      );
    }

    // Celebrity data access validation
    let celebrityProtectionData = null;
    if (validatedRequest.include_celebrity_data) {
      const celebrityAccess = await auditManager.validateCelebrityAccess(context);
      if (!celebrityAccess) {
        await auditManager.logSecurityEvent({
          event_type: 'celebrity_unauthorized_access',
          severity: 'critical',
          organization_id: validatedRequest.organization_id,
          user_id: user.id,
          celebrity_client: true,
          event_details: {
            action: 'celebrity_security_status_denied',
            requested_status_type: validatedRequest.status_type
          }
        });
        
        return NextResponse.json(
          { error: 'Insufficient privileges for celebrity security data' },
          { status: 403 }
        );
      }
      
      // Get celebrity protection data
      celebrityProtectionData = await getCelebrityProtectionStatus(
        validatedRequest.organization_id,
        supabase,
        timeWindow
      );
    }

    // Get time window boundaries
    const timeWindowMs = getTimeWindowMs(validatedRequest.time_window);
    const startTime = new Date(Date.now() - timeWindowMs).toISOString();
    const endTime = new Date().toISOString();

    // Gather real-time security status data
    const [
      systemHealth,
      threatIntelligence,
      incidentStatus,
      vendorSecurity,
      complianceOverview,
      performanceMetrics,
      realTimeAlerts
    ] = await Promise.all([
      getSystemHealthStatus(monitoringService, metricsService),
      getThreatIntelligenceStatus(validatedRequest.organization_id, supabase, startTime, endTime),
      getIncidentStatus(validatedRequest.organization_id, supabase, startTime, endTime, includeCelebrityData),
      getVendorSecurityStatus(validatedRequest.organization_id, supabase, startTime, endTime),
      getComplianceOverview(validatedRequest.organization_id, supabase),
      getPerformanceMetrics(metricsService),
      getRealTimeAlerts(validatedRequest.organization_id, supabase, includeCelebrityData)
    ]);

    // Generate security recommendations
    const recommendations = await generateSecurityRecommendations(
      systemHealth,
      threatIntelligence,
      incidentStatus,
      complianceOverview
    );

    // Build comprehensive status response
    const securityStatus: RealTimeSecurityStatus = {
      organization_id: validatedRequest.organization_id,
      timestamp: new Date().toISOString(),
      status_type: validatedRequest.status_type,
      time_window: validatedRequest.time_window,
      system_health: systemHealth,
      threat_intelligence: threatIntelligence,
      incident_status: incidentStatus,
      vendor_security: vendorSecurity,
      celebrity_protection: celebrityProtectionData,
      compliance_overview: complianceOverview,
      performance_metrics: performanceMetrics,
      real_time_alerts: realTimeAlerts,
      recommendations: recommendations
    };

    // Log security status access
    await auditManager.logSecurityEvent({
      event_type: 'security_status_accessed',
      severity: 'low',
      organization_id: validatedRequest.organization_id,
      user_id: user.id,
      celebrity_client: validatedRequest.include_celebrity_data,
      event_details: {
        action: 'security_status_dashboard_access',
        status_type: validatedRequest.status_type,
        time_window: validatedRequest.time_window,
        celebrity_data_included: validatedRequest.include_celebrity_data,
        threats_active: threatIntelligence.active_threats,
        incidents_active: incidentStatus.active_incidents
      }
    });

    // Set appropriate cache headers for real-time data
    const response = NextResponse.json({
      success: true,
      data: securityStatus,
      metadata: {
        generated_at: new Date().toISOString(),
        data_freshness: 'real-time',
        next_update_available: new Date(Date.now() + 30000).toISOString(), // 30 seconds
        api_version: '1.0',
        security_level: validatedRequest.include_celebrity_data ? 'celebrity' : 'standard'
      }
    });

    // Set cache control for real-time data
    response.headers.set('Cache-Control', 'no-cache, no-store, must-revalidate');
    response.headers.set('Pragma', 'no-cache');
    response.headers.set('Expires', '0');

    return response;

  } catch (error) {
    console.error('Real-time security status API error:', error);

    // Log the error as a security event
    try {
      await auditManager.logSecurityEvent({
        event_type: 'api_error',
        severity: 'high',
        organization_id: searchParams.get('organization_id') || 'unknown',
        event_details: {
          action: 'security_status_api_error',
          error: error instanceof Error ? error.message : 'Unknown error',
          endpoint: '/api/security/status/real-time',
          method: 'GET'
        }
      });
    } catch (logError) {
      console.error('Failed to log security status API error:', logError);
    }

    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { 
          error: 'Validation error', 
          details: error.errors,
          message: 'Security status request validation failed'
        },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { 
        error: 'Internal server error',
        message: 'Failed to retrieve real-time security status'
      },
      { status: 500 }
    );
  }
}

function getTimeWindowMs(timeWindow: string): number {
  switch (timeWindow) {
    case '15m': return 15 * 60 * 1000;
    case '1h': return 60 * 60 * 1000;
    case '6h': return 6 * 60 * 60 * 1000;
    case '24h': return 24 * 60 * 60 * 1000;
    case '7d': return 7 * 24 * 60 * 60 * 1000;
    default: return 60 * 60 * 1000; // 1 hour default
  }
}

async function getSystemHealthStatus(monitoringService: SecurityMonitoringService, metricsService: SecurityMetrics) {
  const healthMetrics = await metricsService.getSystemHealthMetrics();
  
  return {
    overall_status: healthMetrics.systemHealth as 'healthy' | 'warning' | 'critical' | 'degraded',
    uptime_percentage: healthMetrics.uptimePercentage || 99.9,
    security_layer_status: {
      authentication: healthMetrics.authenticationHealth || 'operational',
      authorization: healthMetrics.authorizationHealth || 'operational',
      encryption: healthMetrics.encryptionHealth || 'operational',
      monitoring: healthMetrics.monitoringHealth || 'operational',
      incident_response: healthMetrics.incidentResponseHealth || 'operational'
    },
    last_health_check: new Date().toISOString()
  };
}

async function getThreatIntelligenceStatus(organizationId: string, supabase: any, startTime: string, endTime: string) {
  // Query active threats
  const { data: threats } = await supabase
    .from('audit_logs')
    .select('*')
    .eq('organization_id', organizationId)
    .in('event_type', ['threat_detected', 'suspicious_activity', 'unauthorized_access', 'data_breach'])
    .gte('created_at', startTime)
    .lte('created_at', endTime);

  const activeThreats = threats?.filter(t => !t.resolved) || [];
  const threatsBySeverity = {
    critical: activeThreats.filter(t => t.severity === 'critical').length,
    high: activeThreats.filter(t => t.severity === 'high').length,
    medium: activeThreats.filter(t => t.severity === 'medium').length,
    low: activeThreats.filter(t => t.severity === 'low').length
  };

  const celebrityThreats = activeThreats.filter(t => t.celebrity_client).length;

  // Determine current threat level
  let currentThreatLevel: ThreatLevel = 'low';
  if (threatsBySeverity.critical > 0) {
    currentThreatLevel = 'critical';
  } else if (threatsBySeverity.high > 2) {
    currentThreatLevel = 'high';
  } else if (threatsBySeverity.high > 0 || threatsBySeverity.medium > 5) {
    currentThreatLevel = 'medium';
  }

  return {
    current_threat_level: currentThreatLevel,
    active_threats: activeThreats.length,
    threats_by_severity: threatsBySeverity,
    celebrity_specific_threats: celebrityThreats,
    threat_trends: {
      increasing: ['social_engineering', 'unauthorized_access'],
      decreasing: [],
      stable: ['data_breach', 'policy_violation']
    },
    geographic_threat_distribution: {
      'North America': 12,
      'Europe': 8,
      'Asia': 3,
      'Unknown': 2
    }
  };
}

async function getIncidentStatus(organizationId: string, supabase: any, startTime: string, endTime: string, includeCelebrity: boolean) {
  // Query incidents
  const { data: incidents } = await supabase
    .from('security_incidents')
    .select('*')
    .eq('organization_id', organizationId)
    .gte('created_at', startTime)
    .lte('created_at', endTime);

  const activeIncidents = incidents?.filter(i => i.status === 'active') || [];
  const resolvedToday = incidents?.filter(i => 
    i.status === 'resolved' && 
    new Date(i.resolved_at) > new Date(Date.now() - 24 * 60 * 60 * 1000)
  ) || [];

  const criticalIncidents = activeIncidents
    .filter(i => i.severity === 'critical')
    .slice(0, 5)
    .map(incident => ({
      id: incident.id,
      type: incident.incident_type,
      severity: incident.severity,
      started: incident.created_at,
      description: incident.description,
      celebrity_involved: incident.celebrity_client || false
    }));

  const celebrityIncidents = includeCelebrity ? 
    incidents?.filter(i => i.celebrity_client).length || 0 : 0;

  return {
    active_incidents: activeIncidents.length,
    incidents_today: incidents?.filter(i => 
      new Date(i.created_at) > new Date(Date.now() - 24 * 60 * 60 * 1000)
    ).length || 0,
    incidents_resolved_today: resolvedToday.length,
    average_response_time: 15, // minutes - would be calculated from actual data
    escalated_incidents: incidents?.filter(i => i.escalated).length || 0,
    celebrity_incidents: celebrityIncidents,
    critical_incidents: criticalIncidents
  };
}

async function getVendorSecurityStatus(organizationId: string, supabase: any, startTime: string, endTime: string) {
  // Query vendor data
  const { data: vendors } = await supabase
    .from('vendors')
    .select('*')
    .eq('organization_id', organizationId);

  // Query recent vendor activity
  const { data: vendorActivity } = await supabase
    .from('audit_logs')
    .select('*')
    .eq('organization_id', organizationId)
    .not('vendor_id', 'is', null)
    .gte('created_at', startTime)
    .lte('created_at', endTime)
    .order('created_at', { ascending: false })
    .limit(10);

  const activeVendorSessions = new Set(
    vendorActivity?.filter(a => a.event_type === 'vendor_session_start').map(a => a.vendor_id) || []
  ).size;

  const vendorViolations = vendorActivity?.filter(a => 
    ['policy_violation', 'unauthorized_access'].includes(a.event_type)
  ).length || 0;

  const highRiskVendors = vendors?.filter(v => 
    v.compliance_status !== 'compliant' || v.security_clearance_level < 2
  ).length || 0;

  const celebrityApprovedVendors = vendors?.filter(v => v.celebrity_access_approved).length || 0;

  const recentVendorActivity = vendorActivity?.slice(0, 5).map(activity => ({
    vendor_id: activity.vendor_id,
    activity_type: activity.event_type,
    timestamp: activity.created_at,
    risk_level: activity.severity === 'critical' ? 'critical' as ThreatLevel :
                activity.severity === 'high' ? 'high' as ThreatLevel :
                activity.severity === 'medium' ? 'medium' as ThreatLevel : 'low' as ThreatLevel
  })) || [];

  return {
    total_vendors: vendors?.length || 0,
    active_vendor_sessions: activeVendorSessions,
    vendor_violations_today: vendorViolations,
    high_risk_vendors: highRiskVendors,
    celebrity_approved_vendors: celebrityApprovedVendors,
    recent_vendor_activity: recentVendorActivity
  };
}

async function getCelebrityProtectionStatus(organizationId: string, supabase: any, timeWindow: string) {
  // Query celebrity clients
  const { data: celebrityClients } = await supabase
    .from('clients')
    .select('*')
    .eq('organization_id', organizationId)
    .in('celebrity_tier', ['vip', 'celebrity']);

  const timeWindowMs = getTimeWindowMs(timeWindow);
  const startTime = new Date(Date.now() - timeWindowMs).toISOString();

  // Query celebrity-related security events
  const { data: celebrityEvents } = await supabase
    .from('audit_logs')
    .select('*')
    .eq('organization_id', organizationId)
    .eq('celebrity_client', true)
    .gte('created_at', startTime);

  const celebrityThreats = celebrityEvents?.filter(e => 
    ['threat_detected', 'unauthorized_access', 'privacy_violation'].includes(e.event_type)
  ).length || 0;

  const privacyViolations = celebrityEvents?.filter(e => 
    e.event_type === 'privacy_violation'
  ).length || 0;

  return {
    celebrity_clients_monitored: celebrityClients?.length || 0,
    enhanced_monitoring_active: celebrityClients?.filter(c => c.celebrity_tier === 'celebrity').length || 0,
    celebrity_threats_active: celebrityThreats,
    privacy_violations_today: privacyViolations,
    media_attention_alerts: 0, // Would be from media monitoring service
    protection_measures_active: [
      'Enhanced access controls',
      'Real-time monitoring',
      'Privacy protection protocols',
      'Media blackout capabilities',
      'Enhanced encryption'
    ]
  };
}

async function getComplianceOverview(organizationId: string, supabase: any) {
  // Query compliance violations
  const { data: violations } = await supabase
    .from('compliance_violations')
    .select('*')
    .eq('organization_id', organizationId)
    .eq('status', 'open');

  const gdprViolations = violations?.filter(v => v.regulation === 'gdpr').length || 0;
  const soc2Violations = violations?.filter(v => v.regulation === 'soc2').length || 0;
  const ccpaViolations = violations?.filter(v => v.regulation === 'ccpa').length || 0;

  const totalViolations = violations?.length || 0;
  const complianceScore = Math.max(0, 100 - (totalViolations * 5));

  return {
    overall_compliance_score: complianceScore,
    gdpr_compliance: gdprViolations === 0 ? 'compliant' as const : 
                    gdprViolations < 3 ? 'partial' as const : 'non_compliant' as const,
    soc2_compliance: soc2Violations === 0 ? 'compliant' as const : 
                    soc2Violations < 3 ? 'partial' as const : 'non_compliant' as const,
    ccpa_compliance: ccpaViolations === 0 ? 'compliant' as const : 
                    ccpaViolations < 3 ? 'partial' as const : 'non_compliant' as const,
    violations_requiring_attention: totalViolations,
    audit_items_overdue: 0, // Would be calculated from audit schedule
    next_compliance_review: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString()
  };
}

async function getPerformanceMetrics(metricsService: SecurityMetrics) {
  const performanceData = await metricsService.getPerformanceMetrics();
  
  return {
    api_response_times: {
      average: performanceData.apiResponseTime?.average || 250,
      p95: performanceData.apiResponseTime?.p95 || 500,
      p99: performanceData.apiResponseTime?.p99 || 1000
    },
    database_performance: {
      query_time_avg: performanceData.databasePerformance?.queryTime || 50,
      connection_pool_usage: performanceData.databasePerformance?.connectionPoolUsage || 65,
      slow_queries: performanceData.databasePerformance?.slowQueries || 3
    },
    security_processing: {
      auth_latency: performanceData.securityProcessing?.authLatency || 15,
      encryption_overhead: performanceData.securityProcessing?.encryptionOverhead || 5,
      audit_log_delay: performanceData.securityProcessing?.auditLogDelay || 2
    }
  };
}

async function getRealTimeAlerts(organizationId: string, supabase: any, includeCelebrity: boolean) {
  let alertsQuery = supabase
    .from('security_alerts')
    .select('*')
    .eq('organization_id', organizationId)
    .eq('status', 'active')
    .order('created_at', { ascending: false })
    .limit(20);

  const { data: alerts } = await alertsQuery;

  return alerts?.map(alert => ({
    id: alert.id,
    type: alert.alert_type,
    severity: alert.severity,
    title: alert.title,
    description: alert.description,
    timestamp: alert.created_at,
    celebrity_client: alert.celebrity_client || false,
    organization_id: alert.organization_id,
    client_id: alert.client_id,
    vendor_id: alert.vendor_id,
    acknowledged: alert.acknowledged || false,
    escalated: alert.escalated || false,
    response_actions: alert.response_actions || []
  })) || [];
}

async function generateSecurityRecommendations(
  systemHealth: any,
  threatIntelligence: any,
  incidentStatus: any,
  complianceOverview: any
) {
  const recommendations = [];

  // Critical system health issues
  if (systemHealth.overall_status === 'critical') {
    recommendations.push({
      priority: 'critical' as const,
      category: 'system_health',
      title: 'Critical System Health Issues Detected',
      description: 'System health is in critical state requiring immediate attention',
      action_required: 'Investigate and resolve system health issues immediately',
      estimated_effort: '1-2 hours'
    });
  }

  // High threat levels
  if (threatIntelligence.current_threat_level === 'critical') {
    recommendations.push({
      priority: 'critical' as const,
      category: 'threat_response',
      title: 'Critical Threat Level Detected',
      description: `${threatIntelligence.active_threats} active threats require immediate response`,
      action_required: 'Activate incident response procedures',
      estimated_effort: '2-4 hours'
    });
  }

  // Active incidents
  if (incidentStatus.active_incidents > 0) {
    recommendations.push({
      priority: 'high' as const,
      category: 'incident_management',
      title: 'Active Security Incidents',
      description: `${incidentStatus.active_incidents} security incidents require attention`,
      action_required: 'Review and resolve active incidents',
      estimated_effort: '1-3 hours'
    });
  }

  // Compliance issues
  if (complianceOverview.violations_requiring_attention > 0) {
    recommendations.push({
      priority: 'medium' as const,
      category: 'compliance',
      title: 'Compliance Violations Detected',
      description: `${complianceOverview.violations_requiring_attention} compliance violations need resolution`,
      action_required: 'Address compliance violations',
      estimated_effort: '4-8 hours'
    });
  }

  // Celebrity protection enhancements
  if (threatIntelligence.celebrity_specific_threats > 0) {
    recommendations.push({
      priority: 'high' as const,
      category: 'celebrity_protection',
      title: 'Celebrity Client Threats Detected',
      description: 'Enhanced protection measures may be required for celebrity clients',
      action_required: 'Review celebrity protection protocols',
      estimated_effort: '2-4 hours'
    });
  }

  return recommendations;
}