/**
 * WS-202 Supabase Realtime Integration - Subscribe API Endpoint
 * Team B - Backend/API Implementation
 * 
 * Secure subscription endpoint with authentication, rate limiting, and validation.
 * Supports wedding industry specific realtime channels with performance optimization.
 * 
 * Performance Requirements:
 * - Response time <200ms
 * - Rate limiting: 10 subscriptions/minute per user
 * - Authentication required for all requests
 * - Input validation with Zod schemas
 * - Audit logging for compliance
 */

import { NextRequest, NextResponse } from 'next/server'
import { z } from 'zod'
import { createClient } from '@supabase/supabase-js'
import { getRealtimeManager } from '../../../../lib/realtime/RealtimeSubscriptionManager'
import type { 
  EnhancedRealtimeSubscriptionParams,
  WeddingChannelType 
} from '../../../../types/realtime'

// Input validation schema
const subscribeRequestSchema = z.object({
  channels: z.array(z.enum([
    'wedding_updates',
    'client_messages',
    'form_submissions',
    'vendor_notifications', 
    'system_alerts',
    'journey_progress',
    'supplier_collaboration'
  ])).min(1, 'At least one channel is required').max(5, 'Maximum 5 channels per request'),
  
  filters: z.object({
    organizationId: z.string().uuid('Invalid organization ID'),
    supplierId: z.string().uuid().optional(),
    coupleId: z.string().uuid().optional(),
    weddingId: z.string().uuid().optional(),
    clientId: z.string().uuid().optional(),
    formId: z.string().uuid().optional()
  }),
  
  config: z.object({
    priority: z.enum(['low', 'medium', 'high', 'urgent']).default('medium'),
    heartbeatInterval: z.number().min(10000).max(60000).default(30000),
    retryAttempts: z.number().min(1).max(5).default(3),
    compressionEnabled: z.boolean().default(true)
  }).default({
    priority: 'medium' as const,
    heartbeatInterval: 30000,
    retryAttempts: 3,
    compressionEnabled: true
  }),
  
  metadata: z.object({
    source: z.enum(['dashboard', 'mobile', 'api']).optional(),
    userAgent: z.string().optional(),
    sessionId: z.string().optional()
  }).optional()
})

type SubscribeRequest = z.infer<typeof subscribeRequestSchema>

interface SubscribeResponse {
  success: boolean
  subscriptions: Array<{
    channelName: string
    subscriptionId: string
    status: 'active' | 'failed' | 'pending'
    error?: string
    memoryUsage?: number
    estimatedLatency?: number
  }>
  totalActiveSubscriptions: number
  organizationLimits: {
    current: number
    maximum: number
    tier: string
  }
  nextAllowedRequest?: Date
}

// Rate limiting with Redis-like in-memory store
const rateLimitStore = new Map<string, { count: number; resetTime: number }>()

const RATE_LIMIT = {
  maxRequests: 10,
  windowMs: 60 * 1000 // 1 minute
}

function checkRateLimit(userId: string): { allowed: boolean; resetTime?: number; remaining?: number } {
  const now = Date.now()
  const key = `subscribe:${userId}`
  const existing = rateLimitStore.get(key)
  
  if (!existing || now > existing.resetTime) {
    // New window
    rateLimitStore.set(key, {
      count: 1,
      resetTime: now + RATE_LIMIT.windowMs
    })
    return { allowed: true, remaining: RATE_LIMIT.maxRequests - 1 }
  }
  
  if (existing.count >= RATE_LIMIT.maxRequests) {
    return { allowed: false, resetTime: existing.resetTime, remaining: 0 }
  }
  
  // Increment count
  existing.count++
  rateLimitStore.set(key, existing)
  
  return { allowed: true, remaining: RATE_LIMIT.maxRequests - existing.count }
}

// Authentication helper
async function authenticate(request: NextRequest) {
  const authHeader = request.headers.get('authorization')
  if (!authHeader?.startsWith('Bearer ')) {
    throw new Error('Missing or invalid authorization header')
  }

  const token = authHeader.substring(7)
  
  // Create server client for auth verification
  const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!,
    {
      auth: { autoRefreshToken: false, persistSession: false }
    }
  )

  const { data: { user }, error } = await supabase.auth.getUser(token)
  
  if (error || !user) {
    throw new Error('Invalid authentication token')
  }

  // Get user profile for additional context
  const { data: profile, error: profileError } = await supabase
    .from('user_profiles')
    .select('id, user_type, organization_id, supplier_id, couple_id')
    .eq('id', user.id)
    .single()

  if (profileError || !profile) {
    throw new Error('User profile not found')
  }

  return { user, profile }
}

// Audit logging
async function logSubscriptionActivity(
  userId: string,
  organizationId: string,
  action: 'subscribe_request' | 'subscribe_success' | 'subscribe_failure',
  details: Record<string, unknown>
) {
  try {
    const supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!,
      { auth: { autoRefreshToken: false, persistSession: false } }
    )

    await supabase
      .from('realtime_activity_logs')
      .insert({
        user_id: userId,
        organization_id: organizationId,
        event_type: action,
        payload: details,
        ip_address: details.ipAddress as string || null,
        user_agent: details.userAgent as string || null
      })
  } catch (error) {
    console.error('Audit logging failed:', error)
  }
}

// Organization limits helper
async function getOrganizationLimits(organizationId: string) {
  const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!,
    { auth: { autoRefreshToken: false, persistSession: false } }
  )

  const { data: org } = await supabase
    .from('organizations')
    .select('tier, subscription_status')
    .eq('id', organizationId)
    .single()

  const tierLimits = {
    'FREE': { maxConnections: 5, allowedChannels: ['form_submissions'] },
    'STARTER': { maxConnections: 50, allowedChannels: ['form_submissions', 'client_messages'] },
    'PROFESSIONAL': { maxConnections: 200, allowedChannels: ['form_submissions', 'client_messages', 'journey_progress', 'vendor_notifications'] },
    'SCALE': { maxConnections: 500, allowedChannels: ['form_submissions', 'client_messages', 'journey_progress', 'vendor_notifications', 'supplier_collaboration'] },
    'ENTERPRISE': { maxConnections: 1000, allowedChannels: ['wedding_updates', 'client_messages', 'form_submissions', 'vendor_notifications', 'system_alerts', 'journey_progress', 'supplier_collaboration'] }
  }

  const tier = (org?.tier || 'STARTER') as keyof typeof tierLimits
  return { tier, ...tierLimits[tier] }
}

export async function POST(request: NextRequest) {
  const startTime = Date.now()
  let userId: string = ''
  let organizationId: string = ''

  try {
    // 1. Authentication
    const { user, profile } = await authenticate(request)
    userId = user.id
    organizationId = profile.organization_id

    // Get request metadata for logging
    const ipAddress = request.headers.get('x-forwarded-for') || 
                     request.headers.get('x-real-ip') || 
                     'unknown'
    const userAgent = request.headers.get('user-agent') || 'unknown'

    // 2. Rate limiting
    const rateLimitResult = checkRateLimit(userId)
    if (!rateLimitResult.allowed) {
      await logSubscriptionActivity(userId, organizationId, 'subscribe_failure', {
        reason: 'rate_limited',
        ipAddress,
        userAgent
      })

      return NextResponse.json(
        { 
          error: 'Rate limit exceeded',
          nextAllowedRequest: new Date(rateLimitResult.resetTime || Date.now())
        },
        { 
          status: 429,
          headers: {
            'X-RateLimit-Remaining': '0',
            'X-RateLimit-Reset': rateLimitResult.resetTime?.toString() || ''
          }
        }
      )
    }

    // 3. Input validation
    const body = await request.json()
    const validatedData = subscribeRequestSchema.parse(body)

    await logSubscriptionActivity(userId, organizationId, 'subscribe_request', {
      channels: validatedData.channels,
      filters: validatedData.filters,
      ipAddress,
      userAgent,
      metadata: validatedData.metadata
    })

    // 4. Organization limits check
    const orgLimits = await getOrganizationLimits(organizationId)
    const realtimeManager = getRealtimeManager()
    const currentMetrics = await realtimeManager.getMetrics()
    
    const currentOrgConnections = currentMetrics.totalConnections // This would need to be filtered by org
    
    if (currentOrgConnections >= orgLimits.maxConnections) {
      await logSubscriptionActivity(userId, organizationId, 'subscribe_failure', {
        reason: 'organization_limit_exceeded',
        current: currentOrgConnections,
        limit: orgLimits.maxConnections
      })

      return NextResponse.json({
        success: false,
        error: `Organization connection limit exceeded: ${currentOrgConnections}/${orgLimits.maxConnections}`,
        organizationLimits: {
          current: currentOrgConnections,
          maximum: orgLimits.maxConnections,
          tier: orgLimits.tier
        }
      }, { status: 429 })
    }

    // 5. Channel permissions validation
    const unauthorizedChannels = validatedData.channels.filter(
      channel => !orgLimits.allowedChannels.includes(channel)
    )
    
    if (unauthorizedChannels.length > 0) {
      await logSubscriptionActivity(userId, organizationId, 'subscribe_failure', {
        reason: 'unauthorized_channels',
        channels: unauthorizedChannels,
        tier: orgLimits.tier
      })

      return NextResponse.json({
        success: false,
        error: `Unauthorized channels for ${orgLimits.tier} tier: ${unauthorizedChannels.join(', ')}`,
        allowedChannels: orgLimits.allowedChannels
      }, { status: 403 })
    }

    // 6. Process subscriptions
    const subscriptionResults = []
    
    for (const channelType of validatedData.channels) {
      try {
        const subscriptionParams: EnhancedRealtimeSubscriptionParams = {
          organizationId,
          userId,
          channelName: `${channelType}-${organizationId}-${userId}`,
          channelType: channelType as WeddingChannelType,
          subscriptionConfig: {
            ...validatedData.config,
            supplierId: validatedData.filters.supplierId,
            coupleId: validatedData.filters.coupleId,
            weddingId: validatedData.filters.weddingId,
            clientId: validatedData.filters.clientId,
            formId: validatedData.filters.formId
          },
          filters: {
            table: getTableForChannelType(channelType as WeddingChannelType),
            filter: buildFilterString(channelType as WeddingChannelType, validatedData.filters, profile),
            event: '*'
          },
          priority: validatedData.config?.priority || 'medium'
        }

        const result = await realtimeManager.subscribe(subscriptionParams)
        
        subscriptionResults.push({
          channelName: channelType,
          subscriptionId: result.subscriptionId,
          status: result.success ? 'active' : 'failed',
          error: result.error,
          memoryUsage: result.memoryUsage,
          estimatedLatency: Date.now() - startTime
        })

      } catch (error) {
        subscriptionResults.push({
          channelName: channelType,
          subscriptionId: '',
          status: 'failed',
          error: error instanceof Error ? error.message : 'Unknown error'
        })
      }
    }

    // 7. Success response
    const successfulSubscriptions = subscriptionResults.filter(r => r.status === 'active')
    const totalActiveSubscriptions = currentMetrics.activeSubscriptions + successfulSubscriptions.length

    await logSubscriptionActivity(userId, organizationId, 'subscribe_success', {
      subscriptions: subscriptionResults,
      totalActive: totalActiveSubscriptions,
      responseTime: Date.now() - startTime
    })

    const response: SubscribeResponse = {
      success: true,
      subscriptions: subscriptionResults,
      totalActiveSubscriptions,
      organizationLimits: {
        current: currentOrgConnections + successfulSubscriptions.length,
        maximum: orgLimits.maxConnections,
        tier: orgLimits.tier
      }
    }

    return NextResponse.json(response, {
      headers: {
        'X-RateLimit-Remaining': rateLimitResult.remaining?.toString() || '0',
        'X-Response-Time': `${Date.now() - startTime}ms`
      }
    })

  } catch (error) {
    console.error('Subscribe API error:', error)
    
    if (userId && organizationId) {
      await logSubscriptionActivity(userId, organizationId, 'subscribe_failure', {
        error: error instanceof Error ? error.message : 'Unknown error',
        stack: error instanceof Error ? error.stack : undefined,
        responseTime: Date.now() - startTime
      })
    }

    if (error instanceof z.ZodError) {
      return NextResponse.json({
        success: false,
        error: 'Validation failed',
        details: error.issues
      }, { status: 400 })
    }

    if (error instanceof Error) {
      if (error.message.includes('authorization') || error.message.includes('authentication')) {
        return NextResponse.json({
          success: false,
          error: 'Authentication required'
        }, { status: 401 })
      }
    }

    return NextResponse.json({
      success: false,
      error: 'Internal server error'
    }, { status: 500 })
  }
}

// Helper functions
function getTableForChannelType(channelType: WeddingChannelType): string {
  const tableMapping = {
    'wedding_updates': 'wedding_details',
    'client_messages': 'client_communications', 
    'form_submissions': 'form_responses',
    'vendor_notifications': 'notifications',
    'system_alerts': 'system_notifications',
    'journey_progress': 'journey_progress',
    'supplier_collaboration': 'supplier_communications'
  }
  
  return tableMapping[channelType] || 'form_responses'
}

function buildFilterString(
  channelType: WeddingChannelType,
  filters: SubscribeRequest['filters'],
  profile: { user_type: string; supplier_id: string | null; couple_id: string | null }
): string {
  const conditions: string[] = []
  
  // Always filter by organization
  conditions.push(`organization_id=eq.${filters.organizationId}`)
  
  // Add user-specific filters based on channel type and user permissions
  switch (channelType) {
    case 'form_submissions':
      if (profile.user_type === 'supplier' && profile.supplier_id) {
        conditions.push(`supplier_id=eq.${profile.supplier_id}`)
      } else if (profile.user_type === 'couple' && profile.couple_id) {
        conditions.push(`couple_id=eq.${profile.couple_id}`)
      }
      break
      
    case 'journey_progress':
      if (profile.user_type === 'supplier' && profile.supplier_id) {
        conditions.push(`supplier_id=eq.${profile.supplier_id}`)
      } else if (profile.user_type === 'couple' && profile.couple_id) {
        conditions.push(`couple_id=eq.${profile.couple_id}`)
      }
      break
      
    case 'client_messages':
      if (filters.clientId) {
        conditions.push(`client_id=eq.${filters.clientId}`)
      }
      break
      
    case 'vendor_notifications':
      if (profile.user_type === 'supplier' && profile.supplier_id) {
        conditions.push(`supplier_id=eq.${profile.supplier_id}`)
      }
      break
      
    case 'wedding_updates':
      if (filters.weddingId) {
        conditions.push(`wedding_id=eq.${filters.weddingId}`)
      }
      break
  }
  
  return conditions.join(',')
}

// Health check endpoint
export async function GET() {
  try {
    const realtimeManager = getRealtimeManager()
    const metrics = await realtimeManager.getMetrics()
    
    return NextResponse.json({
      status: 'healthy',
      version: '1.0.0',
      metrics: {
        activeSubscriptions: metrics.activeSubscriptions,
        totalConnections: metrics.totalConnections,
        errorRate: metrics.errorRate,
        averageLatency: metrics.averageLatency,
        memoryUsage: `${Math.round(metrics.memoryUsage / 1024 / 1024)}MB`
      },
      rateLimits: {
        subscribeLimit: `${RATE_LIMIT.maxRequests} requests per ${RATE_LIMIT.windowMs / 1000} seconds`
      }
    })
  } catch (error) {
    return NextResponse.json({
      status: 'error',
      error: 'Health check failed'
    }, { status: 500 })
  }
}