import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { cookies } from 'next/headers'

async function getJourneyDetails(supabase: any, journeyId: string) {
  const { data, error } = await supabase
    .from('journey_canvases')
    .select(`
      *,
      journey_nodes(*)
    `)
    .eq('id', journeyId)
    .single()
  
  if (error) throw error
  return data
}

async function getJourneyPerformanceHistory(supabase: any, journeyId: string) {
  const thirtyDaysAgo = new Date()
  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30)
  
  const { data, error } = await supabase
    .from('journey_analytics')
    .select('*')
    .eq('journey_id', journeyId)
    .gte('date', thirtyDaysAgo.toISOString().split('T')[0])
    .order('date', { ascending: true })
  
  if (error) throw error
  
  return data?.map(d => ({
    date: d.date,
    total_instances: d.total_instances || 0,
    completed_instances: d.completed_instances || 0,
    conversion_rate: d.conversion_rate || 0,
    avg_completion_time: d.avg_completion_time_hours || 0,
    revenue: parseFloat(d.revenue_attributed || 0),
    engagement_score: d.engagement_score || 0
  })) || []
}

async function getNodePerformanceBreakdown(supabase: any, journeyId: string) {
  const { data: nodes, error: nodesError } = await supabase
    .from('journey_nodes')
    .select('*')
    .eq('journey_id', journeyId)
  
  if (nodesError) throw nodesError
  
  const { data: analytics, error: analyticsError } = await supabase
    .from('node_analytics')
    .select('*')
    .eq('journey_id', journeyId)
    .gte('date', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0])
  
  if (analyticsError) throw analyticsError
  
  // Combine node data with analytics
  const nodePerformance = nodes?.map(node => {
    const nodeAnalytics = analytics?.filter(a => a.node_id === node.id) || []
    const totalExecutions = nodeAnalytics.reduce((sum, a) => sum + (a.executions || 0), 0)
    const totalSuccesses = nodeAnalytics.reduce((sum, a) => sum + (a.successes || 0), 0)
    const totalFailures = nodeAnalytics.reduce((sum, a) => sum + (a.failures || 0), 0)
    const avgExecutionTime = nodeAnalytics.length > 0
      ? nodeAnalytics.reduce((sum, a) => sum + (a.avg_execution_time_ms || 0), 0) / nodeAnalytics.length
      : 0
    
    return {
      id: node.id,
      type: node.type,
      name: node.config?.name || node.type,
      executions: totalExecutions,
      successes: totalSuccesses,
      failures: totalFailures,
      success_rate: totalExecutions > 0 ? (totalSuccesses / totalExecutions * 100) : 0,
      avg_execution_time_ms: avgExecutionTime,
      conversion_impact: nodeAnalytics[0]?.conversion_impact || 0
    }
  }) || []
  
  return nodePerformance
}

async function getClientProgressTracking(supabase: any, journeyId: string) {
  const { data, error } = await supabase
    .from('client_journey_progress')
    .select(`
      *,
      clients(name, email, company)
    `)
    .eq('journey_id', journeyId)
    .order('updated_at', { ascending: false })
    .limit(50)
  
  if (error) throw error
  
  return data?.map(progress => ({
    id: progress.id,
    client_name: progress.clients?.name || 'Unknown',
    client_email: progress.clients?.email || '',
    client_company: progress.clients?.company || '',
    current_stage: progress.current_stage,
    completion_percentage: progress.completion_percentage || 0,
    engagement_level: progress.engagement_level,
    last_interaction: progress.last_interaction,
    predicted_completion: progress.predicted_completion_date,
    revenue_potential: parseFloat(progress.revenue_potential || 0),
    updated_at: progress.updated_at
  })) || []
}

async function getJourneyConversionFunnel(supabase: any, journeyId: string) {
  // Get all journey instances for this journey
  const { data: instances, error: instancesError } = await supabase
    .from('journey_instances')
    .select(`
      id,
      status,
      created_at,
      node_executions(node_id, status, created_at)
    `)
    .eq('journey_id', journeyId)
    .gte('created_at', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString())
  
  if (instancesError) throw instancesError
  
  // Get journey nodes to understand the flow
  const { data: nodes, error: nodesError } = await supabase
    .from('journey_nodes')
    .select('*')
    .eq('journey_id', journeyId)
    .order('position', { ascending: true })
  
  if (nodesError) throw nodesError
  
  // Calculate funnel for each node
  const funnel = nodes?.map((node, index) => {
    const instancesReachedNode = instances?.filter(instance => 
      instance.node_executions?.some(exec => exec.node_id === node.id)
    ).length || 0
    
    const instancesCompletedNode = instances?.filter(instance => 
      instance.node_executions?.some(exec => 
        exec.node_id === node.id && exec.status === 'completed'
      )
    ).length || 0
    
    return {
      stage: node.config?.name || `Step ${index + 1}`,
      node_type: node.type,
      reached: instancesReachedNode,
      completed: instancesCompletedNode,
      conversion_rate: instances?.length > 0 
        ? (instancesCompletedNode / instances.length * 100) 
        : 0
    }
  }) || []
  
  return funnel
}

async function generateOptimizationRecommendations(supabase: any, journeyId: string) {
  // Get journey performance data
  const performance = await getJourneyPerformanceHistory(supabase, journeyId)
  const nodePerformance = await getNodePerformanceBreakdown(supabase, journeyId)
  const funnel = await getJourneyConversionFunnel(supabase, journeyId)
  
  const recommendations = []
  
  // Check overall conversion rate
  const avgConversionRate = performance.reduce((sum, p) => sum + p.conversion_rate, 0) / (performance.length || 1)
  if (avgConversionRate < 0.2) {
    recommendations.push({
      type: 'critical',
      title: 'Low Conversion Rate',
      description: `Your journey has an average conversion rate of ${(avgConversionRate * 100).toFixed(1)}%. Consider reviewing your journey steps and messaging.`,
      action: 'Review and optimize journey content'
    })
  }
  
  // Check for bottleneck nodes
  const bottleneckNodes = nodePerformance.filter(n => n.success_rate < 50 && n.executions > 10)
  if (bottleneckNodes.length > 0) {
    recommendations.push({
      type: 'warning',
      title: 'Node Performance Issues',
      description: `${bottleneckNodes.length} nodes have success rates below 50%. These may be causing journey failures.`,
      action: 'Review failing nodes and adjust their configuration',
      nodes: bottleneckNodes.map(n => n.name)
    })
  }
  
  // Check for drop-off points in funnel
  let maxDropOff = 0
  let dropOffStage = ''
  for (let i = 1; i < funnel.length; i++) {
    const dropOff = funnel[i-1].reached - funnel[i].reached
    const dropOffRate = funnel[i-1].reached > 0 ? (dropOff / funnel[i-1].reached) : 0
    if (dropOffRate > maxDropOff) {
      maxDropOff = dropOffRate
      dropOffStage = funnel[i].stage
    }
  }
  
  if (maxDropOff > 0.3) {
    recommendations.push({
      type: 'warning',
      title: 'High Drop-off Rate',
      description: `${(maxDropOff * 100).toFixed(1)}% of clients drop off before "${dropOffStage}". This is a critical point to optimize.`,
      action: 'Review the transition and messaging before this stage'
    })
  }
  
  // Check engagement trends
  const recentPerformance = performance.slice(-7)
  const trendDirection = recentPerformance.length >= 2 
    ? recentPerformance[recentPerformance.length - 1].engagement_score - recentPerformance[0].engagement_score
    : 0
  
  if (trendDirection < -0.1) {
    recommendations.push({
      type: 'info',
      title: 'Declining Engagement',
      description: 'Engagement scores have been declining over the past week. Consider refreshing your content or timing.',
      action: 'A/B test different messaging or scheduling'
    })
  }
  
  return recommendations
}

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  try {
    const cookieStore = cookies()
    const supabase = createClient(cookieStore)
    const journeyId = id
    
    // Check authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      )
    }
    
    // Get all journey analytics data in parallel
    const [
      journey,
      performanceMetrics,
      nodeAnalytics,
      clientProgress,
      conversionFunnel,
      recommendations
    ] = await Promise.all([
      getJourneyDetails(supabase, journeyId),
      getJourneyPerformanceHistory(supabase, journeyId),
      getNodePerformanceBreakdown(supabase, journeyId),
      getClientProgressTracking(supabase, journeyId),
      getJourneyConversionFunnel(supabase, journeyId),
      generateOptimizationRecommendations(supabase, journeyId)
    ])
    
    return NextResponse.json({
      journey,
      performance: performanceMetrics,
      node_analytics: nodeAnalytics,
      client_progress: clientProgress,
      conversion_funnel: conversionFunnel,
      recommendations
    })
    
  } catch (error) {
    console.error('Journey analytics error:', error)
    return NextResponse.json(
      { error: 'Failed to load journey analytics' },
      { status: 500 }
    )
  }
}