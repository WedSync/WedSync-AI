import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { CohortEngine } from '@/lib/analytics/cohort-engine';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

// Rate limiting store (in production, use Redis)
const rateLimitStore = new Map<string, { count: number; resetTime: number }>();

function checkRateLimit(ip: string, limit: number, windowMs: number): boolean {
  const now = Date.now();
  const key = `${ip}:${Math.floor(now / windowMs)}`;
  
  if (!rateLimitStore.has(key)) {
    rateLimitStore.set(key, { count: 1, resetTime: now + windowMs });
    return true;
  }
  
  const current = rateLimitStore.get(key)!;
  if (current.count >= limit) {
    return false;
  }
  
  current.count++;
  return true;
}

export async function GET(request: NextRequest) {
  try {
    // Rate limiting: 100 requests per minute
    const ip = request.ip || 'unknown';
    if (!checkRateLimit(ip, 100, 60000)) {
      return NextResponse.json(
        { 
          success: false, 
          error: 'Rate limit exceeded',
          code: 'RATE_LIMIT_EXCEEDED'
        },
        { status: 429 }
      );
    }

    const url = new URL(request.url);
    const page = parseInt(url.searchParams.get('page') || '1');
    const limit = Math.min(parseInt(url.searchParams.get('limit') || '10'), 50);
    const status = url.searchParams.get('status');
    const cohortType = url.searchParams.get('cohortType');

    // Build query
    let query = supabase
      .from('cohort_definitions')
      .select(`
        id,
        name,
        description,
        cohort_type,
        segmentation_criteria,
        time_window_type,
        time_window_duration,
        metrics_to_track,
        status,
        created_at,
        updated_at,
        last_calculated_at,
        calculation_duration_ms
      `, { count: 'exact' })
      .order('created_at', { ascending: false })
      .range((page - 1) * limit, page * limit - 1);

    if (status) {
      query = query.eq('status', status);
    }

    if (cohortType) {
      query = query.eq('cohort_type', cohortType);
    }

    const { data: cohorts, error, count } = await query;

    if (error) {
      console.error('Database query error:', error);
      return NextResponse.json(
        { 
          success: false, 
          error: 'Failed to retrieve cohorts',
          code: 'DATABASE_ERROR'
        },
        { status: 500 }
      );
    }

    // Transform data for API response
    const transformedCohorts = cohorts?.map(cohort => ({
      id: cohort.id,
      name: cohort.name,
      description: cohort.description,
      type: cohort.cohort_type,
      segmentation: cohort.segmentation_criteria,
      timeWindow: {
        type: cohort.time_window_type,
        duration: cohort.time_window_duration
      },
      metrics: cohort.metrics_to_track,
      status: cohort.status,
      performance: {
        lastCalculated: cohort.last_calculated_at,
        calculationDurationMs: cohort.calculation_duration_ms,
        isStale: cohort.last_calculated_at ? 
          new Date(cohort.last_calculated_at).getTime() < Date.now() - 24 * 60 * 60 * 1000 : 
          true
      },
      createdAt: cohort.created_at,
      updatedAt: cohort.updated_at
    })) || [];

    return NextResponse.json({
      success: true,
      data: {
        cohorts: transformedCohorts,
        pagination: {
          page,
          limit,
          total: count || 0,
          totalPages: Math.ceil((count || 0) / limit),
          hasNextPage: (count || 0) > page * limit,
          hasPreviousPage: page > 1
        }
      },
      meta: {
        timestamp: new Date().toISOString(),
        version: '1.0.0'
      }
    });

  } catch (error) {
    console.error('Cohort list endpoint error:', error);
    return NextResponse.json(
      { 
        success: false, 
        error: 'Internal server error',
        code: 'INTERNAL_ERROR'
      },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    // Rate limiting: 10 requests per 5 minutes for cohort creation
    const ip = request.ip || 'unknown';
    if (!checkRateLimit(ip, 10, 300000)) {
      return NextResponse.json(
        { 
          success: false, 
          error: 'Rate limit exceeded for cohort creation',
          code: 'RATE_LIMIT_EXCEEDED',
          retryAfter: 300
        },
        { status: 429 }
      );
    }

    const body = await request.json();
    
    // Validate required fields
    const {
      name,
      cohortType,
      timeWindow,
      segmentationCriteria = {},
      retentionPeriods = [30, 60, 90, 180, 365],
      metrics = ['retention', 'revenue', 'engagement']
    } = body;

    if (!name || !cohortType || !timeWindow?.start || !timeWindow?.end) {
      return NextResponse.json(
        { 
          success: false, 
          error: 'Missing required fields: name, cohortType, timeWindow.start, timeWindow.end',
          code: 'VALIDATION_ERROR'
        },
        { status: 400 }
      );
    }

    // Validate cohort type
    const validCohortTypes = ['supplier_performance', 'client_engagement', 'revenue_growth'];
    if (!validCohortTypes.includes(cohortType)) {
      return NextResponse.json(
        { 
          success: false, 
          error: `Invalid cohortType. Must be one of: ${validCohortTypes.join(', ')}`,
          code: 'VALIDATION_ERROR'
        },
        { status: 400 }
      );
    }

    // Validate date range
    const startDate = new Date(timeWindow.start);
    const endDate = new Date(timeWindow.end);
    
    if (startDate >= endDate) {
      return NextResponse.json(
        { 
          success: false, 
          error: 'Start date must be before end date',
          code: 'VALIDATION_ERROR'
        },
        { status: 400 }
      );
    }

    // Check if date range is reasonable (not more than 2 years)
    const maxDays = 2 * 365 * 24 * 60 * 60 * 1000; // 2 years in milliseconds
    if (endDate.getTime() - startDate.getTime() > maxDays) {
      return NextResponse.json(
        { 
          success: false, 
          error: 'Time window cannot exceed 2 years',
          code: 'VALIDATION_ERROR'
        },
        { status: 400 }
      );
    }

    // Initialize cohort engine
    const cohortEngine = new CohortEngine();
    
    const config = {
      name,
      cohortType: cohortType as 'supplier_performance' | 'client_engagement' | 'revenue_growth',
      timeWindow: {
        start: startDate,
        end: endDate,
        granularity: (timeWindow.granularity || 'monthly') as 'daily' | 'weekly' | 'monthly'
      },
      segmentationCriteria,
      retentionPeriods,
      metrics: metrics as ('retention' | 'revenue' | 'engagement' | 'conversion')[]
    };

    // Start cohort calculation
    const result = await cohortEngine.calculateCohortAnalysis(config);

    return NextResponse.json({
      success: true,
      data: {
        cohortId: result.cohortId,
        status: result.status,
        config: result.config,
        summary: {
          totalCohorts: result.cohorts.length,
          dateRange: {
            start: config.timeWindow.start.toISOString(),
            end: config.timeWindow.end.toISOString()
          },
          insights: result.insights.length,
          calculatedAt: result.calculatedAt
        },
        preview: {
          cohorts: result.cohorts.slice(0, 3), // First 3 cohorts as preview
          keyInsights: result.insights.filter(i => i.severity === 'critical' || i.severity === 'warning').slice(0, 2)
        }
      },
      meta: {
        timestamp: new Date().toISOString(),
        version: '1.0.0',
        calculationTimeMs: Date.now() - new Date(result.calculatedAt).getTime()
      }
    }, { status: 201 });

  } catch (error) {
    console.error('Cohort creation error:', error);
    
    // Handle specific error types
    if (error.message.includes('Database')) {
      return NextResponse.json(
        { 
          success: false, 
          error: 'Database operation failed',
          code: 'DATABASE_ERROR'
        },
        { status: 500 }
      );
    }

    if (error.message.includes('insufficient data')) {
      return NextResponse.json(
        { 
          success: false, 
          error: 'Insufficient data for cohort analysis',
          code: 'INSUFFICIENT_DATA'
        },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { 
        success: false, 
        error: 'Failed to create cohort analysis',
        code: 'COHORT_CALCULATION_ERROR'
      },
      { status: 500 }
    );
  }
}

export async function PUT(request: NextRequest) {
  try {
    const url = new URL(request.url);
    const cohortId = url.searchParams.get('id');
    
    if (!cohortId) {
      return NextResponse.json(
        { 
          success: false, 
          error: 'Cohort ID is required',
          code: 'VALIDATION_ERROR'
        },
        { status: 400 }
      );
    }

    const body = await request.json();
    const { name, description, status, segmentationCriteria } = body;

    const updateData: any = { updated_at: new Date().toISOString() };
    
    if (name) updateData.name = name;
    if (description !== undefined) updateData.description = description;
    if (status) updateData.status = status;
    if (segmentationCriteria) updateData.segmentation_criteria = segmentationCriteria;

    const { data, error } = await supabase
      .from('cohort_definitions')
      .update(updateData)
      .eq('id', cohortId)
      .select('*')
      .single();

    if (error) {
      return NextResponse.json(
        { 
          success: false, 
          error: 'Failed to update cohort',
          code: 'DATABASE_ERROR'
        },
        { status: 500 }
      );
    }

    if (!data) {
      return NextResponse.json(
        { 
          success: false, 
          error: 'Cohort not found',
          code: 'NOT_FOUND'
        },
        { status: 404 }
      );
    }

    return NextResponse.json({
      success: true,
      data: {
        cohort: data,
        updatedAt: new Date().toISOString()
      }
    });

  } catch (error) {
    console.error('Cohort update error:', error);
    return NextResponse.json(
      { 
        success: false, 
        error: 'Failed to update cohort',
        code: 'INTERNAL_ERROR'
      },
      { status: 500 }
    );
  }
}

export async function DELETE(request: NextRequest) {
  try {
    const url = new URL(request.url);
    const cohortId = url.searchParams.get('id');
    
    if (!cohortId) {
      return NextResponse.json(
        { 
          success: false, 
          error: 'Cohort ID is required',
          code: 'VALIDATION_ERROR'
        },
        { status: 400 }
      );
    }

    // Check if cohort exists and get current status
    const { data: cohort, error: fetchError } = await supabase
      .from('cohort_definitions')
      .select('status')
      .eq('id', cohortId)
      .single();

    if (fetchError || !cohort) {
      return NextResponse.json(
        { 
          success: false, 
          error: 'Cohort not found',
          code: 'NOT_FOUND'
        },
        { status: 404 }
      );
    }

    // Soft delete: mark as archived instead of hard delete
    const { error: updateError } = await supabase
      .from('cohort_definitions')
      .update({ 
        status: 'archived',
        updated_at: new Date().toISOString()
      })
      .eq('id', cohortId);

    if (updateError) {
      return NextResponse.json(
        { 
          success: false, 
          error: 'Failed to archive cohort',
          code: 'DATABASE_ERROR'
        },
        { status: 500 }
      );
    }

    return NextResponse.json({
      success: true,
      data: {
        message: 'Cohort archived successfully',
        cohortId,
        archivedAt: new Date().toISOString()
      }
    });

  } catch (error) {
    console.error('Cohort delete error:', error);
    return NextResponse.json(
      { 
        success: false, 
        error: 'Failed to archive cohort',
        code: 'INTERNAL_ERROR'
      },
      { status: 500 }
    );
  }
}