import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { engagementScoringService } from '@/lib/analytics/engagement-scoring';
import { z } from 'zod';

const querySchema = z.object({
  supplier_id: z.string().uuid(),
  resolved: z.boolean().default(false),
  severity: z.enum(['low', 'medium', 'high', 'critical']).optional(),
  limit: z.number().min(1).max(100).default(50),
});

const resolveSchema = z.object({
  alert_id: z.string().uuid(),
  resolution_note: z.string().optional(),
});

const createAlertSchema = z.object({
  client_id: z.string().uuid(),
  supplier_id: z.string().uuid(),
  alert_type: z.enum(['going_silent', 'low_engagement', 'missed_milestone']),
  severity: z.enum(['low', 'medium', 'high', 'critical']),
  message: z.string(),
  recommended_actions: z.array(z.string()),
});

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const params = querySchema.parse({
      supplier_id: searchParams.get('supplier_id'),
      resolved: searchParams.get('resolved') === 'true',
      severity: searchParams.get('severity'),
      limit: searchParams.get('limit') ? parseInt(searchParams.get('limit')!) : 50,
    });

    const supabase = await createClient();

    // Authentication check
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // Get alerts using the service
    const alerts = await engagementScoringService.getAtRiskAlerts(params.supplier_id, params.resolved);
    
    // Apply additional filters
    let filteredAlerts = alerts;
    
    if (params.severity) {
      filteredAlerts = alerts.filter(alert => alert.severity === params.severity);
    }
    
    // Limit results
    filteredAlerts = filteredAlerts.slice(0, params.limit);

    // Get summary statistics
    const summary = {
      total_alerts: alerts.length,
      by_severity: alerts.reduce((acc, alert) => {
        acc[alert.severity] = (acc[alert.severity] || 0) + 1;
        return acc;
      }, {} as Record<string, number>),
      by_type: alerts.reduce((acc, alert) => {
        acc[alert.alert_type] = (acc[alert.alert_type] || 0) + 1;
        return acc;
      }, {} as Record<string, number>),
      most_recent: alerts.length > 0 ? alerts[0].created_at : null,
    };

    return NextResponse.json({
      data: filteredAlerts,
      summary,
      pagination: {
        limit: params.limit,
        total: alerts.length,
        showing: filteredAlerts.length,
      },
      success: true,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('Alerts API error:', error);
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Invalid parameters', details: error.errors },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { error: 'Failed to fetch alerts' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { action } = body;

    const supabase = await createClient();

    // Authentication check
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    if (action === 'resolve') {
      const params = resolveSchema.parse(body);
      
      // Resolve the alert
      await engagementScoringService.resolveAlert(params.alert_id);
      
      // Log the resolution
      if (params.resolution_note) {
        await supabase
          .from('alert_resolutions')
          .insert({
            alert_id: params.alert_id,
            resolved_by: user.id,
            resolution_note: params.resolution_note,
            resolved_at: new Date().toISOString()
          });
      }
      
      return NextResponse.json({
        success: true,
        message: 'Alert resolved successfully',
        timestamp: new Date().toISOString()
      });
    }

    if (action === 'create') {
      const params = createAlertSchema.parse(body);
      
      // Create new alert
      const { data: alertData, error } = await supabase
        .from('at_risk_alerts')
        .insert([{
          client_id: params.client_id,
          supplier_id: params.supplier_id,
          alert_type: params.alert_type,
          severity: params.severity,
          message: params.message,
          recommended_actions: params.recommended_actions,
        }])
        .select()
        .single();

      if (error) {
        throw error;
      }

      return NextResponse.json({
        success: true,
        message: 'Alert created successfully',
        data: alertData,
        timestamp: new Date().toISOString()
      });
    }

    if (action === 'detect_new') {
      // Trigger detection of new at-risk clients
      const { data, error } = await supabase.rpc('detect_at_risk_clients');
      
      if (error) {
        throw error;
      }
      
      return NextResponse.json({
        success: true,
        message: `Detected ${data || 0} new at-risk clients`,
        alerts_created: data || 0,
        timestamp: new Date().toISOString()
      });
    }

    return NextResponse.json(
      { error: 'Invalid action' },
      { status: 400 }
    );

  } catch (error) {
    console.error('Alerts POST error:', error);
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Invalid parameters', details: error.errors },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { error: 'Failed to process alert request' },
      { status: 500 }
    );
  }
}

export async function PATCH(request: NextRequest) {
  try {
    const body = await request.json();
    const { alert_id, updates } = body;

    if (!alert_id || !updates) {
      return NextResponse.json(
        { error: 'Missing alert_id or updates' },
        { status: 400 }
      );
    }

    const supabase = await createClient();

    // Authentication check
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // Update alert
    const { data, error } = await supabase
      .from('at_risk_alerts')
      .update(updates)
      .eq('id', alert_id)
      .select()
      .single();

    if (error) {
      throw error;
    }

    return NextResponse.json({
      success: true,
      message: 'Alert updated successfully',
      data,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('Alerts PATCH error:', error);
    return NextResponse.json(
      { error: 'Failed to update alert' },
      { status: 500 }
    );
  }
}