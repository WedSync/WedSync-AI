import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@/lib/supabase/server";
import { z } from "zod";

// WS-155: Bulk Template Management APIs
const bulkTemplateSchema = z.object({
  action: z.enum(["create", "update", "delete", "clone", "export", "import"]),
  templates: z.array(z.object({
    id: z.string().optional(),
    name: z.string().min(1).max(200),
    subject: z.string().optional(),
    content: z.string(),
    htmlContent: z.string().optional(),
    channels: z.array(z.enum(["email", "sms", "push"])),
    category: z.string(),
    tags: z.array(z.string()).optional(),
    variables: z.array(z.object({
      name: z.string(),
      type: z.enum(["text", "number", "date", "boolean"]),
      required: z.boolean(),
      defaultValue: z.any().optional()
    })).optional(),
    metadata: z.record(z.any()).optional()
  })),
  options: z.object({
    validateVariables: z.boolean().default(true),
    skipDuplicates: z.boolean().default(false),
    overwrite: z.boolean().default(false),
    preserveStats: z.boolean().default(true)
  }).optional()
});

export async function POST(req: NextRequest) {
  try {
    const supabase = await createClient();
    const { data: user } = await supabase.auth.getUser();
    
    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const body = await req.json();
    const validatedData = bulkTemplateSchema.parse(body);
    
    const results = {
      success: [],
      failed: [],
      skipped: []
    } as any;

    switch (validatedData.action) {
      case "create":
        await bulkCreateTemplates(supabase, user.id, validatedData, results);
        break;
      
      case "update":
        await bulkUpdateTemplates(supabase, user.id, validatedData, results);
        break;
      
      case "delete":
        await bulkDeleteTemplates(supabase, user.id, validatedData, results);
        break;
      
      case "clone":
        await bulkCloneTemplates(supabase, user.id, validatedData, results);
        break;
      
      case "export":
        return await exportTemplates(supabase, user.id, validatedData);
      
      case "import":
        await importTemplates(supabase, user.id, validatedData, results);
        break;
      
      default:
        return NextResponse.json(
          { error: "Invalid bulk action" },
          { status: 400 }
        );
    }

    return NextResponse.json({
      success: true,
      action: validatedData.action,
      summary: {
        total: validatedData.templates.length,
        succeeded: results.success.length,
        failed: results.failed.length,
        skipped: results.skipped.length
      },
      results
    });

  } catch (error) {
    console.error("Bulk template error:", error);
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: "Invalid template data", details: error.errors },
        { status: 400 }
      );
    }
    return NextResponse.json(
      { error: "Failed to process bulk templates" },
      { status: 500 }
    );
  }
}

export async function GET(req: NextRequest) {
  try {
    const supabase = await createClient();
    const { data: user } = await supabase.auth.getUser();
    
    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const url = new URL(req.url);
    const category = url.searchParams.get("category");
    const tags = url.searchParams.get("tags")?.split(",");
    const channels = url.searchParams.get("channels")?.split(",");
    const search = url.searchParams.get("search");
    const limit = parseInt(url.searchParams.get("limit") || "100");
    const offset = parseInt(url.searchParams.get("offset") || "0");

    let query = supabase
      .from("communication_templates")
      .select(`
        *,
        template_stats(
          usage_count,
          last_used_at,
          avg_open_rate,
          avg_click_rate
        )
      `)
      .eq("organization_id", user.id)
      .order("created_at", { ascending: false });

    if (category) {
      query = query.eq("category", category);
    }

    if (tags && tags.length > 0) {
      query = query.contains("tags", tags);
    }

    if (channels && channels.length > 0) {
      query = query.overlaps("channels", channels);
    }

    if (search) {
      query = query.or(`name.ilike.%${search}%,content.ilike.%${search}%`);
    }

    const { data, error, count } = await query
      .range(offset, offset + limit - 1)
      .select("*", { count: "exact" });

    if (error) throw error;

    // Group templates by category for better organization
    const grouped = groupTemplatesByCategory(data || []);

    return NextResponse.json({
      success: true,
      data: data || [],
      grouped,
      pagination: {
        total: count || 0,
        limit,
        offset,
        hasMore: offset + limit < (count || 0)
      }
    });

  } catch (error) {
    console.error("Get bulk templates error:", error);
    return NextResponse.json(
      { error: "Failed to fetch templates" },
      { status: 500 }
    );
  }
}

// Bulk operations helper functions
async function bulkCreateTemplates(supabase: any, organizationId: string, data: any, results: any) {
  for (const template of data.templates) {
    try {
      // Check for duplicates if skipDuplicates is true
      if (data.options?.skipDuplicates) {
        const { data: existing } = await supabase
          .from("communication_templates")
          .select("id")
          .eq("organization_id", organizationId)
          .eq("name", template.name)
          .single();

        if (existing) {
          results.skipped.push({
            name: template.name,
            reason: "Duplicate template name"
          });
          continue;
        }
      }

      // Validate variables if enabled
      if (data.options?.validateVariables) {
        const validationResult = validateTemplateVariables(template);
        if (!validationResult.valid) {
          results.failed.push({
            name: template.name,
            error: validationResult.error
          });
          continue;
        }
      }

      // Create the template
      const { data: created, error } = await supabase
        .from("communication_templates")
        .insert({
          organization_id: organizationId,
          name: template.name,
          subject: template.subject,
          content: template.content,
          html_content: template.htmlContent,
          channels: template.channels,
          category: template.category,
          tags: template.tags || [],
          variables: template.variables || [],
          metadata: template.metadata || {},
          is_active: true,
          created_by: organizationId
        })
        .select()
        .single();

      if (error) throw error;

      results.success.push({
        id: created.id,
        name: created.name
      });

    } catch (error: any) {
      results.failed.push({
        name: template.name,
        error: error.message
      });
    }
  }
}

async function bulkUpdateTemplates(supabase: any, organizationId: string, data: any, results: any) {
  for (const template of data.templates) {
    try {
      if (!template.id) {
        results.failed.push({
          name: template.name,
          error: "Template ID is required for updates"
        });
        continue;
      }

      // Check ownership
      const { data: existing } = await supabase
        .from("communication_templates")
        .select("id, usage_count")
        .eq("id", template.id)
        .eq("organization_id", organizationId)
        .single();

      if (!existing) {
        results.failed.push({
          name: template.name,
          error: "Template not found or unauthorized"
        });
        continue;
      }

      // Update the template
      const updateData: any = {
        name: template.name,
        subject: template.subject,
        content: template.content,
        html_content: template.htmlContent,
        channels: template.channels,
        category: template.category,
        tags: template.tags || [],
        variables: template.variables || [],
        metadata: template.metadata || {},
        updated_at: new Date().toISOString()
      };

      // Preserve stats if requested
      if (!data.options?.preserveStats) {
        updateData.usage_count = 0;
      }

      const { error } = await supabase
        .from("communication_templates")
        .update(updateData)
        .eq("id", template.id);

      if (error) throw error;

      results.success.push({
        id: template.id,
        name: template.name
      });

    } catch (error: any) {
      results.failed.push({
        name: template.name,
        error: error.message
      });
    }
  }
}

async function bulkDeleteTemplates(supabase: any, organizationId: string, data: any, results: any) {
  for (const template of data.templates) {
    try {
      if (!template.id) {
        results.failed.push({
          name: template.name,
          error: "Template ID is required for deletion"
        });
        continue;
      }

      // Soft delete by marking as inactive
      const { error } = await supabase
        .from("communication_templates")
        .update({
          is_active: false,
          deleted_at: new Date().toISOString()
        })
        .eq("id", template.id)
        .eq("organization_id", organizationId);

      if (error) throw error;

      results.success.push({
        id: template.id,
        name: template.name
      });

    } catch (error: any) {
      results.failed.push({
        name: template.name,
        error: error.message
      });
    }
  }
}

async function bulkCloneTemplates(supabase: any, organizationId: string, data: any, results: any) {
  for (const template of data.templates) {
    try {
      if (!template.id) {
        results.failed.push({
          name: template.name,
          error: "Template ID is required for cloning"
        });
        continue;
      }

      // Get original template
      const { data: original } = await supabase
        .from("communication_templates")
        .select("*")
        .eq("id", template.id)
        .single();

      if (!original) {
        results.failed.push({
          name: template.name,
          error: "Original template not found"
        });
        continue;
      }

      // Create cloned template
      const clonedName = template.name || `${original.name} (Copy)`;
      
      const { data: cloned, error } = await supabase
        .from("communication_templates")
        .insert({
          organization_id: organizationId,
          name: clonedName,
          subject: original.subject,
          content: original.content,
          html_content: original.html_content,
          channels: original.channels,
          category: original.category,
          tags: original.tags,
          variables: original.variables,
          metadata: {
            ...original.metadata,
            cloned_from: original.id,
            cloned_at: new Date().toISOString()
          },
          is_active: true,
          created_by: organizationId
        })
        .select()
        .single();

      if (error) throw error;

      results.success.push({
        id: cloned.id,
        name: cloned.name,
        original_id: original.id
      });

    } catch (error: any) {
      results.failed.push({
        name: template.name,
        error: error.message
      });
    }
  }
}

async function exportTemplates(supabase: any, organizationId: string, data: any) {
  const templateIds = data.templates.map((t: any) => t.id).filter(Boolean);
  
  let query = supabase
    .from("communication_templates")
    .select("*")
    .eq("organization_id", organizationId)
    .eq("is_active", true);

  if (templateIds.length > 0) {
    query = query.in("id", templateIds);
  }

  const { data: templates, error } = await query;

  if (error) throw error;

  // Format for export
  const exportData = {
    version: "1.0",
    exported_at: new Date().toISOString(),
    organization_id: organizationId,
    templates: templates?.map(t => ({
      name: t.name,
      subject: t.subject,
      content: t.content,
      html_content: t.html_content,
      channels: t.channels,
      category: t.category,
      tags: t.tags,
      variables: t.variables,
      metadata: t.metadata
    })) || []
  };

  return new NextResponse(JSON.stringify(exportData, null, 2), {
    headers: {
      "Content-Type": "application/json",
      "Content-Disposition": `attachment; filename="templates-export-${Date.now()}.json"`
    }
  });
}

async function importTemplates(supabase: any, organizationId: string, data: any, results: any) {
  // Validate import format
  if (!data.templates || !Array.isArray(data.templates)) {
    throw new Error("Invalid import format");
  }

  // Process each template
  for (const template of data.templates) {
    try {
      // Check for existing template with same name
      const { data: existing } = await supabase
        .from("communication_templates")
        .select("id")
        .eq("organization_id", organizationId)
        .eq("name", template.name)
        .single();

      if (existing && !data.options?.overwrite) {
        results.skipped.push({
          name: template.name,
          reason: "Template already exists"
        });
        continue;
      }

      const templateData = {
        organization_id: organizationId,
        name: template.name,
        subject: template.subject,
        content: template.content,
        html_content: template.htmlContent || template.html_content,
        channels: template.channels,
        category: template.category,
        tags: template.tags || [],
        variables: template.variables || [],
        metadata: {
          ...template.metadata,
          imported_at: new Date().toISOString()
        },
        is_active: true,
        created_by: organizationId
      };

      if (existing && data.options?.overwrite) {
        // Update existing template
        await supabase
          .from("communication_templates")
          .update(templateData)
          .eq("id", existing.id);

        results.success.push({
          id: existing.id,
          name: template.name,
          action: "updated"
        });
      } else {
        // Create new template
        const { data: created } = await supabase
          .from("communication_templates")
          .insert(templateData)
          .select()
          .single();

        results.success.push({
          id: created.id,
          name: template.name,
          action: "created"
        });
      }

    } catch (error: any) {
      results.failed.push({
        name: template.name,
        error: error.message
      });
    }
  }
}

function validateTemplateVariables(template: any) {
  const variablePattern = /\{\{([^}]+)\}\}/g;
  const contentVariables = new Set<string>();
  
  // Extract variables from content
  let match;
  while ((match = variablePattern.exec(template.content)) !== null) {
    contentVariables.add(match[1].trim());
  }
  
  // Check if all content variables are defined
  const definedVariables = new Set(template.variables?.map((v: any) => v.name) || []);
  const undefinedVariables = Array.from(contentVariables).filter(v => !definedVariables.has(v));
  
  if (undefinedVariables.length > 0) {
    return {
      valid: false,
      error: `Undefined variables: ${undefinedVariables.join(", ")}`
    };
  }
  
  return { valid: true };
}

function groupTemplatesByCategory(templates: any[]) {
  const grouped: Record<string, any[]> = {};
  
  for (const template of templates) {
    if (!grouped[template.category]) {
      grouped[template.category] = [];
    }
    grouped[template.category].push(template);
  }
  
  return grouped;
}