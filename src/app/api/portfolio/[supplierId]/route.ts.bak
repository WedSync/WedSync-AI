// WS-186: Portfolio Management API - Team B Round 1  
// Portfolio retrieval and management operations for suppliers

import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@supabase/supabase-js'
import { z } from 'zod'
import { withSecureValidation, withQueryValidation } from '@/lib/validation/middleware'
import { secureStringSchema } from '@/lib/validation/schemas'

interface RouteParams {
  params: { supplierId: string }
}

// Query validation schema for portfolio retrieval
const portfolioQuerySchema = z.object({
  page: z.string().transform(val => Math.max(1, parseInt(val) || 1)),
  limit: z.string().transform(val => Math.min(100, Math.max(1, parseInt(val) || 20))),
  category: z.enum(['ceremony', 'reception', 'portraits', 'details', 'venue']).optional(),
  featured: z.string().transform(val => val === 'true').optional(),
  tags: z.string().optional(),
  search: z.string().min(1).max(100).transform(val => val.trim()).optional(),
  sortBy: z.enum(['created_at', 'views', 'likes', 'ai_score', 'title']).default('created_at'),
  sortOrder: z.enum(['asc', 'desc']).default('desc'),
  status: z.enum(['active', 'processing', 'failed', 'archived']).default('active'),
  cursor: z.string().optional(), // For cursor-based pagination
  include_analytics: z.string().transform(val => val === 'true').optional()
})

// Image metadata update schema
const imageUpdateSchema = z.object({
  title: z.string().min(1).max(200).transform(val => val.trim()).optional(),
  description: z.string().min(1).max(1000).transform(val => val.trim()).optional(),
  tags: z.array(z.string().min(1).max(50).transform(val => val.trim())).max(20).optional(),
  featured: z.boolean().optional(),
  category: z.enum(['ceremony', 'reception', 'portraits', 'details', 'venue']).optional(),
  alt_text: z.string().min(1).max(500).transform(val => val.trim()).optional(),
  display_order: z.number().int().min(0).optional(),
  watermark_position: z.enum(['top-left', 'top-right', 'bottom-left', 'bottom-right', 'center']).optional()
})

// Batch operations schema
const batchOperationSchema = z.object({
  operation: z.enum(['delete', 'archive', 'feature', 'unfeature', 'update_category', 'reorder']),
  image_ids: z.array(z.string().uuid()).min(1).max(100),
  data: z.record(z.any()).optional() // Additional data for specific operations
})

// GET - Retrieve supplier's portfolio with pagination and filtering
export const GET = withQueryValidation(
  portfolioQuerySchema,
  async (request: NextRequest, validatedQuery, { params }: RouteParams) => {
    try {
      const supabase = createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.SUPABASE_SERVICE_ROLE_KEY!
      )

      // Verify supplier exists and user has access
      const authHeader = request.headers.get('authorization')
      if (!authHeader) {
        return NextResponse.json({ error: 'Authorization required' }, { status: 401 })
      }

      const { data: { user }, error: userError } = await supabase.auth.getUser(
        authHeader.replace('Bearer ', '')
      )

      if (userError || !user) {
        return NextResponse.json({ error: 'Invalid authorization' }, { status: 401 })
      }

      // Check supplier access
      const { data: supplierAccess, error: accessError } = await supabase
        .from('user_profiles')
        .select(`
          organization_id,
          suppliers!inner(
            id,
            business_name,
            category,
            organization_id
          )
        `)
        .eq('user_id', user.id)
        .eq('suppliers.id', params.supplierId)
        .single()

      if (accessError || !supplierAccess) {
        return NextResponse.json(
          { error: 'Supplier not found or access denied' },
          { status: 404 }
        )
      }

      // Build query for portfolio images
      let query = supabase
        .from('portfolio_images')
        .select(`
          id,
          title,
          description,
          file_path,
          thumbnail_path,
          category,
          tags,
          featured,
          display_order,
          views_count,
          likes_count,
          ai_analysis,
          processing_status,
          created_at,
          updated_at,
          metadata,
          ${validatedQuery.include_analytics ? 'portfolio_analytics(*)' : ''}
        `)
        .eq('supplier_id', params.supplierId)
        .eq('status', validatedQuery.status)

      // Apply filters
      if (validatedQuery.category) {
        query = query.eq('category', validatedQuery.category)
      }

      if (validatedQuery.featured !== undefined) {
        query = query.eq('featured', validatedQuery.featured)
      }

      if (validatedQuery.tags) {
        const tags = validatedQuery.tags.split(',').map(tag => tag.trim())
        query = query.overlaps('tags', tags)
      }

      if (validatedQuery.search) {
        query = query.or(`title.ilike.%${validatedQuery.search}%,description.ilike.%${validatedQuery.search}%`)
      }

      // Apply sorting
      query = query.order(validatedQuery.sortBy, { 
        ascending: validatedQuery.sortOrder === 'asc' 
      })

      // Apply cursor-based pagination if cursor provided
      if (validatedQuery.cursor) {
        query = query.gt('created_at', validatedQuery.cursor)
      }

      // Apply limit with +1 to check if there are more results
      query = query.limit(validatedQuery.limit + 1)

      const { data: images, error: imagesError } = await query

      if (imagesError) {
        console.error('Portfolio images fetch error:', imagesError)
        throw imagesError
      }

      // Check if there are more results
      const hasMore = images.length > validatedQuery.limit
      const resultImages = hasMore ? images.slice(0, validatedQuery.limit) : images
      const nextCursor = hasMore ? resultImages[resultImages.length - 1].created_at : null

      // Get total count for pagination metadata (expensive, consider caching)
      const { count: totalCount, error: countError } = await supabase
        .from('portfolio_images')
        .select('*', { count: 'exact', head: true })
        .eq('supplier_id', params.supplierId)
        .eq('status', validatedQuery.status)

      if (countError) {
        console.error('Portfolio count error:', countError)
      }

      // Transform images with CDN URLs
      const transformedImages = resultImages.map(img => ({
        id: img.id,
        title: img.title,
        description: img.description,
        imageUrl: `${process.env.NEXT_PUBLIC_SUPABASE_URL}/storage/v1/object/public/portfolio-images/${img.file_path}`,
        thumbnailUrl: img.thumbnail_path 
          ? `${process.env.NEXT_PUBLIC_SUPABASE_URL}/storage/v1/object/public/portfolio-images/${img.thumbnail_path}`
          : null,
        category: img.category,
        tags: img.tags,
        featured: img.featured,
        displayOrder: img.display_order,
        viewsCount: img.views_count,
        likesCount: img.likes_count,
        aiAnalysis: img.ai_analysis,
        processingStatus: img.processing_status,
        createdAt: img.created_at,
        updatedAt: img.updated_at,
        metadata: img.metadata,
        analytics: validatedQuery.include_analytics ? img.portfolio_analytics : undefined
      }))

      // Get portfolio summary
      const { data: portfolioSummary, error: summaryError } = await supabase
        .from('portfolio_images')
        .select('category, featured, processing_status')
        .eq('supplier_id', params.supplierId)
        .eq('status', 'active')

      const summary = portfolioSummary?.reduce((acc, img) => {
        acc.totalImages++
        acc.categoryCounts[img.category] = (acc.categoryCounts[img.category] || 0) + 1
        if (img.featured) acc.featuredImages++
        if (img.processing_status === 'completed') acc.processedImages++
        return acc
      }, {
        totalImages: 0,
        featuredImages: 0,
        processedImages: 0,
        categoryCounts: {}
      }) || {
        totalImages: 0,
        featuredImages: 0,
        processedImages: 0,
        categoryCounts: {}
      }

      return NextResponse.json({
        images: transformedImages,
        pagination: {
          total: totalCount || 0,
          page: validatedQuery.page,
          limit: validatedQuery.limit,
          hasMore,
          nextCursor
        },
        summary,
        supplier: {
          id: supplierAccess.suppliers.id,
          businessName: supplierAccess.suppliers.business_name,
          category: supplierAccess.suppliers.category
        },
        query: {
          category: validatedQuery.category,
          featured: validatedQuery.featured,
          search: validatedQuery.search,
          sortBy: validatedQuery.sortBy,
          sortOrder: validatedQuery.sortOrder
        }
      })

    } catch (error) {
      console.error('Portfolio GET error:', error)
      return NextResponse.json(
        { error: 'Failed to fetch portfolio' },
        { status: 500 }
      )
    }
  }
)

// PATCH - Update image metadata
export const PATCH = withSecureValidation(
  imageUpdateSchema,
  async (request: NextRequest, validatedData, { params }: RouteParams) => {
    try {
      const url = new URL(request.url)
      const imageId = url.searchParams.get('imageId')

      if (!imageId) {
        return NextResponse.json(
          { error: 'Image ID is required' },
          { status: 400 }
        )
      }

      const supabase = createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.SUPABASE_SERVICE_ROLE_KEY!
      )

      // Get user session for authorization
      const authHeader = request.headers.get('authorization')
      if (!authHeader) {
        return NextResponse.json({ error: 'Authorization required' }, { status: 401 })
      }

      const { data: { user }, error: userError } = await supabase.auth.getUser(
        authHeader.replace('Bearer ', '')
      )

      if (userError || !user) {
        return NextResponse.json({ error: 'Invalid authorization' }, { status: 401 })
      }

      // Verify image ownership through supplier access
      const { data: imageAccess, error: accessError } = await supabase
        .from('portfolio_images')
        .select(`
          id,
          supplier_id,
          suppliers!inner(
            organization_id,
            user_profiles!inner(
              user_id
            )
          )
        `)
        .eq('id', imageId)
        .eq('supplier_id', params.supplierId)
        .eq('suppliers.user_profiles.user_id', user.id)
        .single()

      if (accessError || !imageAccess) {
        return NextResponse.json(
          { error: 'Image not found or access denied' },
          { status: 404 }
        )
      }

      // Update image metadata
      const { data: updatedImage, error: updateError } = await supabase
        .from('portfolio_images')
        .update({
          ...validatedData,
          updated_at: new Date().toISOString()
        })
        .eq('id', imageId)
        .select(`
          id,
          title,
          description,
          file_path,
          thumbnail_path,
          category,
          tags,
          featured,
          display_order,
          views_count,
          likes_count,
          updated_at
        `)
        .single()

      if (updateError) {
        console.error('Image update error:', updateError)
        throw updateError
      }

      // Log portfolio activity
      await supabase
        .from('portfolio_activity_logs')
        .insert({
          supplier_id: params.supplierId,
          user_id: user.id,
          action: 'image_updated',
          resource_id: imageId,
          details: {
            updatedFields: Object.keys(validatedData),
            changes: validatedData
          }
        })

      return NextResponse.json({
        success: true,
        image: {
          id: updatedImage.id,
          title: updatedImage.title,
          description: updatedImage.description,
          imageUrl: `${process.env.NEXT_PUBLIC_SUPABASE_URL}/storage/v1/object/public/portfolio-images/${updatedImage.file_path}`,
          thumbnailUrl: updatedImage.thumbnail_path 
            ? `${process.env.NEXT_PUBLIC_SUPABASE_URL}/storage/v1/object/public/portfolio-images/${updatedImage.thumbnail_path}`
            : null,
          category: updatedImage.category,
          tags: updatedImage.tags,
          featured: updatedImage.featured,
          displayOrder: updatedImage.display_order,
          viewsCount: updatedImage.views_count,
          likesCount: updatedImage.likes_count,
          updatedAt: updatedImage.updated_at
        }
      })

    } catch (error) {
      console.error('Image update error:', error)
      return NextResponse.json(
        { error: 'Failed to update image' },
        { status: 500 }
      )
    }
  }
)

// POST - Batch operations on multiple images
export const POST = withSecureValidation(
  batchOperationSchema,
  async (request: NextRequest, validatedData, { params }: RouteParams) => {
    try {
      const supabase = createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.SUPABASE_SERVICE_ROLE_KEY!
      )

      // Get user session for authorization
      const authHeader = request.headers.get('authorization')
      if (!authHeader) {
        return NextResponse.json({ error: 'Authorization required' }, { status: 401 })
      }

      const { data: { user }, error: userError } = await supabase.auth.getUser(
        authHeader.replace('Bearer ', '')
      )

      if (userError || !user) {
        return NextResponse.json({ error: 'Invalid authorization' }, { status: 401 })
      }

      // Verify all images belong to the supplier and user has access
      const { data: imageAccess, error: accessError } = await supabase
        .from('portfolio_images')
        .select(`
          id,
          suppliers!inner(
            organization_id,
            user_profiles!inner(
              user_id
            )
          )
        `)
        .in('id', validatedData.image_ids)
        .eq('supplier_id', params.supplierId)
        .eq('suppliers.user_profiles.user_id', user.id)

      if (accessError || imageAccess.length !== validatedData.image_ids.length) {
        return NextResponse.json(
          { error: 'Some images not found or access denied' },
          { status: 404 }
        )
      }

      let updateData: any = {}
      let logAction = ''

      // Prepare update based on operation type
      switch (validatedData.operation) {
        case 'delete':
          updateData = { status: 'deleted', updated_at: new Date().toISOString() }
          logAction = 'images_deleted'
          break
        case 'archive':
          updateData = { status: 'archived', updated_at: new Date().toISOString() }
          logAction = 'images_archived'
          break
        case 'feature':
          updateData = { featured: true, updated_at: new Date().toISOString() }
          logAction = 'images_featured'
          break
        case 'unfeature':
          updateData = { featured: false, updated_at: new Date().toISOString() }
          logAction = 'images_unfeatured'
          break
        case 'update_category':
          if (!validatedData.data?.category) {
            return NextResponse.json(
              { error: 'Category is required for update_category operation' },
              { status: 400 }
            )
          }
          updateData = { 
            category: validatedData.data.category, 
            updated_at: new Date().toISOString() 
          }
          logAction = 'images_category_updated'
          break
        case 'reorder':
          // For reorder, we need to update display_order based on the array order
          if (!validatedData.data?.order_mapping) {
            return NextResponse.json(
              { error: 'Order mapping is required for reorder operation' },
              { status: 400 }
            )
          }
          // This would require individual updates with different display_order values
          // For now, return success but implement reordering logic later
          logAction = 'images_reordered'
          break
        default:
          return NextResponse.json(
            { error: 'Invalid operation' },
            { status: 400 }
          )
      }

      // Perform batch update (except for reorder which needs individual handling)
      if (validatedData.operation !== 'reorder') {
        const { error: batchUpdateError } = await supabase
          .from('portfolio_images')
          .update(updateData)
          .in('id', validatedData.image_ids)
      }

      // Log portfolio activity
      await supabase
        .from('portfolio_activity_logs')
        .insert({
          supplier_id: params.supplierId,
          user_id: user.id,
          action: logAction,
          details: {
            operation: validatedData.operation,
            imageIds: validatedData.image_ids,
            imageCount: validatedData.image_ids.length,
            operationData: validatedData.data
          }
        })

      return NextResponse.json({
        success: true,
        operation: validatedData.operation,
        affectedImages: validatedData.image_ids.length,
        processedAt: new Date().toISOString()
      })

    } catch (error) {
      console.error('Batch operation error:', error)
      return NextResponse.json(
        { error: 'Batch operation failed' },
        { status: 500 }
      )
    }
  }
)