/**
 * WS-205 Broadcast Acknowledgment API Endpoint
 * Handle broadcast read/acknowledgment tracking with comprehensive analytics
 */

import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { z } from 'zod'
import { BroadcastManager } from '@/lib/broadcast/broadcast-manager'

const acknowledgeSchema = z.object({
  broadcastId: z.string().uuid(),
  action: z.enum(['read', 'acknowledged', 'dismissed', 'action_clicked']),
  actionUrl: z.string().optional(), // For tracking action clicks
  metadata: z.object({
    readTime: z.number().optional(), // Time spent reading (seconds)
    deviceType: z.string().optional(),
    location: z.string().optional() // General location like "dashboard", "inbox"
  }).optional()
})

const bulkAcknowledgeSchema = z.object({
  broadcastIds: z.array(z.string().uuid()).max(50), // Limit bulk operations
  action: z.enum(['read', 'acknowledged', 'dismissed']),
  metadata: z.object({
    batchSize: z.number(),
    deviceType: z.string().optional()
  }).optional()
})

/**
 * POST - Acknowledge single or multiple broadcasts
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = createClient()
    
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const isBulkOperation = 'broadcastIds' in body

    if (isBulkOperation) {
      return await handleBulkAcknowledgment(supabase, user.id, body, request)
    } else {
      return await handleSingleAcknowledgment(supabase, user.id, body, request)
    }

  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json({
        error: 'Validation error',
        details: error.errors.map(e => ({
          field: e.path.join('.'),
          message: e.message
        }))
      }, { status: 400 })
    }

    console.error('Acknowledge API error:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}

/**
 * Handle single broadcast acknowledgment
 */
async function handleSingleAcknowledgment(
  supabase: any,
  userId: string,
  body: any,
  request: NextRequest
) {
  const { broadcastId, action, actionUrl, metadata } = acknowledgeSchema.parse(body)

  // Verify delivery exists and get broadcast details
  const { data: delivery, error: deliveryError } = await supabase
    .from('broadcast_deliveries')
    .select(`
      *,
      broadcast:broadcasts!inner(
        id,
        type,
        priority,
        title,
        wedding_context,
        expires_at,
        created_at
      )
    `)
    .eq('broadcast_id', broadcastId)
    .eq('user_id', userId)
    .single()

  if (deliveryError || !delivery) {
    return NextResponse.json(
      { error: 'Broadcast delivery not found or access denied' },
      { status: 404 }
    )
  }

  // Check if broadcast has expired
  if (delivery.broadcast.expires_at) {
    const expiryDate = new Date(delivery.broadcast.expires_at)
    if (expiryDate < new Date()) {
      return NextResponse.json(
        { error: 'Cannot acknowledge expired broadcast' },
        { status: 410 } // Gone
      )
    }
  }

  // Prepare update data based on action
  const updateData: any = {}
  const timestamp = new Date().toISOString()

  switch (action) {
    case 'read':
      if (!delivery.read_at) {
        updateData.read_at = timestamp
      }
      break
      
    case 'acknowledged':
      if (!delivery.acknowledged_at) {
        updateData.acknowledged_at = timestamp
        if (!delivery.read_at) {
          updateData.read_at = timestamp
        }
      }
      break
      
    case 'dismissed':
      updateData.acknowledged_at = timestamp
      if (!delivery.read_at) {
        updateData.read_at = timestamp
      }
      break
      
    case 'action_clicked':
      if (!delivery.read_at) {
        updateData.read_at = timestamp
      }
      // Action click tracking is handled separately in analytics
      break
  }

  // Update delivery record
  let updatedDelivery = delivery
  if (Object.keys(updateData).length > 0) {
    const { data: updated, error: updateError } = await supabase
      .from('broadcast_deliveries')
      .update(updateData)
      .eq('broadcast_id', broadcastId)
      .eq('user_id', userId)
      .select()
      .single()

    if (updateError) {
      console.error('Delivery update error:', updateError)
      return NextResponse.json(
        { error: 'Failed to update delivery status' },
        { status: 500 }
      )
    }
    updatedDelivery = updated
  }

  // Track comprehensive analytics
  try {
    const analyticsData = {
      broadcastId,
      userId,
      action,
      timestamp,
      actionUrl: actionUrl || null,
      priority: delivery.broadcast.priority,
      type: delivery.broadcast.type,
      weddingContext: delivery.broadcast.wedding_context,
      readTime: metadata?.readTime,
      deviceType: metadata?.deviceType,
      location: metadata?.location,
      userAgent: request.headers.get('user-agent') || 'unknown',
      ipAddress: request.ip || 'unknown'
    }

    // Update broadcast analytics using the increment function
    await supabase.rpc('increment_broadcast_stat', {
      broadcast_id: broadcastId,
      stat_name: action === 'action_clicked' ? 'action_clicked' : action
    })

    // Log critical broadcast acknowledgments for audit
    if (delivery.broadcast.priority === 'critical' && action === 'acknowledged') {
      console.info('CRITICAL BROADCAST ACKNOWLEDGED:', {
        ...analyticsData,
        broadcastTitle: delivery.broadcast.title
      })
    }

    // Log wedding emergency acknowledgments
    if (delivery.broadcast.type === 'wedding.emergency') {
      console.warn('WEDDING EMERGENCY ACKNOWLEDGED:', {
        ...analyticsData,
        weddingId: delivery.broadcast.wedding_context?.weddingId,
        broadcastTitle: delivery.broadcast.title
      })
    }

    // Track user engagement patterns for personalization
    await trackEngagementPattern(supabase, userId, {
      action,
      broadcastType: delivery.broadcast.type,
      priority: delivery.broadcast.priority,
      timeToAction: calculateTimeToAction(delivery.broadcast.created_at, timestamp),
      readTime: metadata?.readTime
    })

  } catch (analyticsError) {
    // Analytics failure shouldn't fail the main request
    console.warn('Analytics tracking failed:', analyticsError)
  }

  return NextResponse.json({
    success: true,
    action,
    broadcastId,
    acknowledgedAt: updateData.acknowledged_at || delivery.acknowledged_at,
    readAt: updateData.read_at || delivery.read_at,
    broadcast: {
      id: delivery.broadcast.id,
      type: delivery.broadcast.type,
      priority: delivery.broadcast.priority,
      title: delivery.broadcast.title
    },
    analytics: {
      timeToAction: calculateTimeToAction(delivery.broadcast.created_at, timestamp),
      actionTracked: true
    }
  })
}

/**
 * Handle bulk broadcast acknowledgment
 */
async function handleBulkAcknowledgment(
  supabase: any,
  userId: string,
  body: any,
  request: NextRequest
) {
  const { broadcastIds, action, metadata } = bulkAcknowledgeSchema.parse(body)

  // Verify all deliveries exist
  const { data: deliveries, error: deliveriesError } = await supabase
    .from('broadcast_deliveries')
    .select(`
      broadcast_id,
      read_at,
      acknowledged_at,
      broadcast:broadcasts!inner(
        id,
        type,
        priority,
        expires_at
      )
    `)
    .eq('user_id', userId)
    .in('broadcast_id', broadcastIds)

  if (deliveriesError) {
    return NextResponse.json(
      { error: 'Failed to fetch deliveries' },
      { status: 500 }
    )
  }

  // Filter out expired broadcasts
  const validDeliveries = deliveries?.filter(d => {
    if (!d.broadcast.expires_at) return true
    return new Date(d.broadcast.expires_at) > new Date()
  }) || []

  if (validDeliveries.length === 0) {
    return NextResponse.json(
      { error: 'No valid broadcasts to acknowledge' },
      { status: 400 }
    )
  }

  // Prepare bulk update
  const timestamp = new Date().toISOString()
  const updatePromises = validDeliveries.map(async (delivery) => {
    const updateData: any = {}
    
    switch (action) {
      case 'read':
        if (!delivery.read_at) updateData.read_at = timestamp
        break
      case 'acknowledged':
        if (!delivery.acknowledged_at) updateData.acknowledged_at = timestamp
        if (!delivery.read_at) updateData.read_at = timestamp
        break
      case 'dismissed':
        updateData.acknowledged_at = timestamp
        if (!delivery.read_at) updateData.read_at = timestamp
        break
    }

    if (Object.keys(updateData).length > 0) {
      return supabase
        .from('broadcast_deliveries')
        .update(updateData)
        .eq('broadcast_id', delivery.broadcast_id)
        .eq('user_id', userId)
    }
    return null
  })

  // Execute bulk updates
  const updateResults = await Promise.allSettled(updatePromises.filter(Boolean))
  const successCount = updateResults.filter(r => r.status === 'fulfilled').length
  const failureCount = updateResults.filter(r => r.status === 'rejected').length

  // Update analytics for successful acknowledgments
  for (const delivery of validDeliveries) {
    try {
      await supabase.rpc('increment_broadcast_stat', {
        broadcast_id: delivery.broadcast_id,
        stat_name: action
      })
    } catch (analyticsError) {
      console.warn('Bulk analytics update failed:', analyticsError)
    }
  }

  // Log bulk operation
  console.info('Bulk broadcast acknowledgment:', {
    userId,
    action,
    requestedCount: broadcastIds.length,
    validCount: validDeliveries.length,
    successCount,
    failureCount,
    deviceType: metadata?.deviceType
  })

  return NextResponse.json({
    success: true,
    action,
    results: {
      requested: broadcastIds.length,
      valid: validDeliveries.length,
      successful: successCount,
      failed: failureCount
    },
    processed: validDeliveries.map(d => ({
      broadcastId: d.broadcast_id,
      type: d.broadcast.type,
      priority: d.broadcast.priority
    }))
  })
}

/**
 * Track user engagement patterns for personalization
 */
async function trackEngagementPattern(
  supabase: any,
  userId: string,
  engagement: {
    action: string
    broadcastType: string
    priority: string
    timeToAction: number
    readTime?: number
  }
) {
  // This would integrate with a user behavior analytics system
  // For now, we'll log the pattern for future ML analysis
  
  const pattern = {
    userId,
    timestamp: new Date().toISOString(),
    ...engagement
  }

  // In production, this would be sent to analytics service
  console.debug('User engagement pattern:', pattern)
  
  // Could be used to:
  // - Optimize broadcast timing
  // - Personalize content
  // - Predict user preferences
  // - A/B test message formats
}

/**
 * Calculate time from broadcast creation to user action
 */
function calculateTimeToAction(createdAt: string, actionAt: string): number {
  const created = new Date(createdAt)
  const action = new Date(actionAt)
  return Math.floor((action.getTime() - created.getTime()) / 1000) // Seconds
}