/**
 * WS-170: Viral Optimization System - Referral Creation API
 * 
 * POST /api/referrals/create
 * Creates new referral codes for users with proper validation and rate limiting
 * 
 * Security Features:
 * - User authentication required
 * - Rate limiting (10 codes/hour/user)
 * - Input sanitization
 * - RLS policies enforced
 */

import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { slidingWindowRateLimit } from '@/lib/rate-limiter/sliding-window'
import { sanitizeUserInput } from '@/lib/security/xss-protection'
import crypto from 'crypto'
import { 
  type CreateReferralRequest,
  type CreateReferralResponse, 
  type ReferralCode,
  REFERRAL_DEFAULTS
} from '@/types/referrals'
import { 
  createReferralRequestSchema,
  sanitizeReferralInput,
  validateExpiryDate,
  REFERRAL_ERROR_MESSAGES
} from '@/lib/validations/referrals'

interface ReferralCode {
  id: string
  user_id: string
  code: string
  description?: string
  campaign_name?: string
  created_at: string
  expires_at?: string
  uses: number
  max_uses?: number
  is_active: boolean
}

interface ReferralCreateResponse {
  success: boolean
  data?: ReferralCode
  error?: string
}

/**
 * Generate a secure referral code
 */
function generateReferralCode(length: number = REFERRAL_DEFAULTS.CODE_LENGTH): string {
  const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
  let result = ''
  const bytes = crypto.randomBytes(length)
  
  for (let i = 0; i < length; i++) {
    result += characters[bytes[i] % characters.length]
  }
  
  return result
}

/**
 * Check if referral code is unique
 */
async function isReferralCodeUnique(supabase: any, code: string): Promise<boolean> {
  const { data, error } = await supabase
    .from('referral_codes')
    .select('code')
    .eq('code', code)
    .single()

  return !data && !error
}

/**
 * Generate unique referral code with retry logic
 */
async function generateUniqueReferralCode(supabase: any, maxRetries: number = 5): Promise<string> {
  for (let i = 0; i < maxRetries; i++) {
    const code = generateReferralCode()
    const isUnique = await isReferralCodeUnique(supabase, code)
    
    if (isUnique) {
      return code
    }
  }
  
  throw new Error('Failed to generate unique referral code after multiple attempts')
}

export async function POST(request: NextRequest): Promise<NextResponse<CreateReferralResponse>> {
  try {
    // Create Supabase client with RLS enabled
    const supabase = createClient()

    // Get authenticated user
    const { data: { user }, error: userError } = await supabase.auth.getUser()
    
    if (userError || !user) {
      return NextResponse.json(
        { success: false, error: 'Authentication required' },
        { status: 401 }
      )
    }

    // Apply rate limiting (10 codes per hour per user)
    const rateLimitKey = `referral_create:${user.id}`
    const rateLimitResult = await slidingWindowRateLimit({
      identifier: rateLimitKey,
      limit: REFERRAL_DEFAULTS.MAX_CODES_PER_HOUR,
      windowMs: 60 * 60 * 1000 // 1 hour in milliseconds
    })

    if (!rateLimitResult.success) {
      return NextResponse.json(
        { 
          success: false, 
          error: `Rate limit exceeded. You can create ${rateLimitResult.remaining} more referral codes. Window resets in ${Math.ceil(rateLimitResult.resetTime / 60000)} minutes.`
        },
        { status: 429 }
      )
    }

    // Parse and validate request body
    let body
    try {
      body = await request.json()
    } catch (error) {
      return NextResponse.json(
        { success: false, error: 'Invalid JSON in request body' },
        { status: 400 }
      )
    }

    // Validate input schema
    const validation = createReferralRequestSchema.safeParse(body)
    if (!validation.success) {
      return NextResponse.json(
        { 
          success: false, 
          error: 'Invalid input data',
          details: validation.error.issues
        },
        { status: 400 }
      )
    }

    // Sanitize inputs
    const sanitizedData = {
      description: validation.data.description ? sanitizeReferralInput(validation.data.description) : undefined,
      campaign_name: validation.data.campaign_name ? sanitizeReferralInput(validation.data.campaign_name) : undefined,
      expires_at: validation.data.expires_at || undefined,
      max_uses: validation.data.max_uses || undefined
    }

    // Additional expiry date validation
    if (sanitizedData.expires_at && !validateExpiryDate(sanitizedData.expires_at)) {
      return NextResponse.json(
        { success: false, error: REFERRAL_ERROR_MESSAGES.INVALID_EXPIRY_DATE },
        { status: 400 }
      )
    }

    // Generate unique referral code
    const referralCode = await generateUniqueReferralCode(supabase)

    // Create referral code in database
    const { data: referralData, error: insertError } = await supabase
      .from('referral_codes')
      .insert({
        user_id: user.id,
        code: referralCode,
        description: sanitizedData.description,
        campaign_name: sanitizedData.campaign_name,
        expires_at: sanitizedData.expires_at,
        created_at: new Date().toISOString(),
        uses: 0,
        max_uses: validation.data.max_uses || null, // Unlimited uses by default
        is_active: true
      })
      .select()
      .single()

    if (insertError) {
      console.error('Failed to create referral code:', insertError)
      return NextResponse.json(
        { success: false, error: 'Failed to create referral code' },
        { status: 500 }
      )
    }

    // Log referral creation for analytics
    await supabase
      .from('referral_analytics')
      .insert({
        user_id: user.id,
        action: 'code_created',
        referral_code_id: referralData.id,
        metadata: {
          campaign_name: sanitizedData.campaign_name,
          has_expiry: !!sanitizedData.expires_at,
          created_at: new Date().toISOString()
        }
      })
      .select()

    return NextResponse.json({
      success: true,
      data: referralData
    }, { status: 201 })

  } catch (error) {
    console.error('Referral creation error:', error)
    
    // Don't leak internal error details
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}

// OPTIONS handler for CORS preflight
export async function OPTIONS(request: NextRequest): Promise<NextResponse> {
  return NextResponse.json({}, { 
    status: 200,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    },
  })
}