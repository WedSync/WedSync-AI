import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { Database } from '@/types/database';
import { emailServiceConnector } from '@/lib/services/email-connector';
import { randomBytes } from 'crypto';
import { ratelimit } from '@/lib/ratelimit';

const supabase = createClient<Database>(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

/**
 * Forgot Password API
 * POST /api/auth/forgot-password
 * Initiates password reset process by sending reset email
 */
export async function POST(request: NextRequest) {
  try {
    const { email } = await request.json();

    // Validate input
    if (!email || !isValidEmail(email)) {
      return NextResponse.json(
        { error: 'Valid email address is required' },
        { status: 400 }
      );
    }

    // Rate limiting - max 3 reset attempts per hour per IP
    const identifier = getClientIP(request) || 'anonymous';
    const { success, limit, reset, remaining } = await ratelimit.limit(
      `password_reset:${identifier}:${email}`
    );

    if (!success) {
      return NextResponse.json(
        { 
          error: 'Too many password reset attempts. Please try again later.',
          retry_after: Math.round((reset - Date.now()) / 1000)
        },
        { 
          status: 429,
          headers: {
            'X-RateLimit-Limit': limit.toString(),
            'X-RateLimit-Remaining': remaining.toString(),
            'X-RateLimit-Reset': new Date(reset).toISOString(),
          },
        }
      );
    }

    // Normalize email
    const normalizedEmail = email.toLowerCase().trim();

    // Check if user exists (but don't reveal this information for security)
    const { data: user } = await supabase
      .from('users')
      .select('id, email, name, role')
      .eq('email', normalizedEmail)
      .single();

    // Always return success to prevent email enumeration
    // But only send email if user actually exists
    if (user) {
      try {
        // Generate secure reset token
        const resetToken = randomBytes(32).toString('hex');
        const expiresAt = new Date(Date.now() + 60 * 60 * 1000); // 1 hour

        // Store reset token in database
        const { error: tokenError } = await supabase
          .from('password_reset_tokens')
          .upsert({
            user_id: user.id,
            email: normalizedEmail,
            token: resetToken,
            expires_at: expiresAt.toISOString(),
            used: false,
            created_at: new Date().toISOString(),
            ip_address: getClientIP(request),
            user_agent: request.headers.get('user-agent')
          });

        if (tokenError) {
          console.error('Error storing reset token:', tokenError);
          throw new Error('Failed to generate reset token');
        }

        // Send password reset email
        const resetUrl = `${process.env.NEXT_PUBLIC_APP_URL}/auth/reset-password?token=${resetToken}`;
        
        await emailServiceConnector.sendEmail({
          template_id: 'password_reset',
          recipient: {
            email: normalizedEmail,
            name: user.name || 'User'
          },
          variables: {
            user_name: user.name || 'there',
            user_email: normalizedEmail,
            reset_url: resetUrl,
            expires_in: '1 hour',
            ip_address: getClientIP(request) || 'Unknown',
            user_agent: request.headers.get('user-agent') || 'Unknown',
            support_email: process.env.SUPPORT_EMAIL || 'support@wedsync.co',
            timestamp: new Date().toLocaleString()
          },
          priority: 'high',
          track_opens: false, // Don't track opens for security emails
          track_clicks: false // Don't track clicks for security emails
        });

        // Log password reset attempt
        await supabase
          .from('security_events')
          .insert({
            event_type: 'password_reset_requested',
            user_id: user.id,
            ip_address: getClientIP(request),
            user_agent: request.headers.get('user-agent'),
            event_data: {
              email: normalizedEmail,
              timestamp: new Date().toISOString()
            }
          });

        console.log(`Password reset email sent to: ${normalizedEmail}`);

      } catch (emailError) {
        console.error('Error sending password reset email:', emailError);
        // Don't reveal the error to prevent information disclosure
      }
    }

    // Always return success response (security best practice)
    return NextResponse.json({
      message: 'If your email address is registered, you will receive a password reset link shortly.',
      sent: true
    });

  } catch (error) {
    console.error('Forgot password API error:', error);
    return NextResponse.json(
      { error: 'Internal server error. Please try again later.' },
      { status: 500 }
    );
  }
}

/**
 * Validate email format
 */
function isValidEmail(email: string): boolean {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}

/**
 * Get client IP address
 */
function getClientIP(request: NextRequest): string | null {
  const xForwardedFor = request.headers.get('x-forwarded-for');
  const xRealIp = request.headers.get('x-real-ip');
  
  if (xForwardedFor) {
    return xForwardedFor.split(',')[0].trim();
  }
  
  if (xRealIp) {
    return xRealIp;
  }
  
  return request.ip || null;
}

// Handle OPTIONS request for CORS
export async function OPTIONS() {
  return new NextResponse(null, {
    status: 200,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    },
  });
}