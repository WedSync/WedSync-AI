import { NextRequest, NextResponse } from 'next/server';
import { supabase } from '@/lib/supabase/server';
import { logger } from '@/lib/logger';
import { headers } from 'next/headers';
import { z } from 'zod';

const installCompleteSchema = z.object({
  event_type: z.enum(['installation_started', 'installation_completed', 'installation_failed']),
  user_id: z.string().uuid().optional(),
  session_id: z.string().min(1),
  installation_method: z.enum(['browser_prompt', 'manual_menu', 'share_menu', 'other']).optional(),
  device_info: z.object({
    platform: z.string().optional().transform(val => val ? sanitizePlatform(val) : null),
    viewport_width: z.number().optional(),
    viewport_height: z.number().optional(),
    is_standalone: z.boolean().optional(),
    supports_web_share: z.boolean().optional(),
    supports_notifications: z.boolean().optional(),
    storage_quota_mb: z.number().optional(),
    connection_speed: z.enum(['slow', 'medium', 'fast', 'unknown']).optional()
  }).optional(),
  installation_context: z.object({
    page_url: z.string().transform(val => sanitizeUrl(val)),
    referrer: z.string().optional().transform(val => val ? sanitizeUrl(val) : null),
    time_on_page_seconds: z.number().optional(),
    interactions_before_install: z.number().optional(),
    from_offline_banner: z.boolean().optional()
  }).optional(),
  wedding_context: z.object({
    has_active_wedding: z.boolean().optional(),
    days_until_wedding: z.number().optional(),
    supplier_type: z.enum(['photographer', 'florist', 'caterer', 'venue', 'planner', 'other']).optional(),
    wedding_party_size: z.enum(['small', 'medium', 'large']).optional(),
    is_wedding_week: z.boolean().optional()
  }).optional(),
  performance_metrics: z.object({
    service_worker_ready_time: z.number().optional(),
    cache_initialization_time: z.number().optional(),
    first_load_time: z.number().optional(),
    critical_resources_cached: z.number().optional()
  }).optional()
});

function sanitizePlatform(platform: string): string {
  const allowed = ['web', 'ios', 'android', 'windows', 'macos', 'linux', 'other'];
  const normalized = platform.toLowerCase();
  return allowed.find(name => normalized.includes(name)) || 'other';
}

function sanitizeUrl(url: string): string {
  try {
    const urlObj = new URL(url);
    return `${urlObj.protocol}//${urlObj.host}${urlObj.pathname}`;
  } catch {
    return '/unknown';
  }
}

function sanitizeUserAgent(userAgent: string): string {
  return userAgent
    .replace(/\d+\.\d+\.\d+/g, 'x.x.x')
    .replace(/Chrome\/[\d\.]+/g, 'Chrome/x.x.x')
    .replace(/Safari\/[\d\.]+/g, 'Safari/x.x.x')
    .replace(/Firefox\/[\d\.]+/g, 'Firefox/x.x.x')
    .replace(/Edge\/[\d\.]+/g, 'Edge/x.x.x');
}

async function getClientInfo(request: NextRequest) {
  const headersList = await headers();
  const userAgent = headersList.get('user-agent') || '';
  const ip = headersList.get('x-forwarded-for') || 
             headersList.get('x-real-ip') || 
             'unknown';
  
  return {
    sanitized_user_agent: sanitizeUserAgent(userAgent),
    client_ip_hash: await hashIP(ip),
    timestamp: new Date().toISOString()
  };
}

async function hashIP(ip: string): Promise<string> {
  if (typeof crypto === 'undefined' || !crypto.subtle) {
    return 'hashed';
  }
  
  try {
    const encoder = new TextEncoder();
    const data = encoder.encode(ip + process.env.IP_HASH_SALT || 'wedsync-pwa-salt-2025');
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('').slice(0, 16);
  } catch {
    return 'hash_error';
  }
}

async function logInstallCompleteEvent(data: any, clientInfo: any) {
  try {
    const { error } = await supabase
      .from('pwa_installation_events')
      .insert({
        event_type: data.event_type,
        user_id: data.user_id,
        session_id: data.session_id,
        installation_method: data.installation_method,
        device_info: data.device_info,
        installation_context: data.installation_context,
        wedding_context: data.wedding_context,
        performance_metrics: data.performance_metrics,
        client_info: clientInfo,
        created_at: new Date().toISOString()
      });

    if (error) {
      logger.error('Failed to log PWA installation complete event', { error, data });
      return false;
    }

    logger.info('PWA installation complete event logged', {
      event_type: data.event_type,
      user_id: data.user_id ? 'present' : 'anonymous',
      session_id: data.session_id.slice(0, 8) + '...',
      installation_method: data.installation_method
    });

    // Update installation success metrics if completed
    if (data.event_type === 'installation_completed') {
      await updateInstallationMetrics(data.user_id, clientInfo);
    }

    return true;
  } catch (error) {
    logger.error('Exception logging PWA installation complete event', { error });
    return false;
  }
}

async function updateInstallationMetrics(userId?: string, clientInfo?: any) {
  try {
    const today = new Date().toISOString().split('T')[0];
    
    const { error } = await supabase
      .from('pwa_analytics_summary')
      .upsert({
        date: today,
        metric_type: 'installation_success',
        total_count: 1,
        updated_at: new Date().toISOString()
      }, {
        onConflict: 'date,metric_type',
        ignoreDuplicates: false
      });

    if (error) {
      logger.warn('Failed to update installation metrics', { error });
    }

    logger.info('Installation success metrics updated', { date: today });
  } catch (error) {
    logger.error('Exception updating installation metrics', { error });
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    
    const validation = installCompleteSchema.safeParse(body);
    if (!validation.success) {
      logger.warn('Invalid PWA installation complete data', { 
        errors: validation.error.errors,
        body 
      });
      
      return NextResponse.json({
        error: 'Invalid request data',
        details: validation.error.errors
      }, { status: 400 });
    }

    const data = validation.data;
    const clientInfo = await getClientInfo(request);

    const success = await logInstallCompleteEvent(data, clientInfo);
    
    if (!success) {
      return NextResponse.json({
        error: 'Failed to log event'
      }, { status: 500 });
    }

    return NextResponse.json({
      success: true,
      message: 'Installation complete event logged successfully'
    }, { 
      status: 201,
      headers: {
        'Cache-Control': 'no-cache, no-store, must-revalidate',
        'Pragma': 'no-cache',
        'Expires': '0'
      }
    });

  } catch (error) {
    logger.error('PWA installation complete API error', { error });
    
    return NextResponse.json({
      error: 'Internal server error'
    }, { status: 500 });
  }
}

export async function GET() {
  return NextResponse.json({
    error: 'Method not allowed'
  }, { status: 405 });
}