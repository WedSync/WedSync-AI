// WS-229 Admin Quick Actions - Webhook Processing API
// Handle webhook events and trigger admin actions

import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { adminNotificationService } from '@/lib/services/admin-notification-service';
import { Logger } from '@/lib/logging/Logger';
import { z } from 'zod';
import crypto from 'crypto';

const logger = new Logger('AdminWebhookProcessorAPI');

// Webhook event schema
const webhookEventSchema = z.object({
  source: z.string().min(1, 'Webhook source is required'),
  eventType: z.string().min(1, 'Event type is required'),
  eventId: z.string().optional(),
  payload: z.record(z.any()),
  signature: z.string().optional(),
  timestamp: z.string().datetime().optional(),
  retryCount: z.number().int().min(0).default(0)
});

interface WebhookProcessor {
  source: string;
  handler: (event: any) => Promise<{ success: boolean; result?: any; error?: string }>;
  validateSignature?: (payload: string, signature: string) => boolean;
  shouldNotifyAdmin?: (event: any) => boolean;
}

export class AdminWebhookProcessorService {
  private processors: Map<string, WebhookProcessor> = new Map();
  private supabase = createClient();

  constructor() {
    this.registerProcessors();
  }

  private registerProcessors() {
    // Stripe webhook processor
    this.processors.set('stripe', {
      source: 'stripe',
      handler: this.processStripeEvent.bind(this),
      validateSignature: this.validateStripeSignature.bind(this),
      shouldNotifyAdmin: (event) => [
        'payment_intent.payment_failed',
        'invoice.payment_failed',
        'customer.subscription.deleted',
        'charge.dispute.created'
      ].includes(event.type)
    });

    // Twilio webhook processor
    this.processors.set('twilio', {
      source: 'twilio',
      handler: this.processTwilioEvent.bind(this),
      validateSignature: this.validateTwilioSignature.bind(this),
      shouldNotifyAdmin: (event) => event.MessageStatus === 'failed' || event.MessageStatus === 'undelivered'
    });

    // Supabase webhook processor
    this.processors.set('supabase', {
      source: 'supabase',
      handler: this.processSupabaseEvent.bind(this),
      shouldNotifyAdmin: (event) => event.type === 'database_error' || event.type === 'auth_error'
    });

    // Google Calendar webhook processor
    this.processors.set('google_calendar', {
      source: 'google_calendar',
      handler: this.processGoogleCalendarEvent.bind(this),
      shouldNotifyAdmin: (event) => event.eventType === 'sync_failed'
    });

    // Tave CRM webhook processor
    this.processors.set('tave', {
      source: 'tave',
      handler: this.processTaveEvent.bind(this),
      shouldNotifyAdmin: (event) => event.type === 'sync_error' || event.type === 'api_limit_exceeded'
    });

    // System health webhook processor
    this.processors.set('system_health', {
      source: 'system_health',
      handler: this.processSystemHealthEvent.bind(this),
      shouldNotifyAdmin: (event) => event.severity === 'critical' || event.severity === 'high'
    });
  }

  // Main webhook processing method
  async processWebhook(
    source: string,
    eventData: any,
    signature?: string,
    rawPayload?: string
  ): Promise<{ success: boolean; webhookId: string; result?: any; error?: string }> {
    const startTime = Date.now();

    try {
      // Get processor for this source
      const processor = this.processors.get(source);
      if (!processor) {
        throw new Error(`No processor registered for webhook source: ${source}`);
      }

      // Validate signature if required
      if (processor.validateSignature && signature && rawPayload) {
        const isValidSignature = processor.validateSignature(rawPayload, signature);
        if (!isValidSignature) {
          throw new Error('Invalid webhook signature');
        }
      }

      // Create webhook event record
      const webhookEvent = await this.createWebhookRecord({
        webhookSource: source,
        eventType: eventData.type || eventData.eventType || 'unknown',
        eventId: eventData.id || eventData.eventId,
        rawPayload: eventData,
        headers: signature ? { signature } : undefined,
        signatureValid: !processor.validateSignature || !!signature,
        timestampValid: true,
        payloadValid: true
      });

      if (!webhookEvent?.id) {
        throw new Error('Failed to create webhook record');
      }

      // Update processing status
      await this.updateWebhookStatus(webhookEvent.id, 'processing', {
        processingStartedAt: new Date().toISOString(),
        handlerFunction: processor.handler.name
      });

      // Process the webhook
      const processingResult = await processor.handler(eventData);

      if (!processingResult.success) {
        await this.updateWebhookStatus(webhookEvent.id, 'failed', {
          errorMessage: processingResult.error,
          processingCompletedAt: new Date().toISOString(),
          processingDurationMs: Date.now() - startTime
        });

        // Send admin notification if this should notify admin
        if (processor.shouldNotifyAdmin?.(eventData)) {
          await this.sendWebhookFailureNotification(source, eventData, processingResult.error);
        }

        return {
          success: false,
          webhookId: webhookEvent.id,
          error: processingResult.error
        };
      }

      // Update success status
      await this.updateWebhookStatus(webhookEvent.id, 'completed', {
        resultData: processingResult.result,
        processingCompletedAt: new Date().toISOString(),
        processingDurationMs: Date.now() - startTime
      });

      // Send admin notification if this should notify admin
      if (processor.shouldNotifyAdmin?.(eventData)) {
        await this.sendWebhookSuccessNotification(source, eventData, processingResult.result);
      }

      logger.info('Webhook processed successfully', {
        source,
        eventType: eventData.type || eventData.eventType,
        webhookId: webhookEvent.id,
        duration: Date.now() - startTime
      });

      return {
        success: true,
        webhookId: webhookEvent.id,
        result: processingResult.result
      };

    } catch (error) {
      logger.error('Webhook processing failed', error, {
        source,
        eventType: eventData.type || eventData.eventType,
        duration: Date.now() - startTime
      });

      // Send critical failure notification
      await this.sendWebhookFailureNotification(source, eventData, error instanceof Error ? error.message : 'Unknown error');

      return {
        success: false,
        webhookId: '',
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  // Stripe event processor
  private async processStripeEvent(event: any): Promise<{ success: boolean; result?: any; error?: string }> {
    try {
      logger.info('Processing Stripe webhook', { eventType: event.type, eventId: event.id });

      switch (event.type) {
        case 'payment_intent.payment_failed':
          return await this.handleStripePaymentFailure(event);
        
        case 'invoice.payment_failed':
          return await this.handleStripeInvoiceFailure(event);
        
        case 'customer.subscription.deleted':
          return await this.handleStripeSubscriptionCanceled(event);
        
        case 'charge.dispute.created':
          return await this.handleStripeDispute(event);
        
        default:
          return { success: true, result: { message: 'Event acknowledged but not processed' } };
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Stripe processing error'
      };
    }
  }

  // Twilio event processor
  private async processTwilioEvent(event: any): Promise<{ success: boolean; result?: any; error?: string }> {
    try {
      logger.info('Processing Twilio webhook', { messageStatus: event.MessageStatus, messageSid: event.MessageSid });

      // Update notification delivery status
      if (event.MessageSid && event.notificationId) {
        await this.supabase
          .from('admin_notifications')
          .update({
            sms_status: event.MessageStatus,
            updated_at: new Date().toISOString()
          })
          .eq('id', event.notificationId);
      }

      return { success: true, result: { messageStatus: event.MessageStatus } };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Twilio processing error'
      };
    }
  }

  // Supabase event processor
  private async processSupabaseEvent(event: any): Promise<{ success: boolean; result?: any; error?: string }> {
    try {
      logger.info('Processing Supabase webhook', { eventType: event.type });

      switch (event.type) {
        case 'database_error':
          return await this.handleSupabaseDatabaseError(event);
        
        case 'auth_error':
          return await this.handleSupabaseAuthError(event);
        
        default:
          return { success: true, result: { message: 'Supabase event acknowledged' } };
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Supabase processing error'
      };
    }
  }

  // Google Calendar event processor
  private async processGoogleCalendarEvent(event: any): Promise<{ success: boolean; result?: any; error?: string }> {
    try {
      logger.info('Processing Google Calendar webhook', { eventType: event.eventType });

      if (event.eventType === 'sync_failed') {
        return await this.handleGoogleCalendarSyncFailure(event);
      }

      return { success: true, result: { message: 'Calendar event processed' } };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Google Calendar processing error'
      };
    }
  }

  // Tave CRM event processor
  private async processTaveEvent(event: any): Promise<{ success: boolean; result?: any; error?: string }> {
    try {
      logger.info('Processing Tave webhook', { eventType: event.type });

      switch (event.type) {
        case 'sync_error':
          return await this.handleTaveSyncError(event);
        
        case 'api_limit_exceeded':
          return await this.handleTaveApiLimitExceeded(event);
        
        default:
          return { success: true, result: { message: 'Tave event processed' } };
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Tave processing error'
      };
    }
  }

  // System health event processor
  private async processSystemHealthEvent(event: any): Promise<{ success: boolean; result?: any; error?: string }> {
    try {
      logger.info('Processing system health event', { severity: event.severity, component: event.component });

      if (event.severity === 'critical') {
        return await this.handleCriticalSystemEvent(event);
      }

      return { success: true, result: { message: 'Health event processed' } };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'System health processing error'
      };
    }
  }

  // Helper methods for specific event handling
  private async handleStripePaymentFailure(event: any): Promise<{ success: boolean; result?: any; error?: string }> {
    // Implementation for handling payment failures
    // This would typically involve notifying the customer and admin
    return { success: true, result: { action: 'payment_failure_handled' } };
  }

  private async handleStripeInvoiceFailure(event: any): Promise<{ success: boolean; result?: any; error?: string }> {
    // Implementation for handling invoice failures
    return { success: true, result: { action: 'invoice_failure_handled' } };
  }

  private async handleStripeSubscriptionCanceled(event: any): Promise<{ success: boolean; result?: any; error?: string }> {
    // Implementation for handling subscription cancellations
    return { success: true, result: { action: 'subscription_canceled_handled' } };
  }

  private async handleStripeDispute(event: any): Promise<{ success: boolean; result?: any; error?: string }> {
    // Implementation for handling payment disputes
    return { success: true, result: { action: 'dispute_handled' } };
  }

  private async handleSupabaseDatabaseError(event: any): Promise<{ success: boolean; result?: any; error?: string }> {
    // Implementation for handling database errors
    return { success: true, result: { action: 'database_error_handled' } };
  }

  private async handleSupabaseAuthError(event: any): Promise<{ success: boolean; result?: any; error?: string }> {
    // Implementation for handling auth errors
    return { success: true, result: { action: 'auth_error_handled' } };
  }

  private async handleGoogleCalendarSyncFailure(event: any): Promise<{ success: boolean; result?: any; error?: string }> {
    // Implementation for handling calendar sync failures
    return { success: true, result: { action: 'calendar_sync_failure_handled' } };
  }

  private async handleTaveSyncError(event: any): Promise<{ success: boolean; result?: any; error?: string }> {
    // Implementation for handling Tave sync errors
    return { success: true, result: { action: 'tave_sync_error_handled' } };
  }

  private async handleTaveApiLimitExceeded(event: any): Promise<{ success: boolean; result?: any; error?: string }> {
    // Implementation for handling API limit exceeded
    return { success: true, result: { action: 'api_limit_handled' } };
  }

  private async handleCriticalSystemEvent(event: any): Promise<{ success: boolean; result?: any; error?: string }> {
    // Implementation for handling critical system events
    return { success: true, result: { action: 'critical_system_event_handled' } };
  }

  // Signature validation methods
  private validateStripeSignature(payload: string, signature: string): boolean {
    try {
      const secret = process.env.STRIPE_WEBHOOK_SECRET;
      if (!secret) return false;

      const expectedSignature = crypto
        .createHmac('sha256', secret)
        .update(payload, 'utf8')
        .digest('hex');

      return crypto.timingSafeEqual(
        Buffer.from(signature.replace('sha256=', ''), 'hex'),
        Buffer.from(expectedSignature, 'hex')
      );
    } catch (error) {
      return false;
    }
  }

  private validateTwilioSignature(payload: string, signature: string): boolean {
    try {
      const secret = process.env.TWILIO_AUTH_TOKEN;
      if (!secret) return false;

      const expectedSignature = crypto
        .createHmac('sha1', secret)
        .update(payload, 'utf8')
        .digest('base64');

      return crypto.timingSafeEqual(
        Buffer.from(signature, 'base64'),
        Buffer.from(expectedSignature, 'base64')
      );
    } catch (error) {
      return false;
    }
  }

  // Database operations
  private async createWebhookRecord(data: any): Promise<any> {
    const { data: webhook, error } = await this.supabase
      .from('webhook_events')
      .insert({
        webhook_source: data.webhookSource,
        event_type: data.eventType,
        event_id: data.eventId,
        raw_payload: data.rawPayload,
        headers: data.headers,
        signature_valid: data.signatureValid,
        timestamp_valid: data.timestampValid,
        payload_valid: data.payloadValid,
        status: 'received'
      })
      .select()
      .single();

    if (error) throw error;
    return webhook;
  }

  private async updateWebhookStatus(webhookId: string, status: string, updates: any): Promise<void> {
    const { error } = await this.supabase
      .from('webhook_events')
      .update({
        status,
        ...updates,
        updated_at: new Date().toISOString()
      })
      .eq('id', webhookId);

    if (error) throw error;
  }

  // Notification methods
  private async sendWebhookFailureNotification(source: string, eventData: any, error: string): Promise<void> {
    // Get all admin users
    const { data: admins } = await this.supabase
      .from('user_profiles')
      .select('user_id')
      .in('role', ['admin', 'super_admin']);

    if (!admins?.length) return;

    for (const admin of admins) {
      await adminNotificationService.sendNotification({
        adminUserId: admin.user_id,
        title: `Webhook Processing Failed - ${source}`,
        message: `Failed to process webhook from ${source}: ${error}`,
        priority: 'high',
        type: 'integration_failure',
        data: {
          webhookSource: source,
          eventType: eventData.type || eventData.eventType,
          error
        }
      });
    }
  }

  private async sendWebhookSuccessNotification(source: string, eventData: any, result: any): Promise<void> {
    // Only send success notifications for critical events
    if (!['stripe', 'supabase'].includes(source)) return;

    const { data: admins } = await this.supabase
      .from('user_profiles')
      .select('user_id')
      .eq('role', 'super_admin');

    if (!admins?.length) return;

    for (const admin of admins) {
      await adminNotificationService.sendNotification({
        adminUserId: admin.user_id,
        title: `Critical Webhook Processed - ${source}`,
        message: `Successfully processed critical webhook from ${source}`,
        priority: 'normal',
        type: 'system_alert',
        data: {
          webhookSource: source,
          eventType: eventData.type || eventData.eventType,
          result
        }
      });
    }
  }
}

const webhookProcessor = new AdminWebhookProcessorService();

export async function POST(request: NextRequest) {
  const startTime = Date.now();
  
  try {
    // Get webhook source from URL parameters
    const url = new URL(request.url);
    const source = url.searchParams.get('source') || 'unknown';

    // Get signature from headers
    const signature = request.headers.get('signature') || 
                     request.headers.get('x-stripe-signature') || 
                     request.headers.get('x-twilio-signature');

    // Get raw payload
    const rawPayload = await request.text();
    let eventData;

    try {
      eventData = JSON.parse(rawPayload);
    } catch (error) {
      return NextResponse.json(
        { error: 'Invalid JSON payload', code: 'INVALID_PAYLOAD' },
        { status: 400 }
      );
    }

    // Validate the webhook event
    const validatedEvent = webhookEventSchema.parse({
      source,
      eventType: eventData.type || eventData.eventType || 'unknown',
      eventId: eventData.id || eventData.eventId,
      payload: eventData,
      signature,
      timestamp: new Date().toISOString()
    });

    // Process the webhook
    const result = await webhookProcessor.processWebhook(
      validatedEvent.source,
      validatedEvent.payload,
      validatedEvent.signature,
      rawPayload
    );

    const duration = Date.now() - startTime;

    logger.info('Webhook API request completed', {
      source: validatedEvent.source,
      eventType: validatedEvent.eventType,
      success: result.success,
      duration
    });

    if (result.success) {
      return NextResponse.json({
        success: true,
        webhookId: result.webhookId,
        result: result.result,
        duration
      });
    } else {
      return NextResponse.json(
        {
          error: 'Webhook processing failed',
          code: 'PROCESSING_FAILED',
          details: result.error,
          webhookId: result.webhookId
        },
        { status: 422 }
      );
    }

  } catch (error) {
    const duration = Date.now() - startTime;

    if (error instanceof z.ZodError) {
      return NextResponse.json(
        {
          error: 'Invalid webhook data',
          code: 'VALIDATION_ERROR',
          details: error.errors
        },
        { status: 400 }
      );
    }

    logger.error('Webhook API request failed', error, { duration });

    return NextResponse.json(
      {
        error: 'Internal server error',
        code: 'INTERNAL_ERROR',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}

export async function GET(request: NextRequest) {
  try {
    // Get authenticated user
    const supabase = createClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json(
        { error: 'Unauthorized', code: 'AUTH_REQUIRED' },
        { status: 401 }
      );
    }

    // Check if user has admin privileges
    const { data: profile } = await supabase
      .from('user_profiles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (!profile?.role || !['admin', 'super_admin'].includes(profile.role)) {
      return NextResponse.json(
        { error: 'Insufficient permissions', code: 'INSUFFICIENT_PERMISSIONS' },
        { status: 403 }
      );
    }

    // Get webhook event history
    const url = new URL(request.url);
    const source = url.searchParams.get('source');
    const status = url.searchParams.get('status');
    const limit = parseInt(url.searchParams.get('limit') || '50');
    const offset = parseInt(url.searchParams.get('offset') || '0');

    let query = supabase
      .from('webhook_events')
      .select('*')
      .order('created_at', { ascending: false })
      .range(offset, offset + limit - 1);

    if (source) {
      query = query.eq('webhook_source', source);
    }
    if (status) {
      query = query.eq('status', status);
    }

    const { data: webhooks, error } = await query;

    if (error) {
      throw new Error(`Failed to get webhook history: ${error.message}`);
    }

    return NextResponse.json({
      success: true,
      webhooks: webhooks || [],
      pagination: {
        limit,
        offset,
        count: webhooks?.length || 0
      }
    });

  } catch (error) {
    logger.error('Failed to get webhook history', error);

    return NextResponse.json(
      {
        error: 'Failed to get webhook history',
        code: 'GET_FAILED',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}