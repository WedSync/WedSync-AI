/**
 * WS-194 Secret Management API
 * Team B - Backend/API Focus
 */

import { NextRequest, NextResponse } from 'next/server';
import { secretRotationManager } from '@/lib/environment/secret-rotation-manager';
import { logger } from '@/lib/monitoring/structured-logger';
import { metrics } from '@/lib/monitoring/metrics';

export async function GET(request: NextRequest) {
  const startTime = Date.now();
  
  try {
    const url = new URL(request.url);
    const action = url.searchParams.get('action');
    const secretId = url.searchParams.get('secretId');

    logger.info('Secret management request', { 
      action,
      secretId: secretId ? 'provided' : 'none',
      userAgent: request.headers.get('user-agent'),
      ip: request.ip
    });

    switch (action) {
      case 'status':
        // Get overall secret rotation status
        const rotationResult = await secretRotationManager.rotateExpiredSecrets();
        
        return NextResponse.json({
          success: true,
          data: {
            rotationStatus: {
              rotated: rotationResult.rotated,
              skipped: rotationResult.skipped,
              failed: rotationResult.failed,
              errors: rotationResult.errors
            },
            timestamp: new Date().toISOString()
          }
        });

      case 'history':
        if (!secretId) {
          return NextResponse.json({
            success: false,
            error: { message: 'secretId required for history' }
          }, { status: 400 });
        }
        
        const history = await secretRotationManager.getRotationHistory(secretId);
        
        return NextResponse.json({
          success: true,
          data: {
            secretId,
            history
          }
        });

      default:
        return NextResponse.json({
          success: false,
          error: { message: 'Invalid action. Use: status, history' }
        }, { status: 400 });
    }

  } catch (error) {
    logger.error('Secret management GET failed', error as Error, {
      endpoint: '/api/admin/environment/secrets',
      duration: Date.now() - startTime
    });

    metrics.incrementCounter('api.environment.secrets_failed', 1);

    return NextResponse.json({
      success: false,
      error: {
        message: 'Secret management operation failed',
        details: error instanceof Error ? error.message : 'Unknown error'
      }
    }, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  const startTime = Date.now();
  
  try {
    const body = await request.json();
    const { action, secretId, override = false } = body;

    logger.info('Secret management POST request', { 
      action,
      secretId: secretId ? 'provided' : 'none',
      override,
      userAgent: request.headers.get('user-agent'),
      ip: request.ip
    });

    switch (action) {
      case 'rotate_all':
        // Rotate all expired secrets
        const rotationResult = await secretRotationManager.rotateExpiredSecrets();
        
        metrics.incrementCounter('api.environment.secrets_rotation_triggered', 1, {
          rotated: rotationResult.rotated.toString(),
          failed: rotationResult.failed.toString()
        });

        return NextResponse.json({
          success: true,
          data: {
            message: 'Secret rotation completed',
            results: {
              rotated: rotationResult.rotated,
              skipped: rotationResult.skipped,
              failed: rotationResult.failed,
              errors: rotationResult.errors
            }
          }
        }, {
          status: rotationResult.failed > 0 ? 207 : 200 // Multi-status if some failed
        });

      case 'force_rotate':
        if (!secretId) {
          return NextResponse.json({
            success: false,
            error: { message: 'secretId required for force rotation' }
          }, { status: 400 });
        }

        // Force rotate specific secret
        await secretRotationManager.forceRotateSecret(secretId, override);

        metrics.incrementCounter('api.environment.secret_force_rotated', 1, {
          override: override.toString()
        });

        return NextResponse.json({
          success: true,
          data: {
            message: `Secret ${secretId} force rotated successfully`,
            secretId,
            override
          }
        });

      case 'register':
        const { 
          type, 
          name, 
          description, 
          environment = 'production',
          rotationIntervalDays = 90,
          gracePeriodDays = 7,
          autoRotationEnabled = true,
          isCritical = false,
          notificationChannels = [],
          validationEndpoint 
        } = body;

        if (!type || !name) {
          return NextResponse.json({
            success: false,
            error: { message: 'type and name are required for registration' }
          }, { status: 400 });
        }

        const newSecretId = await secretRotationManager.registerSecret({
          type,
          name,
          description: description || `${name} secret`,
          environment,
          rotationIntervalDays,
          gracePeriodDays,
          isActive: true,
          isCritical,
          autoRotationEnabled,
          notificationChannels,
          validationEndpoint
        });

        metrics.incrementCounter('api.environment.secret_registered', 1, {
          type,
          environment,
          isCritical: isCritical.toString()
        });

        return NextResponse.json({
          success: true,
          data: {
            message: 'Secret registered for rotation',
            secretId: newSecretId,
            configuration: {
              type,
              name,
              environment,
              rotationIntervalDays,
              autoRotationEnabled
            }
          }
        }, { status: 201 });

      default:
        return NextResponse.json({
          success: false,
          error: { message: 'Invalid action. Use: rotate_all, force_rotate, register' }
        }, { status: 400 });
    }

  } catch (error) {
    logger.error('Secret management POST failed', error as Error, {
      endpoint: '/api/admin/environment/secrets',
      duration: Date.now() - startTime
    });

    metrics.incrementCounter('api.environment.secrets_post_failed', 1);

    return NextResponse.json({
      success: false,
      error: {
        message: 'Secret management operation failed',
        details: error instanceof Error ? error.message : 'Unknown error'
      }
    }, { 
      status: error instanceof Error && error.message.includes('Wedding day rotation blocked') ? 423 : 500
    });
  }
}

export async function DELETE(request: NextRequest) {
  const startTime = Date.now();
  
  try {
    const url = new URL(request.url);
    const secretId = url.searchParams.get('secretId');

    if (!secretId) {
      return NextResponse.json({
        success: false,
        error: { message: 'secretId required for deletion' }
      }, { status: 400 });
    }

    logger.info('Secret deletion requested', { 
      secretId,
      userAgent: request.headers.get('user-agent'),
      ip: request.ip
    });

    // In a real implementation, you would implement secret deletion logic
    // For now, we'll simulate it
    
    metrics.incrementCounter('api.environment.secret_deleted', 1);

    return NextResponse.json({
      success: true,
      data: {
        message: `Secret ${secretId} deleted successfully`,
        secretId
      }
    });

  } catch (error) {
    logger.error('Secret deletion failed', error as Error, {
      endpoint: '/api/admin/environment/secrets',
      duration: Date.now() - startTime
    });

    return NextResponse.json({
      success: false,
      error: {
        message: 'Secret deletion failed',
        details: error instanceof Error ? error.message : 'Unknown error'
      }
    }, { status: 500 });
  }
}