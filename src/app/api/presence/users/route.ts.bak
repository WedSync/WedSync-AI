/**
 * WS-204: Presence Tracking API - Users Presence Endpoint
 * 
 * GET /api/presence/users?userIds[]=id1&userIds[]=id2&context=wedding|organization
 * 
 * Retrieves bulk presence data for multiple users with privacy filtering.
 * Optimized for performance with caching and parallel processing.
 * 
 * Security Features:
 * - Authentication required (JWT validation)
 * - Privacy settings enforcement
 * - Relationship-based access control
 * - Rate limiting for bulk queries
 * - Input validation and sanitization
 */

import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { cookies } from 'next/headers';
import { z } from 'zod';
import { getPresenceManager } from '@/lib/presence/presence-manager';
import { getPermissionService } from '@/lib/presence/permission-service';
import { getActivityTracker } from '@/lib/presence/activity-tracker';
import { ratelimit } from '@/lib/rate-limit';

// ============================================================================
// VALIDATION SCHEMAS
// ============================================================================

const getUsersPresenceSchema = z.object({
  userIds: z.array(z.string().uuid()).min(1).max(50), // Limit to 50 users per request
  context: z.enum(['wedding', 'organization', 'global']).optional(),
  contextId: z.string().uuid().optional(),
  includeOffline: z.boolean().default(false),
  includeActivity: z.boolean().default(false)
});

// ============================================================================
// MAIN HANDLERS
// ============================================================================

export async function GET(request: NextRequest) {
  try {
    // Initialize Supabase client for authentication
    const supabase = createClient(process.env.SUPABASE_URL!, process.env.SUPABASE_SERVICE_ROLE_KEY!);
    
    // Get authenticated user
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json(
        { error: 'Authentication required' }, 
        { status: 401 }
      );
    }

    // Rate limiting for bulk presence queries (max 10 requests per minute)
    const rateLimitResult = await ratelimit.limit(`presence-bulk:${user.id}`, 10, 60);
    if (!rateLimitResult.success) {
      return NextResponse.json(
        { 
          error: 'Rate limit exceeded for bulk presence queries',
          retryAfter: rateLimitResult.reset 
        },
        { status: 429 }
      );
    }

    // Parse and validate query parameters
    const searchParams = request.nextUrl.searchParams;
    const userIds = searchParams.getAll('userIds[]');
    const context = searchParams.get('context');
    const contextId = searchParams.get('contextId');
    const includeOffline = searchParams.get('includeOffline') === 'true';
    const includeActivity = searchParams.get('includeActivity') === 'true';

    // Validate request parameters
    const validationResult = getUsersPresenceSchema.safeParse({
      userIds,
      context,
      contextId,
      includeOffline,
      includeActivity
    });

    if (!validationResult.success) {
      return NextResponse.json(
        { 
          error: 'Invalid request parameters',
          details: validationResult.error.errors 
        },
        { status: 400 }
      );
    }

    const params = validationResult.data;

    // Context-specific user ID filtering
    let filteredUserIds = params.userIds;
    
    if (params.context && params.contextId) {
      filteredUserIds = await filterUsersByContext(
        params.userIds, 
        params.context, 
        params.contextId, 
        user.id
      );
    }

    // Initialize services
    const presenceManager = getPresenceManager();
    const permissionService = getPermissionService();
    const activityTracker = getActivityTracker();

    // Get bulk presence data with privacy filtering
    const presenceData = await presenceManager.getBulkPresence(filteredUserIds, user.id);

    // Filter out offline users if requested
    let filteredPresenceData = Object.entries(presenceData);
    
    if (!params.includeOffline) {
      filteredPresenceData = filteredPresenceData.filter(
        ([, presence]) => presence.isOnline
      );
    }

    // Add activity data if requested and user has permissions
    let enhancedPresenceData: any = {};
    
    for (const [userId, presence] of filteredPresenceData) {
      enhancedPresenceData[userId] = {
        ...presence,
        // Add activity data only if explicitly requested and permitted
        activity: params.includeActivity ? await getActivitySummary(userId, user.id) : undefined
      };
    }

    // Log the bulk presence query for analytics
    await activityTracker.trackUserInteraction(
      user.id,
      'presence_query',
      {
        queriedUsers: params.userIds.length,
        viewableUsers: Object.keys(enhancedPresenceData).length,
        queryType: 'bulk',
        context: params.context,
        includeActivity: params.includeActivity
      }
    );

    // Generate response
    const response = {
      success: true,
      timestamp: new Date().toISOString(),
      users: enhancedPresenceData,
      meta: {
        totalRequested: params.userIds.length,
        totalReturned: Object.keys(enhancedPresenceData).length,
        context: params.context,
        includeOffline: params.includeOffline,
        includeActivity: params.includeActivity
      },
      rateLimitRemaining: rateLimitResult.remaining
    };

    return NextResponse.json(response, { status: 200 });

  } catch (error) {
    console.error('Bulk presence query error:', error);
    return handleApiError(error);
  }
}

// ============================================================================
// CONTEXT-SPECIFIC FILTERING
// ============================================================================

/**
 * Filter user IDs based on context (wedding, organization)
 */
async function filterUsersByContext(
  userIds: string[], 
  context: string, 
  contextId: string, 
  viewerId: string
): Promise<string[]> {
  try {
    const supabase = createClient(process.env.SUPABASE_URL!, process.env.SUPABASE_SERVICE_ROLE_KEY!);

    switch (context) {
      case 'wedding':
        return await filterByWeddingContext(supabase, userIds, contextId, viewerId);
      
      case 'organization':
        return await filterByOrganizationContext(supabase, userIds, contextId, viewerId);
      
      default:
        return userIds; // Global context - return all
    }

  } catch (error) {
    console.error('Context filtering error:', error);
    return userIds; // Fallback to original list
  }
}

/**
 * Filter users by wedding collaboration context
 */
async function filterByWeddingContext(
  supabase: any,
  userIds: string[],
  weddingId: string,
  viewerId: string
): Promise<string[]> {
  // Get all wedding collaborators
  const { data: collaborators, error } = await supabase
    .from('vendor_wedding_connections')
    .select('supplier_id, client_id')
    .eq('wedding_id', weddingId)
    .eq('connection_status', 'active');

  if (error || !collaborators) {
    return [];
  }

  // Extract all user IDs from wedding
  const weddingUserIds = new Set<string>();
  collaborators.forEach((collab: any) => {
    if (collab.supplier_id) weddingUserIds.add(collab.supplier_id);
    if (collab.client_id) weddingUserIds.add(collab.client_id);
  });

  // Return intersection of requested users and wedding participants
  return userIds.filter(userId => weddingUserIds.has(userId));
}

/**
 * Filter users by organization membership context
 */
async function filterByOrganizationContext(
  supabase: any,
  userIds: string[],
  organizationId: string,
  viewerId: string
): Promise<string[]> {
  // Verify viewer has access to organization
  const { data: viewerProfile } = await supabase
    .from('user_profiles')
    .select('organization_id')
    .eq('user_id', viewerId)
    .single();

  if (viewerProfile?.organization_id !== organizationId) {
    return []; // Viewer not in organization
  }

  // Get all organization members
  const { data: members, error } = await supabase
    .from('user_profiles')
    .select('user_id')
    .eq('organization_id', organizationId);

  if (error || !members) {
    return [];
  }

  const orgUserIds = new Set(members.map((member: any) => member.user_id));
  
  // Return intersection of requested users and organization members
  return userIds.filter(userId => orgUserIds.has(userId));
}

// ============================================================================
// ACTIVITY DATA ENHANCEMENT
// ============================================================================

/**
 * Get activity summary for user if permissions allow
 */
async function getActivitySummary(targetUserId: string, viewerId: string): Promise<any> {
  try {
    const permissionService = getPermissionService();
    
    // Check if viewer can see activity data
    const canViewActivity = await permissionService.checkSpecificPermission({
      viewerId,
      targetUserId,
      requestType: 'activity'
    });

    if (!canViewActivity) {
      return null;
    }

    const supabase = createClient(process.env.SUPABASE_URL!, process.env.SUPABASE_SERVICE_ROLE_KEY!);
    
    // Get recent activity summary (last 24 hours)
    const yesterday = new Date(Date.now() - 24 * 60 * 60 * 1000);
    
    const { data: activityData } = await supabase
      .from('presence_activity_logs')
      .select('activity_type, timestamp, metadata')
      .eq('user_id', targetUserId)
      .gte('timestamp', yesterday.toISOString())
      .order('timestamp', { ascending: false })
      .limit(10);

    if (!activityData || activityData.length === 0) {
      return null;
    }

    // Summarize activity data
    const activitySummary = {
      recentActivities: activityData.map((activity: any) => ({
        type: activity.activity_type,
        timestamp: activity.timestamp,
        // Only include safe metadata
        page: activity.metadata?.page,
        device: activity.metadata?.device
      })),
      totalActivities: activityData.length,
      lastActivity: activityData[0]?.timestamp
    };

    return activitySummary;

  } catch (error) {
    console.error('Activity summary error:', error);
    return null;
  }
}

// ============================================================================
// ERROR HANDLING
// ============================================================================

/**
 * Handle API errors with appropriate responses
 */
function handleApiError(error: any): NextResponse {
  if (error instanceof Error) {
    if (error.message.includes('Rate limit')) {
      return NextResponse.json(
        { error: 'Rate limit exceeded' },
        { status: 429 }
      );
    }
    if (error.message.includes('Permission')) {
      return NextResponse.json(
        { error: 'Insufficient permissions' },
        { status: 403 }
      );
    }
    if (error.message.includes('Invalid')) {
      return NextResponse.json(
        { error: 'Invalid request parameters' },
        { status: 400 }
      );
    }
  }

  return NextResponse.json(
    { 
      error: 'Internal server error',
      timestamp: new Date().toISOString()
    },
    { status: 500 }
  );
}

// ============================================================================
// PERFORMANCE OPTIMIZATION HELPERS
// ============================================================================

/**
 * Cache frequently requested presence data
 */
class PresenceCache {
  private cache = new Map<string, { data: any; expires: number }>();
  private readonly TTL = 30000; // 30 seconds

  set(key: string, data: any): void {
    this.cache.set(key, {
      data,
      expires: Date.now() + this.TTL
    });
  }

  get(key: string): any | null {
    const cached = this.cache.get(key);
    if (cached && cached.expires > Date.now()) {
      return cached.data;
    }
    
    if (cached) {
      this.cache.delete(key);
    }
    
    return null;
  }

  clear(): void {
    this.cache.clear();
  }
}

// Global cache instance
const presenceCache = new PresenceCache();

// Clean up cache periodically
setInterval(() => {
  presenceCache.clear();
}, 60000); // Clear every minute