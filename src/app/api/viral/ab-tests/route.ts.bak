import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { ConversionOptimizer } from '@/lib/services/conversion-optimizer';
import { z } from 'zod';

const TestFiltersSchema = z.object({
  status: z.enum(['draft', 'running', 'completed', 'paused']).optional(),
  test_type: z.enum(['template', 'timing', 'channel', 'subject']).optional(),
  page: z.string().transform(Number).optional(),
  limit: z.string().transform(Number).optional()
});

/**
 * GET /api/viral/ab-tests
 * Get A/B tests with optional filtering
 */
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient();
    
    // Check authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json(
        { error: 'Authentication required', code: 'AUTH_REQUIRED' },
        { status: 401 }
      );
    }

    const url = new URL(request.url);
    const filters = {
      status: url.searchParams.get('status'),
      test_type: url.searchParams.get('test_type'),
      page: url.searchParams.get('page') || '1',
      limit: url.searchParams.get('limit') || '20'
    };

    const validatedFilters = TestFiltersSchema.parse(filters);

    // Build query
    let query = supabase
      .from('viral_ab_tests')
      .select(`
        *,
        viral_ab_test_variants (
          id,
          name,
          variant_key,
          traffic_allocation,
          configuration,
          is_control
        )
      `, { count: 'exact' })
      .eq('created_by', user.id);

    // Apply filters
    if (validatedFilters.status) {
      query = query.eq('status', validatedFilters.status);
    }

    if (validatedFilters.test_type) {
      query = query.eq('test_type', validatedFilters.test_type);
    }

    // Apply pagination
    const page = validatedFilters.page || 1;
    const limit = Math.min(validatedFilters.limit || 20, 100);
    const offset = (page - 1) * limit;

    query = query
      .order('created_at', { ascending: false })
      .range(offset, offset + limit - 1);

    const { data, error, count } = await query;

    if (error) throw error;

    const totalPages = Math.ceil((count || 0) / limit);

    return NextResponse.json({
      success: true,
      data: data || [],
      pagination: {
        page,
        limit,
        total: count || 0,
        total_pages: totalPages,
        has_next: page < totalPages,
        has_previous: page > 1
      },
      metadata: {
        user_id: user.id,
        filters: validatedFilters
      }
    });

  } catch (error) {
    console.error('Get A/B tests error:', error);
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { 
          error: 'Invalid query parameters', 
          code: 'VALIDATION_ERROR',
          details: error.errors 
        },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { 
        error: 'Failed to retrieve A/B tests',
        code: 'FETCH_ERROR'
      },
      { status: 500 }
    );
  }
}

const UpdateTestSchema = z.object({
  test_ids: z.array(z.string().uuid()),
  updates: z.object({
    status: z.enum(['draft', 'running', 'completed', 'paused']).optional(),
    end_date: z.string().datetime().optional(),
    minimum_sample_size: z.number().min(10).max(10000).optional()
  })
});

/**
 * PUT /api/viral/ab-tests
 * Update A/B test status or configuration
 */
export async function PUT(request: NextRequest) {
  try {
    const supabase = await createClient();
    
    // Check authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json(
        { error: 'Authentication required', code: 'AUTH_REQUIRED' },
        { status: 401 }
      );
    }

    const body = await request.json();
    const validatedData = UpdateTestSchema.parse(body);

    const updateData = {
      ...validatedData.updates,
      updated_at: new Date().toISOString()
    };

    const { data, error } = await supabase
      .from('viral_ab_tests')
      .update(updateData)
      .in('id', validatedData.test_ids)
      .eq('created_by', user.id)
      .select();

    if (error) throw error;

    return NextResponse.json({
      success: true,
      data: {
        updated_tests: data || [],
        updated_count: data?.length || 0
      },
      message: `${data?.length || 0} A/B tests updated successfully`
    });

  } catch (error) {
    console.error('Update A/B tests error:', error);
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { 
          error: 'Invalid update data', 
          code: 'VALIDATION_ERROR',
          details: error.errors 
        },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { 
        error: 'Failed to update A/B tests',
        code: 'UPDATE_ERROR'
      },
      { status: 500 }
    );
  }
}

const DeleteTestsSchema = z.object({
  test_ids: z.array(z.string().uuid()).min(1).max(50)
});

/**
 * DELETE /api/viral/ab-tests
 * Delete A/B tests (soft delete)
 */
export async function DELETE(request: NextRequest) {
  try {
    const supabase = await createClient();
    
    // Check authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json(
        { error: 'Authentication required', code: 'AUTH_REQUIRED' },
        { status: 401 }
      );
    }

    const body = await request.json();
    const validatedData = DeleteTestsSchema.parse(body);

    // Soft delete by updating status to 'deleted'
    const { data, error } = await supabase
      .from('viral_ab_tests')
      .update({
        status: 'deleted',
        deleted_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      })
      .in('id', validatedData.test_ids)
      .eq('created_by', user.id)
      .select('id, name');

    if (error) throw error;

    return NextResponse.json({
      success: true,
      data: {
        deleted_tests: data || [],
        deleted_count: data?.length || 0
      },
      message: `${data?.length || 0} A/B tests deleted successfully`
    });

  } catch (error) {
    console.error('Delete A/B tests error:', error);
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { 
          error: 'Invalid delete request', 
          code: 'VALIDATION_ERROR',
          details: error.errors 
        },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { 
        error: 'Failed to delete A/B tests',
        code: 'DELETE_ERROR'
      },
      { status: 500 }
    );
  }
}