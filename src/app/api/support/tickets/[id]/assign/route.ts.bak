import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { z } from 'zod';

// Validation schema
const AssignTicketSchema = z.object({
  assigned_to: z.string().uuid('Invalid agent ID').optional(),
  assigned_team: z.string().optional(),
  reason: z.string().optional(),
  priority_change: z.enum(['low', 'medium', 'high', 'critical']).optional(),
  auto_assign: z.boolean().default(false) // Auto-assign to best available agent
}).refine(data => data.assigned_to || data.assigned_team || data.auto_assign, {
  message: "Must specify assigned_to, assigned_team, or auto_assign"
});

// Find best available agent for auto-assignment
async function findBestAvailableAgent(supabase: any, ticket: any) {
  // Get category for skill matching
  let requiredSkills: string[] = [];
  if (ticket.category_id) {
    const { data: category } = await supabase
      .from('support_categories')
      .select('ai_keywords')
      .eq('id', ticket.category_id)
      .single();
      
    if (category && category.ai_keywords) {
      requiredSkills = category.ai_keywords;
    }
  }
  
  // Build agent query
  let agentQuery = supabase
    .from('support_agents')
    .select('*')
    .eq('status', 'active')
    .lt('current_ticket_count', supabase.rpc('max_concurrent_tickets'))
    .order('current_ticket_count', { ascending: true })
    .order('satisfaction_score', { ascending: false });
    
  // Prefer wedding specialists for wedding day issues
  if (ticket.is_wedding_day_issue) {
    agentQuery = agentQuery.eq('is_wedding_day_specialist', true);
  }
    
  const { data: agents, error } = await agentQuery.limit(5);
  
  if (error || !agents || agents.length === 0) {
    return null;
  }
  
  // Score agents based on skills match and availability
  const scoredAgents = agents.map(agent => {
    let score = 0;
    
    // Base score from performance metrics
    score += (agent.satisfaction_score || 3) * 10;
    score -= (agent.current_ticket_count || 0) * 5;
    score += Math.min((agent.avg_first_response_minutes || 240) / 60, 10); // Faster response = higher score
    
    // Skill matching bonus
    if (agent.skills && requiredSkills.length > 0) {
      const matchingSkills = agent.skills.filter((skill: string) => 
        requiredSkills.some(required => 
          skill.toLowerCase().includes(required.toLowerCase()) ||
          required.toLowerCase().includes(skill.toLowerCase())
        )
      );
      score += matchingSkills.length * 15;
    }
    
    // Wedding specialist bonus for wedding issues
    if (ticket.is_wedding_day_issue && agent.is_wedding_day_specialist) {
      score += 50;
    }
    
    // Priority boost for high-tier customers
    if (ticket.user_tier === 'enterprise') {
      score += 20;
    } else if (ticket.user_tier === 'scale') {
      score += 10;
    } else if (ticket.user_tier === 'professional') {
      score += 5;
    }
    
    return { ...agent, score };
  });
  
  // Return highest scoring agent
  scoredAgents.sort((a, b) => b.score - a.score);
  return scoredAgents[0];
}

export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const supabase = createClient();
    
    // Check authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    
    const ticketId = params.id;
    
    // Parse and validate request body
    const body = await request.json();
    const validatedData = AssignTicketSchema.parse(body);
    
    // Check if user has permission to assign tickets
    const { data: supportAgent } = await supabase
      .from('support_agents')
      .select('id, agent_name, team, skills')
      .eq('user_id', user.id)
      .single();
      
    const { data: userProfile } = await supabase
      .from('user_profiles')
      .select('role')
      .eq('user_id', user.id)
      .single();
    
    const canAssign = supportAgent || 
                     userProfile?.role === 'ADMIN' || 
                     userProfile?.role === 'OWNER';
    
    if (!canAssign) {
      return NextResponse.json({ 
        error: 'Insufficient permissions to assign tickets' 
      }, { status: 403 });
    }
    
    // Get current ticket
    const { data: ticket, error: ticketError } = await supabase
      .from('support_tickets')
      .select('*')
      .eq('id', ticketId)
      .single();
      
    if (ticketError || !ticket) {
      return NextResponse.json({ error: 'Ticket not found' }, { status: 404 });
    }
    
    // Handle auto-assignment
    let targetAgent = null;
    if (validatedData.auto_assign) {
      targetAgent = await findBestAvailableAgent(supabase, ticket);
      
      if (!targetAgent) {
        return NextResponse.json({ 
          error: 'No available agents found for auto-assignment' 
        }, { status: 400 });
      }
    } else if (validatedData.assigned_to) {
      // Validate specified agent exists and is available
      const { data: agent, error: agentError } = await supabase
        .from('support_agents')
        .select('*')
        .eq('id', validatedData.assigned_to)
        .single();
        
      if (agentError || !agent) {
        return NextResponse.json({ error: 'Agent not found' }, { status: 404 });
      }
      
      if (agent.status !== 'active') {
        return NextResponse.json({ 
          error: 'Agent is not currently available' 
        }, { status: 400 });
      }
      
      if (agent.current_ticket_count >= agent.max_concurrent_tickets) {
        return NextResponse.json({ 
          error: 'Agent has reached maximum ticket capacity' 
        }, { status: 400 });
      }
      
      targetAgent = agent;
    }
    
    // Prepare update data
    const updateData: any = {
      assigned_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };
    
    if (targetAgent) {
      updateData.assigned_to = targetAgent.id;
      updateData.assigned_team = targetAgent.team;
    } else if (validatedData.assigned_team) {
      updateData.assigned_team = validatedData.assigned_team;
      updateData.assigned_to = null; // Unassign from specific agent
    }
    
    // Update priority if specified
    if (validatedData.priority_change) {
      updateData.priority = validatedData.priority_change;
    }
    
    // Auto-change status when assigned
    if (ticket.status === 'open' || ticket.status === 'new') {
      updateData.status = 'assigned';
    }
    
    // If this is first assignment and no previous first response, mark as first response
    if (targetAgent && !ticket.first_response_at && !ticket.assigned_to) {
      updateData.first_response_at = new Date().toISOString();
      
      // Log SLA event
      await supabase
        .from('ticket_sla_events')
        .insert({
          ticket_id: ticketId,
          event_type: 'first_response',
          expected_at: ticket.sla_first_response_deadline,
          actual_at: new Date().toISOString(),
          minutes_to_target: Math.round((new Date().getTime() - new Date(ticket.sla_first_response_deadline).getTime()) / (1000 * 60)),
          agent_id: targetAgent.id
        });
    }
    
    // Update the ticket
    const { data: updatedTicket, error: updateError } = await supabase
      .from('support_tickets')
      .update(updateData)
      .eq('id', ticketId)
      .select(`
        *,
        support_categories (
          id,
          name,
          description,
          wedding_priority
        ),
        support_agents (
          id,
          agent_name,
          email,
          skills,
          team
        )
      `)
      .single();
      
    if (updateError) {
      console.error('Error assigning ticket:', updateError);
      return NextResponse.json({ error: 'Failed to assign ticket' }, { status: 500 });
    }
    
    // Log assignment activity
    const assignmentMessage = targetAgent 
      ? `Ticket assigned to ${targetAgent.agent_name}${validatedData.reason ? `: ${validatedData.reason}` : ''}`
      : `Ticket assigned to team: ${validatedData.assigned_team}${validatedData.reason ? `: ${validatedData.reason}` : ''}`;
      
    await supabase
      .from('ticket_messages')
      .insert({
        ticket_id: ticketId,
        sender_type: 'system',
        sender_id: user.id,
        sender_name: supportAgent?.agent_name || 'System',
        message: assignmentMessage,
        message_type: 'assignment',
        is_internal: true,
        is_automated: validatedData.auto_assign
      });
    
    // Send assignment notification to the assigned agent
    if (targetAgent) {
      // TODO: Send email notification to assigned agent
      // TODO: Send Slack/Teams notification if configured
      
      // Create notification record (if notifications table exists)
      try {
        await supabase
          .from('notifications')
          .insert({
            user_id: targetAgent.user_id,
            type: 'ticket_assigned',
            title: `New ticket assigned: ${ticket.subject}`,
            message: `Ticket ${ticketId} has been assigned to you. Priority: ${updateData.priority || ticket.priority}`,
            data: {
              ticket_id: ticketId,
              ticket_subject: ticket.subject,
              priority: updateData.priority || ticket.priority,
              is_wedding_day: ticket.is_wedding_day_issue,
              assigned_by: supportAgent?.agent_name || 'System'
            },
            is_read: false
          });
      } catch (notificationError) {
        console.log('Note: Notifications table not available, skipping notification');
      }
    }
    
    // Update agent workload counter (handled by trigger in database)
    
    return NextResponse.json({
      ticket: updatedTicket,
      assignment: {
        agent: targetAgent ? {
          id: targetAgent.id,
          name: targetAgent.agent_name,
          team: targetAgent.team,
          skills: targetAgent.skills
        } : null,
        team: updateData.assigned_team,
        method: validatedData.auto_assign ? 'auto' : 'manual',
        assigned_by: supportAgent?.agent_name || 'Admin',
        reason: validatedData.reason
      },
      message: 'Ticket assigned successfully'
    });
    
  } catch (error) {
    console.error('POST /api/support/tickets/[id]/assign error:', error);
    
    if (error instanceof z.ZodError) {
      return NextResponse.json({ 
        error: 'Invalid assignment data',
        details: error.errors 
      }, { status: 400 });
    }
    
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}