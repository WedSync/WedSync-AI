/**
 * Agent Metrics API
 * WS-235: Support Operations Ticket Management System
 * 
 * Provides performance metrics for support agents
 * Routes: GET /api/support/metrics/agents
 */

import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { cookies } from 'next/headers';

/**
 * GET /api/support/metrics/agents - Get agent performance metrics
 */
export async function GET(request: NextRequest) {
  try {
    const supabase = createServerComponentClient({ cookies });
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Verify user permissions (admin, manager, or support_agent)
    const { data: profile } = await supabase
      .from('user_profiles')
      .select('role')
      .eq('id', user.id)
      .single();

    if (!profile || !['admin', 'manager', 'support_agent'].includes(profile.role || '')) {
      return NextResponse.json({ error: 'Insufficient permissions' }, { status: 403 });
    }

    // Get time range from query parameters
    const { searchParams } = new URL(request.url);
    const range = searchParams.get('range') || '7d';

    // Calculate date range
    const endDate = new Date();
    const startDate = new Date();
    
    switch (range) {
      case '24h':
        startDate.setHours(startDate.getHours() - 24);
        break;
      case '7d':
        startDate.setDate(startDate.getDate() - 7);
        break;
      case '30d':
        startDate.setDate(startDate.getDate() - 30);
        break;
      case '90d':
        startDate.setDate(startDate.getDate() - 90);
        break;
      default:
        startDate.setDate(startDate.getDate() - 7);
    }

    // Get agent metrics using a complex query
    const { data: agentMetrics, error } = await supabase
      .rpc('get_agent_performance_metrics', {
        start_date: startDate.toISOString(),
        end_date: endDate.toISOString()
      });

    if (error) {
      console.error('Error fetching agent metrics:', error);
      return NextResponse.json({ error: 'Failed to fetch agent metrics' }, { status: 500 });
    }

    // If the stored procedure doesn't exist, fall back to manual calculation
    if (!agentMetrics) {
      const fallbackMetrics = await calculateAgentMetricsManually(supabase, startDate, endDate);
      return NextResponse.json({
        agents: fallbackMetrics,
        time_range: range,
        calculated_at: new Date().toISOString()
      });
    }

    return NextResponse.json({
      agents: agentMetrics,
      time_range: range,
      calculated_at: new Date().toISOString()
    });

  } catch (error) {
    console.error('GET /api/support/metrics/agents error:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

/**
 * Fallback manual calculation of agent metrics
 */
async function calculateAgentMetricsManually(supabase: any, startDate: Date, endDate: Date) {
  try {
    // Get all support agents
    const { data: agents } = await supabase
      .from('support_agents')
      .select(`
        id,
        name,
        email,
        status,
        shift_start,
        shift_end,
        specialties,
        performance_score
      `)
      .eq('is_active', true);

    if (!agents) return [];

    // Calculate metrics for each agent
    const agentMetrics = await Promise.all(
      agents.map(async (agent: any) => {
        // Get ticket assignments for this agent in the time range
        const { data: tickets } = await supabase
          .from('support_tickets')
          .select(`
            id,
            status,
            priority,
            category,
            created_at,
            resolved_at,
            first_response_at,
            customer_tier,
            is_wedding_emergency,
            ticket_sla_events!inner(
              event_type,
              event_time
            )
          `)
          .eq('assigned_to', agent.id)
          .gte('created_at', startDate.toISOString())
          .lte('created_at', endDate.toISOString());

        const assignedTickets = tickets || [];
        const resolvedTickets = assignedTickets.filter(t => t.status === 'resolved');
        const weddingEmergencies = assignedTickets.filter(t => t.is_wedding_emergency);

        // Calculate response times
        const responseTimes = assignedTickets
          .filter(t => t.first_response_at)
          .map(t => {
            const created = new Date(t.created_at).getTime();
            const responded = new Date(t.first_response_at).getTime();
            return (responded - created) / (1000 * 60); // minutes
          });

        // Calculate resolution times
        const resolutionTimes = resolvedTickets
          .filter(t => t.resolved_at)
          .map(t => {
            const created = new Date(t.created_at).getTime();
            const resolved = new Date(t.resolved_at).getTime();
            return (resolved - created) / (1000 * 60); // minutes
          });

        // Get template usage count
        const { count: templateUsage } = await supabase
          .from('template_usage')
          .select('id', { count: 'exact' })
          .eq('used_by', agent.id)
          .gte('used_at', startDate.toISOString())
          .lte('used_at', endDate.toISOString());

        // Get escalations received
        const { count: escalations } = await supabase
          .from('ticket_escalations')
          .select('id', { count: 'exact' })
          .eq('escalated_to', agent.id)
          .gte('escalated_at', startDate.toISOString())
          .lte('escalated_at', endDate.toISOString());

        // Calculate SLA compliance
        let slaCompliant = 0;
        let totalSlaChecks = 0;

        assignedTickets.forEach(ticket => {
          const responseTime = responseTimes.find(rt => rt > 0) || 0;
          const tier = ticket.customer_tier || 'free';
          
          let slaTarget = 24 * 60; // 24 hours for free tier
          if (tier === 'enterprise') slaTarget = 15; // 15 minutes
          else if (tier === 'scale') slaTarget = 60; // 1 hour
          else if (tier === 'professional') slaTarget = 2 * 60; // 2 hours

          if (ticket.is_wedding_emergency) slaTarget = 5; // 5 minutes for emergencies

          totalSlaChecks++;
          if (responseTime <= slaTarget) {
            slaCompliant++;
          }
        });

        const slaComplianceRate = totalSlaChecks > 0 ? (slaCompliant / totalSlaChecks) * 100 : 100;

        // Mock customer satisfaction (would come from surveys in real implementation)
        const customerSatisfaction = 4.2 + (Math.random() * 0.8); // 4.2 - 5.0 range

        return {
          agent_id: agent.id,
          agent_name: agent.name,
          agent_email: agent.email,
          tickets_assigned: assignedTickets.length,
          tickets_resolved: resolvedTickets.length,
          avg_response_time: responseTimes.length > 0 
            ? responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length 
            : 0,
          avg_resolution_time: resolutionTimes.length > 0 
            ? resolutionTimes.reduce((a, b) => a + b, 0) / resolutionTimes.length 
            : 0,
          sla_compliance_rate: slaComplianceRate,
          customer_satisfaction: Math.min(5.0, customerSatisfaction),
          templates_used: templateUsage || 0,
          escalations_received: escalations || 0,
          wedding_emergencies_handled: weddingEmergencies.length,
          status: agent.status,
          shift_start: agent.shift_start,
          shift_end: agent.shift_end
        };
      })
    );

    return agentMetrics;

  } catch (error) {
    console.error('Error calculating agent metrics manually:', error);
    return [];
  }
}