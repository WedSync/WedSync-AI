import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { rateLimit, rateLimitConfigs } from '@/lib/rate-limit'
import { z } from 'zod'

const statusUpdateSchema = z.object({
  status: z.string().min(1).max(50),
  reason: z.string().optional(),
  notes: z.string().optional(),
  followUpDate: z.string().datetime().optional(),
  assignTo: z.string().uuid().optional(),
  priority: z.enum(['low', 'medium', 'high', 'urgent']).optional(),
  estimatedValue: z.number().positive().optional(),
  probabilityToClose: z.number().min(0).max(100).optional()
})

export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    // Apply rate limiting
    const rateLimitResult = await rateLimit(request, rateLimitConfigs.api)
    if (rateLimitResult) return rateLimitResult

    const supabase = await createClient()
    const { data: user } = await supabase.auth.getUser()

    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { id } = await params

    const { data: profile } = await supabase
      .from('user_profiles')
      .select('organization_id')
      .eq('user_id', user.id)
      .single()

    if (!profile?.organization_id) {
      return NextResponse.json({ error: 'No organization found' }, { status: 400 })
    }

    // Validate request body
    const body = await request.json()
    const validatedData = statusUpdateSchema.parse(body)

    // Verify client exists and belongs to organization
    const { data: client, error: clientError } = await supabase
      .from('clients')
      .select('id, status, organization_id, lead_score')
      .eq('id', id)
      .eq('organization_id', profile.organization_id)
      .single()

    if (clientError || !client) {
      return NextResponse.json(
        { error: 'Client not found or unauthorized' },
        { status: 404 }
      )
    }

    // Use the database function to update status with history tracking
    const { data: statusUpdateResult, error: statusError } = await supabase
      .rpc('update_lead_status', {
        client_uuid: id,
        new_status: validatedData.status,
        change_reason: validatedData.reason,
        notes: validatedData.notes
      })

    if (statusError) {
      console.error('Error updating lead status:', statusError)
      return NextResponse.json(
        { error: 'Failed to update status' },
        { status: 500 }
      )
    }

    // Update additional fields if provided
    const additionalUpdates: any = {}
    if (validatedData.followUpDate) {
      additionalUpdates.follow_up_date = validatedData.followUpDate
    }
    if (validatedData.assignTo) {
      additionalUpdates.assigned_to = validatedData.assignTo
    }
    if (validatedData.priority) {
      additionalUpdates.lead_priority = validatedData.priority
    }
    if (validatedData.estimatedValue) {
      additionalUpdates.estimated_value = validatedData.estimatedValue
    }
    if (validatedData.probabilityToClose !== undefined) {
      additionalUpdates.probability_to_close = validatedData.probabilityToClose
    }

    if (Object.keys(additionalUpdates).length > 0) {
      additionalUpdates.updated_at = new Date().toISOString()
      additionalUpdates.last_modified_by = user.id

      await supabase
        .from('clients')
        .update(additionalUpdates)
        .eq('id', id)
    }

    // Get updated client data with related information
    const { data: updatedClient, error: fetchError } = await supabase
      .from('clients')
      .select(`
        *,
        lead_scores (
          total_score,
          score_grade,
          demographic_score,
          behavioral_score,
          engagement_score,
          fit_score,
          score_trend,
          last_calculated_at
        ),
        lead_sources (
          source_name,
          source_category
        ),
        assigned_user:user_profiles!clients_assigned_to_fkey (
          id,
          first_name,
          last_name,
          email
        ),
        recent_status_changes:lead_status_history (
          id,
          previous_status,
          new_status,
          status_changed_at,
          changed_by,
          change_reason,
          notes,
          time_in_previous_status_hours
        )
      `)
      .eq('id', id)
      .single()

    if (fetchError) {
      console.error('Error fetching updated client:', fetchError)
      return NextResponse.json(
        { error: 'Status updated but failed to fetch updated data' },
        { status: 500 }
      )
    }

    // Log activity
    await supabase
      .from('client_activities')
      .insert({
        client_id: id,
        organization_id: profile.organization_id,
        activity_type: 'status_changed',
        activity_title: `Status changed to ${validatedData.status}`,
        activity_description: validatedData.reason || `Lead status updated to ${validatedData.status}`,
        performed_by: user.id,
        metadata: {
          previousStatus: client.status,
          newStatus: validatedData.status,
          reason: validatedData.reason,
          additionalUpdates
        }
      })

    // Trigger lead score recalculation
    await supabase.rpc('calculate_lead_score', { client_uuid: id })

    return NextResponse.json({
      client: updatedClient,
      statusUpdate: {
        success: true,
        previousStatus: client.status,
        newStatus: validatedData.status,
        updatedAt: new Date().toISOString()
      }
    })

  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Validation error', details: error.errors },
        { status: 400 }
      )
    }
    console.error('Error updating lead status:', error)
    return NextResponse.json(
      { error: 'Failed to update lead status' },
      { status: 500 }
    )
  }
}

// Get status history for a lead
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const supabase = await createClient()
    const { data: user } = await supabase.auth.getUser()

    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { id } = await params

    const { data: profile } = await supabase
      .from('user_profiles')
      .select('organization_id')
      .eq('user_id', user.id)
      .single()

    if (!profile?.organization_id) {
      return NextResponse.json({ error: 'No organization found' }, { status: 400 })
    }

    // Get status history
    const { data: statusHistory, error: historyError } = await supabase
      .from('lead_status_history')
      .select(`
        *,
        changed_by_user:user_profiles!lead_status_history_changed_by_fkey (
          id,
          first_name,
          last_name,
          email
        )
      `)
      .eq('client_id', id)
      .eq('organization_id', profile.organization_id)
      .order('status_changed_at', { ascending: false })

    if (historyError) {
      console.error('Error fetching status history:', historyError)
      return NextResponse.json(
        { error: 'Failed to fetch status history' },
        { status: 500 }
      )
    }

    // Get current client info
    const { data: client, error: clientError } = await supabase
      .from('clients')
      .select('id, status, lead_score, lead_grade, created_at')
      .eq('id', id)
      .eq('organization_id', profile.organization_id)
      .single()

    if (clientError) {
      return NextResponse.json(
        { error: 'Client not found' },
        { status: 404 }
      )
    }

    // Calculate status analytics
    const analytics = {
      totalStatusChanges: statusHistory?.length || 0,
      averageTimeInStatus: 0,
      currentStatusDuration: 0,
      statusDistribution: {} as Record<string, number>
    }

    if (statusHistory && statusHistory.length > 0) {
      const times = statusHistory
        .filter(h => h.time_in_previous_status_hours !== null)
        .map(h => h.time_in_previous_status_hours)
      
      if (times.length > 0) {
        analytics.averageTimeInStatus = Math.round(
          times.reduce((sum, time) => sum + time, 0) / times.length
        )
      }

      // Current status duration
      const lastChange = statusHistory[0]
      if (lastChange) {
        const hoursSinceChange = Math.floor(
          (new Date().getTime() - new Date(lastChange.status_changed_at).getTime()) / (1000 * 60 * 60)
        )
        analytics.currentStatusDuration = hoursSinceChange
      }

      // Status distribution
      statusHistory.forEach(h => {
        analytics.statusDistribution[h.new_status] = 
          (analytics.statusDistribution[h.new_status] || 0) + 1
      })
    }

    return NextResponse.json({
      client: {
        id: client.id,
        currentStatus: client.status,
        leadScore: client.lead_score,
        leadGrade: client.lead_grade,
        createdAt: client.created_at
      },
      statusHistory,
      analytics
    })

  } catch (error) {
    console.error('Error fetching status history:', error)
    return NextResponse.json(
      { error: 'Failed to fetch status history' },
      { status: 500 }
    )
  }
}