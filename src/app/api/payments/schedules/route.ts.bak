import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { PaymentSecurityManager } from '@/lib/security/payment-security';
import { z } from 'zod';

const PaymentScheduleSchema = z.object({
  weddingId: z.string().uuid(),
  title: z.string().min(1).max(200),
  description: z.string().optional(),
  amount: z.number().positive().max(1000000),
  dueDate: z.string().datetime(),
  vendor: z.object({
    id: z.string().uuid(),
    name: z.string().min(1).max(100),
    category: z.string().min(1).max(50),
    contact: z.object({
      email: z.string().email().optional(),
      phone: z.string().optional(),
    }).optional(),
  }),
  priority: z.enum(['low', 'medium', 'high', 'critical']),
  reminderSettings: z.object({
    enabled: z.boolean(),
    daysBefore: z.array(z.number().min(0).max(365)),
    notificationTypes: z.array(z.enum(['push', 'email', 'sms'])),
  }),
  paymentMethod: z.object({
    type: z.enum(['check', 'transfer', 'card', 'cash']),
    reference: z.string().optional(),
  }).optional(),
  encryptedData: z.string().optional(),
});

const securityManager = new PaymentSecurityManager();

export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient();
    const { searchParams } = new URL(request.url);
    const weddingId = searchParams.get('weddingId');

    if (!weddingId) {
      return NextResponse.json(
        { error: 'Wedding ID is required' },
        { status: 400 }
      );
    }

    // Validate user has access to this wedding
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // Check wedding access
    const { data: weddingAccess, error: accessError } = await supabase
      .from('wedding_access')
      .select('role')
      .eq('wedding_id', weddingId)
      .eq('user_id', user.id)
      .single();

    if (accessError || !weddingAccess) {
      return NextResponse.json(
        { error: 'Access denied to this wedding' },
        { status: 403 }
      );
    }

    // Build filters
    let query = supabase
      .from('payment_schedules')
      .select(`
        *,
        vendor:vendors(id, name, category, contact_info)
      `)
      .eq('wedding_id', weddingId)
      .order('due_date', { ascending: true });

    // Apply filters from search params
    const status = searchParams.getAll('status');
    if (status.length > 0) {
      query = query.in('status', status);
    }

    const priority = searchParams.getAll('priority');
    if (priority.length > 0) {
      query = query.in('priority', priority);
    }

    const vendorIds = searchParams.getAll('vendorId');
    if (vendorIds.length > 0) {
      query = query.in('vendor_id', vendorIds);
    }

    const startDate = searchParams.get('startDate');
    const endDate = searchParams.get('endDate');
    if (startDate) {
      query = query.gte('due_date', startDate);
    }
    if (endDate) {
      query = query.lte('due_date', endDate);
    }

    const { data: schedules, error } = await query;

    if (error) {
      console.error('Database error:', error);
      return NextResponse.json(
        { error: 'Failed to fetch payment schedules' },
        { status: 500 }
      );
    }

    // Process schedules to match the expected format
    const processedSchedules = await Promise.all(
      schedules.map(async (schedule) => {
        // Decrypt sensitive data if present
        let decryptedData = {};
        if (schedule.encrypted_payment_data) {
          try {
            decryptedData = await securityManager.decryptPaymentData(schedule.encrypted_payment_data);
          } catch (error) {
            console.error('Failed to decrypt payment data:', error);
          }
        }

        return {
          id: schedule.id,
          weddingId: schedule.wedding_id,
          title: schedule.title,
          description: schedule.description,
          amount: schedule.amount,
          dueDate: schedule.due_date,
          vendor: {
            id: schedule.vendor?.id || schedule.vendor_id,
            name: schedule.vendor?.name || 'Unknown Vendor',
            category: schedule.vendor?.category || 'Other',
            contact: schedule.vendor?.contact_info,
          },
          status: schedule.status,
          priority: schedule.priority,
          reminderSettings: {
            enabled: schedule.reminder_enabled || false,
            daysBefore: schedule.reminder_days_before || [7, 3, 1],
            notificationTypes: schedule.notification_types || ['push'],
          },
          paymentMethod: schedule.payment_method,
          paidDate: schedule.paid_date,
          paidAmount: schedule.paid_amount,
          attachments: schedule.attachments || [],
          createdAt: schedule.created_at,
          updatedAt: schedule.updated_at,
          createdBy: schedule.created_by,
          ...decryptedData,
        };
      })
    );

    return NextResponse.json({
      schedules: processedSchedules,
      total: schedules.length,
    });

  } catch (error) {
    console.error('GET /api/payments/schedules error:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient();
    const body = await request.json();

    // Validate request body
    const validatedData = PaymentScheduleSchema.parse(body);

    // Authenticate user
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // Check wedding access
    const { data: weddingAccess, error: accessError } = await supabase
      .from('wedding_access')
      .select('role')
      .eq('wedding_id', validatedData.weddingId)
      .eq('user_id', user.id)
      .single();

    if (accessError || !weddingAccess) {
      return NextResponse.json(
        { error: 'Access denied to this wedding' },
        { status: 403 }
      );
    }

    // Check if user can create payment schedules (admin or planner role)
    if (!['admin', 'planner', 'couple'].includes(weddingAccess.role)) {
      return NextResponse.json(
        { error: 'Insufficient permissions to create payment schedules' },
        { status: 403 }
      );
    }

    // Verify vendor exists and belongs to this wedding
    const { data: vendor, error: vendorError } = await supabase
      .from('vendors')
      .select('id, name, category')
      .eq('id', validatedData.vendor.id)
      .eq('wedding_id', validatedData.weddingId)
      .single();

    if (vendorError || !vendor) {
      return NextResponse.json(
        { error: 'Invalid vendor for this wedding' },
        { status: 400 }
      );
    }

    // Prepare payment schedule data
    const scheduleData = {
      wedding_id: validatedData.weddingId,
      vendor_id: validatedData.vendor.id,
      title: validatedData.title,
      description: validatedData.description,
      amount: validatedData.amount,
      due_date: validatedData.dueDate,
      status: 'upcoming',
      priority: validatedData.priority,
      reminder_enabled: validatedData.reminderSettings.enabled,
      reminder_days_before: validatedData.reminderSettings.daysBefore,
      notification_types: validatedData.reminderSettings.notificationTypes,
      payment_method: validatedData.paymentMethod,
      encrypted_payment_data: validatedData.encryptedData,
      created_by: user.id,
    };

    const { data: schedule, error } = await supabase
      .from('payment_schedules')
      .insert(scheduleData)
      .select(`
        *,
        vendor:vendors(id, name, category, contact_info)
      `)
      .single();

    if (error) {
      console.error('Database error creating schedule:', error);
      return NextResponse.json(
        { error: 'Failed to create payment schedule' },
        { status: 500 }
      );
    }

    // Format response
    const responseSchedule = {
      id: schedule.id,
      weddingId: schedule.wedding_id,
      title: schedule.title,
      description: schedule.description,
      amount: schedule.amount,
      dueDate: schedule.due_date,
      vendor: {
        id: schedule.vendor.id,
        name: schedule.vendor.name,
        category: schedule.vendor.category,
        contact: schedule.vendor.contact_info,
      },
      status: schedule.status,
      priority: schedule.priority,
      reminderSettings: {
        enabled: schedule.reminder_enabled,
        daysBefore: schedule.reminder_days_before,
        notificationTypes: schedule.notification_types,
      },
      paymentMethod: schedule.payment_method,
      createdAt: schedule.created_at,
      updatedAt: schedule.updated_at,
      createdBy: schedule.created_by,
    };

    return NextResponse.json({
      schedule: responseSchedule,
      message: 'Payment schedule created successfully'
    }, { status: 201 });

  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { 
          error: 'Validation error',
          details: error.errors
        },
        { status: 400 }
      );
    }

    console.error('POST /api/payments/schedules error:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}