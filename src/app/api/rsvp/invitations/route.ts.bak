import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { z } from 'zod';

// Validation schemas
const CreateInvitationSchema = z.object({
  event_id: z.string().uuid(),
  guest_name: z.string().min(1, 'Guest name is required'),
  guest_email: z.string().email().optional(),
  guest_phone: z.string().optional(),
  max_party_size: z.number().positive().default(1),
  is_vip: z.boolean().default(false),
  table_assignment: z.string().optional()
});

const BulkCreateInvitationsSchema = z.object({
  event_id: z.string().uuid(),
  invitations: z.array(z.object({
    guest_name: z.string().min(1),
    guest_email: z.string().email().optional(),
    guest_phone: z.string().optional(),
    max_party_size: z.number().positive().default(1),
    is_vip: z.boolean().default(false),
    table_assignment: z.string().optional()
  })),
  send_immediately: z.boolean().default(false)
});

// GET /api/rsvp/invitations - List invitations with filters
export async function GET(req: NextRequest) {
  try {
    const supabase = await createClient();
    const searchParams = req.nextUrl.searchParams;
    const eventId = searchParams.get('event_id');
    const status = searchParams.get('status'); // sent, pending, responded
    
    // Get current user
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    let query = supabase
      .from('rsvp_invitations')
      .select(`
        *,
        rsvp_events!inner (
          id,
          event_name,
          event_date,
          vendor_id
        ),
        rsvp_responses (
          id,
          response_status,
          party_size,
          responded_at
        )
      `)
      .eq('rsvp_events.vendor_id', user.id);

    if (eventId) {
      query = query.eq('event_id', eventId);
    }

    // Filter by status
    if (status === 'sent') {
      query = query.not('invitation_sent_at', 'is', null);
    } else if (status === 'pending') {
      query = query.is('invitation_sent_at', null);
    } else if (status === 'responded') {
      query = query.not('rsvp_responses', 'is', null);
    }

    const { data: invitations, error } = await query
      .order('created_at', { ascending: false });

    if (error) {
      console.error('Error fetching invitations:', error);
      return NextResponse.json({ error: 'Failed to fetch invitations' }, { status: 500 });
    }

    // Process invitations to include status
    const processedInvitations = invitations?.map((invitation: any) => ({
      ...invitation,
      status: invitation.rsvp_responses && invitation.rsvp_responses.length > 0
        ? 'responded'
        : invitation.invitation_sent_at
        ? 'sent'
        : 'pending',
      response: invitation.rsvp_responses?.[0] || null
    }));

    return NextResponse.json({ invitations: processedInvitations });
  } catch (error) {
    console.error('Error in GET /api/rsvp/invitations:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

// POST /api/rsvp/invitations - Create single or bulk invitations
export async function POST(req: NextRequest) {
  try {
    const supabase = await createClient();
    
    // Get current user
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await req.json();

    // Check if bulk create
    if (body.invitations && Array.isArray(body.invitations)) {
      const validatedData = BulkCreateInvitationsSchema.parse(body);
      
      // Verify event ownership
      const { data: event, error: eventError } = await supabase
        .from('rsvp_events')
        .select('id')
        .eq('id', validatedData.event_id)
        .eq('vendor_id', user.id)
        .single();

      if (eventError || !event) {
        return NextResponse.json({ error: 'Event not found or unauthorized' }, { status: 404 });
      }

      // Prepare invitations data
      const invitationsData = validatedData.invitations.map(inv => ({
        ...inv,
        event_id: validatedData.event_id
      }));

      // Create invitations
      const { data: createdInvitations, error } = await supabase
        .from('rsvp_invitations')
        .insert(invitationsData)
        .select();

      if (error) {
        console.error('Error creating invitations:', error);
        return NextResponse.json({ error: 'Failed to create invitations' }, { status: 500 });
      }

      // Schedule reminders for each invitation
      for (const invitation of createdInvitations) {
        await supabase.rpc('schedule_rsvp_reminders', { 
          p_event_id: validatedData.event_id,
          p_invitation_id: invitation.id 
        });
      }

      // Send invitations immediately if requested
      if (validatedData.send_immediately) {
        // Queue invitation emails/SMS
        for (const invitation of createdInvitations) {
          if (invitation.guest_email || invitation.guest_phone) {
            // This would integrate with your notification service
            await sendInvitation(invitation);
          }
        }
      }

      return NextResponse.json({ 
        invitations: createdInvitations,
        count: createdInvitations.length 
      }, { status: 201 });

    } else {
      // Single invitation create
      const validatedData = CreateInvitationSchema.parse(body);
      
      // Verify event ownership
      const { data: event, error: eventError } = await supabase
        .from('rsvp_events')
        .select('id')
        .eq('id', validatedData.event_id)
        .eq('vendor_id', user.id)
        .single();

      if (eventError || !event) {
        return NextResponse.json({ error: 'Event not found or unauthorized' }, { status: 404 });
      }

      // Create invitation
      const { data: invitation, error } = await supabase
        .from('rsvp_invitations')
        .insert(validatedData)
        .select()
        .single();

      if (error) {
        console.error('Error creating invitation:', error);
        return NextResponse.json({ error: 'Failed to create invitation' }, { status: 500 });
      }

      // Schedule reminders
      await supabase.rpc('schedule_rsvp_reminders', { 
        p_event_id: validatedData.event_id,
        p_invitation_id: invitation.id 
      });

      return NextResponse.json({ invitation }, { status: 201 });
    }
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json({ 
        error: 'Validation error', 
        details: error.issues 
      }, { status: 400 });
    }
    console.error('Error in POST /api/rsvp/invitations:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

// Helper function to send invitation (placeholder)
async function sendInvitation(invitation: any) {
  // This would integrate with your email/SMS service
  // For now, just mark as sent
  const supabase = await createClient();
  await supabase
    .from('rsvp_invitations')
    .update({ invitation_sent_at: new Date().toISOString() })
    .eq('id', invitation.id);
}