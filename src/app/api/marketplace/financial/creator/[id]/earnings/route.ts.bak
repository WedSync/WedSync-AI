/**
 * WS-109: Creator Earnings History API Endpoint
 * 
 * GET /api/marketplace/financial/creator/[id]/earnings
 * 
 * Retrieves comprehensive earnings history and financial data for a specific creator
 * including daily earnings, monthly summaries, and tax document preparation data.
 * 
 * Team B - Batch 8 - Round 2
 */

import { NextRequest, NextResponse } from 'next/server';
import { financialDataProcessingService } from '@/lib/services/financialDataProcessingService';
import { createClient } from '@supabase/supabase-js';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_KEY!
);

// =====================================================================================
// REQUEST/RESPONSE INTERFACES
// =====================================================================================

interface CreatorEarningsResponse {
  success: boolean;
  earnings_data?: {
    creator_id: string;
    creator_name?: string;
    summary: {
      total_earnings_cents: number;
      pending_earnings_cents: number;
      paid_earnings_cents: number;
      lifetime_sales_count: number;
      lifetime_revenue_cents: number;
      current_month_earnings_cents: number;
      current_year_earnings_cents: number;
      last_updated: string;
    };
    daily_history: Array<{
      date: string;
      earnings_cents: number;
      sales_count: number;
    }>;
    monthly_breakdown: Array<{
      year: number;
      month: number;
      earnings_cents: number;
      sales_count: number;
      revenue_cents: number;
    }>;
    tax_documents: Array<{
      tax_year: number;
      total_earnings_cents: number;
      total_commission_deducted_cents: number;
      vat_collected_cents: number;
      document_generated: boolean;
      document_sent_date?: string;
      quarterly_breakdown: Array<{
        quarter: number;
        earnings_cents: number;
        commission_cents: number;
        vat_cents: number;
      }>;
    }>;
    payout_history: Array<{
      payout_date: string;
      amount_cents: number;
      status: string;
      payout_method: string;
      reference_id?: string;
    }>;
  };
  error?: string;
}

// =====================================================================================
// API HANDLERS
// =====================================================================================

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const resolvedParams = await params;
    const creatorId = resolvedParams.id;

    // Authentication and authorization check
    const authCheck = await verifyCreatorAccess(request, creatorId);
    if (!authCheck.valid) {
      return NextResponse.json(
        { 
          success: false, 
          error: authCheck.error 
        },
        { status: authCheck.status || 403 }
      );
    }

    const { searchParams } = request.nextUrl;
    
    // Parse query parameters
    const startDateStr = searchParams.get('start_date');
    const endDateStr = searchParams.get('end_date');
    const includePayouts = searchParams.get('include_payouts') !== 'false'; // default true
    const includeTax = searchParams.get('include_tax') !== 'false'; // default true
    
    // Validate and parse dates
    let startDate: Date | undefined;
    let endDate: Date | undefined;
    
    if (startDateStr) {
      startDate = new Date(startDateStr);
      if (isNaN(startDate.getTime())) {
        return NextResponse.json(
          { success: false, error: 'Invalid start_date format. Use ISO 8601 format.' },
          { status: 400 }
        );
      }
    }
    
    if (endDateStr) {
      endDate = new Date(endDateStr);
      if (isNaN(endDate.getTime())) {
        return NextResponse.json(
          { success: false, error: 'Invalid end_date format. Use ISO 8601 format.' },
          { status: 400 }
        );
      }
    }

    if (startDate && endDate && startDate >= endDate) {
      return NextResponse.json(
        { success: false, error: 'start_date must be before end_date' },
        { status: 400 }
      );
    }

    // Get creator earnings summary
    const summary = await getCreatorEarningsSummary(creatorId);
    if (!summary) {
      return NextResponse.json(
        { success: false, error: 'Creator earnings data not found' },
        { status: 404 }
      );
    }

    // Get daily earnings history
    const dailyHistory = await financialDataProcessingService.getCreatorEarningsHistory(
      creatorId,
      startDate,
      endDate
    );

    // Get monthly breakdown
    const monthlyBreakdown = await getMonthlyBreakdown(creatorId, startDate, endDate);

    // Get tax documents if requested
    let taxDocuments: any[] = [];
    if (includeTax) {
      taxDocuments = await getTaxDocuments(creatorId);
    }

    // Get payout history if requested
    let payoutHistory: any[] = [];
    if (includePayouts) {
      payoutHistory = await getPayoutHistory(creatorId, startDate, endDate);
    }

    // Get creator name
    const creatorName = await getCreatorName(creatorId);

    const response: CreatorEarningsResponse = {
      success: true,
      earnings_data: {
        creator_id: creatorId,
        creator_name: creatorName,
        summary: {
          total_earnings_cents: summary.total_earnings_cents || 0,
          pending_earnings_cents: summary.pending_earnings_cents || 0,
          paid_earnings_cents: (summary.total_earnings_cents || 0) - (summary.pending_earnings_cents || 0),
          lifetime_sales_count: summary.lifetime_sales_count || 0,
          lifetime_revenue_cents: summary.lifetime_revenue_cents || 0,
          current_month_earnings_cents: summary.current_month_earnings_cents || 0,
          current_year_earnings_cents: summary.current_year_earnings_cents || 0,
          last_updated: summary.last_updated || new Date().toISOString()
        },
        daily_history: dailyHistory || [],
        monthly_breakdown: monthlyBreakdown,
        tax_documents: taxDocuments,
        payout_history: payoutHistory
      }
    };

    return NextResponse.json(response);

  } catch (error) {
    console.error('Creator earnings API error:', error);
    
    return NextResponse.json(
      { 
        success: false, 
        error: 'Failed to retrieve creator earnings data. Please try again.' 
      },
      { status: 500 }
    );
  }
}

// =====================================================================================
// HELPER FUNCTIONS
// =====================================================================================

async function verifyCreatorAccess(
  request: NextRequest, 
  creatorId: string
): Promise<{ 
  valid: boolean; 
  error?: string; 
  status?: number;
  userId?: string; 
}> {
  try {
    const authHeader = request.headers.get('Authorization');
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return { 
        valid: false, 
        error: 'Authorization header required', 
        status: 401 
      };
    }

    const token = authHeader.substring(7);
    
    // Verify token with Supabase
    const { data: { user }, error } = await supabase.auth.getUser(token);
    
    if (error || !user) {
      return { 
        valid: false, 
        error: 'Invalid or expired token', 
        status: 401 
      };
    }

    // Check if user is the creator or has admin access
    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('role')
      .eq('id', user.id)
      .single();

    if (profileError || !profile) {
      return { 
        valid: false, 
        error: 'User profile not found', 
        status: 404 
      };
    }

    // Allow access if user is admin or the creator themselves
    const isAdmin = ['admin', 'super_admin', 'finance_admin'].includes(profile.role);
    const isCreator = user.id === creatorId;

    if (!isAdmin && !isCreator) {
      return { 
        valid: false, 
        error: 'Access denied. You can only view your own earnings data.', 
        status: 403 
      };
    }

    return { valid: true, userId: user.id };

  } catch (error) {
    console.error('Creator access verification error:', error);
    return { 
      valid: false, 
      error: 'Authentication verification failed', 
      status: 500 
    };
  }
}

async function getCreatorEarningsSummary(creatorId: string) {
  try {
    const { data, error } = await supabase
      .from('marketplace_creator_earnings_summary')
      .select('*')
      .eq('creator_id', creatorId)
      .single();

    if (error && error.code !== 'PGRST116') {
      throw new Error(`Failed to fetch earnings summary: ${error.message}`);
    }

    return data;

  } catch (error) {
    console.error('Creator earnings summary error:', error);
    return null;
  }
}

async function getMonthlyBreakdown(
  creatorId: string,
  startDate?: Date,
  endDate?: Date
) {
  try {
    let query = supabase
      .from('marketplace_creator_monthly_earnings')
      .select('*')
      .eq('creator_id', creatorId)
      .order('year', { ascending: false })
      .order('month', { ascending: false });

    if (startDate) {
      const startYear = startDate.getFullYear();
      const startMonth = startDate.getMonth() + 1;
      query = query.or(`year.gt.${startYear},and(year.eq.${startYear},month.gte.${startMonth})`);
    }

    if (endDate) {
      const endYear = endDate.getFullYear();
      const endMonth = endDate.getMonth() + 1;
      query = query.or(`year.lt.${endYear},and(year.eq.${endYear},month.lte.${endMonth})`);
    }

    const { data, error } = await query;

    if (error) {
      throw new Error(`Failed to fetch monthly breakdown: ${error.message}`);
    }

    return data || [];

  } catch (error) {
    console.error('Monthly breakdown error:', error);
    return [];
  }
}

async function getTaxDocuments(creatorId: string) {
  try {
    const { data, error } = await supabase
      .from('marketplace_creator_tax_documents')
      .select('*')
      .eq('creator_id', creatorId)
      .order('tax_year', { ascending: false });

    if (error) {
      throw new Error(`Failed to fetch tax documents: ${error.message}`);
    }

    return data || [];

  } catch (error) {
    console.error('Tax documents error:', error);
    return [];
  }
}

async function getPayoutHistory(
  creatorId: string,
  startDate?: Date,
  endDate?: Date
) {
  try {
    let query = supabase
      .from('marketplace_creator_payouts')
      .select('payout_date, net_payout_cents, status, payout_method, stripe_transfer_id')
      .eq('creator_id', creatorId)
      .order('payout_date', { ascending: false });

    if (startDate) {
      query = query.gte('payout_date', startDate.toISOString());
    }

    if (endDate) {
      query = query.lte('payout_date', endDate.toISOString());
    }

    const { data, error } = await query;

    if (error) {
      throw new Error(`Failed to fetch payout history: ${error.message}`);
    }

    return (data || []).map(payout => ({
      payout_date: payout.payout_date,
      amount_cents: payout.net_payout_cents,
      status: payout.status,
      payout_method: payout.payout_method || 'stripe',
      reference_id: payout.stripe_transfer_id
    }));

  } catch (error) {
    console.error('Payout history error:', error);
    return [];
  }
}

async function getCreatorName(creatorId: string): Promise<string | undefined> {
  try {
    const { data, error } = await supabase
      .from('suppliers')
      .select('business_name, first_name, last_name')
      .eq('id', creatorId)
      .single();

    if (error || !data) {
      return undefined;
    }

    return data.business_name || `${data.first_name || ''} ${data.last_name || ''}`.trim() || undefined;

  } catch (error) {
    console.error('Creator name fetch error:', error);
    return undefined;
  }
}