/**
 * WS-109: Creator Commission API Endpoint
 * 
 * GET /api/marketplace/commission/creator/[id]
 * 
 * Retrieves comprehensive commission and payout information for a specific creator.
 * Includes tier info, earnings history, payout status, and progression data.
 * 
 * Team B - Batch 8 - Round 2
 */

import { NextRequest, NextResponse } from 'next/server';
import { commissionCalculationService } from '@/lib/services/commissionCalculationService';
import { payoutProcessingService } from '@/lib/services/payoutProcessingService';
import { createClient } from '@supabase/supabase-js';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_KEY!
);

// =====================================================================================
// REQUEST/RESPONSE INTERFACES
// =====================================================================================

interface CreatorCommissionResponse {
  success: boolean;
  creator_info?: {
    creator_id: string;
    business_name: string;
    tier_info: any;
    payout_status: any;
    earnings_summary: {
      total_lifetime_earnings_cents: number;
      current_month_earnings_cents: number;
      pending_payout_cents: number;
      total_sales: number;
      average_sale_amount_cents: number;
    };
    recent_transactions: any[];
    commission_history: any[];
    next_milestone?: {
      tier: string;
      sales_needed: number;
      revenue_needed: number;
      progress_percentage: number;
    };
  };
  error?: string;
}

// =====================================================================================
// API HANDLERS
// =====================================================================================

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const creatorId = id;

    // Validate creator ID
    if (!creatorId || typeof creatorId !== 'string') {
      return NextResponse.json(
        { success: false, error: 'Invalid creator ID' },
        { status: 400 }
      );
    }

    // Verify creator access (basic auth check)
    const authCheck = await verifyCreatorAccess(request, creatorId);
    if (!authCheck.valid) {
      return NextResponse.json(
        { success: false, error: authCheck.error },
        { status: authCheck.status || 403 }
      );
    }

    // Get creator basic info
    const creatorInfo = await getCreatorBasicInfo(creatorId);
    if (!creatorInfo) {
      return NextResponse.json(
        { success: false, error: 'Creator not found' },
        { status: 404 }
      );
    }

    // Get comprehensive commission data in parallel
    const [
      tierInfo,
      payoutStatus,
      earningsSummary,
      recentTransactions,
      commissionHistory
    ] = await Promise.all([
      commissionCalculationService.getCreatorTier(creatorId),
      payoutProcessingService.getCreatorPayoutStatus(creatorId, 10),
      getEarningsSummary(creatorId),
      getRecentTransactions(creatorId, 20),
      getCommissionHistory(creatorId, 12) // Last 12 months
    ]);

    // Get next milestone info
    const nextMilestone = tierInfo.next_tier ? {
      tier: tierInfo.next_tier.tier_name,
      sales_needed: tierInfo.next_tier.requirements.sales_needed,
      revenue_needed: tierInfo.next_tier.requirements.revenue_needed,
      progress_percentage: tierInfo.next_tier.requirements.progress_percentage
    } : undefined;

    const response: CreatorCommissionResponse = {
      success: true,
      creator_info: {
        creator_id: creatorId,
        business_name: creatorInfo.business_name,
        tier_info: {
          current_tier: tierInfo.current_tier,
          commission_rate: tierInfo.commission_rate,
          tier_achieved_date: tierInfo.tier_achieved_date,
          tier_benefits: tierInfo.tier_benefits,
          stats: tierInfo.stats,
          next_tier: tierInfo.next_tier
        },
        payout_status: {
          recent_payouts: payoutStatus.recent_payouts.map(payout => ({
            ...payout,
            // Convert cents to display format
            gross_earnings: Math.round(payout.gross_earnings_cents / 100 * 100) / 100,
            net_payout: Math.round(payout.net_payout_cents / 100 * 100) / 100
          })),
          pending_amount: Math.round(payoutStatus.pending_amount_cents / 100 * 100) / 100,
          next_payout_date: payoutStatus.next_payout_date,
          total_lifetime_earnings: Math.round(payoutStatus.total_lifetime_earnings_cents / 100 * 100) / 100
        },
        earnings_summary: {
          total_lifetime_earnings_cents: payoutStatus.total_lifetime_earnings_cents,
          current_month_earnings_cents: earningsSummary.current_month_earnings_cents,
          pending_payout_cents: payoutStatus.pending_amount_cents,
          total_sales: earningsSummary.total_sales,
          average_sale_amount_cents: earningsSummary.average_sale_amount_cents
        },
        recent_transactions: recentTransactions.map(transaction => ({
          ...transaction,
          // Convert amounts for display
          gross_amount: Math.round(transaction.gross_sale_amount_cents / 100 * 100) / 100,
          creator_earnings: Math.round(transaction.creator_earnings_cents / 100 * 100) / 100,
          commission_amount: Math.round(transaction.commission_amount_cents / 100 * 100) / 100
        })),
        commission_history: commissionHistory,
        next_milestone: nextMilestone
      }
    };

    // Log API access for analytics
    await logCreatorApiAccess(creatorId, authCheck.userId || 'anonymous');

    return NextResponse.json(response);

  } catch (error) {
    console.error('Creator commission API error:', error);
    
    return NextResponse.json(
      { 
        success: false, 
        error: 'Failed to retrieve creator commission data' 
      },
      { status: 500 }
    );
  }
}

// PUT endpoint for updating creator commission settings
export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const creatorId = id;

    // Verify admin access for commission setting updates
    const authCheck = await verifyAdminAccess(request);
    if (!authCheck.valid) {
      return NextResponse.json(
        { success: false, error: authCheck.error },
        { status: authCheck.status || 403 }
      );
    }

    const body = await request.json();
    const { action, data } = body;

    switch (action) {
      case 'manual_tier_upgrade':
        const result = await performManualTierUpgrade(creatorId, data.target_tier, authCheck.userId);
        return NextResponse.json({ success: true, result });

      case 'apply_promotional_rate':
        await applyPromotionalRate(creatorId, data.promotion_code, authCheck.userId);
        return NextResponse.json({ success: true });

      case 'adjust_commission':
        await adjustCommission(creatorId, data.adjustment, authCheck.userId);
        return NextResponse.json({ success: true });

      default:
        return NextResponse.json(
          { success: false, error: 'Invalid action' },
          { status: 400 }
        );
    }

  } catch (error) {
    console.error('Creator commission update error:', error);
    
    return NextResponse.json(
      { success: false, error: 'Failed to update creator commission settings' },
      { status: 500 }
    );
  }
}

// =====================================================================================
// HELPER FUNCTIONS
// =====================================================================================

async function verifyCreatorAccess(
  request: NextRequest,
  creatorId: string
): Promise<{ valid: boolean; error?: string; status?: number; userId?: string }> {
  try {
    const authHeader = request.headers.get('Authorization');
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return { 
        valid: false, 
        error: 'Authorization required', 
        status: 401 
      };
    }

    const token = authHeader.substring(7);
    
    // Verify token with Supabase
    const { data: { user }, error } = await supabase.auth.getUser(token);
    
    if (error || !user) {
      return { 
        valid: false, 
        error: 'Invalid or expired token', 
        status: 401 
      };
    }

    // Check if user can access this creator's data
    // Allow access if: user is the creator, user is admin, or user is associated with the creator
    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('role')
      .eq('id', user.id)
      .single();

    if (profileError) {
      return { 
        valid: false, 
        error: 'User profile not found', 
        status: 404 
      };
    }

    // Admin users have access to all creator data
    if (profile.role === 'admin' || profile.role === 'super_admin') {
      return { valid: true, userId: user.id };
    }

    // Regular users can only access their own creator data
    if (user.id === creatorId) {
      return { valid: true, userId: user.id };
    }

    // Check if user is associated with the creator organization
    const { data: orgAccess, error: orgError } = await supabase
      .from('organization_members')
      .select('role')
      .eq('user_id', user.id)
      .eq('organization_id', creatorId) // Assuming creator_id maps to organization
      .single();

    if (orgError || !orgAccess) {
      return { 
        valid: false, 
        error: 'Access denied', 
        status: 403 
      };
    }

    return { valid: true, userId: user.id };

  } catch (error) {
    console.error('Creator access verification error:', error);
    return { 
      valid: false, 
      error: 'Authentication verification failed', 
      status: 500 
    };
  }
}

async function verifyAdminAccess(request: NextRequest): Promise<{ 
  valid: boolean; 
  error?: string; 
  status?: number;
  userId?: string; 
}> {
  try {
    const authHeader = request.headers.get('Authorization');
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return { 
        valid: false, 
        error: 'Authorization header required', 
        status: 401 
      };
    }

    const token = authHeader.substring(7);
    
    // Verify token with Supabase
    const { data: { user }, error } = await supabase.auth.getUser(token);
    
    if (error || !user) {
      return { 
        valid: false, 
        error: 'Invalid or expired token', 
        status: 401 
      };
    }

    // Check if user has admin role
    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('role')
      .eq('id', user.id)
      .single();

    if (profileError || !profile) {
      return { 
        valid: false, 
        error: 'User profile not found', 
        status: 404 
      };
    }

    if (profile.role !== 'admin' && profile.role !== 'super_admin') {
      return { 
        valid: false, 
        error: 'Admin access required', 
        status: 403 
      };
    }

    return { valid: true, userId: user.id };

  } catch (error) {
    console.error('Admin verification error:', error);
    return { 
      valid: false, 
      error: 'Authentication verification failed', 
      status: 500 
    };
  }
}

async function getCreatorBasicInfo(creatorId: string): Promise<any> {
  try {
    const { data, error } = await supabase
      .from('suppliers')
      .select('id, business_name, account_status, created_at')
      .eq('id', creatorId)
      .single();

    if (error) {
      console.error('Error fetching creator info:', error);
      return null;
    }

    return data;

  } catch (error) {
    console.error('Error in getCreatorBasicInfo:', error);
    return null;
  }
}

async function getEarningsSummary(creatorId: string): Promise<{
  current_month_earnings_cents: number;
  total_sales: number;
  average_sale_amount_cents: number;
}> {
  try {
    // Get current month earnings
    const currentMonth = new Date();
    const monthStart = new Date(currentMonth.getFullYear(), currentMonth.getMonth(), 1);
    
    const { data: monthlyData, error } = await supabase
      .from('marketplace_commission_records')
      .select('creator_earnings_cents, gross_sale_amount_cents')
      .eq('creator_id', creatorId)
      .gte('created_at', monthStart.toISOString());

    if (error) {
      console.error('Error fetching earnings summary:', error);
      return {
        current_month_earnings_cents: 0,
        total_sales: 0,
        average_sale_amount_cents: 0
      };
    }

    const currentMonthEarnings = (monthlyData || [])
      .reduce((sum, record) => sum + (record.creator_earnings_cents || 0), 0);

    // Get all-time stats
    const { data: allTimeData, error: allTimeError } = await supabase
      .from('marketplace_commission_records')
      .select('gross_sale_amount_cents')
      .eq('creator_id', creatorId);

    if (allTimeError) {
      console.error('Error fetching all-time stats:', error);
    }

    const totalSales = (allTimeData || []).length;
    const totalRevenue = (allTimeData || [])
      .reduce((sum, record) => sum + (record.gross_sale_amount_cents || 0), 0);
    const averageSaleAmount = totalSales > 0 ? totalRevenue / totalSales : 0;

    return {
      current_month_earnings_cents: currentMonthEarnings,
      total_sales: totalSales,
      average_sale_amount_cents: Math.round(averageSaleAmount)
    };

  } catch (error) {
    console.error('Error in getEarningsSummary:', error);
    return {
      current_month_earnings_cents: 0,
      total_sales: 0,
      average_sale_amount_cents: 0
    };
  }
}

async function getRecentTransactions(creatorId: string, limit: number): Promise<any[]> {
  try {
    const { data, error } = await supabase
      .from('marketplace_commission_records')
      .select('*')
      .eq('creator_id', creatorId)
      .order('created_at', { ascending: false })
      .limit(limit);

    if (error) {
      console.error('Error fetching recent transactions:', error);
      return [];
    }

    return data || [];

  } catch (error) {
    console.error('Error in getRecentTransactions:', error);
    return [];
  }
}

async function getCommissionHistory(creatorId: string, months: number): Promise<any[]> {
  try {
    const endDate = new Date();
    const startDate = new Date();
    startDate.setMonth(startDate.getMonth() - months);

    const { data, error } = await supabase
      .from('marketplace_commission_records')
      .select('created_at, creator_earnings_cents, commission_amount_cents')
      .eq('creator_id', creatorId)
      .gte('created_at', startDate.toISOString())
      .order('created_at', { ascending: true });

    if (error) {
      console.error('Error fetching commission history:', error);
      return [];
    }

    // Group by month
    const monthlyData: Record<string, { earnings: number; commission: number; sales: number }> = {};
    
    for (const record of data || []) {
      const date = new Date(record.created_at);
      const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
      
      if (!monthlyData[monthKey]) {
        monthlyData[monthKey] = { earnings: 0, commission: 0, sales: 0 };
      }
      
      monthlyData[monthKey].earnings += record.creator_earnings_cents || 0;
      monthlyData[monthKey].commission += record.commission_amount_cents || 0;
      monthlyData[monthKey].sales += 1;
    }

    return Object.entries(monthlyData).map(([month, data]) => ({
      month,
      earnings_cents: data.earnings,
      commission_cents: data.commission,
      sales_count: data.sales
    }));

  } catch (error) {
    console.error('Error in getCommissionHistory:', error);
    return [];
  }
}

async function performManualTierUpgrade(
  creatorId: string, 
  targetTier: string, 
  adminUserId: string
): Promise<any> {
  try {
    const { error } = await supabase
      .from('marketplace_creator_commission_tiers')
      .update({
        current_tier: targetTier,
        tier_achieved_date: new Date().toISOString(),
        manual_override: true,
        manual_override_by: adminUserId,
        manual_override_reason: 'Admin manual tier upgrade'
      })
      .eq('creator_id', creatorId);

    if (error) {
      throw error;
    }

    // Log the manual upgrade
    await supabase
      .from('marketplace_tier_upgrade_log')
      .insert({
        creator_id: creatorId,
        target_tier: targetTier,
        upgrade_type: 'manual',
        performed_by: adminUserId,
        created_at: new Date().toISOString()
      });

    return { tier_upgraded: targetTier };

  } catch (error) {
    console.error('Error in manual tier upgrade:', error);
    throw error;
  }
}

async function applyPromotionalRate(
  creatorId: string, 
  promotionCode: string, 
  adminUserId: string
): Promise<void> {
  // Implementation for applying promotional commission rates
  // This would interact with the commission promotions system
}

async function adjustCommission(
  creatorId: string, 
  adjustment: any, 
  adminUserId: string
): Promise<void> {
  // Implementation for manual commission adjustments
  // This would create commission adjustment records
}

async function logCreatorApiAccess(creatorId: string, userId: string): Promise<void> {
  try {
    const { error } = await supabase
      .from('marketplace_api_access_log')
      .insert({
        creator_id: creatorId,
        accessed_by: userId,
        endpoint: 'commission_creator_info',
        accessed_at: new Date().toISOString()
      });

    if (error) {
      console.error('Failed to log API access:', error);
    }

  } catch (error) {
    console.error('Error logging API access:', error);
  }
}