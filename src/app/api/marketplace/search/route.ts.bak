/**
 * WS-114: Marketplace Search API Endpoint
 * 
 * GET /api/marketplace/search
 * 
 * Advanced search and filtering system with natural language search,
 * faceted filtering, relevance scoring, and performance optimization.
 * 
 * Team B - Batch 9 - Round 1
 */

import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_KEY!
);

// =====================================================================================
// REQUEST/RESPONSE INTERFACES
// =====================================================================================

interface SearchFilters {
  category?: string;
  subcategory?: string;
  priceMin?: number;
  priceMax?: number;
  ratingMin?: number;
  tier?: string;
  tags?: string[];
  weddingTypes?: string[];
}

interface SearchParams {
  query?: string;
  filters?: SearchFilters;
  sortBy?: 'relevance' | 'price' | 'rating' | 'popularity' | 'newest' | 'featured';
  sortDirection?: 'ASC' | 'DESC';
  page?: number;
  limit?: number;
  includeFacets?: boolean;
}

interface MarketplaceTemplate {
  id: string;
  supplier_id: string;
  title: string;
  description: string;
  template_type: string;
  category: string;
  subcategory: string;
  price_cents: number;
  currency: string;
  minimum_tier: string;
  preview_data: object;
  preview_images: string[];
  demo_url: string | null;
  install_count: number;
  view_count: number;
  conversion_rate: number;
  average_rating: number;
  rating_count: number;
  target_wedding_types: string[];
  target_price_range: string;
  tags: string[];
  featured: boolean;
  created_at: string;
  updated_at: string;
  search_rank?: number;
  highlighted_title?: string;
  highlighted_description?: string;
}

interface SearchResponse {
  success: boolean;
  results?: {
    templates: MarketplaceTemplate[];
    pagination: {
      page: number;
      limit: number;
      total: number;
      totalPages: number;
      hasNext: boolean;
      hasPrev: boolean;
    };
    facets?: object;
    searchMetadata: {
      query: string;
      resultCount: number;
      searchTime: number;
      filters: SearchFilters;
      sortBy: string;
      sortDirection: string;
    };
  };
  error?: string;
}

// =====================================================================================
// API HANDLERS  
// =====================================================================================

export async function GET(request: NextRequest) {
  const startTime = Date.now();

  try {
    const { searchParams } = request.nextUrl;
    
    // Parse search parameters
    const params: SearchParams = {
      query: searchParams.get('q') || '',
      sortBy: (searchParams.get('sort') as any) || 'relevance',
      sortDirection: (searchParams.get('direction') as any) || 'DESC',
      page: parseInt(searchParams.get('page') || '1'),
      limit: Math.min(parseInt(searchParams.get('limit') || '20'), 100),
      includeFacets: searchParams.get('facets') === 'true',
      filters: {
        category: searchParams.get('category') || undefined,
        subcategory: searchParams.get('subcategory') || undefined,
        priceMin: searchParams.get('price_min') ? parseInt(searchParams.get('price_min')!) : undefined,
        priceMax: searchParams.get('price_max') ? parseInt(searchParams.get('price_max')!) : undefined,
        ratingMin: searchParams.get('rating_min') ? parseFloat(searchParams.get('rating_min')!) : undefined,
        tier: searchParams.get('tier') || undefined,
        tags: searchParams.get('tags') ? searchParams.get('tags')!.split(',') : undefined,
        weddingTypes: searchParams.get('wedding_types') ? searchParams.get('wedding_types')!.split(',') : undefined,
      }
    };

    // Validate parameters
    if (params.page! < 1) {
      return NextResponse.json(
        { success: false, error: 'Page must be >= 1' },
        { status: 400 }
      );
    }

    if (params.limit! < 1 || params.limit! > 100) {
      return NextResponse.json(
        { success: false, error: 'Limit must be between 1 and 100' },
        { status: 400 }
      );
    }

    // Get user context for analytics
    const authHeader = request.headers.get('Authorization');
    let userId: string | null = null;
    if (authHeader?.startsWith('Bearer ')) {
      const { data: user } = await supabase.auth.getUser(authHeader.substring(7));
      userId = user?.id || null;
    }

    // Execute search
    const searchResults = await executeMarketplaceSearch(params);
    
    if (!searchResults) {
      return NextResponse.json(
        { success: false, error: 'Search execution failed' },
        { status: 500 }
      );
    }

    // Get facets if requested
    let facets = undefined;
    if (params.includeFacets) {
      facets = await getFacetCounts(params);
    }

    // Calculate pagination
    const offset = (params.page! - 1) * params.limit!;
    const totalPages = Math.ceil(searchResults.total / params.limit!);
    
    const pagination = {
      page: params.page!,
      limit: params.limit!,
      total: searchResults.total,
      totalPages,
      hasNext: params.page! < totalPages,
      hasPrev: params.page! > 1
    };

    // Record search analytics
    await recordSearchAnalytics({
      userId,
      sessionId: request.headers.get('X-Session-ID') || 'anonymous',
      query: params.query!,
      filters: params.filters!,
      resultCount: searchResults.total
    });

    const searchTime = Date.now() - startTime;

    const response: SearchResponse = {
      success: true,
      results: {
        templates: searchResults.templates,
        pagination,
        facets,
        searchMetadata: {
          query: params.query!,
          resultCount: searchResults.total,
          searchTime,
          filters: params.filters!,
          sortBy: params.sortBy!,
          sortDirection: params.sortDirection!
        }
      }
    };

    // Add cache headers for performance
    const cacheHeaders = {
      'Cache-Control': 'public, max-age=60, stale-while-revalidate=300',
      'Vary': 'Authorization'
    };

    return NextResponse.json(response, { headers: cacheHeaders });

  } catch (error) {
    console.error('Marketplace search API error:', error);
    
    return NextResponse.json(
      { 
        success: false, 
        error: 'Failed to execute search. Please try again.' 
      },
      { status: 500 }
    );
  }
}

// =====================================================================================
// HELPER FUNCTIONS
// =====================================================================================

async function executeMarketplaceSearch(params: SearchParams): Promise<{
  templates: MarketplaceTemplate[];
  total: number;
} | null> {
  try {
    const offset = (params.page! - 1) * params.limit!;
    
    let query = supabase
      .from('marketplace_templates')
      .select('*', { count: 'exact' })
      .eq('status', 'active');

    // Apply text search if query provided
    if (params.query && params.query.length > 0) {
      query = query.textSearch('search_vector', params.query, { 
        type: 'websearch',
        config: 'english'
      });
    }

    // Apply filters
    if (params.filters?.category) {
      query = query.eq('category', params.filters.category);
    }
    
    if (params.filters?.subcategory) {
      query = query.eq('subcategory', params.filters.subcategory);
    }
    
    if (params.filters?.priceMin !== undefined) {
      query = query.gte('price_cents', params.filters.priceMin);
    }
    
    if (params.filters?.priceMax !== undefined) {
      query = query.lte('price_cents', params.filters.priceMax);
    }
    
    if (params.filters?.ratingMin !== undefined) {
      query = query.gte('average_rating', params.filters.ratingMin);
    }
    
    if (params.filters?.tier) {
      query = query.eq('minimum_tier', params.filters.tier);
    }
    
    if (params.filters?.tags && params.filters.tags.length > 0) {
      query = query.overlaps('tags', params.filters.tags);
    }
    
    if (params.filters?.weddingTypes && params.filters.weddingTypes.length > 0) {
      query = query.overlaps('target_wedding_types', params.filters.weddingTypes);
    }

    // Apply sorting
    switch (params.sortBy) {
      case 'price':
        query = query.order('price_cents', { ascending: params.sortDirection === 'ASC' });
        break;
      case 'rating':
        query = query
          .order('average_rating', { ascending: params.sortDirection === 'ASC' })
          .order('rating_count', { ascending: false });
        break;
      case 'popularity':
        query = query
          .order('install_count', { ascending: params.sortDirection === 'ASC' })
          .order('average_rating', { ascending: false });
        break;
      case 'newest':
        query = query.order('created_at', { ascending: params.sortDirection === 'ASC' });
        break;
      case 'featured':
        query = query
          .order('featured', { ascending: false })
          .order('average_rating', { ascending: false });
        break;
      default: // relevance
        if (params.query && params.query.length > 0) {
          // For text searches, PostgreSQL handles relevance ranking
          query = query
            .order('featured', { ascending: false })
            .order('average_rating', { ascending: false });
        } else {
          // For non-search queries, sort by featured and rating
          query = query
            .order('featured', { ascending: false })
            .order('average_rating', { ascending: false })
            .order('install_count', { ascending: false });
        }
    }

    // Apply pagination
    query = query.range(offset, offset + params.limit! - 1);

    const { data, error, count } = await query;

    if (error) {
      console.error('Search query error:', error);
      return null;
    }

    // Enhance results with highlighting for text searches
    const enhancedTemplates = params.query && params.query.length > 0 
      ? data.map(template => enhanceWithHighlighting(template, params.query!))
      : data;

    return {
      templates: enhancedTemplates,
      total: count || 0
    };

  } catch (error) {
    console.error('Search execution error:', error);
    return null;
  }
}

function enhanceWithHighlighting(template: any, query: string): MarketplaceTemplate {
  // Simple highlighting implementation - could be enhanced with more sophisticated algorithms
  const highlightText = (text: string, query: string): string => {
    if (!query || !text) return text;
    
    const words = query.toLowerCase().split(/\s+/);
    let highlighted = text;
    
    words.forEach(word => {
      if (word.length > 2) { // Only highlight words longer than 2 characters
        const regex = new RegExp(`(${word})`, 'gi');
        highlighted = highlighted.replace(regex, '<mark>$1</mark>');
      }
    });
    
    return highlighted;
  };

  return {
    ...template,
    highlighted_title: highlightText(template.title, query),
    highlighted_description: highlightText(
      template.description.length > 200 
        ? template.description.substring(0, 200) + '...' 
        : template.description, 
      query
    )
  };
}

async function getFacetCounts(params: SearchParams): Promise<object> {
  try {
    // Build a base query for facet calculation
    let baseQuery = supabase
      .from('marketplace_templates')
      .select('category, minimum_tier, price_cents, average_rating, tags, target_wedding_types')
      .eq('status', 'active');

    // Apply the same filters as the main search (except the one we're faceting on)
    if (params.query && params.query.length > 0) {
      baseQuery = baseQuery.textSearch('search_vector', params.query, { 
        type: 'websearch',
        config: 'english'
      });
    }

    // Apply other filters for facet context
    if (params.filters?.subcategory) {
      baseQuery = baseQuery.eq('subcategory', params.filters.subcategory);
    }
    
    if (params.filters?.priceMin !== undefined) {
      baseQuery = baseQuery.gte('price_cents', params.filters.priceMin);
    }
    
    if (params.filters?.priceMax !== undefined) {
      baseQuery = baseQuery.lte('price_cents', params.filters.priceMax);
    }
    
    if (params.filters?.ratingMin !== undefined) {
      baseQuery = baseQuery.gte('average_rating', params.filters.ratingMin);
    }

    const { data: baseResults, error } = await baseQuery;

    if (error || !baseResults) {
      console.error('Facet query error:', error);
      return {};
    }

    // Calculate facets from the results
    const facets = {
      categories: {},
      tiers: {},
      priceRanges: {
        '0-1000': 0,
        '1000-2500': 0, 
        '2500-5000': 0,
        '5000-10000': 0,
        '10000+': 0
      },
      ratings: {
        '4.5+': 0,
        '4.0+': 0,
        '3.5+': 0,
        '3.0+': 0
      },
      tags: {},
      weddingTypes: {}
    };

    baseResults.forEach((template: any) => {
      // Category facets
      facets.categories[template.category] = (facets.categories[template.category] || 0) + 1;
      
      // Tier facets
      facets.tiers[template.minimum_tier] = (facets.tiers[template.minimum_tier] || 0) + 1;
      
      // Price range facets
      if (template.price_cents < 1000) facets.priceRanges['0-1000']++;
      else if (template.price_cents < 2500) facets.priceRanges['1000-2500']++;
      else if (template.price_cents < 5000) facets.priceRanges['2500-5000']++;
      else if (template.price_cents < 10000) facets.priceRanges['5000-10000']++;
      else facets.priceRanges['10000+']++;
      
      // Rating facets
      if (template.average_rating >= 4.5) facets.ratings['4.5+']++;
      if (template.average_rating >= 4.0) facets.ratings['4.0+']++;
      if (template.average_rating >= 3.5) facets.ratings['3.5+']++;
      if (template.average_rating >= 3.0) facets.ratings['3.0+']++;
      
      // Tag facets (top 20 most common)
      if (template.tags) {
        template.tags.forEach((tag: string) => {
          facets.tags[tag] = (facets.tags[tag] || 0) + 1;
        });
      }
      
      // Wedding type facets
      if (template.target_wedding_types) {
        template.target_wedding_types.forEach((type: string) => {
          facets.weddingTypes[type] = (facets.weddingTypes[type] || 0) + 1;
        });
      }
    });

    // Limit tag facets to top 20
    const sortedTags = Object.entries(facets.tags)
      .sort(([,a], [,b]) => (b as number) - (a as number))
      .slice(0, 20);
    facets.tags = Object.fromEntries(sortedTags);

    return facets;

  } catch (error) {
    console.error('Facet calculation error:', error);
    return {};
  }
}

async function recordSearchAnalytics(data: {
  userId: string | null;
  sessionId: string;
  query: string;
  filters: SearchFilters;
  resultCount: number;
}): Promise<void> {
  try {
    await supabase
      .from('marketplace_search_analytics')
      .insert({
        user_id: data.userId,
        session_id: data.sessionId,
        search_query: data.query,
        filters_applied: data.filters,
        result_count: data.resultCount,
        search_timestamp: new Date().toISOString()
      });
  } catch (error) {
    console.error('Failed to record search analytics:', error);
    // Don't fail the request if analytics recording fails
  }
}