import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@supabase/supabase-js'

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_KEY!
)

interface MarketplaceTemplatesRequest {
  category?: string
  subcategory?: string
  minPrice?: number
  maxPrice?: number
  minTier?: 'starter' | 'professional' | 'scale'
  sort?: 'popular' | 'newest' | 'price_low' | 'price_high' | 'rating'
  search?: string
  page?: number
  limit?: number
  targetWeddingTypes?: string[]
  priceRange?: string
}

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams
    const params: MarketplaceTemplatesRequest = {
      category: searchParams.get('category') || undefined,
      subcategory: searchParams.get('subcategory') || undefined,
      minPrice: searchParams.get('minPrice') ? Number(searchParams.get('minPrice')) : undefined,
      maxPrice: searchParams.get('maxPrice') ? Number(searchParams.get('maxPrice')) : undefined,
      minTier: (searchParams.get('minTier') as 'starter' | 'professional' | 'scale') || undefined,
      sort: (searchParams.get('sort') as 'popular' | 'newest' | 'price_low' | 'price_high' | 'rating') || 'popular',
      search: searchParams.get('search') || undefined,
      page: Number(searchParams.get('page')) || 1,
      limit: Number(searchParams.get('limit')) || 12,
      targetWeddingTypes: searchParams.get('targetWeddingTypes')?.split(',') || undefined,
      priceRange: searchParams.get('priceRange') || undefined
    }

    // Build the query
    let query = supabase
      .from('marketplace_templates')
      .select(`
        id,
        title,
        description,
        template_type,
        category,
        subcategory,
        price_cents,
        currency,
        minimum_tier,
        preview_images,
        install_count,
        average_rating,
        rating_count,
        featured,
        tags,
        target_wedding_types,
        target_price_range,
        suppliers!inner (
          id,
          business_name,
          vendor_type
        )
      `)
      .eq('status', 'active')

    // Apply filters
    if (params.category && params.category !== 'all') {
      query = query.eq('category', params.category)
    }

    if (params.subcategory) {
      query = query.eq('subcategory', params.subcategory)
    }

    if (params.minPrice) {
      query = query.gte('price_cents', params.minPrice * 100)
    }

    if (params.maxPrice) {
      query = query.lte('price_cents', params.maxPrice * 100)
    }

    if (params.minTier) {
      const tierLevels = { starter: 1, professional: 2, scale: 3 }
      const tierLevel = tierLevels[params.minTier]
      // This would need a database function or view to properly filter by tier level
      // For now, we'll do basic filtering
      if (params.minTier === 'professional') {
        query = query.in('minimum_tier', ['starter', 'professional'])
      } else if (params.minTier === 'scale') {
        query = query.in('minimum_tier', ['starter', 'professional', 'scale'])
      }
    }

    if (params.search) {
      query = query.or(`title.ilike.%${params.search}%,description.ilike.%${params.search}%,tags.cs.{${params.search}}`)
    }

    if (params.targetWeddingTypes && params.targetWeddingTypes.length > 0) {
      query = query.overlaps('target_wedding_types', params.targetWeddingTypes)
    }

    if (params.priceRange) {
      query = query.eq('target_price_range', params.priceRange)
    }

    // Apply sorting
    switch (params.sort) {
      case 'popular':
        query = query.order('install_count', { ascending: false })
        break
      case 'newest':
        query = query.order('created_at', { ascending: false })
        break
      case 'price_low':
        query = query.order('price_cents', { ascending: true })
        break
      case 'price_high':
        query = query.order('price_cents', { ascending: false })
        break
      case 'rating':
        query = query.order('average_rating', { ascending: false })
        break
      default:
        query = query.order('featured', { ascending: false })
          .order('install_count', { ascending: false })
    }

    // Apply pagination
    const offset = (params.page - 1) * params.limit
    query = query.range(offset, offset + params.limit - 1)

    const { data: templates, error, count } = await query

    if (error) {
      console.error('Database error:', error)
      return NextResponse.json({ error: 'Failed to fetch templates' }, { status: 500 })
    }

    // Transform data to match interface
    const transformedTemplates = templates?.map(template => ({
      id: template.id,
      title: template.title,
      description: template.description,
      templateType: template.template_type,
      category: template.category,
      subcategory: template.subcategory,
      priceCents: template.price_cents,
      currency: template.currency,
      minimumTier: template.minimum_tier,
      previewImages: template.preview_images || [],
      installCount: template.install_count || 0,
      averageRating: template.average_rating || 0,
      ratingCount: template.rating_count || 0,
      creator: {
        id: template.suppliers.id,
        businessName: template.suppliers.business_name,
        vendorType: template.suppliers.vendor_type,
        avatarUrl: `/api/placeholder/40/40` // Would be from supplier profile
      },
      featured: template.featured || false,
      tags: template.tags || [],
      targetWeddingTypes: template.target_wedding_types || [],
      targetPriceRange: template.target_price_range || ''
    })) || []

    // Get category counts for filters
    const { data: categoryCounts } = await supabase
      .from('marketplace_templates')
      .select('category, count(*)')
      .eq('status', 'active')
      .group('category')

    const categoryCountMap = categoryCounts?.reduce((acc, item) => {
      acc[item.category] = item.count
      return acc
    }, {} as Record<string, number>) || {}

    // Get total count for pagination
    const { count: totalCount } = await supabase
      .from('marketplace_templates')
      .select('*', { count: 'exact', head: true })
      .eq('status', 'active')

    const response = {
      templates: transformedTemplates,
      pagination: {
        page: params.page,
        limit: params.limit,
        total: totalCount || 0,
        hasMore: (totalCount || 0) > offset + params.limit
      },
      filters: {
        categories: Object.entries(categoryCountMap).map(([name, count]) => ({
          name,
          count
        })),
        priceRanges: [
          { range: '£0-25', count: 0 },
          { range: '£25-50', count: 0 },
          { range: '£50-100', count: 0 },
          { range: '£100+', count: 0 }
        ],
        tiers: [
          { tier: 'starter', count: 0 },
          { tier: 'professional', count: 0 },
          { tier: 'scale', count: 0 }
        ]
      }
    }

    return NextResponse.json(response)

  } catch (error) {
    console.error('API error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}