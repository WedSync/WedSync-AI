/**
 * WS-168: Optimized Customer Success Health Score API
 * High-performance API with caching, pagination, and streaming support
 */

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth/config';
import { withSecureValidation } from '@/lib/validation/middleware';
import { z } from 'zod';
import { createClient } from '@/lib/supabase/server';
import { ratelimit } from '@/lib/ratelimit';
import { Redis } from 'ioredis';
import { performance } from 'perf_hooks';

// Performance monitoring
import { reportApiMetrics } from '@/lib/monitoring/api-metrics';

// Redis client for caching
const redis = new Redis({
  host: process.env.REDIS_HOST,
  port: parseInt(process.env.REDIS_PORT || '6379'),
  retryDelayOnFailover: 100,
  maxRetriesPerRequest: 3,
});

// Cache configuration
const CACHE_CONFIG = {
  healthScore: {
    ttl: 300, // 5 minutes
    key: (orgId: string, userId?: string) => `health:${orgId}:${userId || 'all'}`
  },
  dashboardMetrics: {
    ttl: 180, // 3 minutes
    key: (orgId: string, filters: string) => `dashboard:${orgId}:${filters}`
  },
  distribution: {
    ttl: 600, // 10 minutes
    key: (orgId: string) => `distribution:${orgId}`
  }
} as const;

// Optimized validation schemas
const optimizedHealthQuerySchema = z.object({
  userId: z.string().uuid().optional(),
  organizationId: z.string().uuid().optional(),
  timeframe: z.enum(['7d', '30d', '90d']).default('30d'),
  includeRecommendations: z.boolean().default(false), // Default to false for performance
  includeHistory: z.boolean().default(false),
  page: z.number().int().positive().default(1),
  limit: z.number().int().min(1).max(100).default(25),
  search: z.string().max(100).optional(),
  status: z.enum(['all', 'healthy', 'at-risk', 'critical']).default('all'),
  sortBy: z.enum(['score', 'name', 'risk', 'activity']).default('score'),
  sortOrder: z.enum(['asc', 'desc']).default('desc'),
  forceRefresh: z.boolean().default(false)
});

const bulkHealthQuerySchema = z.object({
  organizationId: z.string().uuid(),
  userIds: z.array(z.string().uuid()).max(50).optional(), // Limit batch size
  filters: z.object({
    minScore: z.number().min(0).max(100).optional(),
    maxScore: z.number().min(0).max(100).optional(),
    riskLevels: z.array(z.enum(['low', 'medium', 'high', 'critical'])).optional()
  }).optional(),
  includeMetrics: z.boolean().default(true),
  format: z.enum(['json', 'csv', 'stream']).default('json')
});

// Performance tracking utility
class ApiPerformanceTracker {
  private startTime: number;
  private queryCount = 0;
  private cacheHits = 0;
  
  constructor() {
    this.startTime = performance.now();
  }

  addQuery() {
    this.queryCount++;
  }

  addCacheHit() {
    this.cacheHits++;
  }

  getMetrics() {
    const duration = performance.now() - this.startTime;
    return {
      duration,
      queryCount: this.queryCount,
      cacheHits: this.cacheHits,
      cacheHitRate: this.queryCount > 0 ? this.cacheHits / this.queryCount : 0
    };
  }
}

// Optimized health score calculation with caching
async function getOptimizedHealthMetrics(
  supabase: any,
  organizationId: string,
  options: {
    search?: string;
    status?: string;
    page?: number;
    limit?: number;
    includeHistory?: boolean;
    forceRefresh?: boolean;
  }
) {
  const tracker = new ApiPerformanceTracker();
  const cacheKey = CACHE_CONFIG.dashboardMetrics.key(
    organizationId,
    JSON.stringify(options)
  );

  // Check cache unless force refresh
  if (!options.forceRefresh) {
    try {
      const cached = await redis.get(cacheKey);
      if (cached) {
        tracker.addCacheHit();
        return { data: JSON.parse(cached), metrics: tracker.getMetrics() };
      }
    } catch (error) {
      console.warn('Cache read error:', error);
    }
  }

  const offset = ((options.page || 1) - 1) * (options.limit || 25);

  // Build optimized query using the new database schema
  let query = supabase
    .from('customer_success_dashboard') // Use the optimized view
    .select(`
      organization_id,
      organization_name,
      subscription_tier,
      overall_score,
      health_status,
      churn_risk_percentage,
      days_since_last_login,
      score_trend,
      recent_interventions,
      pending_interventions,
      total_clients,
      total_forms,
      last_client_activity,
      health_score_updated
    `);

  // Apply filters
  if (options.search) {
    query = query.ilike('organization_name', `%${options.search}%`);
  }

  if (options.status && options.status !== 'all') {
    const statusMap = {
      'healthy': 'healthy',
      'at-risk': 'at_risk',
      'critical': 'critical'
    };
    query = query.eq('health_status', statusMap[options.status as keyof typeof statusMap]);
  }

  // Add ordering and pagination
  query = query
    .order('overall_score', { ascending: false })
    .range(offset, offset + (options.limit || 25) - 1);

  tracker.addQuery();
  const { data: healthData, error: healthError, count } = await query;

  if (healthError) {
    throw new Error(`Health data query failed: ${healthError.message}`);
  }

  // Get summary metrics in parallel
  const [summaryData, distributionData] = await Promise.all([
    getSummaryMetrics(supabase, organizationId, tracker),
    getHealthDistribution(supabase, organizationId, tracker)
  ]);

  const result = {
    summary: summaryData,
    health_distribution: distributionData,
    at_risk_users: healthData?.filter(d => d.health_status === 'at_risk' || d.health_status === 'critical') || [],
    engagement_trends: await getEngagementTrends(supabase, organizationId, 30, tracker),
    pagination: {
      page: options.page || 1,
      limit: options.limit || 25,
      total: count || 0,
      hasMore: (count || 0) > offset + (options.limit || 25)
    },
    metadata: {
      cached: false,
      queryTime: tracker.getMetrics().duration,
      lastUpdated: new Date().toISOString()
    }
  };

  // Cache the result
  try {
    await redis.setex(cacheKey, CACHE_CONFIG.dashboardMetrics.ttl, JSON.stringify(result));
  } catch (error) {
    console.warn('Cache write error:', error);
  }

  return { data: result, metrics: tracker.getMetrics() };
}

// Optimized summary metrics with single query
async function getSummaryMetrics(supabase: any, organizationId: string, tracker: ApiPerformanceTracker) {
  tracker.addQuery();
  
  // Single aggregation query for all summary metrics
  const { data, error } = await supabase.rpc('get_organization_summary_metrics', {
    p_organization_id: organizationId
  });

  if (error) {
    console.error('Summary metrics error:', error);
    return {
      total_users: 0,
      average_health_score: 0,
      milestones_achieved_today: 0,
      at_risk_users: 0,
      champion_users: 0
    };
  }

  return data[0] || {
    total_users: 0,
    average_health_score: 0,
    milestones_achieved_today: 0,
    at_risk_users: 0,
    champion_users: 0
  };
}

// Optimized health distribution calculation
async function getHealthDistribution(supabase: any, organizationId: string, tracker: ApiPerformanceTracker) {
  const cacheKey = CACHE_CONFIG.distribution.key(organizationId);
  
  try {
    const cached = await redis.get(cacheKey);
    if (cached) {
      tracker.addCacheHit();
      return JSON.parse(cached);
    }
  } catch (error) {
    console.warn('Cache read error for distribution:', error);
  }

  tracker.addQuery();
  const { data, error } = await supabase
    .from('customer_health_scores')
    .select('health_status, overall_score')
    .eq('organization_id', organizationId)
    .gte('score_calculation_date', new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString());

  if (error || !data) {
    return [];
  }

  // Calculate distribution ranges
  const ranges = [
    { range: '0-20 (Critical)', min: 0, max: 20 },
    { range: '21-40 (High Risk)', min: 21, max: 40 },
    { range: '41-60 (Medium Risk)', min: 41, max: 60 },
    { range: '61-80 (Low Risk)', min: 61, max: 80 },
    { range: '81-100 (Healthy)', min: 81, max: 100 }
  ];

  const distribution = ranges.map(range => {
    const count = data.filter(d => 
      d.overall_score >= range.min && d.overall_score <= range.max
    ).length;
    
    return {
      range: range.range,
      count,
      percentage: data.length > 0 ? (count / data.length * 100) : 0
    };
  });

  // Cache the distribution
  try {
    await redis.setex(cacheKey, CACHE_CONFIG.distribution.ttl, JSON.stringify(distribution));
  } catch (error) {
    console.warn('Cache write error for distribution:', error);
  }

  return distribution;
}

// Optimized engagement trends
async function getEngagementTrends(supabase: any, organizationId: string, days: number, tracker: ApiPerformanceTracker) {
  tracker.addQuery();
  
  const { data, error } = await supabase.rpc('get_engagement_trends', {
    p_organization_id: organizationId,
    p_days: days
  });

  if (error || !data) {
    // Return mock data for now
    const mockTrends = [];
    for (let i = days - 1; i >= 0; i--) {
      const date = new Date();
      date.setDate(date.getDate() - i);
      mockTrends.push({
        date: date.toISOString().split('T')[0],
        active_users: Math.floor(Math.random() * 50) + 20,
        avg_engagement_score: Math.floor(Math.random() * 40) + 60
      });
    }
    return mockTrends;
  }

  return data;
}

/**
 * GET /api/customer-success/health-score-optimized
 * Optimized endpoint for dashboard metrics with caching and pagination
 */
export const GET = withSecureValidation(
  optimizedHealthQuerySchema,
  async (request: NextRequest, validatedData) => {
    const startTime = performance.now();
    const identifier = request.ip ?? 'anonymous';

    // Apply rate limiting with higher limits for authenticated users
    const { success, remaining } = await ratelimit.limit(identifier);
    
    if (!success) {
      return NextResponse.json(
        { error: 'Rate limit exceeded', remaining },
        { status: 429 }
      );
    }

    try {
      const session = await getServerSession(authOptions);
      if (!session?.user) {
        return NextResponse.json(
          { error: 'Authentication required' },
          { status: 401 }
        );
      }

      const organizationId = validatedData.organizationId || session.user.organizationId;

      // Authorization check
      if (!session.user.isAdmin && organizationId !== session.user.organizationId) {
        return NextResponse.json(
          { error: 'Access denied' },
          { status: 403 }
        );
      }

      const supabase = createClient();
      
      const { data: healthMetrics, metrics } = await getOptimizedHealthMetrics(
        supabase,
        organizationId,
        {
          search: validatedData.search,
          status: validatedData.status,
          page: validatedData.page,
          limit: validatedData.limit,
          includeHistory: validatedData.includeHistory,
          forceRefresh: validatedData.forceRefresh
        }
      );

      const totalDuration = performance.now() - startTime;

      // Report performance metrics
      reportApiMetrics({
        endpoint: 'health-score-optimized',
        method: 'GET',
        duration: totalDuration,
        organizationId,
        userId: session.user.id,
        cacheHitRate: metrics.cacheHitRate,
        queryCount: metrics.queryCount
      });

      return NextResponse.json({
        success: true,
        data: healthMetrics,
        performance: {
          totalDuration: Math.round(totalDuration),
          queryCount: metrics.queryCount,
          cacheHits: metrics.cacheHits,
          remaining: remaining
        }
      });

    } catch (error) {
      const duration = performance.now() - startTime;
      
      console.error('Optimized health score API error:', error);
      
      // Report error metrics
      reportApiMetrics({
        endpoint: 'health-score-optimized',
        method: 'GET',
        duration,
        error: error instanceof Error ? error.message : 'Unknown error',
        success: false
      });

      return NextResponse.json(
        { 
          error: 'Failed to fetch health metrics',
          message: error instanceof Error ? error.message : 'Unknown error',
          duration: Math.round(duration)
        },
        { status: 500 }
      );
    }
  }
);

/**
 * POST /api/customer-success/health-score-optimized/bulk
 * Bulk health score calculation with streaming support
 */
export const POST = withSecureValidation(
  bulkHealthQuerySchema,
  async (request: NextRequest, validatedData) => {
    const startTime = performance.now();
    const identifier = request.ip ?? 'anonymous';

    // Stricter rate limiting for bulk operations
    const { success, remaining } = await ratelimit.limit(identifier, { 
      requests: 5,
      window: '1m'
    });
    
    if (!success) {
      return NextResponse.json(
        { error: 'Rate limit exceeded for bulk operations', remaining },
        { status: 429 }
      );
    }

    try {
      const session = await getServerSession(authOptions);
      if (!session?.user?.isAdmin) {
        return NextResponse.json(
          { error: 'Admin access required' },
          { status: 403 }
        );
      }

      const organizationId = validatedData.organizationId;

      // Additional authorization check
      if (organizationId !== session.user.organizationId) {
        return NextResponse.json(
          { error: 'Access denied to organization data' },
          { status: 403 }
        );
      }

      const supabase = createClient();
      const tracker = new ApiPerformanceTracker();

      // Handle streaming response for large datasets
      if (validatedData.format === 'stream') {
        return handleStreamingResponse(supabase, validatedData, tracker);
      }

      // Handle CSV export
      if (validatedData.format === 'csv') {
        return handleCsvExport(supabase, validatedData, tracker);
      }

      // Regular JSON response for smaller datasets
      const results = await processBulkHealthScores(supabase, validatedData, tracker);
      
      const totalDuration = performance.now() - startTime;
      const metrics = tracker.getMetrics();

      // Report performance metrics
      reportApiMetrics({
        endpoint: 'health-score-optimized-bulk',
        method: 'POST',
        duration: totalDuration,
        organizationId,
        userId: session.user.id,
        queryCount: metrics.queryCount,
        recordCount: results.processedCount || 0
      });

      return NextResponse.json({
        success: true,
        data: results,
        performance: {
          totalDuration: Math.round(totalDuration),
          queryCount: metrics.queryCount,
          recordsProcessed: results.processedCount || 0,
          remaining: remaining
        }
      });

    } catch (error) {
      const duration = performance.now() - startTime;
      
      console.error('Bulk health score API error:', error);
      
      reportApiMetrics({
        endpoint: 'health-score-optimized-bulk',
        method: 'POST',
        duration,
        error: error instanceof Error ? error.message : 'Unknown error',
        success: false
      });

      return NextResponse.json(
        { 
          error: 'Failed to process bulk health score calculation',
          message: error instanceof Error ? error.message : 'Unknown error'
        },
        { status: 500 }
      );
    }
  }
);

// Helper function for processing bulk health scores
async function processBulkHealthScores(supabase: any, validatedData: any, tracker: ApiPerformanceTracker) {
  let query = supabase.from('customer_success_dashboard');
  
  if (validatedData.userIds && validatedData.userIds.length > 0) {
    query = query.in('organization_id', validatedData.userIds);
  }

  if (validatedData.filters) {
    if (validatedData.filters.minScore !== undefined) {
      query = query.gte('overall_score', validatedData.filters.minScore);
    }
    if (validatedData.filters.maxScore !== undefined) {
      query = query.lte('overall_score', validatedData.filters.maxScore);
    }
    if (validatedData.filters.riskLevels && validatedData.filters.riskLevels.length > 0) {
      query = query.in('health_status', validatedData.filters.riskLevels);
    }
  }

  query = query.select(`
    organization_id,
    organization_name,
    overall_score,
    health_status,
    churn_risk_percentage,
    recent_interventions,
    total_clients,
    health_score_updated
  `);

  tracker.addQuery();
  const { data, error, count } = await query;

  if (error) {
    throw new Error(`Bulk query failed: ${error.message}`);
  }

  return {
    results: data || [],
    processedCount: data?.length || 0,
    totalCount: count || 0,
    calculatedAt: new Date().toISOString()
  };
}

// Helper function for streaming large datasets
async function handleStreamingResponse(supabase: any, validatedData: any, tracker: ApiPerformanceTracker) {
  // Implementation for streaming large datasets
  // This would use ReadableStream for efficient memory usage
  const encoder = new TextEncoder();
  
  const stream = new ReadableStream({
    async start(controller) {
      try {
        // Stream data in chunks
        const chunkSize = 100;
        let offset = 0;
        let hasMore = true;

        while (hasMore) {
          const { data, error } = await supabase
            .from('customer_success_dashboard')
            .select('*')
            .range(offset, offset + chunkSize - 1);
          
          if (error) {
            controller.error(error);
            return;
          }

          if (!data || data.length === 0) {
            hasMore = false;
          } else {
            const chunk = JSON.stringify(data) + '\n';
            controller.enqueue(encoder.encode(chunk));
            offset += chunkSize;
            hasMore = data.length === chunkSize;
          }
        }
        
        controller.close();
      } catch (error) {
        controller.error(error);
      }
    }
  });

  return new NextResponse(stream, {
    headers: {
      'Content-Type': 'application/x-ndjson',
      'Cache-Control': 'no-cache',
    }
  });
}

// Helper function for CSV export
async function handleCsvExport(supabase: any, validatedData: any, tracker: ApiPerformanceTracker) {
  // Implementation for CSV export
  const { data, error } = await processBulkHealthScores(supabase, validatedData, tracker);
  
  if (error) {
    throw error;
  }

  // Convert to CSV
  const headers = ['Organization ID', 'Organization Name', 'Health Score', 'Status', 'Risk %', 'Last Updated'];
  const csvContent = [
    headers.join(','),
    ...data.results.map((row: any) => [
      row.organization_id,
      `"${row.organization_name}"`,
      row.overall_score,
      row.health_status,
      row.churn_risk_percentage,
      row.health_score_updated
    ].join(','))
  ].join('\n');

  return new NextResponse(csvContent, {
    headers: {
      'Content-Type': 'text/csv',
      'Content-Disposition': 'attachment; filename="customer-health-export.csv"',
      'Cache-Control': 'no-cache',
    }
  });
}