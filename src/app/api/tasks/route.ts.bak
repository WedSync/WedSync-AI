import { NextRequest, NextResponse } from 'next/server';
import { TaskCreationService } from '@/lib/services/task-creation-service';
import { TaskTemplateService } from '@/lib/services/task-template-service';
import { TaskSecurityMiddleware } from '@/middleware/task-security';
import { z } from 'zod';

// Edge Runtime for optimal performance - revolutionary upgrade
export const runtime = 'edge';

// Initialize services with dependency injection
const taskCreationService = new TaskCreationService();
const taskTemplateService = new TaskTemplateService();
const securityMiddleware = new TaskSecurityMiddleware();

// Validation schemas for input sanitization
const createTaskSchema = z.object({
  title: z.string().min(3).max(200),
  description: z.string().max(2000).optional(),
  category: z.enum([
    'VENUE_MANAGEMENT',
    'VENDOR_COORDINATION', 
    'CLIENT_MANAGEMENT',
    'LOGISTICS',
    'DESIGN',
    'PHOTOGRAPHY',
    'CATERING',
    'FLORALS',
    'MUSIC',
    'TRANSPORTATION'
  ]),
  priority: z.enum(['LOW', 'MEDIUM', 'HIGH', 'CRITICAL']),
  deadline: z.string().datetime().optional(),
  assigned_to: z.string().uuid().optional(),
  vendor_id: z.string().uuid().optional(),
  estimated_duration: z.number().min(0.25).max(24).optional(),
  buffer_time: z.number().min(0).max(4).optional(),
  dependencies: z.array(z.string().uuid()).optional(),
  notes: z.string().max(1000).optional()
});

const bulkTaskCreationSchema = z.object({
  template_ids: z.array(z.string().uuid()).optional(),
  individual_tasks: z.array(createTaskSchema).optional(),
  customizations: z.record(z.any()).optional(),
  wedding_date: z.string().datetime(),
  force_create: z.boolean().default(false)
});

const timingValidationSchema = z.object({
  task_data: createTaskSchema,
  exclude_task_id: z.string().uuid().optional()
});

/**
 * POST /api/tasks - Action-based Task Management API
 * Revolutionary security implementation with comprehensive validation
 * Compatible with existing action-based API pattern
 */
export async function POST(request: NextRequest) {
  let security_result: any = null;
  let request_data: any = null;
  
  try {
    // Parse and validate request structure
    const raw_data = await request.json();
    const { action, data } = raw_data;

    if (!action || !data) {
      return NextResponse.json({
        success: false,
        error: 'Missing required fields: action and data',
        code: 'INVALID_REQUEST_FORMAT'
      }, { status: 400 });
    }

    request_data = data;
    const wedding_id = data.wedding_id;

    if (!wedding_id) {
      return NextResponse.json({
        success: false,
        error: 'Wedding ID is required',
        code: 'MISSING_WEDDING_ID'
      }, { status: 400 });
    }

    // Revolutionary security validation - addresses 305+ unprotected endpoint vulnerability
    security_result = await securityMiddleware.validateTaskAccess(
      request,
      wedding_id,
      action
    );

    if (!security_result.valid) {
      return NextResponse.json({
        success: false,
        error: security_result.message,
        code: 'SECURITY_VALIDATION_FAILED'
      }, { status: security_result.status });
    }

    // Route to specific action handler
    const result = await routeTaskAction(action, data, security_result.user);

    // Comprehensive audit logging
    await securityMiddleware.auditTaskOperation({
      user_id: security_result.user.id,
      wedding_id,
      action,
      resource_type: 'task',
      data_snapshot: data,
      result_snapshot: result,
      ip_address: security_result.audit_context!.ip_address,
      user_agent: security_result.audit_context!.user_agent,
      request_id: security_result.audit_context!.request_id,
      severity: result.success ? 'low' : 'medium'
    });

    // Return with performance headers
    return NextResponse.json(result, {
      status: result.success ? 200 : 400,
      headers: {
        'Cache-Control': 'no-cache',
        'Content-Type': 'application/json',
        'X-Request-ID': security_result.audit_context!.request_id
      }
    });

  } catch (error) {
    console.error('Task API error:', error);

    // Security audit for errors
    if (security_result?.valid) {
      await securityMiddleware.auditTaskOperation({
        user_id: security_result.user.id,
        wedding_id: request_data?.wedding_id || 'unknown',
        action: 'unknown',
        resource_type: 'task',
        data_snapshot: request_data,
        result_snapshot: { error: error.message },
        ip_address: security_result.audit_context!.ip_address,
        user_agent: security_result.audit_context!.user_agent,
        request_id: security_result.audit_context!.request_id,
        severity: 'high'
      });
    }

    return NextResponse.json({
      success: false,
      error: 'Internal server error',
      code: 'INTERNAL_ERROR',
      request_id: security_result?.audit_context?.request_id || crypto.randomUUID()
    }, { status: 500 });
  }
}

/**
 * GET /api/tasks - Task querying with advanced filtering
 * Compatible with existing analytics and dependency endpoints
 */
export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const action = searchParams.get('action');
  const wedding_id = searchParams.get('weddingId');

  if (!action || !wedding_id) {
    return NextResponse.json({
      success: false,
      error: 'Missing required parameters: action and weddingId',
      code: 'MISSING_PARAMETERS'
    }, { status: 400 });
  }

  try {
    // Security validation for GET requests
    const security_result = await securityMiddleware.validateTaskAccess(
      request,
      wedding_id,
      action
    );

    if (!security_result.valid) {
      return NextResponse.json({
        success: false,
        error: security_result.message,
        code: 'SECURITY_VALIDATION_FAILED'
      }, { status: security_result.status });
    }

    // Route to GET action handler
    const result = await routeTaskGetAction(action, searchParams, security_result.user);

    return NextResponse.json(result, {
      status: 200,
      headers: {
        'Cache-Control': 'private, max-age=60',
        'Content-Type': 'application/json'
      }
    });

  } catch (error) {
    console.error('Task GET API error:', error);
    
    return NextResponse.json({
      success: false,
      error: 'Failed to fetch task data',
      code: 'FETCH_FAILED'
    }, { status: 500 });
  }
}

/**
 * Action router for POST operations
 * Implements comprehensive input validation and business logic
 */
async function routeTaskAction(action: string, data: any, user: any) {
  switch (action) {
    case 'create_single_task':
      return await handleCreateSingleTask(data, user);
      
    case 'create_bulk_tasks':
      return await handleCreateBulkTasks(data, user);
      
    case 'validate_timing':
      return await handleValidateTiming(data, user);
      
    case 'detect_conflicts':
      return await handleDetectConflicts(data, user);

    case 'update_task':
      return await handleUpdateTask(data, user);

    case 'delete_task':
      return await handleDeleteTask(data, user);

    default:
      return {
        success: false,
        error: `Unknown action: ${action}`,
        code: 'UNKNOWN_ACTION'
      };
  }
}

/**
 * Action router for GET operations
 */
async function routeTaskGetAction(action: string, searchParams: URLSearchParams, user: any) {
  const wedding_id = searchParams.get('weddingId')!;

  switch (action) {
    case 'list_tasks':
      return await handleListTasks(wedding_id, searchParams, user);
      
    case 'get_task_details':
      const task_id = searchParams.get('taskId');
      if (!task_id) throw new Error('Task ID required for get_task_details');
      return await handleGetTaskDetails(task_id, user);
      
    case 'get_timing_analytics':
      return await handleGetTimingAnalytics(wedding_id, user);

    case 'export_tasks':
      return await handleExportTasks(wedding_id, searchParams, user);

    default:
      return {
        success: false,
        error: `Unknown GET action: ${action}`,
        code: 'UNKNOWN_GET_ACTION'
      };
  }
}

// Action handlers with validation

async function handleCreateSingleTask(data: any, user: any) {
  try {
    // Validate input against schema
    const validated_data = createTaskSchema.parse(data.task_data);
    
    const result = await taskCreationService.createSingleTask(
      data.wedding_id,
      {
        ...validated_data,
        deadline: validated_data.deadline ? new Date(validated_data.deadline) : undefined
      },
      user.id
    );

    return {
      success: result.success,
      data: result.task,
      conflicts: result.conflicts || [],
      suggestions: result.suggestions || [],
      warnings: result.warnings || [],
      message: result.success ? 'Task created successfully' : 'Task creation failed'
    };

  } catch (error) {
    if (error instanceof z.ZodError) {
      return {
        success: false,
        error: 'Validation failed',
        code: 'VALIDATION_ERROR',
        details: error.errors
      };
    }

    console.error('Create single task error:', error);
    return {
      success: false,
      error: error.message,
      code: 'CREATION_FAILED'
    };
  }
}

async function handleCreateBulkTasks(data: any, user: any) {
  try {
    // Validate bulk creation request
    const validated_data = bulkTaskCreationSchema.parse(data.request);
    
    const result = await taskCreationService.createBulkTasks(
      data.wedding_id,
      validated_data,
      user.id
    );

    return {
      success: result.success,
      data: {
        created_tasks: result.created_tasks || [],
        template_usage: result.template_usage || [],
        skipped_tasks: result.skipped_tasks || []
      },
      conflicts: result.conflicts || [],
      affected_tasks: result.affected_tasks || [],
      message: result.success 
        ? `Successfully created ${result.created_tasks?.length || 0} tasks`
        : 'Bulk task creation failed'
    };

  } catch (error) {
    if (error instanceof z.ZodError) {
      return {
        success: false,
        error: 'Bulk validation failed',
        code: 'BULK_VALIDATION_ERROR',
        details: error.errors
      };
    }

    console.error('Create bulk tasks error:', error);
    return {
      success: false,
      error: error.message,
      code: 'BULK_CREATION_FAILED'
    };
  }
}

async function handleValidateTiming(data: any, user: any) {
  try {
    // Validate timing request
    const validated_data = timingValidationSchema.parse(data);
    
    const result = await taskCreationService.validateTaskTiming(
      data.wedding_id,
      {
        ...validated_data.task_data,
        deadline: validated_data.task_data.deadline ? new Date(validated_data.task_data.deadline) : undefined
      },
      validated_data.exclude_task_id
    );

    return {
      success: true,
      data: {
        valid: result.valid,
        risk_level: result.risk_level,
        conflicts: result.conflicts,
        suggestions: result.suggestions
      },
      message: result.valid ? 'No timing conflicts detected' : `${result.conflicts.length} conflicts found`
    };

  } catch (error) {
    console.error('Validate timing error:', error);
    return {
      success: false,
      error: error.message,
      code: 'TIMING_VALIDATION_FAILED'
    };
  }
}

async function handleDetectConflicts(data: any, user: any) {
  try {
    const tasks = data.tasks || [];
    
    const conflicts = await taskCreationService.detectAllConflicts(
      data.wedding_id,
      tasks
    );

    return {
      success: true,
      data: {
        conflicts,
        conflict_count: conflicts.length,
        risk_level: conflicts.some(c => c.severity === 'critical') ? 'critical' :
                   conflicts.some(c => c.severity === 'high') ? 'high' :
                   conflicts.some(c => c.severity === 'medium') ? 'medium' : 'low'
      },
      message: `Detected ${conflicts.length} potential conflicts`
    };

  } catch (error) {
    console.error('Detect conflicts error:', error);
    return {
      success: false,
      error: error.message,
      code: 'CONFLICT_DETECTION_FAILED'
    };
  }
}

async function handleUpdateTask(data: any, user: any) {
  // Implementation would use existing task update logic
  return {
    success: false,
    error: 'Task update functionality to be implemented',
    code: 'NOT_IMPLEMENTED'
  };
}

async function handleDeleteTask(data: any, user: any) {
  // Implementation would use existing task deletion logic
  return {
    success: false,
    error: 'Task deletion functionality to be implemented', 
    code: 'NOT_IMPLEMENTED'
  };
}

async function handleListTasks(wedding_id: string, searchParams: URLSearchParams, user: any) {
  // Implementation would integrate with existing task listing
  return {
    success: false,
    error: 'Task listing functionality to be implemented',
    code: 'NOT_IMPLEMENTED'
  };
}

async function handleGetTaskDetails(task_id: string, user: any) {
  // Implementation would get task details with security validation
  return {
    success: false,
    error: 'Task details functionality to be implemented',
    code: 'NOT_IMPLEMENTED'
  };
}

async function handleGetTimingAnalytics(wedding_id: string, user: any) {
  // Implementation would provide timing analytics
  return {
    success: false,
    error: 'Timing analytics functionality to be implemented',
    code: 'NOT_IMPLEMENTED'
  };
}

async function handleExportTasks(wedding_id: string, searchParams: URLSearchParams, user: any) {
  // Implementation would export tasks in various formats
  return {
    success: false,
    error: 'Task export functionality to be implemented',
    code: 'NOT_IMPLEMENTED'
  };
}