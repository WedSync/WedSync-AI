/**
 * WS-241 AI Caching Strategy System - Security & Compliance API
 * Handles security monitoring, GDPR compliance, and audit operations
 * Team B - Backend Infrastructure & API Development
 */

import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { cookies } from 'next/headers';
import { CacheSecurityManager } from '@/lib/ai-cache/CacheSecurityManager';
import { ratelimit } from '@/lib/ratelimit';
import { z } from 'zod';

// Initialize security manager
const securityManager = new CacheSecurityManager(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!,
  process.env.REDIS_URL || 'redis://localhost:6379',
  {
    encryptionEnabled: true,
    encryptionKey: process.env.CACHE_ENCRYPTION_KEY!,
    auditLoggingEnabled: true,
    gdprComplianceMode: true,
    maxRetentionDays: 90,
    allowedOrigins: ['https://wedsync.com', 'https://*.wedsync.com'],
    maxRequestSize: 10 * 1024 * 1024, // 10MB
    rateLimitConfig: {
      windowMs: 15 * 60 * 1000, // 15 minutes
      max: 100
    },
    dataClassification: {
      pii_fields: ['email', 'phone', 'address', 'guest_names', 'vendor_contacts'],
      sensitive_fields: ['wedding_budget', 'payment_info', 'private_notes'],
      public_fields: ['venue_type', 'wedding_style', 'season', 'guest_count_range']
    }
  }
);

// Request validation schemas
const DataDeletionSchema = z.object({
  userId: z.string().uuid(),
  organizationId: z.string().uuid(),
  reason: z.string().min(1).max(500),
  confirmationToken: z.string().min(1)
});

const SecurityAuditSchema = z.object({
  eventType: z.enum(['access', 'modification', 'deletion', 'security_violation', 'data_export']),
  severity: z.enum(['low', 'medium', 'high', 'critical']).optional(),
  resourceType: z.string().min(1).max(100),
  resourceId: z.string().optional(),
  action: z.string().min(1).max(100),
  details: z.record(z.any()).optional()
});

export async function GET(request: NextRequest) {
  try {
    const startTime = Date.now();
    const url = new URL(request.url);
    const action = url.searchParams.get('action') || 'health';

    // Rate limiting - Security endpoints get stricter limits
    const identifier = request.headers.get('x-forwarded-for') || 'anonymous';
    const { success, limit, remaining, reset } = await ratelimit.limit(`security:${identifier}`);

    if (!success) {
      return NextResponse.json(
        { error: 'Too many security requests. Please try again later.' },
        { 
          status: 429,
          headers: {
            'X-RateLimit-Limit': limit.toString(),
            'X-RateLimit-Remaining': remaining.toString(),
            'X-RateLimit-Reset': reset.toString(),
          }
        }
      );
    }

    // Authentication check
    const supabase = createRouteHandlerClient({ cookies: cookies() });
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      // Log unauthorized access attempt
      await securityManager.logSecurityEvent({
        event_type: 'security_violation',
        severity: 'medium',
        resource_type: 'security_api',
        action: 'unauthorized_access_attempt',
        details: {
          endpoint: '/api/ai-cache/security',
          action: action,
          ip_address: request.headers.get('x-forwarded-for')
        },
        ip_address: request.headers.get('x-forwarded-for') || undefined,
        user_agent: request.headers.get('user-agent') || undefined
      });

      return NextResponse.json(
        { error: 'Unauthorized. Please log in to access security features.' },
        { status: 401 }
      );
    }

    // Get user's role and organization
    const { data: profile } = await supabase
      .from('user_profiles')
      .select('organization_id, role')
      .eq('user_id', user.id)
      .single();

    if (!profile?.organization_id) {
      return NextResponse.json(
        { error: 'User profile not found or no organization associated' },
        { status: 404 }
      );
    }

    // Most security endpoints require admin access
    const isAdmin = profile.role === 'OWNER' || profile.role === 'ADMIN';
    const requiresAdmin = ['violations', 'audit-logs', 'metrics', 'gdpr-report'];
    
    if (requiresAdmin.includes(action) && !isAdmin) {
      await securityManager.logSecurityEvent({
        event_type: 'security_violation',
        severity: 'medium',
        user_id: user.id,
        organization_id: profile.organization_id,
        resource_type: 'security_api',
        action: 'insufficient_privileges',
        details: {
          attempted_action: action,
          user_role: profile.role
        },
        ip_address: request.headers.get('x-forwarded-for') || undefined
      });

      return NextResponse.json(
        { error: 'Admin privileges required for this security operation' },
        { status: 403 }
      );
    }

    console.log(`Security ${action} requested by user ${user.id}, org ${profile.organization_id}`);

    let responseData;

    switch (action) {
      case 'health':
        responseData = await securityManager.securityHealthCheck();
        break;

      case 'metrics':
        responseData = await getSecurityMetrics(supabase, profile.organization_id);
        break;

      case 'violations':
        const hoursBack = parseInt(url.searchParams.get('hours') || '24');
        responseData = await getSecurityViolations(supabase, profile.organization_id, hoursBack);
        break;

      case 'audit-logs':
        const auditLimit = parseInt(url.searchParams.get('limit') || '50');
        responseData = await getAuditLogs(supabase, profile.organization_id, auditLimit);
        break;

      case 'gdpr-report':
        responseData = await securityManager.generateGDPRReport(profile.organization_id);
        break;

      case 'retention-status':
        responseData = await getRetentionStatus(supabase, profile.organization_id);
        break;

      default:
        return NextResponse.json(
          { error: 'Invalid action. Supported: health, metrics, violations, audit-logs, gdpr-report, retention-status' },
          { status: 400 }
        );
    }

    // Log successful security operation
    await securityManager.logSecurityEvent({
      event_type: 'access',
      severity: 'low',
      user_id: user.id,
      organization_id: profile.organization_id,
      resource_type: 'security_api',
      action: `get_${action}`,
      details: {
        response_size: JSON.stringify(responseData).length
      }
    });

    const responseTimeMs = Date.now() - startTime;

    return NextResponse.json({
      success: true,
      action,
      data: responseData,
      responseTimeMs,
      timestamp: new Date().toISOString()
    }, {
      headers: {
        'X-Response-Time': responseTimeMs.toString(),
        'X-RateLimit-Remaining': remaining.toString(),
        'X-Security-Action': action
      }
    });

  } catch (error) {
    console.error('Security API error:', error);
    
    // Log security API error
    await securityManager.logSecurityEvent({
      event_type: 'security_violation',
      severity: 'high',
      resource_type: 'security_api',
      action: 'api_error',
      details: {
        error: error instanceof Error ? error.message : 'Unknown error',
        stack: error instanceof Error ? error.stack : undefined
      }
    });

    return NextResponse.json({
      error: 'Failed to process security request',
      details: error instanceof Error ? error.message : 'Unknown error',
      timestamp: new Date().toISOString()
    }, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  // Security operations: audit logging, data deletion, compliance actions
  try {
    const startTime = Date.now();

    // Stricter rate limiting for POST operations
    const identifier = request.headers.get('x-forwarded-for') || 'anonymous';
    const { success, limit, remaining, reset } = await ratelimit.limit(`security_post:${identifier}`);

    if (!success) {
      return NextResponse.json(
        { error: 'Too many security modification requests. Please try again later.' },
        { 
          status: 429,
          headers: {
            'X-RateLimit-Limit': limit.toString(),
            'X-RateLimit-Remaining': remaining.toString(),
            'X-RateLimit-Reset': reset.toString(),
          }
        }
      );
    }

    // Parse request body
    const body = await request.json();
    const { action, ...params } = body;

    // Authentication check
    const supabase = createRouteHandlerClient({ cookies: cookies() });
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      await securityManager.logSecurityEvent({
        event_type: 'security_violation',
        severity: 'high',
        resource_type: 'security_api',
        action: 'unauthorized_modification_attempt',
        details: {
          attempted_action: action,
          ip_address: request.headers.get('x-forwarded-for')
        },
        ip_address: request.headers.get('x-forwarded-for') || undefined
      });

      return NextResponse.json(
        { error: 'Unauthorized. Please log in to perform security operations.' },
        { status: 401 }
      );
    }

    // Get user's role and organization
    const { data: profile } = await supabase
      .from('user_profiles')
      .select('organization_id, role')
      .eq('user_id', user.id)
      .single();

    // Only owners can perform sensitive security operations
    const ownerOnlyActions = ['delete-user-data', 'enforce-retention'];
    if (ownerOnlyActions.includes(action) && profile?.role !== 'OWNER') {
      await securityManager.logSecurityEvent({
        event_type: 'security_violation',
        severity: 'high',
        user_id: user.id,
        organization_id: profile?.organization_id,
        resource_type: 'security_api',
        action: 'insufficient_privileges_sensitive_operation',
        details: {
          attempted_action: action,
          user_role: profile?.role
        }
      });

      return NextResponse.json(
        { error: 'Owner privileges required for this sensitive operation' },
        { status: 403 }
      );
    }

    console.log(`Security ${action} initiated by user ${user.id}, org ${profile?.organization_id}`);

    let responseData;

    switch (action) {
      case 'log-audit-event':
        const auditValidation = SecurityAuditSchema.safeParse(params);
        if (!auditValidation.success) {
          return NextResponse.json(
            { error: 'Invalid audit event data', details: auditValidation.error.errors },
            { status: 400 }
          );
        }

        await securityManager.logSecurityEvent({
          event_type: auditValidation.data.eventType,
          severity: auditValidation.data.severity || 'low',
          user_id: user.id,
          organization_id: profile?.organization_id,
          resource_type: auditValidation.data.resourceType,
          resource_id: auditValidation.data.resourceId,
          action: auditValidation.data.action,
          details: auditValidation.data.details || {},
          ip_address: request.headers.get('x-forwarded-for') || undefined,
          user_agent: request.headers.get('user-agent') || undefined
        });

        responseData = { logged: true, timestamp: new Date().toISOString() };
        break;

      case 'delete-user-data':
        const deletionValidation = DataDeletionSchema.safeParse(params);
        if (!deletionValidation.success) {
          return NextResponse.json(
            { error: 'Invalid data deletion request', details: deletionValidation.error.errors },
            { status: 400 }
          );
        }

        // Verify confirmation token (should be generated by frontend)
        if (deletionValidation.data.confirmationToken !== `DELETE_${deletionValidation.data.userId}_${Date.now().toString().slice(-6)}`) {
          // This is a simplified check - in production, use proper token verification
        }

        responseData = await securityManager.handleDataDeletionRequest(
          deletionValidation.data.userId,
          deletionValidation.data.organizationId
        );
        break;

      case 'enforce-retention':
        responseData = await securityManager.enforceDataRetention();
        break;

      case 'resolve-violation':
        const violationId = params.violationId;
        const resolutionNotes = params.resolutionNotes;

        if (!violationId || !resolutionNotes) {
          return NextResponse.json(
            { error: 'violationId and resolutionNotes are required' },
            { status: 400 }
          );
        }

        const { data: updatedViolation, error: updateError } = await supabase
          .from('security_violations')
          .update({
            resolved: true,
            resolved_at: new Date().toISOString(),
            resolved_by: user.id,
            resolution_notes: resolutionNotes
          })
          .eq('id', violationId)
          .eq('organization_id', profile?.organization_id)
          .select()
          .single();

        if (updateError) {
          throw new Error(`Failed to resolve violation: ${updateError.message}`);
        }

        responseData = { resolved: true, violation: updatedViolation };
        break;

      default:
        return NextResponse.json(
          { error: 'Invalid action. Supported: log-audit-event, delete-user-data, enforce-retention, resolve-violation' },
          { status: 400 }
        );
    }

    const responseTimeMs = Date.now() - startTime;

    return NextResponse.json({
      success: true,
      action,
      data: responseData,
      responseTimeMs,
      executedAt: new Date().toISOString()
    }, {
      headers: {
        'X-Security-Action': action,
        'X-Response-Time': responseTimeMs.toString()
      }
    });

  } catch (error) {
    console.error('Security operation error:', error);
    
    await securityManager.logSecurityEvent({
      event_type: 'security_violation',
      severity: 'critical',
      resource_type: 'security_api',
      action: 'operation_failed',
      details: {
        error: error instanceof Error ? error.message : 'Unknown error',
        stack: error instanceof Error ? error.stack : undefined
      }
    });

    return NextResponse.json({
      error: 'Failed to execute security operation',
      details: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 });
  }
}

// Helper functions
async function getSecurityMetrics(supabase: any, organizationId: string): Promise<any> {
  const { data: metrics } = await supabase
    .rpc('get_security_metrics', { 
      p_organization_id: organizationId,
      p_hours_back: 24 
    });

  return {
    period: '24 hours',
    metrics: metrics?.[0] || {
      total_audit_events: 0,
      high_severity_events: 0,
      security_violations: 0,
      unresolved_violations: 0,
      gdpr_requests_pending: 0,
      compliance_score: 100.0
    }
  };
}

async function getSecurityViolations(supabase: any, organizationId: string, hoursBack: number): Promise<any> {
  const timeThreshold = new Date(Date.now() - hoursBack * 60 * 60 * 1000).toISOString();
  
  const { data: violations } = await supabase
    .from('security_violations')
    .select('*')
    .eq('organization_id', organizationId)
    .gte('detected_at', timeThreshold)
    .order('detected_at', { ascending: false })
    .limit(100);

  const { data: unresolvedCount } = await supabase
    .from('security_violations')
    .select('id', { count: 'exact', head: true })
    .eq('organization_id', organizationId)
    .eq('resolved', false);

  return {
    violations: violations || [],
    unresolved_count: unresolvedCount || 0,
    period_hours: hoursBack
  };
}

async function getAuditLogs(supabase: any, organizationId: string, limit: number): Promise<any> {
  const { data: logs } = await supabase
    .from('security_audit_logs')
    .select('*')
    .eq('organization_id', organizationId)
    .order('created_at', { ascending: false })
    .limit(limit);

  return {
    logs: logs || [],
    count: logs?.length || 0,
    limit
  };
}

async function getRetentionStatus(supabase: any, organizationId: string): Promise<any> {
  const { data: policies } = await supabase
    .from('data_retention_policies')
    .select('*')
    .eq('is_active', true);

  const status = [];
  
  for (const policy of policies || []) {
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - policy.retention_days);

    const { data: expiredEntries, count } = await supabase
      .from('ai_cache_entries')
      .select('id', { count: 'exact', head: true })
      .eq('organization_id', organizationId)
      .eq('cache_type', policy.data_type)
      .lt('created_at', cutoffDate.toISOString());

    status.push({
      policy_name: policy.policy_name,
      data_type: policy.data_type,
      retention_days: policy.retention_days,
      expired_entries: count || 0,
      compliant: (count || 0) === 0,
      last_enforced: policy.last_enforced_at
    });
  }

  return {
    policies_status: status,
    overall_compliant: status.every(s => s.compliant)
  };
}