/**
 * WS-241 AI Caching Strategy System - Cache Preloading Endpoint
 * Handles seasonal and targeted cache preloading
 * Team B - Backend Infrastructure & API Development
 */

import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { cookies } from 'next/headers';
import { WeddingAICacheService, CacheType } from '@/lib/ai-cache/WeddingAICacheService';
import { LocationBasedCachePartitioner } from '@/lib/ai-cache/LocationBasedCachePartitioner';
import { VendorCacheOptimizer, VendorType } from '@/lib/ai-cache/VendorCacheOptimizer';
import { ratelimit } from '@/lib/ratelimit';

// Initialize services
const cacheService = new WeddingAICacheService(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!,
  process.env.REDIS_URL || 'redis://localhost:6379'
);

const locationPartitioner = new LocationBasedCachePartitioner(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

const vendorOptimizer = new VendorCacheOptimizer(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

type WeddingSeason = 'spring' | 'summer' | 'fall' | 'winter';
type PreloadType = 'seasonal' | 'vendor' | 'location' | 'high_priority';

export async function POST(request: NextRequest) {
  try {
    const startTime = Date.now();

    // Rate limiting - 5 preload requests per hour per user (very restrictive)
    const identifier = request.headers.get('x-forwarded-for') || 'anonymous';
    const { success, limit, remaining, reset } = await ratelimit.limit(`preload:${identifier}`, {
      window: '1h',
      limit: 5
    });

    if (!success) {
      return NextResponse.json(
        { error: 'Too many preload requests. Preloading is resource-intensive and limited to 5 requests per hour.' },
        { 
          status: 429,
          headers: {
            'X-RateLimit-Limit': limit.toString(),
            'X-RateLimit-Remaining': remaining.toString(),
            'X-RateLimit-Reset': reset.toString(),
          }
        }
      );
    }

    // Parse request body
    const body = await request.json();
    const { 
      type = 'seasonal',
      season,
      locations,
      cacheTypes,
      vendorTypes,
      priority = 'normal',
      estimateOnly = false,
      maxEntries = 10000
    } = body as {
      type?: PreloadType;
      season?: WeddingSeason;
      locations?: string[];
      cacheTypes?: CacheType[];
      vendorTypes?: VendorType[];
      priority?: 'low' | 'normal' | 'high';
      estimateOnly?: boolean;
      maxEntries?: number;
    };

    // Authentication and authorization check
    const supabase = createRouteHandlerClient({ cookies: cookies() });
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json(
        { error: 'Unauthorized. Please log in to initiate cache preloading.' },
        { status: 401 }
      );
    }

    // Get user's organization and role
    const { data: profile } = await supabase
      .from('user_profiles')
      .select('organization_id, role')
      .eq('user_id', user.id)
      .single();

    if (!profile?.organization_id) {
      return NextResponse.json(
        { error: 'User profile not found or no organization associated' },
        { status: 404 }
      );
    }

    // Authorization - only admins can initiate preloading
    const isAdmin = profile.role === 'OWNER' || profile.role === 'ADMIN';
    if (!isAdmin) {
      return NextResponse.json(
        { error: 'Cache preloading requires admin privileges' },
        { status: 403 }
      );
    }

    // Validate season if provided
    if (season && !['spring', 'summer', 'fall', 'winter'].includes(season)) {
      return NextResponse.json(
        { error: 'Invalid season. Must be one of: spring, summer, fall, winter' },
        { status: 400 }
      );
    }

    console.log(`Cache preload request: type=${type}, season=${season || 'current'}, user=${user.id}, estimateOnly=${estimateOnly}`);

    // Determine current season if not provided
    const currentSeason = season || getCurrentSeason();
    
    let preloadPlan: any = {};
    let jobId: string | null = null;

    switch (type) {
      case 'seasonal':
        preloadPlan = await planSeasonalPreload(supabase, currentSeason, locations, cacheTypes, maxEntries);
        break;
        
      case 'vendor':
        if (!vendorTypes || vendorTypes.length === 0) {
          return NextResponse.json(
            { error: 'Vendor types are required for vendor preloading' },
            { status: 400 }
          );
        }
        preloadPlan = await planVendorPreload(supabase, vendorTypes, cacheTypes, currentSeason, maxEntries);
        break;
        
      case 'location':
        if (!locations || locations.length === 0) {
          return NextResponse.json(
            { error: 'Locations are required for location preloading' },
            { status: 400 }
          );
        }
        preloadPlan = await planLocationPreload(supabase, locations, cacheTypes, currentSeason, maxEntries);
        break;
        
      case 'high_priority':
        preloadPlan = await planHighPriorityPreload(supabase, currentSeason, maxEntries);
        break;
        
      default:
        return NextResponse.json(
          { error: 'Invalid preload type. Must be one of: seasonal, vendor, location, high_priority' },
          { status: 400 }
        );
    }

    // If estimate only, return the plan without executing
    if (estimateOnly) {
      return NextResponse.json({
        estimateOnly: true,
        type,
        season: currentSeason,
        plan: preloadPlan,
        responseTimeMs: Date.now() - startTime
      });
    }

    // Create preload job
    const { data: job } = await supabase
      .from('cache_warming_jobs')
      .insert({
        job_type: type,
        status: 'pending',
        job_config: {
          type,
          season: currentSeason,
          locations: locations || [],
          cacheTypes: cacheTypes || [],
          vendorTypes: vendorTypes || [],
          priority,
          maxEntries,
          initiatedBy: user.id
        },
        target_cache_types: preloadPlan.cacheTypes || [],
        target_locations: preloadPlan.locations || [],
        target_seasons: [currentSeason],
        total_items: preloadPlan.estimatedEntries || 0,
        estimated_completion: new Date(Date.now() + (preloadPlan.estimatedDurationMinutes || 30) * 60 * 1000).toISOString()
      })
      .select()
      .single();

    if (job) {
      jobId = job.id;
      
      // Start preload execution asynchronously
      executePreloadJob(job.id, type, preloadPlan, currentSeason).catch(error => {
        console.error(`Preload job ${job.id} failed:`, error);
      });
    }

    // Record audit log
    await supabase.from('audit_logs').insert({
      user_id: user.id,
      organization_id: profile.organization_id,
      action: 'cache_preload_initiated',
      details: {
        type,
        season: currentSeason,
        jobId,
        estimatedEntries: preloadPlan.estimatedEntries,
        estimatedDuration: preloadPlan.estimatedDurationMinutes,
        timestamp: new Date().toISOString()
      }
    });

    const responseTimeMs = Date.now() - startTime;

    return NextResponse.json({
      success: true,
      jobId,
      type,
      season: currentSeason,
      status: 'queued',
      estimatedCompletion: job?.estimated_completion,
      plan: preloadPlan,
      responseTimeMs,
      message: 'Cache preloading job has been queued and will begin execution shortly'
    }, {
      headers: {
        'X-Job-ID': jobId || 'unknown',
        'X-Response-Time': responseTimeMs.toString(),
        'X-RateLimit-Remaining': remaining.toString()
      }
    });

  } catch (error) {
    console.error('Cache preload error:', error);
    
    return NextResponse.json({
      error: 'Failed to initiate cache preloading',
      details: error instanceof Error ? error.message : 'Unknown error',
      timestamp: new Date().toISOString()
    }, { status: 500 });
  }
}

export async function GET(request: NextRequest) {
  // Get preload job status and recent preload jobs
  try {
    const url = new URL(request.url);
    const jobId = url.searchParams.get('jobId');
    const status = url.searchParams.get('status');
    const limit = parseInt(url.searchParams.get('limit') || '20');

    // Authentication check
    const supabase = createRouteHandlerClient({ cookies: cookies() });
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    if (jobId) {
      // Get specific job status
      const { data: job } = await supabase
        .from('cache_warming_jobs')
        .select('*')
        .eq('id', jobId)
        .single();

      if (!job) {
        return NextResponse.json(
          { error: 'Job not found' },
          { status: 404 }
        );
      }

      return NextResponse.json({
        job,
        progress: job.progress_percentage,
        status: job.status,
        estimatedCompletion: job.estimated_completion
      });
    }

    // Get recent preload jobs
    let query = supabase
      .from('cache_warming_jobs')
      .select('*')
      .order('created_at', { ascending: false })
      .limit(limit);

    if (status) {
      query = query.eq('status', status);
    }

    const { data: jobs } = await query;

    // Get overall preload statistics
    const { data: stats } = await supabase
      .from('cache_warming_jobs')
      .select(`
        job_type,
        status,
        created_at
      `)
      .gte('created_at', new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString()); // Last 7 days

    const statistics = {
      totalJobs: stats?.length || 0,
      completedJobs: stats?.filter(s => s.status === 'completed').length || 0,
      failedJobs: stats?.filter(s => s.status === 'failed').length || 0,
      runningJobs: stats?.filter(s => s.status === 'running').length || 0,
      jobsByType: stats?.reduce((acc, s) => {
        acc[s.job_type] = (acc[s.job_type] || 0) + 1;
        return acc;
      }, {} as Record<string, number>) || {}
    };

    return NextResponse.json({
      jobs: jobs || [],
      statistics,
      canInitiatePreload: true // This would check user permissions
    });

  } catch (error) {
    console.error('Error fetching preload data:', error);
    return NextResponse.json({
      error: 'Failed to fetch preload data'
    }, { status: 500 });
  }
}

// Helper functions

function getCurrentSeason(): WeddingSeason {
  const month = new Date().getMonth();
  if (month >= 2 && month <= 4) return 'spring'; // Mar-May
  if (month >= 5 && month <= 7) return 'summer'; // Jun-Aug
  if (month >= 8 && month <= 10) return 'fall';  // Sep-Nov
  return 'winter'; // Dec-Feb
}

async function planSeasonalPreload(
  supabase: any,
  season: WeddingSeason,
  locations?: string[],
  cacheTypes?: CacheType[],
  maxEntries: number = 10000
) {
  // Default to major wedding markets if no locations specified
  const targetLocations = locations || ['NYC', 'LA', 'Chicago', 'Miami', 'Atlanta', 'Dallas'];
  
  // Default to high-priority cache types for seasonal preload
  const targetCacheTypes = cacheTypes || [
    'venue_recommendations',
    'vendor_matching',
    'location_insights',
    'seasonal_planning'
  ];

  const estimatedEntries = Math.min(maxEntries, targetLocations.length * targetCacheTypes.length * 50);
  const estimatedDurationMinutes = Math.ceil(estimatedEntries / 100); // Rough estimate

  return {
    type: 'seasonal',
    season,
    locations: targetLocations,
    cacheTypes: targetCacheTypes,
    estimatedEntries,
    estimatedDurationMinutes,
    priority: 'high'
  };
}

async function planVendorPreload(
  supabase: any,
  vendorTypes: VendorType[],
  cacheTypes?: CacheType[],
  season?: WeddingSeason,
  maxEntries: number = 10000
) {
  const targetCacheTypes = cacheTypes || ['vendor_matching', 'pricing_estimates'];
  const estimatedEntries = Math.min(maxEntries, vendorTypes.length * targetCacheTypes.length * 100);
  const estimatedDurationMinutes = Math.ceil(estimatedEntries / 80);

  return {
    type: 'vendor',
    vendorTypes,
    cacheTypes: targetCacheTypes,
    season,
    estimatedEntries,
    estimatedDurationMinutes,
    priority: 'medium'
  };
}

async function planLocationPreload(
  supabase: any,
  locations: string[],
  cacheTypes?: CacheType[],
  season?: WeddingSeason,
  maxEntries: number = 10000
) {
  const targetCacheTypes = cacheTypes || [
    'venue_recommendations',
    'location_insights',
    'vendor_matching'
  ];

  const estimatedEntries = Math.min(maxEntries, locations.length * targetCacheTypes.length * 75);
  const estimatedDurationMinutes = Math.ceil(estimatedEntries / 90);

  return {
    type: 'location',
    locations,
    cacheTypes: targetCacheTypes,
    season,
    estimatedEntries,
    estimatedDurationMinutes,
    priority: 'medium'
  };
}

async function planHighPriorityPreload(
  supabase: any,
  season: WeddingSeason,
  maxEntries: number = 10000
) {
  // High priority preload focuses on the most requested cache types and locations
  const highPriorityLocations = ['NYC', 'LA', 'Chicago', 'Miami'];
  const highPriorityCacheTypes = ['venue_recommendations', 'vendor_matching'];
  
  const estimatedEntries = Math.min(maxEntries, 2000); // Limited high-priority entries
  const estimatedDurationMinutes = Math.ceil(estimatedEntries / 150); // Faster processing

  return {
    type: 'high_priority',
    locations: highPriorityLocations,
    cacheTypes: highPriorityCacheTypes,
    season,
    estimatedEntries,
    estimatedDurationMinutes,
    priority: 'high'
  };
}

async function executePreloadJob(
  jobId: string,
  type: PreloadType,
  plan: any,
  season: WeddingSeason
): Promise<void> {
  const supabase = createRouteHandlerClient({ cookies: cookies() });
  
  try {
    // Update job status to running
    await supabase
      .from('cache_warming_jobs')
      .update({ 
        status: 'running', 
        started_at: new Date().toISOString() 
      })
      .eq('id', jobId);

    let processedItems = 0;
    const totalItems = plan.estimatedEntries;

    // Execute based on type
    switch (type) {
      case 'seasonal':
        await cacheService.preloadSeasonalCache(
          season,
          plan.locations,
          plan.cacheTypes
        );
        processedItems = totalItems; // Simplified for this implementation
        break;
        
      case 'high_priority':
        await locationPartitioner.preloadHighPriorityMarkets(
          season,
          plan.cacheTypes
        );
        processedItems = totalItems;
        break;
        
      default:
        // For vendor and location preloading, simulate the process
        for (let i = 0; i < totalItems; i++) {
          // Simulate processing
          await new Promise(resolve => setTimeout(resolve, 10));
          processedItems++;
          
          // Update progress every 10%
          if (processedItems % Math.ceil(totalItems / 10) === 0) {
            await supabase
              .from('cache_warming_jobs')
              .update({ processed_items: processedItems })
              .eq('id', jobId);
          }
        }
    }

    // Mark job as completed
    await supabase
      .from('cache_warming_jobs')
      .update({
        status: 'completed',
        processed_items: processedItems,
        completed_at: new Date().toISOString(),
        results: {
          success: true,
          entriesPreloaded: processedItems,
          completedAt: new Date().toISOString()
        }
      })
      .eq('id', jobId);

    console.log(`Preload job ${jobId} completed successfully. Processed ${processedItems} items.`);

  } catch (error) {
    console.error(`Preload job ${jobId} failed:`, error);
    
    // Mark job as failed
    await supabase
      .from('cache_warming_jobs')
      .update({
        status: 'failed',
        completed_at: new Date().toISOString(),
        error_log: error instanceof Error ? error.message : 'Unknown error',
        results: {
          success: false,
          error: error instanceof Error ? error.message : 'Unknown error'
        }
      })
      .eq('id', jobId);
  }
}