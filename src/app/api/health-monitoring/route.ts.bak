// app/api/health-monitoring/route.ts
// WS-233: API Health Monitoring Endpoint
// Team B - Backend Implementation
// System health monitoring and alerting

import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { getApiAnalyticsService } from '@/lib/services/api-analytics-service';
import { getApiUsageTracker } from '@/lib/middleware/api-usage-tracker';
import { createClient } from '@supabase/supabase-js';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

// Health check response interface
interface SystemHealthResponse {
  status: 'healthy' | 'degraded' | 'unhealthy';
  timestamp: string;
  uptime: number;
  version: string;
  components: {
    database: ComponentHealth;
    redis: ComponentHealth;
    usageTracking: ComponentHealth;
    analytics: ComponentHealth;
    rateLimiting: ComponentHealth;
  };
  metrics: {
    totalRequestsLastHour: number;
    avgResponseTimeLast5Min: number;
    errorRateLastHour: number;
    activeConnections: number;
    memoryUsage: number;
  };
  alerts?: Array<{
    severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
    message: string;
    component: string;
    timestamp: string;
  }>;
}

interface ComponentHealth {
  status: 'healthy' | 'degraded' | 'unhealthy';
  responseTime?: number;
  lastChecked: string;
  details?: any;
  message?: string;
}

/**
 * GET /api/health-monitoring
 * Comprehensive health check for the API monitoring system
 */
async function GET(request: NextRequest): Promise<NextResponse> {
  const startTime = Date.now();
  
  try {
    // Check if this is an authenticated admin request for detailed info
    const authHeader = request.headers.get('authorization');
    const isAuthenticated = authHeader?.startsWith('Bearer ');
    let isAdmin = false;

    if (isAuthenticated) {
      try {
        const token = authHeader!.split(' ')[1];
        const { data: session } = await supabase.auth.getUser(token);
        
        if (session.user) {
          const { data: userRoles } = await supabase
            .from('user_organization_roles')
            .select('role')
            .eq('user_id', session.user.id);
          
          isAdmin = userRoles?.some(role => role.role === 'admin') || false;
        }
      } catch {
        // Continue with unauthenticated check
      }
    }

    // Initialize health check results
    const healthChecks: SystemHealthResponse = {
      status: 'healthy',
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      version: process.env.npm_package_version || '1.0.0',
      components: {
        database: { status: 'healthy', lastChecked: new Date().toISOString() },
        redis: { status: 'healthy', lastChecked: new Date().toISOString() },
        usageTracking: { status: 'healthy', lastChecked: new Date().toISOString() },
        analytics: { status: 'healthy', lastChecked: new Date().toISOString() },
        rateLimiting: { status: 'healthy', lastChecked: new Date().toISOString() }
      },
      metrics: {
        totalRequestsLastHour: 0,
        avgResponseTimeLast5Min: 0,
        errorRateLastHour: 0,
        activeConnections: 0,
        memoryUsage: 0
      }
    };

    // Parallel health checks for performance
    const healthCheckPromises = [
      checkDatabaseHealth(),
      checkRedisHealth(),
      checkUsageTrackingHealth(),
      checkAnalyticsHealth(),
      checkRateLimitingHealth()
    ];

    const healthResults = await Promise.allSettled(healthCheckPromises);

    // Process health check results
    healthChecks.components.database = healthResults[0].status === 'fulfilled' 
      ? healthResults[0].value 
      : { status: 'unhealthy', lastChecked: new Date().toISOString(), message: 'Health check failed' };

    healthChecks.components.redis = healthResults[1].status === 'fulfilled' 
      ? healthResults[1].value 
      : { status: 'unhealthy', lastChecked: new Date().toISOString(), message: 'Health check failed' };

    healthChecks.components.usageTracking = healthResults[2].status === 'fulfilled' 
      ? healthResults[2].value 
      : { status: 'unhealthy', lastChecked: new Date().toISOString(), message: 'Health check failed' };

    healthChecks.components.analytics = healthResults[3].status === 'fulfilled' 
      ? healthResults[3].value 
      : { status: 'unhealthy', lastChecked: new Date().toISOString(), message: 'Health check failed' };

    healthChecks.components.rateLimiting = healthResults[4].status === 'fulfilled' 
      ? healthResults[4].value 
      : { status: 'unhealthy', lastChecked: new Date().toISOString(), message: 'Health check failed' };

    // Determine overall system status
    const componentStatuses = Object.values(healthChecks.components).map(c => c.status);
    const unhealthyCount = componentStatuses.filter(s => s === 'unhealthy').length;
    const degradedCount = componentStatuses.filter(s => s === 'degraded').length;

    if (unhealthyCount > 0) {
      healthChecks.status = 'unhealthy';
    } else if (degradedCount > 0) {
      healthChecks.status = 'degraded';
    }

    // Get system metrics (admin only for detailed metrics)
    if (isAdmin) {
      try {
        const metrics = await getSystemMetrics();
        healthChecks.metrics = { ...healthChecks.metrics, ...metrics };

        // Get active alerts
        const alerts = await getActiveSystemAlerts();
        if (alerts.length > 0) {
          healthChecks.alerts = alerts;
        }
      } catch (error) {
        console.error('[Health Monitor] Metrics collection failed:', error);
      }
    }

    // Add response time to headers
    const responseTime = Date.now() - startTime;
    const response = NextResponse.json(healthChecks, {
      status: healthChecks.status === 'healthy' ? 200 : 
             healthChecks.status === 'degraded' ? 200 : 503
    });

    response.headers.set('X-Response-Time', `${responseTime}ms`);
    response.headers.set('X-Health-Status', healthChecks.status);
    
    // Cache headers for load balancer health checks
    if (!isAdmin) {
      response.headers.set('Cache-Control', 'public, max-age=30');
    }

    return response;

  } catch (error: any) {
    console.error('[Health Monitor] Health check failed:', error);

    return NextResponse.json({
      status: 'unhealthy',
      timestamp: new Date().toISOString(),
      error: 'Health check failed',
      responseTime: Date.now() - startTime
    }, { status: 503 });
  }
}

/**
 * POST /api/health-monitoring/alerts
 * Trigger manual health alert or acknowledge existing alerts
 */
async function POST(request: NextRequest): Promise<NextResponse> {
  try {
    // Authenticate admin user
    const authHeader = request.headers.get('authorization');
    if (!authHeader?.startsWith('Bearer ')) {
      return NextResponse.json(
        { error: 'Authentication required', code: 'UNAUTHORIZED' },
        { status: 401 }
      );
    }

    const token = authHeader.split(' ')[1];
    const { data: session } = await supabase.auth.getUser(token);
    
    if (!session.user) {
      return NextResponse.json(
        { error: 'Invalid authentication token', code: 'UNAUTHORIZED' },
        { status: 401 }
      );
    }

    // Check admin access
    const { data: userRoles } = await supabase
      .from('user_organization_roles')
      .select('role')
      .eq('user_id', session.user.id);

    const isAdmin = userRoles?.some(role => role.role === 'admin');
    if (!isAdmin) {
      return NextResponse.json(
        { error: 'Admin access required', code: 'FORBIDDEN' },
        { status: 403 }
      );
    }

    const body = await request.json();
    
    const alertActionSchema = z.object({
      action: z.enum(['acknowledge', 'resolve', 'trigger']),
      incidentId: z.string().uuid().optional(),
      alertType: z.string().optional(),
      message: z.string().max(500).optional(),
      severity: z.enum(['LOW', 'MEDIUM', 'HIGH', 'CRITICAL']).optional()
    });

    const validatedAction = alertActionSchema.parse(body);

    switch (validatedAction.action) {
      case 'acknowledge':
        if (!validatedAction.incidentId) {
          return NextResponse.json(
            { error: 'Incident ID required for acknowledgment', code: 'VALIDATION_ERROR' },
            { status: 400 }
          );
        }

        const { error: ackError } = await supabase
          .from('api_alert_incidents')
          .update({ 
            status: 'ACKNOWLEDGED',
            resolved_by: session.user.id,
            updated_at: new Date().toISOString()
          })
          .eq('id', validatedAction.incidentId)
          .eq('status', 'ACTIVE');

        if (ackError) {
          return NextResponse.json(
            { error: 'Failed to acknowledge incident', code: 'INTERNAL_ERROR' },
            { status: 500 }
          );
        }

        return NextResponse.json({ 
          success: true, 
          message: 'Incident acknowledged' 
        });

      case 'resolve':
        if (!validatedAction.incidentId) {
          return NextResponse.json(
            { error: 'Incident ID required for resolution', code: 'VALIDATION_ERROR' },
            { status: 400 }
          );
        }

        const { error: resolveError } = await supabase
          .from('api_alert_incidents')
          .update({ 
            status: 'RESOLVED',
            resolved_by: session.user.id,
            resolved_at: new Date().toISOString(),
            resolution_notes: validatedAction.message,
            updated_at: new Date().toISOString()
          })
          .eq('id', validatedAction.incidentId);

        if (resolveError) {
          return NextResponse.json(
            { error: 'Failed to resolve incident', code: 'INTERNAL_ERROR' },
            { status: 500 }
          );
        }

        return NextResponse.json({ 
          success: true, 
          message: 'Incident resolved' 
        });

      case 'trigger':
        // Manual alert trigger for testing
        const { error: triggerError } = await supabase
          .from('api_alert_incidents')
          .insert({
            alert_rule_id: null, // Manual trigger
            organization_id: null, // System-wide
            incident_title: `Manual Alert: ${validatedAction.alertType || 'System Check'}`,
            incident_description: validatedAction.message || 'Manually triggered alert',
            severity: validatedAction.severity || 'MEDIUM',
            status: 'ACTIVE',
            triggered_value: 0,
            trigger_threshold: 0,
            metrics_snapshot: { manual_trigger: true, triggered_by: session.user.id }
          });

        if (triggerError) {
          return NextResponse.json(
            { error: 'Failed to trigger alert', code: 'INTERNAL_ERROR' },
            { status: 500 }
          );
        }

        return NextResponse.json({ 
          success: true, 
          message: 'Manual alert triggered' 
        }, { status: 201 });

      default:
        return NextResponse.json(
          { error: 'Invalid action', code: 'VALIDATION_ERROR' },
          { status: 400 }
        );
    }

  } catch (error: any) {
    console.error('[Health Monitor] Alert action failed:', error);
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { 
          error: 'Invalid request format', 
          code: 'VALIDATION_ERROR',
          details: error.errors 
        },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { error: 'Internal server error', code: 'INTERNAL_ERROR' },
      { status: 500 }
    );
  }
}

// Health check helper functions
async function checkDatabaseHealth(): Promise<ComponentHealth> {
  const startTime = Date.now();
  
  try {
    // Test database connection and basic query
    const { data, error } = await supabase
      .from('api_quotas')
      .select('subscription_tier')
      .limit(1);

    const responseTime = Date.now() - startTime;

    if (error) {
      return {
        status: 'unhealthy',
        responseTime,
        lastChecked: new Date().toISOString(),
        message: `Database error: ${error.message}`,
        details: { error: error.code }
      };
    }

    // Check if response time is acceptable
    const status = responseTime > 1000 ? 'degraded' : 'healthy';

    return {
      status,
      responseTime,
      lastChecked: new Date().toISOString(),
      message: status === 'degraded' ? 'Slow database response' : 'Database connection healthy',
      details: { recordCount: data?.length || 0 }
    };

  } catch (error: any) {
    return {
      status: 'unhealthy',
      responseTime: Date.now() - startTime,
      lastChecked: new Date().toISOString(),
      message: `Database connection failed: ${error.message}`
    };
  }
}

async function checkRedisHealth(): Promise<ComponentHealth> {
  const startTime = Date.now();
  
  try {
    // Skip Redis check if not configured
    if (!process.env.REDIS_URL) {
      return {
        status: 'healthy',
        responseTime: 0,
        lastChecked: new Date().toISOString(),
        message: 'Redis not configured (optional)',
        details: { configured: false }
      };
    }

    // Redis health check would go here
    // For now, return healthy since Redis is optional
    const responseTime = Date.now() - startTime;

    return {
      status: 'healthy',
      responseTime,
      lastChecked: new Date().toISOString(),
      message: 'Redis connection healthy',
      details: { configured: true }
    };

  } catch (error: any) {
    return {
      status: 'degraded',
      responseTime: Date.now() - startTime,
      lastChecked: new Date().toISOString(),
      message: `Redis connection issues: ${error.message}`,
      details: { fallbackActive: true }
    };
  }
}

async function checkUsageTrackingHealth(): Promise<ComponentHealth> {
  const startTime = Date.now();
  
  try {
    const tracker = getApiUsageTracker();
    const health = await tracker.healthCheck();
    const responseTime = Date.now() - startTime;

    return {
      status: health.status as any,
      responseTime,
      lastChecked: new Date().toISOString(),
      message: `Usage tracking ${health.status}`,
      details: health.details
    };

  } catch (error: any) {
    return {
      status: 'unhealthy',
      responseTime: Date.now() - startTime,
      lastChecked: new Date().toISOString(),
      message: `Usage tracking failed: ${error.message}`
    };
  }
}

async function checkAnalyticsHealth(): Promise<ComponentHealth> {
  const startTime = Date.now();
  
  try {
    const analyticsService = getApiAnalyticsService();
    const health = await analyticsService.healthCheck();
    const responseTime = Date.now() - startTime;

    return {
      status: health.status as any,
      responseTime,
      lastChecked: new Date().toISOString(),
      message: `Analytics service ${health.status}`,
      details: health.details
    };

  } catch (error: any) {
    return {
      status: 'unhealthy',
      responseTime: Date.now() - startTime,
      lastChecked: new Date().toISOString(),
      message: `Analytics service failed: ${error.message}`
    };
  }
}

async function checkRateLimitingHealth(): Promise<ComponentHealth> {
  const startTime = Date.now();
  
  try {
    // Test rate limiting functionality by checking recent rate limit entries
    const { data, error } = await supabase
      .from('api_rate_limits')
      .select('id')
      .gte('created_at', new Date(Date.now() - 5 * 60 * 1000).toISOString()) // Last 5 minutes
      .limit(1);

    const responseTime = Date.now() - startTime;

    if (error) {
      return {
        status: 'degraded',
        responseTime,
        lastChecked: new Date().toISOString(),
        message: `Rate limiting query failed: ${error.message}`,
        details: { fallbackActive: true }
      };
    }

    return {
      status: 'healthy',
      responseTime,
      lastChecked: new Date().toISOString(),
      message: 'Rate limiting operational',
      details: { recentActivity: !!data?.length }
    };

  } catch (error: any) {
    return {
      status: 'degraded',
      responseTime: Date.now() - startTime,
      lastChecked: new Date().toISOString(),
      message: `Rate limiting check failed: ${error.message}`,
      details: { fallbackActive: true }
    };
  }
}

async function getSystemMetrics() {
  const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
  const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);

  // Get request volume and performance metrics
  const { data: recentLogs } = await supabase
    .from('api_usage_logs')
    .select('response_time_ms, status_code, created_at')
    .gte('created_at', oneHourAgo.toISOString());

  const totalRequestsLastHour = recentLogs?.length || 0;
  const recentLogs5Min = recentLogs?.filter(log => 
    new Date(log.created_at) >= fiveMinutesAgo
  ) || [];
  
  const avgResponseTimeLast5Min = recentLogs5Min.length > 0
    ? recentLogs5Min.reduce((sum, log) => sum + (log.response_time_ms || 0), 0) / recentLogs5Min.length
    : 0;

  const errorCount = recentLogs?.filter(log => log.status_code >= 400).length || 0;
  const errorRateLastHour = totalRequestsLastHour > 0 
    ? (errorCount / totalRequestsLastHour) * 100 
    : 0;

  return {
    totalRequestsLastHour,
    avgResponseTimeLast5Min: Math.round(avgResponseTimeLast5Min),
    errorRateLastHour: Math.round(errorRateLastHour * 100) / 100,
    activeConnections: 0, // Would need process monitoring
    memoryUsage: process.memoryUsage().heapUsed / 1024 / 1024 // MB
  };
}

async function getActiveSystemAlerts() {
  const { data: incidents } = await supabase
    .from('api_alert_incidents')
    .select('severity, incident_title, triggered_at')
    .eq('status', 'ACTIVE')
    .order('triggered_at', { ascending: false })
    .limit(10);

  return incidents?.map(incident => ({
    severity: incident.severity,
    message: incident.incident_title,
    component: 'system',
    timestamp: incident.triggered_at
  })) || [];
}

export { GET, POST };