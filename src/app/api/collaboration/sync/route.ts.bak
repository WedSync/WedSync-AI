/**
 * Collaborative Document Sync API - Real-time synchronization for mobile collaboration
 * WS-244 Team D - Mobile-First Real-Time Collaboration System
 * 
 * Features:
 * - Y.js operational transformation and conflict resolution
 * - Mobile-optimized batch synchronization
 * - Wedding-specific collaborative features
 * - Offline-to-online sync with conflict detection
 * - Battery-aware sync intervals for mobile devices
 */

import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { cookies } from 'next/headers';
import { z } from 'zod';
import * as Y from 'yjs';
import { ratelimit } from '@/lib/rate-limit';

// Validation schema for sync request
const syncRequestSchema = z.object({
  documentId: z.string().uuid('Invalid document ID format'),
  weddingId: z.string().uuid('Invalid wedding ID format'),
  localState: z.string().optional(), // Base64 encoded Y.js state
  lastSync: z.string().optional(), // ISO timestamp
  operation: z.object({
    type: z.string(),
    data: z.any(),
    timestamp: z.string()
  }).optional(),
  clientVersion: z.number().optional(),
  operations: z.array(z.object({
    type: z.enum(['insert', 'delete', 'format', 'presence']),
    position: z.number(),
    content: z.string().optional(),
    length: z.number().optional(),
    attributes: z.record(z.any()).optional(),
    timestamp: z.string(),
    userId: z.string()
  })).optional()
});

// Conflict resolution schema
const conflictSchema = z.object({
  type: z.enum(['text', 'structure', 'user_presence']),
  localChange: z.string(),
  remoteChange: z.string(),
  timestamp: z.string(),
  position: z.number().optional()
});

// Rate limiting - 60 syncs per minute per user (mobile-friendly)
const syncRateLimit = ratelimit({
  limiter: 'sliding_window_log',
  max: 60,
  window: '1m'
});

export async function POST(request: NextRequest) {
  try {
    const cookieStore = cookies();
    const supabase = createRouteHandlerClient({ cookies: () => cookieStore });

    // Authentication check
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json(
        { error: 'Authentication required' },
        { status: 401 }
      );
    }

    // Rate limiting with mobile consideration
    const rateLimitResult = await syncRateLimit.limit(user.id);
    if (!rateLimitResult.success) {
      return NextResponse.json(
        { 
          error: 'Sync rate limit exceeded', 
          retryAfter: rateLimitResult.reset,
          remaining: rateLimitResult.remaining,
          mobileOptimized: true // Signal to client to use battery-saving mode
        },
        { 
          status: 429,
          headers: {
            'X-RateLimit-Limit': rateLimitResult.limit.toString(),
            'X-RateLimit-Remaining': rateLimitResult.remaining.toString(),
            'X-RateLimit-Reset': new Date(rateLimitResult.reset).toISOString(),
            'X-Mobile-Backoff': '30' // Suggest 30-second backoff for mobile
          }
        }
      );
    }

    // Parse and validate request
    const body = await request.json();
    const { 
      documentId, 
      weddingId, 
      localState, 
      lastSync, 
      operation, 
      clientVersion, 
      operations = []
    } = syncRequestSchema.parse(body);

    // Get current document state
    const { data: document, error: docError } = await supabase
      .from('collaborative_documents')
      .select(`
        id,
        version,
        yjs_state,
        updated_at,
        wedding_id,
        type,
        collaborative_document_permissions (
          user_id,
          can_read,
          can_write
        )
      `)
      .eq('id', documentId)
      .eq('wedding_id', weddingId)
      .single();

    if (docError || !document) {
      return NextResponse.json(
        { error: 'Document not found or access denied' },
        { status: 404 }
      );
    }

    // Check permissions
    const userPermissions = document.collaborative_document_permissions?.find(
      (p: any) => p.user_id === user.id
    );

    if (!userPermissions?.can_read) {
      // Check wedding team membership
      const { data: teamMember } = await supabase
        .from('wedding_team_members')
        .select('role')
        .eq('wedding_id', weddingId)
        .eq('user_id', user.id)
        .single();

      if (!teamMember) {
        return NextResponse.json(
          { error: 'Access denied' },
          { status: 403 }
        );
      }
    }

    // Initialize Y.js documents for conflict resolution
    const serverDoc = new Y.Doc();
    const clientDoc = new Y.Doc();

    let conflicts: any[] = [];
    let mergedState: string | null = null;

    try {
      // Load server state
      if (document.yjs_state) {
        const serverState = Buffer.from(document.yjs_state, 'base64');
        Y.applyUpdate(serverDoc, serverState);
      }

      // Load client state
      if (localState) {
        const clientState = Buffer.from(localState, 'base64');
        Y.applyUpdate(clientDoc, clientState);
      }

      // Detect conflicts by comparing Y.js states
      const serverText = serverDoc.getText('content').toString();
      const clientText = clientDoc.getText('content').toString();

      if (serverText !== clientText && localState) {
        // Create conflict resolution
        conflicts.push({
          type: 'text',
          localChange: clientText,
          remoteChange: serverText,
          timestamp: new Date().toISOString(),
          requiresResolution: true
        });
      }

      // Apply client operations to server document
      if (operations.length > 0) {
        const serverText = serverDoc.getText('content');
        
        serverDoc.transact(() => {
          for (const op of operations) {
            switch (op.type) {
              case 'insert':
                if (op.content && op.position >= 0) {
                  serverText.insert(op.position, op.content);
                }
                break;
              case 'delete':
                if (op.position >= 0 && op.length && op.length > 0) {
                  serverText.delete(op.position, op.length);
                }
                break;
              case 'format':
                // Handle formatting operations
                if (op.attributes && op.position >= 0 && op.length && op.length > 0) {
                  serverText.format(op.position, op.length, op.attributes);
                }
                break;
            }
          }
        });
      }

      // Generate merged state
      mergedState = Buffer.from(Y.encodeStateAsUpdate(serverDoc)).toString('base64');

    } catch (yjsError) {
      console.error('Y.js operation failed:', yjsError);
      // Fall back to simple conflict detection without operational transformation
      conflicts.push({
        type: 'structure',
        localChange: 'Client state',
        remoteChange: 'Server state',  
        timestamp: new Date().toISOString(),
        requiresManualResolution: true
      });
    }

    // Get changes since last sync
    const changesSince = lastSync ? new Date(lastSync) : new Date(Date.now() - 24 * 60 * 60 * 1000);
    
    const { data: recentChanges } = await supabase
      .from('collaborative_document_history')
      .select(`
        action,
        user_id,
        timestamp,
        content_length,
        user_profiles (
          full_name,
          avatar_url
        )
      `)
      .eq('document_id', documentId)
      .gt('timestamp', changesSince.toISOString())
      .neq('user_id', user.id)
      .order('timestamp', { ascending: false })
      .limit(50);

    // Update document if operations were applied
    let updatedDocument = document;
    if (operations.length > 0 && mergedState && userPermissions?.can_write) {
      const { data: updated, error: updateError } = await supabase
        .from('collaborative_documents')
        .update({
          yjs_state: mergedState,
          version: document.version + 1,
          updated_at: new Date().toISOString(),
          last_edited_by: user.id
        })
        .eq('id', documentId)
        .eq('version', document.version) // Optimistic locking
        .select('id, version, updated_at, yjs_state')
        .single();

      if (!updateError && updated) {
        updatedDocument = { ...document, ...updated };
        
        // Log the sync operation
        await supabase
          .from('collaborative_document_history')
          .insert({
            document_id: documentId,
            user_id: user.id,
            action: 'sync',
            operation_count: operations.length,
            has_conflicts: conflicts.length > 0,
            timestamp: new Date().toISOString()
          });
      } else if (updateError) {
        // Version conflict occurred
        conflicts.push({
          type: 'structure',
          localChange: `Client version ${clientVersion}`,
          remoteChange: `Server version ${document.version}`,
          timestamp: new Date().toISOString(),
          requiresReload: true
        });
      }
    }

    // Update user's presence and activity
    await supabase
      .from('collaborative_document_sessions')
      .upsert({
        document_id: documentId,
        user_id: user.id,
        last_active: new Date().toISOString(),
        is_typing: false,
        device_info: JSON.stringify({
          userAgent: request.headers.get('user-agent'),
          isMobile: /Mobile|Android|iPhone|iPad/.test(request.headers.get('user-agent') || '')
        })
      }, {
        onConflict: 'document_id,user_id'
      });

    // Real-time broadcast if changes were made
    if (operations.length > 0) {
      try {
        await supabase
          .channel(`document-${documentId}`)
          .send({
            type: 'broadcast',
            event: 'document_synced',
            payload: {
              documentId,
              userId: user.id,
              version: updatedDocument.version,
              operationsCount: operations.length,
              hasConflicts: conflicts.length > 0,
              timestamp: new Date().toISOString()
            }
          });
      } catch (broadcastError) {
        console.warn('Failed to broadcast sync:', broadcastError);
      }
    }

    // Mobile-optimized response
    const response = {
      success: true,
      document: {
        id: updatedDocument.id,
        version: updatedDocument.version,
        updated_at: updatedDocument.updated_at,
        yjs_state: mergedState || document.yjs_state
      },
      sync: {
        timestamp: new Date().toISOString(),
        operationsApplied: operations.length,
        conflictsDetected: conflicts.length,
        hasRemoteChanges: (recentChanges?.length || 0) > 0
      },
      conflicts,
      recentChanges: recentChanges?.map(change => ({
        action: change.action,
        user_name: change.user_profiles?.full_name || 'Unknown User',
        user_avatar: change.user_profiles?.avatar_url,
        timestamp: change.timestamp,
        contentLength: change.content_length
      })) || [],
      mobile: {
        rateLimitRemaining: rateLimitResult.remaining,
        suggestedSyncInterval: conflicts.length > 0 ? 10000 : 5000, // More frequent if conflicts
        batterySaveMode: rateLimitResult.remaining < 10
      }
    };

    // Add wedding-specific context
    if (['guest_list', 'timeline'].includes(document.type)) {
      // Get active collaborators for important documents
      const { data: activeCollaborators } = await supabase
        .from('collaborative_document_sessions')
        .select(`
          user_id,
          last_active,
          is_typing,
          user_profiles (
            full_name,
            avatar_url
          )
        `)
        .eq('document_id', documentId)
        .gt('last_active', new Date(Date.now() - 5 * 60 * 1000).toISOString()) // Last 5 minutes
        .neq('user_id', user.id);

      response.collaborators = activeCollaborators?.map(collab => ({
        user_id: collab.user_id,
        name: collab.user_profiles?.full_name || 'Unknown',
        avatar: collab.user_profiles?.avatar_url,
        last_active: collab.last_active,
        is_typing: collab.is_typing
      })) || [];
    }

    return NextResponse.json(response);

  } catch (error) {
    console.error('Collaboration sync API error:', error);

    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { 
          error: 'Invalid sync request',
          details: error.errors.map(e => `${e.path.join('.')}: ${e.message}`)
        },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { error: 'Sync operation failed' },
      { status: 500 }
    );
  }
}

// Handle OPTIONS for CORS
export async function OPTIONS(request: NextRequest) {
  return new NextResponse(null, {
    status: 200,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    },
  });
}