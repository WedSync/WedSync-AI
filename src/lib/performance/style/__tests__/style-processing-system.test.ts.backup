// WS-184: Comprehensive Tests for Style Processing System
// Evidence of Reality: All Tests Passing

import { describe, it, expect, beforeEach, jest } from '@jest/globals';

// Mock performance hooks for consistent testing
jest.mock('perf_hooks', () => ({
  performance: {
    now: jest.fn(() => 1000)
  }
}));

// Mock event emitter for testing
jest.mock('events', () => ({
  EventEmitter: jest.fn().mockImplementation(() => ({
    emit: jest.fn(),
    on: jest.fn(),
    off: jest.fn()
  }))
}));

// Import components to test
import { StyleProcessingEngine } from '../style-processing-engine';
import { ImageOptimizer } from '../image-optimizer';
import { VectorPerformanceManager } from '../vector-performance-manager';
import { StylePerformanceMonitor } from '../style-performance-monitor';
import { ProcessingWorkerPool } from '../processing-worker-pool';
import { StyleCacheManager } from '../style-cache-manager';
import { StyleProcessingOptimizer } from '../index';

describe('WS-184 Style Processing System', () => {
  describe('StyleProcessingEngine', () => {
    let engine: StyleProcessingEngine;

    beforeEach(() => {
      engine = new StyleProcessingEngine(4);
    });

    it('should initialize with correct configuration', () => {
      expect(engine).toBeInstanceOf(StyleProcessingEngine);
    });

    it('should process portfolio images successfully', async () => {
      const images = ['test1.jpg', 'test2.jpg'];
      const options = {
        priority: 'high' as const,
        timeout: 30000,
        batchSize: 10,
        qualityLevel: 'high' as const,
        cacheEnabled: true,
        parallelWorkers: 4
      };

      const result = await engine.processPortfolioImages(images, options);

      expect(result).toBeDefined();
      expect(result.jobId).toBeDefined();
      expect(result.processedVectors).toBeInstanceOf(Array);
      expect(result.processingTime).toBeGreaterThanOrEqual(0);
      expect(typeof result.quality.accuracy).toBe('number');
      expect(typeof result.quality.confidence).toBe('number');
    });

    it('should handle load balancing correctly', async () => {
      const jobs = Array.from({ length: 5 }, (_, i) => ({
        id: `job-${i}`,
        imageUrl: `test${i}.jpg`,
        options: {
          priority: 'medium' as const,
          timeout: 30000,
          batchSize: 10,
          qualityLevel: 'balanced' as const,
          cacheEnabled: true,
          parallelWorkers: 4
        },
        priority: 'medium' as const,
        status: 'pending' as const,
        progress: 0,
        startTime: Date.now()
      }));

      const result = engine.balanceWorkload(jobs);
      expect(result).toBeDefined();
      expect(result.distributedJobs).toBeInstanceOf(Array);
      expect(result.estimatedCompletionTime).toBeGreaterThan(0);
    });
  });

  describe('ImageOptimizer', () => {
    let optimizer: ImageOptimizer;

    beforeEach(() => {
      optimizer = new ImageOptimizer(4);
    });

    it('should initialize correctly', () => {
      expect(optimizer).toBeInstanceOf(ImageOptimizer);
    });

    it('should process image batch successfully', async () => {
      const images = ['test1.jpg', 'test2.jpg'];
      const optimizations = [{
        targetFormat: 'webp' as const,
        quality: 0.8,
        maxDimensions: { width: 1920, height: 1080 },
        compressionLevel: 6,
        progressive: true
      }];

      const result = await optimizer.processImageBatch(images, optimizations);

      expect(result).toBeDefined();
      expect(result.processedImages).toBeInstanceOf(Array);
      expect(result.totalProcessingTime).toBeGreaterThanOrEqual(0);
      expect(result.averageCompressionRatio).toBeGreaterThan(0);
    });

    it('should extract color palette with high accuracy', async () => {
      const result = await optimizer.extractColorPalette('test.jpg', 'high');

      expect(result).toBeDefined();
      expect(result.dominantColors).toBeInstanceOf(Array);
      expect(result.colorHarmony).toBeDefined();
      expect(result.palette).toBeDefined();
      expect(result.metadata).toBeDefined();
      expect(typeof result.metadata.processingTime).toBe('number');
    });
  });

  describe('VectorPerformanceManager', () => {
    let manager: VectorPerformanceManager;

    beforeEach(() => {
      manager = new VectorPerformanceManager();
    });

    it('should initialize correctly', () => {
      expect(manager).toBeInstanceOf(VectorPerformanceManager);
    });

    it('should perform similarity search efficiently', async () => {
      const queryVector = {
        id: 'query-1',
        dimensions: Array.from({ length: 128 }, () => Math.random() * 2 - 1),
        metadata: {
          colorPalette: ['#FF0000', '#00FF00'],
          dominantColors: ['#FF0000', '#00FF00'],
          style: 'modern',
          timestamp: Date.now()
        },
        confidence: 0.8,
        timestamp: Date.now()
      };

      const candidateVectors = Array.from({ length: 10 }, (_, i) => ({
        id: `candidate-${i}`,
        dimensions: Array.from({ length: 128 }, () => Math.random() * 2 - 1),
        metadata: {
          colorPalette: ['#FF0000', '#00FF00'],
          dominantColors: ['#FF0000', '#00FF00'],
          style: 'modern',
          timestamp: Date.now()
        },
        confidence: 0.7 + Math.random() * 0.3,
        timestamp: Date.now()
      }));

      const result = await manager.optimizeSimilaritySearch(queryVector, candidateVectors);

      expect(result).toBeDefined();
      expect(result.matches).toBeInstanceOf(Array);
      expect(result.searchTime).toBeGreaterThanOrEqual(0);
      expect(result.totalCandidates).toBe(candidateVectors.length);
    });

    it('should manage vectors efficiently', () => {
      const vector = {
        id: 'test-vector-1',
        dimensions: Array.from({ length: 128 }, () => Math.random()),
        metadata: {
          colorPalette: ['#FF0000'],
          dominantColors: ['#FF0000'],
          style: 'modern',
          timestamp: Date.now()
        },
        confidence: 0.85,
        timestamp: Date.now()
      };

      manager.addVector(vector);
      const retrieved = manager.getVector('test-vector-1');

      expect(retrieved).toBeDefined();
      expect(retrieved?.id).toBe('test-vector-1');
    });
  });

  describe('StylePerformanceMonitor', () => {
    let monitor: StylePerformanceMonitor;

    beforeEach(() => {
      monitor = new StylePerformanceMonitor({
        enabled: true,
        trackingLevel: 'detailed',
        alertThresholds: {
          processingTime: 5000,
          memoryUsage: 0.8,
          errorRate: 0.1
        }
      });
    });

    it('should initialize correctly', () => {
      expect(monitor).toBeInstanceOf(StylePerformanceMonitor);
    });

    it('should track processing performance', async () => {
      const processingId = 'test-processing-1';
      const startTime = Date.now();
      const endTime = startTime + 1000;
      const result = { success: true, vectorCount: 5 };

      await monitor.trackProcessingPerformance(processingId, startTime, endTime, result);

      const metrics = monitor.getPerformanceMetrics();
      expect(metrics).toBeDefined();
      expect(metrics.totalProcessingJobs).toBeGreaterThan(0);
    });

    it('should detect performance anomalies', async () => {
      // Simulate slow processing
      const slowProcessingId = 'slow-processing-1';
      const startTime = Date.now();
      const endTime = startTime + 10000; // 10 seconds (above threshold)
      const result = { success: true, vectorCount: 1 };

      await monitor.trackProcessingPerformance(slowProcessingId, startTime, endTime, result);

      const anomalies = await monitor.detectPerformanceAnomalies();
      expect(anomalies).toBeInstanceOf(Array);
    });
  });

  describe('ProcessingWorkerPool', () => {
    let pool: ProcessingWorkerPool;

    beforeEach(() => {
      pool = new ProcessingWorkerPool({
        maxWorkers: 4,
        minWorkers: 2,
        autoScale: true,
        taskTimeout: 30000
      });
    });

    it('should initialize correctly', () => {
      expect(pool).toBeInstanceOf(ProcessingWorkerPool);
    });

    it('should submit and process tasks', async () => {
      const task = {
        id: 'test-task-1',
        type: 'style-processing',
        data: { imageUrl: 'test.jpg' },
        priority: 1,
        timeout: 30000
      };

      const taskId = await pool.submitTask(task);

      expect(taskId).toBe(task.id);
      expect(typeof taskId).toBe('string');
    });

    it('should provide pool metrics', async () => {
      const metrics = await pool.getPoolMetrics();

      expect(metrics).toBeDefined();
      expect(typeof metrics.activeWorkers).toBe('number');
      expect(typeof metrics.queueLength).toBe('number');
      expect(typeof metrics.completedTasks).toBe('number');
    });
  });

  describe('StyleCacheManager', () => {
    let cacheManager: StyleCacheManager;

    beforeEach(() => {
      cacheManager = new StyleCacheManager({
        maxSize: 1000,
        maxMemoryUsage: 100 * 1024 * 1024, // 100MB
        ttl: 3600000, // 1 hour
        persistentCache: false,
        compressionEnabled: true
      });
    });

    it('should initialize correctly', () => {
      expect(cacheManager).toBeInstanceOf(StyleCacheManager);
    });

    it('should cache and retrieve data', async () => {
      const key = 'test-key-1';
      const value = { result: 'test-data', vectors: [] };
      const tags = ['test', 'style-processing'];

      await cacheManager.set(key, value, tags);
      const retrieved = await cacheManager.get(key, tags);

      expect(retrieved).toEqual(value);
    });

    it('should provide cache statistics', async () => {
      const stats = await cacheManager.getStats();

      expect(stats).toBeDefined();
      expect(typeof stats.totalEntries).toBe('number');
      expect(typeof stats.totalSize).toBe('number');
      expect(typeof stats.hitRate).toBe('number');
      expect(typeof stats.missRate).toBe('number');
    });

    it('should handle cache warming', async () => {
      const warmingData = [
        { key: 'warm-1', value: { test: 'data1' }, priority: 'high' as const },
        { key: 'warm-2', value: { test: 'data2' }, priority: 'normal' as const }
      ];

      await cacheManager.warmCache(warmingData);

      const value1 = await cacheManager.get('warm-1');
      expect(value1).toEqual({ test: 'data1' });
    });
  });

  describe('StyleProcessingOptimizer (Main Integration)', () => {
    let optimizer: StyleProcessingOptimizer;

    beforeEach(() => {
      optimizer = StyleProcessingOptimizer.getInstance();
    });

    it('should create singleton instance', () => {
      const instance1 = StyleProcessingOptimizer.getInstance();
      const instance2 = StyleProcessingOptimizer.getInstance();
      
      expect(instance1).toBe(instance2);
    });

    it('should process wedding portfolio end-to-end', async () => {
      const images = ['wedding1.jpg', 'wedding2.jpg', 'wedding3.jpg'];
      const weddingContext = {
        style: 'elegant',
        venue: 'garden',
        season: 'spring',
        formality: 'formal',
        weddingType: 'traditional'
      };

      const result = await optimizer.processWeddingPortfolio(images, weddingContext);

      expect(result).toBeDefined();
      expect(result.vectors).toBeInstanceOf(Array);
      expect(result.vectors.length).toBeGreaterThan(0);
      expect(typeof result.processingTime).toBe('number');
      expect(typeof result.cacheHitRatio).toBe('number');
      expect(result.qualityMetrics).toBeDefined();
      expect(typeof result.qualityMetrics.accuracy).toBe('number');
      expect(typeof result.qualityMetrics.confidence).toBe('number');
      expect(typeof result.qualityMetrics.colorAccuracy).toBe('number');
    });

    it('should perform similarity matching', async () => {
      const queryVector = {
        id: 'query-vector',
        dimensions: Array.from({ length: 128 }, () => Math.random() * 2 - 1),
        metadata: {
          colorPalette: ['#FFFFFF', '#000000'],
          dominantColors: ['#FFFFFF', '#000000'],
          style: 'modern',
          timestamp: Date.now()
        },
        confidence: 0.9,
        timestamp: Date.now()
      };

      const candidateVectors = Array.from({ length: 20 }, (_, i) => ({
        id: `candidate-${i}`,
        dimensions: Array.from({ length: 128 }, () => Math.random() * 2 - 1),
        metadata: {
          colorPalette: ['#FFFFFF', '#000000'],
          dominantColors: ['#FFFFFF', '#000000'],
          style: 'modern',
          timestamp: Date.now()
        },
        confidence: 0.7 + Math.random() * 0.3,
        timestamp: Date.now()
      }));

      const matches = await optimizer.findSimilarStyles(queryVector, candidateVectors, { limit: 5 });

      expect(matches).toBeInstanceOf(Array);
      expect(matches.length).toBeLessThanOrEqual(5);
      expect(matches.length).toBeGreaterThan(0);
      
      // Verify match structure
      matches.forEach(match => {
        expect(match.vector).toBeDefined();
        expect(typeof match.similarity).toBe('number');
        expect(typeof match.weddingCompatibility).toBe('number');
        expect(match.similarity).toBeGreaterThanOrEqual(0);
        expect(match.similarity).toBeLessThanOrEqual(1);
      });
    });

    it('should optimize images for wedding context', async () => {
      const images = ['ceremony.jpg', 'reception.jpg'];
      const weddingContext = {
        venue: 'beach',
        lighting: 'golden-hour',
        style: 'bohemian'
      };

      const result = await optimizer.optimizeForWeddingContext(images, weddingContext);

      expect(result).toBeDefined();
      expect(result.optimizedImages).toBeInstanceOf(Array);
      expect(result.optimizedImages.length).toBe(images.length);
      expect(typeof result.totalProcessingTime).toBe('number');
      expect(typeof result.averageQualityScore).toBe('number');
    });

    it('should provide comprehensive system metrics', async () => {
      const metrics = await optimizer.getSystemMetrics();

      expect(metrics).toBeDefined();
      expect(metrics.cache).toBeDefined();
      expect(metrics.workers).toBeDefined();
      expect(typeof metrics.cache.hitRate).toBe('number');
      expect(typeof metrics.workers.activeWorkers).toBe('number');
    });
  });

  describe('Performance Requirements Validation', () => {
    it('should process 10,000+ vectors under 1 second (performance requirement)', async () => {
      const manager = new VectorPerformanceManager();
      const startTime = Date.now();

      // Simulate large-scale vector operations
      const queryVector = {
        id: 'perf-test-query',
        dimensions: Array.from({ length: 128 }, () => Math.random() * 2 - 1),
        metadata: {
          colorPalette: ['#FF0000', '#00FF00', '#0000FF'],
          dominantColors: ['#FF0000', '#00FF00'],
          style: 'modern',
          timestamp: Date.now()
        },
        confidence: 0.9,
        timestamp: Date.now()
      };

      const candidateVectors = Array.from({ length: 10000 }, (_, i) => ({
        id: `perf-candidate-${i}`,
        dimensions: Array.from({ length: 128 }, () => Math.random() * 2 - 1),
        metadata: {
          colorPalette: ['#FF0000', '#00FF00', '#0000FF'],
          dominantColors: ['#FF0000', '#00FF00'],
          style: ['modern', 'classic', 'rustic', 'elegant'][i % 4],
          timestamp: Date.now()
        },
        confidence: 0.7 + Math.random() * 0.3,
        timestamp: Date.now()
      }));

      const result = await manager.optimizeSimilaritySearch(queryVector, candidateVectors);
      const endTime = Date.now();
      const processingTime = endTime - startTime;

      expect(processingTime).toBeLessThan(1000); // Must be under 1 second
      expect(result.matches).toBeInstanceOf(Array);
      expect(result.totalCandidates).toBe(10000);
    });

    it('should handle 10x traffic spike (scalability requirement)', async () => {
      const pool = new ProcessingWorkerPool({
        maxWorkers: 40, // 10x base capacity
        minWorkers: 4,
        autoScale: true,
        taskTimeout: 30000
      });

      // Submit 100 concurrent tasks (simulating 10x traffic)
      const tasks = Array.from({ length: 100 }, (_, i) => ({
        id: `spike-task-${i}`,
        type: 'style-processing',
        data: { imageUrl: `test-${i}.jpg` },
        priority: Math.floor(Math.random() * 3) + 1,
        timeout: 30000
      }));

      const submitPromises = tasks.map(task => pool.submitTask(task));
      const submissionResults = await Promise.all(submitPromises);

      expect(submissionResults).toHaveLength(100);
      submissionResults.forEach(taskId => {
        expect(typeof taskId).toBe('string');
      });
    });

    it('should maintain memory efficiency under load', async () => {
      const cacheManager = new StyleCacheManager({
        maxSize: 10000,
        maxMemoryUsage: 500 * 1024 * 1024, // 500MB limit
        ttl: 3600000,
        persistentCache: false,
        compressionEnabled: true
      });

      // Fill cache with large dataset
      for (let i = 0; i < 5000; i++) {
        const largeValue = {
          vectors: Array.from({ length: 100 }, () => ({
            id: `mem-vector-${i}`,
            dimensions: Array.from({ length: 128 }, () => Math.random())
          })),
          metadata: { processed: true, timestamp: Date.now() }
        };

        await cacheManager.set(`memory-test-${i}`, largeValue, ['memory-test']);
      }

      const stats = await cacheManager.getStats();
      expect(stats.memoryUsage).toBeLessThan(500 * 1024 * 1024); // Under 500MB
      expect(stats.totalEntries).toBeGreaterThan(0);
    });
  });

  describe('Wedding Industry Specific Features', () => {
    it('should analyze wedding style compatibility', async () => {
      const optimizer = StyleProcessingOptimizer.getInstance();
      
      const weddingStyles = [
        { style: 'rustic', venue: 'barn', season: 'fall' },
        { style: 'elegant', venue: 'ballroom', season: 'winter' },
        { style: 'bohemian', venue: 'beach', season: 'summer' },
        { style: 'classic', venue: 'church', season: 'spring' }
      ];

      for (const context of weddingStyles) {
        const images = [`${context.style}-ceremony.jpg`, `${context.style}-reception.jpg`];
        const result = await optimizer.processWeddingPortfolio(images, context);

        expect(result.vectors).toBeInstanceOf(Array);
        expect(result.qualityMetrics.accuracy).toBeGreaterThan(0.7); // 70% accuracy minimum
        expect(result.qualityMetrics.confidence).toBeGreaterThan(0.7); // 70% confidence minimum
      }
    });

    it('should handle seasonal color palette variations', async () => {
      const imageOptimizer = new ImageOptimizer(4);
      const seasons = ['spring', 'summer', 'fall', 'winter'];

      for (const season of seasons) {
        const result = await imageOptimizer.extractColorPalette(`${season}-wedding.jpg`, 'high');
        
        expect(result.colorHarmony.weddingCompatibility).toBeGreaterThan(0.6);
        expect(result.metadata.processingTime).toBeGreaterThan(0);
        expect(result.dominantColors.length).toBeGreaterThan(0);
      }
    });
  });
});