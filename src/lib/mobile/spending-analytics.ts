/**
 * Advanced Spending Analytics & Pattern Recognition
 * Team D - Round 2 WS-163 Implementation
 *
 * Provides intelligent spending pattern analysis, predictions, and recommendations
 * specifically tailored for wedding planning with mobile visualizations.
 */

import {
  WeddingBudget,
  BudgetCategory,
  BudgetItem,
  SpendingPattern,
  SpendingAnomaly,
} from './advanced-budget-system';

// ==================== TYPES AND INTERFACES ====================

export interface SpendingAnalytics {
  overall: OverallSpendingMetrics;
  categories: CategoryAnalytics[];
  predictions: SpendingPredictions;
  trends: SpendingTrends;
  comparisons: IndustryComparisons;
  alerts: SpendingAlert[];
  visualizations: VisualizationData[];
}

export interface OverallSpendingMetrics {
  totalSpent: number;
  totalBudget: number;
  remainingBudget: number;
  spentPercentage: number;
  projectedTotal: number;
  projectedOverrun: number;
  burnRate: number;
  daysRemaining: number;
  velocity: SpendingVelocity;
}

export interface CategoryAnalytics {
  categoryId: string;
  name: string;
  allocated: number;
  spent: number;
  remaining: number;
  utilization: number;
  trend: TrendDirection;
  trendStrength: number;
  seasonalityFactor: number;
  averageItemCost: number;
  costPerDay: number;
  projectedFinal: number;
  confidenceScore: number;
  riskLevel: RiskLevel;
  recommendations: CategoryRecommendation[];
}

export interface SpendingPredictions {
  finalTotalPrediction: number;
  categoryPredictions: { [categoryId: string]: CategoryPrediction };
  timelinePredictions: TimelinePrediction[];
  confidenceIntervals: ConfidenceInterval[];
  scenarioAnalysis: ScenarioAnalysis;
}

export interface CategoryPrediction {
  categoryId: string;
  predictedTotal: number;
  confidenceScore: number;
  factors: PredictionFactor[];
  riskFactors: string[];
  opportunities: string[];
}

export interface SpendingTrends {
  monthlyTrends: MonthlyTrend[];
  weeklyPatterns: WeeklyPattern[];
  vendorSpendingTrends: VendorTrend[];
  paymentMethodTrends: PaymentMethodTrend[];
  seasonalPatterns: SeasonalPattern[];
}

export interface IndustryComparisons {
  industryAverages: { [categoryName: string]: number };
  percentileRanking: number;
  similarWeddingComparisons: SimilarWeddingComparison[];
  regionalDifferences: RegionalComparison[];
  budgetRangeComparisons: BudgetRangeComparison[];
}

export interface SpendingAlert {
  id: string;
  type: AlertType;
  severity: AlertSeverity;
  categoryId?: string;
  title: string;
  description: string;
  recommendation: string;
  impact: number;
  timeframe: string;
  autoGenerated: boolean;
  dismissed: boolean;
  createdAt: string;
}

export interface VisualizationData {
  type: VisualizationType;
  title: string;
  data: any;
  config: VisualizationConfig;
  mobileOptimized: boolean;
  interactionHints: string[];
}

export interface SpendingVelocity {
  currentRate: number;
  averageRate: number;
  accelerating: boolean;
  daysToDepletion: number;
}

export interface TimelinePrediction {
  date: string;
  predictedSpend: number;
  cumulativeSpend: number;
  confidence: number;
  majorEvents: string[];
}

export interface ConfidenceInterval {
  categoryId: string;
  lower: number;
  upper: number;
  confidence: number;
}

export interface ScenarioAnalysis {
  optimistic: ScenarioOutcome;
  realistic: ScenarioOutcome;
  pessimistic: ScenarioOutcome;
}

export interface ScenarioOutcome {
  totalCost: number;
  overrunAmount: number;
  probability: number;
  keyFactors: string[];
}

export enum TrendDirection {
  INCREASING = 'increasing',
  DECREASING = 'decreasing',
  STABLE = 'stable',
  VOLATILE = 'volatile',
}

export enum RiskLevel {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  CRITICAL = 'critical',
}

export enum AlertType {
  BUDGET_OVERRUN = 'budget_overrun',
  RAPID_SPENDING = 'rapid_spending',
  CATEGORY_IMBALANCE = 'category_imbalance',
  VENDOR_PRICE_INCREASE = 'vendor_price_increase',
  PAYMENT_DUE = 'payment_due',
  COST_OPPORTUNITY = 'cost_opportunity',
}

export enum AlertSeverity {
  INFO = 'info',
  WARNING = 'warning',
  ERROR = 'error',
  CRITICAL = 'critical',
}

export enum VisualizationType {
  PIE_CHART = 'pie_chart',
  BAR_CHART = 'bar_chart',
  LINE_CHART = 'line_chart',
  SCATTER_PLOT = 'scatter_plot',
  HEAT_MAP = 'heat_map',
  TREND_LINE = 'trend_line',
  PROGRESS_RING = 'progress_ring',
}

export interface VisualizationConfig {
  responsive: boolean;
  touchEnabled: boolean;
  colors: string[];
  animation: boolean;
  legend: boolean;
  dataLabels: boolean;
}

export interface MonthlyTrend {
  month: string;
  totalSpent: number;
  trend: TrendDirection;
  variance: number;
}

export interface WeeklyPattern {
  dayOfWeek: string;
  averageSpend: number;
  peakHours: number[];
}

export interface VendorTrend {
  vendorId: string;
  vendorName: string;
  totalSpent: number;
  itemCount: number;
  averageItemCost: number;
  trend: TrendDirection;
}

export interface PaymentMethodTrend {
  method: string;
  usage: number;
  averageAmount: number;
  trend: TrendDirection;
}

export interface SeasonalPattern {
  season: string;
  multiplier: number;
  categories: string[];
}

export interface SimilarWeddingComparison {
  weddingSize: string;
  location: string;
  season: string;
  averageTotal: number;
  categoryBreakdown: { [category: string]: number };
}

export interface RegionalComparison {
  region: string;
  averageTotal: number;
  costOfLiving: number;
  categoryDifferences: { [category: string]: number };
}

export interface BudgetRangeComparison {
  range: string;
  averageSpend: number;
  commonCategories: string[];
  priorityDifferences: string[];
}

export interface CategoryRecommendation {
  type: 'reallocation' | 'optimization' | 'timing';
  description: string;
  impact: number;
  confidence: number;
}

export interface PredictionFactor {
  name: string;
  impact: number;
  confidence: number;
  description: string;
}

// ==================== ADVANCED SPENDING ANALYTICS ENGINE ====================

export class AdvancedSpendingAnalyticsEngine {
  private static instance: AdvancedSpendingAnalyticsEngine;
  private mlModels: MachineLearningModels;
  private industryData: IndustryBenchmarkData;
  private visualizationEngine: MobileVisualizationEngine;

  private constructor() {
    this.mlModels = new MachineLearningModels();
    this.industryData = new IndustryBenchmarkData();
    this.visualizationEngine = new MobileVisualizationEngine();
  }

  public static getInstance(): AdvancedSpendingAnalyticsEngine {
    if (!AdvancedSpendingAnalyticsEngine.instance) {
      AdvancedSpendingAnalyticsEngine.instance =
        new AdvancedSpendingAnalyticsEngine();
    }
    return AdvancedSpendingAnalyticsEngine.instance;
  }

  // ==================== COMPREHENSIVE ANALYTICS ====================

  public async generateComprehensiveAnalytics(
    budget: WeddingBudget,
  ): Promise<SpendingAnalytics> {
    const [
      overall,
      categories,
      predictions,
      trends,
      comparisons,
      alerts,
      visualizations,
    ] = await Promise.all([
      this.calculateOverallMetrics(budget),
      this.analyzeCategoriesInDepth(budget),
      this.generatePredictions(budget),
      this.analyzeTrends(budget),
      this.generateIndustryComparisons(budget),
      this.generateAlerts(budget),
      this.createMobileVisualizations(budget),
    ]);

    return {
      overall,
      categories,
      predictions,
      trends,
      comparisons,
      alerts,
      visualizations,
    };
  }

  // ==================== OVERALL METRICS CALCULATION ====================

  private async calculateOverallMetrics(
    budget: WeddingBudget,
  ): Promise<OverallSpendingMetrics> {
    const totalSpent = budget.spent_amount;
    const totalBudget = budget.total_budget;
    const remainingBudget = totalBudget - totalSpent;
    const spentPercentage = (totalSpent / totalBudget) * 100;

    // Calculate burn rate (spending per day)
    const weddingDate = new Date(
      budget.milestones.find((m) => m.name === 'Wedding Day')?.target_date ||
        Date.now() + 365 * 24 * 60 * 60 * 1000,
    );
    const daysRemaining = Math.max(
      1,
      Math.ceil((weddingDate.getTime() - Date.now()) / (24 * 60 * 60 * 1000)),
    );
    const burnRate = this.calculateBurnRate(budget);

    // Project final costs
    const projectedTotal = await this.mlModels.predictFinalCost(budget);
    const projectedOverrun = Math.max(0, projectedTotal - totalBudget);

    // Calculate spending velocity
    const velocity = this.calculateSpendingVelocity(budget);

    return {
      totalSpent,
      totalBudget,
      remainingBudget,
      spentPercentage,
      projectedTotal,
      projectedOverrun,
      burnRate,
      daysRemaining,
      velocity,
    };
  }

  private calculateBurnRate(budget: WeddingBudget): number {
    // Calculate based on recent spending activity
    const recentItems = this.getRecentItems(budget, 30); // Last 30 days
    const totalRecentSpent = recentItems.reduce(
      (sum, item) => sum + (item.actual_cost || 0),
      0,
    );
    return totalRecentSpent / 30; // Daily burn rate
  }

  private calculateSpendingVelocity(budget: WeddingBudget): SpendingVelocity {
    const recentItems = this.getRecentItems(budget, 14); // Last 2 weeks
    const olderItems = this.getRecentItems(budget, 28).filter(
      (item) => !recentItems.find((r) => r.id === item.id),
    );

    const recentRate =
      recentItems.reduce((sum, item) => sum + (item.actual_cost || 0), 0) / 14;
    const olderRate =
      olderItems.length > 0
        ? olderItems.reduce((sum, item) => sum + (item.actual_cost || 0), 0) /
          14
        : recentRate;

    const averageRate = (recentRate + olderRate) / 2;
    const accelerating = recentRate > olderRate * 1.1;
    const daysToDepletion = budget.remaining_budget / Math.max(recentRate, 1);

    return {
      currentRate: recentRate,
      averageRate,
      accelerating,
      daysToDepletion,
    };
  }

  // ==================== CATEGORY ANALYTICS ====================

  private async analyzeCategoriesInDepth(
    budget: WeddingBudget,
  ): Promise<CategoryAnalytics[]> {
    const analytics: CategoryAnalytics[] = [];

    for (const category of budget.categories) {
      const spent = category.spent_amount;
      const allocated = category.allocated_amount;
      const remaining = allocated - spent;
      const utilization = (spent / allocated) * 100;

      // Analyze trends
      const trend = this.analyzeCategoryTrend(category);
      const trendStrength = this.calculateTrendStrength(category);
      const seasonalityFactor = this.calculateSeasonality(category.name);

      // Item metrics
      const averageItemCost =
        category.items.length > 0
          ? spent / category.items.filter((i) => i.actual_cost).length
          : 0;
      const costPerDay = this.calculateCostPerDay(category);

      // Predictions
      const projectedFinal = await this.mlModels.predictCategoryCost(
        category,
        budget,
      );
      const confidenceScore = this.calculateConfidenceScore(category);
      const riskLevel = this.assessRiskLevel(
        category,
        projectedFinal,
        allocated,
      );

      // Recommendations
      const recommendations = this.generateCategoryRecommendations(
        category,
        budget,
      );

      analytics.push({
        categoryId: category.id,
        name: category.name,
        allocated,
        spent,
        remaining,
        utilization,
        trend,
        trendStrength,
        seasonalityFactor,
        averageItemCost,
        costPerDay,
        projectedFinal,
        confidenceScore,
        riskLevel,
        recommendations,
      });
    }

    return analytics;
  }

  private analyzeCategoryTrend(category: BudgetCategory): TrendDirection {
    const items = category.items
      .filter((item) => item.actual_cost && item.updated_at)
      .sort(
        (a, b) =>
          new Date(a.updated_at).getTime() - new Date(b.updated_at).getTime(),
      );

    if (items.length < 3) return TrendDirection.STABLE;

    const firstThird = items.slice(0, Math.floor(items.length / 3));
    const lastThird = items.slice(-Math.floor(items.length / 3));

    const firstAvg =
      firstThird.reduce((sum, item) => sum + (item.actual_cost || 0), 0) /
      firstThird.length;
    const lastAvg =
      lastThird.reduce((sum, item) => sum + (item.actual_cost || 0), 0) /
      lastThird.length;

    const changePercentage = ((lastAvg - firstAvg) / firstAvg) * 100;

    if (Math.abs(changePercentage) < 5) return TrendDirection.STABLE;
    if (changePercentage > 15) return TrendDirection.INCREASING;
    if (changePercentage < -15) return TrendDirection.DECREASING;

    // Check for volatility
    const variance = this.calculateVariance(
      items.map((i) => i.actual_cost || 0),
    );
    const mean =
      items.reduce((sum, item) => sum + (item.actual_cost || 0), 0) /
      items.length;
    const coefficientOfVariation = Math.sqrt(variance) / mean;

    return coefficientOfVariation > 0.5
      ? TrendDirection.VOLATILE
      : TrendDirection.STABLE;
  }

  private calculateTrendStrength(category: BudgetCategory): number {
    const items = category.items.filter((item) => item.actual_cost);
    if (items.length < 2) return 0;

    const values = items.map((item) => item.actual_cost || 0);
    const n = values.length;
    const sumX = values.reduce((sum, _, index) => sum + index, 0);
    const sumY = values.reduce((sum, value) => sum + value, 0);
    const sumXY = values.reduce((sum, value, index) => sum + index * value, 0);
    const sumXX = values.reduce((sum, _, index) => sum + index * index, 0);

    const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
    const avgY = sumY / n;

    return Math.abs(slope) / avgY; // Normalized trend strength
  }

  private calculateSeasonality(categoryName: string): number {
    // Wedding-specific seasonality factors
    const seasonalCategories: { [key: string]: number } = {
      flowers: 1.2, // Higher in spring/summer
      venue: 1.3, // Peak wedding season premium
      photography: 1.1, // Slight seasonal variation
      catering: 1.0, // Relatively stable
      attire: 0.9, // Often purchased off-season
      transportation: 1.2, // Higher in peak season
      music: 1.1, // Higher demand in summer
      decorations: 1.0, // Stable year-round
    };

    const lowerName = categoryName.toLowerCase();
    for (const [category, factor] of Object.entries(seasonalCategories)) {
      if (lowerName.includes(category)) {
        return factor;
      }
    }

    return 1.0; // Default no seasonality
  }

  private calculateCostPerDay(category: BudgetCategory): number {
    const itemsWithDates = category.items.filter(
      (item) => item.actual_cost && item.updated_at,
    );
    if (itemsWithDates.length === 0) return 0;

    const sortedItems = itemsWithDates.sort(
      (a, b) =>
        new Date(a.updated_at).getTime() - new Date(b.updated_at).getTime(),
    );

    const firstDate = new Date(sortedItems[0].updated_at);
    const lastDate = new Date(sortedItems[sortedItems.length - 1].updated_at);
    const daysDiff = Math.max(
      1,
      (lastDate.getTime() - firstDate.getTime()) / (24 * 60 * 60 * 1000),
    );

    return category.spent_amount / daysDiff;
  }

  private calculateConfidenceScore(category: BudgetCategory): number {
    let confidence = 0.5; // Base confidence

    // More items = higher confidence
    const itemCount = category.items.length;
    confidence += Math.min(0.3, itemCount * 0.05);

    // More actual costs = higher confidence
    const actualCosts = category.items.filter(
      (item) => item.actual_cost,
    ).length;
    confidence += Math.min(0.2, (actualCosts / Math.max(itemCount, 1)) * 0.2);

    // Less variance = higher confidence
    const costs = category.items
      .map((item) => item.actual_cost || 0)
      .filter((cost) => cost > 0);
    if (costs.length > 1) {
      const variance = this.calculateVariance(costs);
      const mean = costs.reduce((sum, cost) => sum + cost, 0) / costs.length;
      const cv = Math.sqrt(variance) / mean;
      confidence += Math.max(0, 0.2 - cv * 0.1);
    }

    return Math.min(1, confidence);
  }

  private assessRiskLevel(
    category: BudgetCategory,
    projected: number,
    allocated: number,
  ): RiskLevel {
    const overrunPercentage = ((projected - allocated) / allocated) * 100;

    if (overrunPercentage > 50) return RiskLevel.CRITICAL;
    if (overrunPercentage > 25) return RiskLevel.HIGH;
    if (overrunPercentage > 10) return RiskLevel.MEDIUM;
    return RiskLevel.LOW;
  }

  // ==================== PREDICTIONS ====================

  private async generatePredictions(
    budget: WeddingBudget,
  ): Promise<SpendingPredictions> {
    const finalTotalPrediction = await this.mlModels.predictFinalCost(budget);
    const categoryPredictions: { [categoryId: string]: CategoryPrediction } =
      {};

    for (const category of budget.categories) {
      const prediction = await this.predictCategoryOutcome(category, budget);
      categoryPredictions[category.id] = prediction;
    }

    const timelinePredictions = await this.generateTimelinePredictions(budget);
    const confidenceIntervals = this.calculateConfidenceIntervals(budget);
    const scenarioAnalysis = await this.generateScenarioAnalysis(budget);

    return {
      finalTotalPrediction,
      categoryPredictions,
      timelinePredictions,
      confidenceIntervals,
      scenarioAnalysis,
    };
  }

  private async predictCategoryOutcome(
    category: BudgetCategory,
    budget: WeddingBudget,
  ): Promise<CategoryPrediction> {
    const predictedTotal = await this.mlModels.predictCategoryCost(
      category,
      budget,
    );
    const confidenceScore = this.calculateConfidenceScore(category);

    const factors: PredictionFactor[] = [
      {
        name: 'Spending Velocity',
        impact: this.calculateCostPerDay(category),
        confidence: 0.8,
        description: 'Current rate of spending in this category',
      },
      {
        name: 'Seasonality',
        impact: this.calculateSeasonality(category.name),
        confidence: 0.7,
        description: 'Seasonal price variations for wedding services',
      },
      {
        name: 'Market Conditions',
        impact: this.getMarketConditionsFactor(category.name),
        confidence: 0.6,
        description: 'Current market pricing trends',
      },
    ];

    const riskFactors = this.identifyRiskFactors(category, budget);
    const opportunities = this.identifyOpportunities(category, budget);

    return {
      categoryId: category.id,
      predictedTotal,
      confidenceScore,
      factors,
      riskFactors,
      opportunities,
    };
  }

  private identifyRiskFactors(
    category: BudgetCategory,
    budget: WeddingBudget,
  ): string[] {
    const risks: string[] = [];

    // Check for rapid spending
    const costPerDay = this.calculateCostPerDay(category);
    const daysRemaining = this.getDaysUntilWedding(budget);
    if (costPerDay * daysRemaining > category.allocated_amount * 1.5) {
      risks.push('Rapid spending rate may exceed budget');
    }

    // Check for incomplete items
    const incompleteItems = category.items.filter(
      (item) => item.status !== 'completed' && item.status !== 'paid',
    ).length;
    if (incompleteItems > category.items.length * 0.5) {
      risks.push('Many items still incomplete - costs may increase');
    }

    // Check for seasonal pricing
    if (this.calculateSeasonality(category.name) > 1.1) {
      risks.push('Peak season pricing may apply');
    }

    return risks;
  }

  private identifyOpportunities(
    category: BudgetCategory,
    budget: WeddingBudget,
  ): string[] {
    const opportunities: string[] = [];

    // Check for under-utilization
    const utilization =
      (category.spent_amount / category.allocated_amount) * 100;
    if (utilization < 70) {
      opportunities.push('Potential savings to reallocate to other categories');
    }

    // Check for bulk purchasing opportunities
    const unpaidItems = category.items.filter((item) => !item.actual_cost);
    if (unpaidItems.length > 3) {
      opportunities.push('Bulk purchasing discounts may be available');
    }

    // Check for off-season savings
    if (this.calculateSeasonality(category.name) > 1.0) {
      opportunities.push('Consider booking during off-peak times');
    }

    return opportunities;
  }

  // ==================== MOBILE VISUALIZATIONS ====================

  private async createMobileVisualizations(
    budget: WeddingBudget,
  ): Promise<VisualizationData[]> {
    return await this.visualizationEngine.generateMobileOptimizedCharts(budget);
  }

  // ==================== ALERT GENERATION ====================

  private async generateAlerts(
    budget: WeddingBudget,
  ): Promise<SpendingAlert[]> {
    const alerts: SpendingAlert[] = [];

    // Budget overrun alerts
    for (const category of budget.categories) {
      const projected = await this.mlModels.predictCategoryCost(
        category,
        budget,
      );
      if (projected > category.allocated_amount * 1.1) {
        alerts.push({
          id: `alert_${Date.now()}_${category.id}`,
          type: AlertType.BUDGET_OVERRUN,
          severity:
            projected > category.allocated_amount * 1.25
              ? AlertSeverity.CRITICAL
              : AlertSeverity.WARNING,
          categoryId: category.id,
          title: `${category.name} Budget Risk`,
          description: `Projected cost ($${projected.toFixed(2)}) may exceed budget ($${category.allocated_amount.toFixed(2)})`,
          recommendation: 'Consider adjusting scope or increasing allocation',
          impact: projected - category.allocated_amount,
          timeframe: 'Before wedding day',
          autoGenerated: true,
          dismissed: false,
          createdAt: new Date().toISOString(),
        });
      }
    }

    // Rapid spending alerts
    const burnRate = this.calculateBurnRate(budget);
    const daysRemaining = this.getDaysUntilWedding(budget);
    if (burnRate * daysRemaining > budget.remaining_budget * 1.5) {
      alerts.push({
        id: `alert_${Date.now()}_burn_rate`,
        type: AlertType.RAPID_SPENDING,
        severity: AlertSeverity.WARNING,
        title: 'High Spending Rate',
        description: `Current spending rate may exhaust budget before wedding`,
        recommendation: 'Review recent expenses and adjust spending pace',
        impact: burnRate * daysRemaining - budget.remaining_budget,
        timeframe: `${Math.floor(budget.remaining_budget / burnRate)} days at current rate`,
        autoGenerated: true,
        dismissed: false,
        createdAt: new Date().toISOString(),
      });
    }

    return alerts;
  }

  // ==================== UTILITY METHODS ====================

  private getRecentItems(budget: WeddingBudget, days: number): BudgetItem[] {
    const cutoff = new Date(Date.now() - days * 24 * 60 * 60 * 1000);
    return budget.categories
      .flatMap((cat) => cat.items)
      .filter((item) => item.actual_cost && new Date(item.updated_at) > cutoff);
  }

  private calculateVariance(values: number[]): number {
    if (values.length === 0) return 0;
    const mean = values.reduce((sum, value) => sum + value, 0) / values.length;
    return (
      values.reduce((sum, value) => sum + Math.pow(value - mean, 2), 0) /
      values.length
    );
  }

  private getDaysUntilWedding(budget: WeddingBudget): number {
    const weddingMilestone = budget.milestones.find(
      (m) => m.name === 'Wedding Day',
    );
    if (!weddingMilestone) return 365; // Default 1 year

    const weddingDate = new Date(weddingMilestone.target_date);
    return Math.max(
      1,
      Math.ceil((weddingDate.getTime() - Date.now()) / (24 * 60 * 60 * 1000)),
    );
  }

  private getMarketConditionsFactor(categoryName: string): number {
    // Simplified market conditions - in reality, this would come from external data
    const marketFactors: { [key: string]: number } = {
      venue: 1.1, // High demand
      catering: 1.05, // Moderate increase
      photography: 1.0, // Stable
      flowers: 1.15, // Supply chain issues
      music: 1.0, // Stable
      transportation: 1.2, // Fuel costs
    };

    const lowerName = categoryName.toLowerCase();
    for (const [category, factor] of Object.entries(marketFactors)) {
      if (lowerName.includes(category)) {
        return factor;
      }
    }

    return 1.0; // Default stable
  }

  private async generateTimelinePredictions(
    budget: WeddingBudget,
  ): Promise<TimelinePrediction[]> {
    // Generate predictions for the next 12 months
    const predictions: TimelinePrediction[] = [];
    const weddingDate = new Date(
      budget.milestones.find((m) => m.name === 'Wedding Day')?.target_date ||
        Date.now() + 365 * 24 * 60 * 60 * 1000,
    );

    for (let i = 0; i < 12; i++) {
      const date = new Date();
      date.setMonth(date.getMonth() + i);

      const predictedSpend = await this.mlModels.predictMonthlySpend(
        budget,
        date,
      );
      const cumulativeSpend = budget.spent_amount + predictedSpend * i;

      predictions.push({
        date: date.toISOString().split('T')[0],
        predictedSpend,
        cumulativeSpend,
        confidence: 0.8 - i * 0.05, // Confidence decreases over time
        majorEvents: this.getMajorEventsForMonth(date, weddingDate),
      });
    }

    return predictions;
  }

  private getMajorEventsForMonth(date: Date, weddingDate: Date): string[] {
    const events: string[] = [];
    const monthsUntilWedding = Math.ceil(
      (weddingDate.getTime() - date.getTime()) / (30 * 24 * 60 * 60 * 1000),
    );

    if (monthsUntilWedding === 12) events.push('Initial vendor bookings');
    if (monthsUntilWedding === 6) events.push('Final headcount, venue details');
    if (monthsUntilWedding === 3)
      events.push('Final payments, last-minute details');
    if (monthsUntilWedding === 1) events.push('Final preparations, honeymoon');
    if (monthsUntilWedding === 0) events.push('Wedding month');

    return events;
  }

  private calculateConfidenceIntervals(
    budget: WeddingBudget,
  ): ConfidenceInterval[] {
    return budget.categories.map((category) => ({
      categoryId: category.id,
      lower: category.allocated_amount * 0.9,
      upper: category.allocated_amount * 1.2,
      confidence: 0.95,
    }));
  }

  private async generateScenarioAnalysis(
    budget: WeddingBudget,
  ): Promise<ScenarioAnalysis> {
    const baseTotal = await this.mlModels.predictFinalCost(budget);

    return {
      optimistic: {
        totalCost: baseTotal * 0.95,
        overrunAmount: Math.max(0, baseTotal * 0.95 - budget.total_budget),
        probability: 0.2,
        keyFactors: [
          'No unexpected costs',
          'Good vendor negotiation',
          'Off-season savings',
        ],
      },
      realistic: {
        totalCost: baseTotal,
        overrunAmount: Math.max(0, baseTotal - budget.total_budget),
        probability: 0.6,
        keyFactors: [
          'Expected cost increases',
          'Some scope changes',
          'Normal market conditions',
        ],
      },
      pessimistic: {
        totalCost: baseTotal * 1.15,
        overrunAmount: Math.max(0, baseTotal * 1.15 - budget.total_budget),
        probability: 0.2,
        keyFactors: [
          'Significant scope creep',
          'Peak season pricing',
          'Vendor price increases',
        ],
      },
    };
  }

  private async analyzeTrends(budget: WeddingBudget): Promise<SpendingTrends> {
    // Simplified trend analysis - in practice, this would be more sophisticated
    return {
      monthlyTrends: [],
      weeklyPatterns: [],
      vendorSpendingTrends: [],
      paymentMethodTrends: [],
      seasonalPatterns: [],
    };
  }

  private async generateIndustryComparisons(
    budget: WeddingBudget,
  ): Promise<IndustryComparisons> {
    return await this.industryData.getComparisons(budget);
  }

  private generateCategoryRecommendations(
    category: BudgetCategory,
    budget: WeddingBudget,
  ): CategoryRecommendation[] {
    const recommendations: CategoryRecommendation[] = [];

    const utilization =
      (category.spent_amount / category.allocated_amount) * 100;

    if (utilization < 50) {
      recommendations.push({
        type: 'reallocation',
        description:
          'Consider reallocating unused budget to categories that may go over',
        impact: category.allocated_amount - category.spent_amount,
        confidence: 0.8,
      });
    }

    if (utilization > 80) {
      recommendations.push({
        type: 'optimization',
        description:
          'Look for cost-saving opportunities or increase allocation',
        impact: category.spent_amount - category.allocated_amount,
        confidence: 0.7,
      });
    }

    return recommendations;
  }
}

// ==================== MACHINE LEARNING MODELS ====================

class MachineLearningModels {
  async predictFinalCost(budget: WeddingBudget): Promise<number> {
    // Simplified ML prediction - in reality, this would use trained models
    let prediction = budget.spent_amount;

    for (const category of budget.categories) {
      const categoryCost = await this.predictCategoryCost(category, budget);
      prediction += categoryCost - category.spent_amount;
    }

    return prediction;
  }

  async predictCategoryCost(
    category: BudgetCategory,
    budget: WeddingBudget,
  ): Promise<number> {
    // Simple linear regression based on current spending patterns
    const paidItems = category.items.filter((item) => item.actual_cost);
    const unpaidItems = category.items.filter((item) => !item.actual_cost);

    if (paidItems.length === 0) {
      return category.allocated_amount; // Default to allocation
    }

    const avgCost =
      paidItems.reduce((sum, item) => sum + (item.actual_cost || 0), 0) /
      paidItems.length;
    const predictedUnpaidCost = unpaidItems.reduce(
      (sum, item) => sum + (item.estimated_cost || avgCost),
      0,
    );

    return category.spent_amount + predictedUnpaidCost;
  }

  async predictMonthlySpend(
    budget: WeddingBudget,
    month: Date,
  ): Promise<number> {
    // Simplified monthly prediction
    const totalRemaining = budget.total_budget - budget.spent_amount;
    const monthsRemaining = this.getMonthsUntilWedding(budget);

    // Wedding spending typically accelerates as the date approaches
    const accelerationFactor = Math.max(0.5, 2 - monthsRemaining / 12);

    return (totalRemaining / monthsRemaining) * accelerationFactor;
  }

  private getMonthsUntilWedding(budget: WeddingBudget): number {
    const weddingMilestone = budget.milestones.find(
      (m) => m.name === 'Wedding Day',
    );
    if (!weddingMilestone) return 12;

    const weddingDate = new Date(weddingMilestone.target_date);
    return Math.max(
      1,
      Math.ceil(
        (weddingDate.getTime() - Date.now()) / (30 * 24 * 60 * 60 * 1000),
      ),
    );
  }
}

// ==================== INDUSTRY BENCHMARK DATA ====================

class IndustryBenchmarkData {
  async getComparisons(budget: WeddingBudget): Promise<IndustryComparisons> {
    // Simplified industry data - in reality, this would come from external APIs
    const industryAverages = {
      Venue: 0.45, // 45% of budget
      Catering: 0.3, // 30% of budget
      Photography: 0.1, // 10% of budget
      Music: 0.08, // 8% of budget
      Flowers: 0.07, // 7% of budget
    };

    return {
      industryAverages,
      percentileRanking: 75, // Example: 75th percentile
      similarWeddingComparisons: [],
      regionalDifferences: [],
      budgetRangeComparisons: [],
    };
  }
}

// ==================== MOBILE VISUALIZATION ENGINE ====================

class MobileVisualizationEngine {
  async generateMobileOptimizedCharts(
    budget: WeddingBudget,
  ): Promise<VisualizationData[]> {
    const visualizations: VisualizationData[] = [];

    // Budget overview pie chart
    visualizations.push({
      type: VisualizationType.PIE_CHART,
      title: 'Budget Breakdown',
      data: budget.categories.map((cat) => ({
        name: cat.name,
        value: cat.allocated_amount,
        color: cat.color,
      })),
      config: {
        responsive: true,
        touchEnabled: true,
        colors: budget.categories.map((cat) => cat.color),
        animation: true,
        legend: true,
        dataLabels: true,
      },
      mobileOptimized: true,
      interactionHints: ['Tap slice for details', 'Pinch to zoom'],
    });

    // Spending progress rings
    visualizations.push({
      type: VisualizationType.PROGRESS_RING,
      title: 'Category Progress',
      data: budget.categories.map((cat) => ({
        name: cat.name,
        spent: cat.spent_amount,
        budget: cat.allocated_amount,
        percentage: (cat.spent_amount / cat.allocated_amount) * 100,
      })),
      config: {
        responsive: true,
        touchEnabled: true,
        colors: ['#4CAF50', '#FF9800', '#F44336'],
        animation: true,
        legend: false,
        dataLabels: true,
      },
      mobileOptimized: true,
      interactionHints: ['Swipe to see all categories'],
    });

    return visualizations;
  }
}

// ==================== SINGLETON EXPORT ====================

export const spendingAnalytics = AdvancedSpendingAnalyticsEngine.getInstance();
export default AdvancedSpendingAnalyticsEngine;
