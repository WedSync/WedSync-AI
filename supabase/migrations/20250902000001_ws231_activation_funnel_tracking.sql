-- =============================================
-- WS-231: ACTIVATION FUNNEL TRACKING SYSTEM
-- Team D (Platform) - Round 1 Implementation  
-- Generated by: Team D Platform Team
-- Date: 2025-09-02
-- =============================================

-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pg_stat_statements";

-- =============================================
-- ACTIVATION TRACKING TABLES
-- =============================================

-- User activation events tracking
-- Tracks detailed user actions that contribute to activation
CREATE TABLE IF NOT EXISTS user_activation_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  user_type TEXT CHECK (user_type IN ('supplier', 'couple')) NOT NULL,
  event_name TEXT NOT NULL,
  event_data JSONB DEFAULT '{}',
  session_id TEXT,
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  
  -- Wedding industry context
  wedding_context JSONB DEFAULT '{}', -- Wedding date, venue info, etc.
  business_context JSONB DEFAULT '{}', -- Business size, industry segment, etc.
  
  -- Technical metadata
  page_url TEXT,
  referrer TEXT,
  user_agent TEXT,
  platform VARCHAR(50) DEFAULT 'wedsync', -- 'wedsync' or 'wedme'
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Activation stages configuration
-- Defines the funnel stages for different user types
CREATE TABLE IF NOT EXISTS activation_stages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_type TEXT NOT NULL CHECK (user_type IN ('supplier', 'couple')),
  stage_order INTEGER NOT NULL,
  stage_name TEXT NOT NULL,
  stage_description TEXT,
  
  -- Event criteria for stage completion
  required_events TEXT[] NOT NULL DEFAULT ARRAY[]::TEXT[], -- Events that MUST occur
  optional_events TEXT[] DEFAULT ARRAY[]::TEXT[], -- Events that can substitute
  min_events INTEGER DEFAULT 1, -- Minimum number of events needed
  max_timeframe_days INTEGER DEFAULT 30, -- Max days from signup to complete stage
  
  -- Business logic
  is_critical BOOLEAN DEFAULT true, -- Is this stage critical for activation?
  weight DECIMAL(3,2) DEFAULT 1.0, -- Weight in overall activation score
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(user_type, stage_order)
);

-- User activation status tracking
-- Consolidated view of each user's activation progress
CREATE TABLE IF NOT EXISTS user_activation_status (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  user_type TEXT NOT NULL CHECK (user_type IN ('supplier', 'couple')),
  
  -- Activation metrics
  is_activated BOOLEAN DEFAULT FALSE,
  activation_score DECIMAL(5,2) DEFAULT 0.00, -- 0-100 activation score
  stages_completed INTEGER DEFAULT 0,
  total_stages INTEGER DEFAULT 0,
  
  -- Timing metrics
  signed_up_at TIMESTAMPTZ,
  activated_at TIMESTAMPTZ,
  first_critical_action_at TIMESTAMPTZ,
  last_activity_at TIMESTAMPTZ,
  time_to_activation INTERVAL, -- Time from signup to activation
  
  -- Stage completion tracking
  stage_completion_data JSONB DEFAULT '{}', -- Detailed stage progress
  dropoff_stage INTEGER, -- Stage where user dropped off
  dropoff_reason TEXT,
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(user_id)
);

-- Activation cohort analysis
-- Pre-calculated activation metrics by cohort
CREATE TABLE IF NOT EXISTS activation_cohort_metrics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  cohort_date DATE NOT NULL, -- Signup date
  user_type TEXT NOT NULL CHECK (user_type IN ('supplier', 'couple')),
  
  -- Cohort size metrics
  total_signups INTEGER DEFAULT 0,
  activated_users INTEGER DEFAULT 0,
  activation_rate DECIMAL(5,2) DEFAULT 0.00,
  
  -- Timing metrics
  avg_time_to_activation INTERVAL,
  median_time_to_activation INTERVAL,
  p95_time_to_activation INTERVAL,
  
  -- Stage breakdown (JSONB for flexibility)
  stage_breakdown JSONB DEFAULT '{}',
  dropoff_analysis JSONB DEFAULT '{}',
  
  -- Attribution data
  traffic_sources JSONB DEFAULT '{}',
  conversion_by_source JSONB DEFAULT '{}',
  
  -- Calculation metadata
  calculated_at TIMESTAMPTZ DEFAULT NOW(),
  calculation_duration_ms INTEGER,
  
  UNIQUE(cohort_date, user_type)
);

-- =============================================
-- PERFORMANCE INDEXES
-- =============================================

-- User activation events indexes
CREATE INDEX IF NOT EXISTS idx_activation_events_user_time 
  ON user_activation_events(user_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_activation_events_type_event 
  ON user_activation_events(user_type, event_name, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_activation_events_session 
  ON user_activation_events(session_id, created_at);
CREATE INDEX IF NOT EXISTS idx_activation_events_organization 
  ON user_activation_events(organization_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_activation_events_data 
  ON user_activation_events USING GIN(event_data);
CREATE INDEX IF NOT EXISTS idx_activation_events_wedding_context 
  ON user_activation_events USING GIN(wedding_context);

-- User activation status indexes
CREATE INDEX IF NOT EXISTS idx_activation_status_type_activated 
  ON user_activation_status(user_type, is_activated);
CREATE INDEX IF NOT EXISTS idx_activation_status_score 
  ON user_activation_status(activation_score DESC) WHERE is_activated = true;
CREATE INDEX IF NOT EXISTS idx_activation_status_timing 
  ON user_activation_status(signed_up_at, activated_at) WHERE activated_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_activation_status_dropoff 
  ON user_activation_status(dropoff_stage) WHERE dropoff_stage IS NOT NULL;

-- Activation stages indexes
CREATE INDEX IF NOT EXISTS idx_activation_stages_type_order 
  ON activation_stages(user_type, stage_order);

-- Cohort metrics indexes
CREATE INDEX IF NOT EXISTS idx_cohort_metrics_date_type 
  ON activation_cohort_metrics(cohort_date DESC, user_type);
CREATE INDEX IF NOT EXISTS idx_cohort_metrics_rate 
  ON activation_cohort_metrics(activation_rate DESC);

-- =============================================
-- DEFAULT ACTIVATION STAGES CONFIGURATION
-- =============================================

-- Supplier activation stages (Photography business workflow)
INSERT INTO activation_stages (user_type, stage_order, stage_name, stage_description, required_events, min_events, max_timeframe_days, is_critical, weight) VALUES
('supplier', 1, 'Email Verification', 'Confirm email address and access account', ARRAY['email_verified'], 1, 1, true, 1.0),
('supplier', 2, 'Profile Setup', 'Complete business profile with basic information', ARRAY['profile_completed', 'business_info_added'], 1, 7, true, 1.0),
('supplier', 3, 'Service Configuration', 'Add services, pricing, or portfolio items', ARRAY['service_added', 'pricing_set', 'portfolio_uploaded'], 1, 7, true, 1.0),
('supplier', 4, 'Client Interaction', 'Add first client or create first form', ARRAY['client_added', 'form_created'], 1, 7, true, 1.0),
('supplier', 5, 'Active Engagement', 'Start using core features regularly', ARRAY['journey_started', 'form_published', 'client_communication_sent'], 1, 14, false, 0.8);

-- Couple activation stages (Wedding planning workflow)
INSERT INTO activation_stages (user_type, stage_order, stage_name, stage_description, required_events, min_events, max_timeframe_days, is_critical, weight) VALUES
('couple', 1, 'Email Verification', 'Confirm email address and access account', ARRAY['email_verified'], 1, 1, true, 1.0),
('couple', 2, 'Wedding Details', 'Set wedding date and basic wedding information', ARRAY['wedding_date_set', 'wedding_info_completed'], 1, 14, true, 1.0),
('couple', 3, 'Venue Selection', 'Add wedding venue information', ARRAY['venue_added', 'location_set'], 1, 14, true, 1.0),
('couple', 4, 'Guest Management', 'Start building guest list', ARRAY['guest_added', 'guest_list_started'], 1, 21, true, 1.0),
('couple', 5, 'Vendor Interaction', 'Connect with or invite wedding vendors', ARRAY['vendor_contacted', 'vendor_invited', 'form_submitted'], 1, 30, false, 0.8);

-- =============================================
-- ACTIVATION TRACKING FUNCTIONS
-- =============================================

-- Function to calculate activation funnel for a specific user type and time period
CREATE OR REPLACE FUNCTION calculate_activation_funnel(
  p_user_type TEXT,
  p_start_date TIMESTAMPTZ,
  p_end_date TIMESTAMPTZ
) RETURNS TABLE (
  stage_order INTEGER,
  stage_name TEXT,
  stage_description TEXT,
  users_reached INTEGER,
  users_completed INTEGER,
  conversion_rate DECIMAL,
  avg_time_to_reach DECIMAL,
  dropoff_rate DECIMAL
) AS $$
BEGIN
  RETURN QUERY
  WITH signup_cohort AS (
    SELECT DISTINCT u.id as user_id, up.created_at as signup_date
    FROM auth.users u
    JOIN user_profiles up ON u.id = up.user_id
    WHERE up.created_at >= p_start_date 
    AND up.created_at < p_end_date
    AND (
      (p_user_type = 'supplier' AND up.organization_id IS NOT NULL) OR
      (p_user_type = 'couple' AND up.organization_id IS NULL)
    )
  ),
  stage_completions AS (
    SELECT 
      s.stage_order,
      s.stage_name,
      s.stage_description,
      COUNT(DISTINCT sc.user_id) as users_reached,
      COUNT(DISTINCT CASE 
        WHEN uas.stages_completed >= s.stage_order THEN sc.user_id 
        ELSE NULL 
      END) as users_completed,
      AVG(EXTRACT(EPOCH FROM (
        CASE WHEN uas.stages_completed >= s.stage_order 
        THEN uas.activated_at - sc.signup_date 
        ELSE NULL END
      )) / 3600) as avg_hours_to_reach
    FROM activation_stages s
    CROSS JOIN signup_cohort sc
    LEFT JOIN user_activation_status uas ON sc.user_id = uas.user_id
    WHERE s.user_type = p_user_type
    GROUP BY s.stage_order, s.stage_name, s.stage_description
  )
  SELECT 
    sc.stage_order,
    sc.stage_name,
    sc.stage_description,
    sc.users_reached,
    sc.users_completed,
    CASE WHEN sc.users_reached > 0 
      THEN ROUND((sc.users_completed::DECIMAL / sc.users_reached) * 100, 2)
      ELSE 0 
    END as conversion_rate,
    COALESCE(sc.avg_hours_to_reach, 0) as avg_time_to_reach,
    CASE WHEN sc.users_reached > 0 
      THEN ROUND(((sc.users_reached - sc.users_completed)::DECIMAL / sc.users_reached) * 100, 2)
      ELSE 0 
    END as dropoff_rate
  FROM stage_completions sc
  ORDER BY sc.stage_order;
END;
$$ LANGUAGE plpgsql;

-- Function to track activation event and update user status
CREATE OR REPLACE FUNCTION track_activation_event(
  p_user_id UUID,
  p_event_name TEXT,
  p_event_data JSONB DEFAULT '{}',
  p_session_id TEXT DEFAULT NULL
) RETURNS BOOLEAN AS $$
DECLARE
  v_user_type TEXT;
  v_organization_id UUID;
  v_activation_updated BOOLEAN := FALSE;
BEGIN
  -- Get user type and organization
  SELECT 
    CASE WHEN up.organization_id IS NOT NULL THEN 'supplier' ELSE 'couple' END,
    up.organization_id
  INTO v_user_type, v_organization_id
  FROM user_profiles up
  WHERE up.user_id = p_user_id;
  
  -- Insert activation event
  INSERT INTO user_activation_events (
    user_id, user_type, event_name, event_data, session_id, organization_id
  ) VALUES (
    p_user_id, v_user_type, p_event_name, p_event_data, p_session_id, v_organization_id
  );
  
  -- Update user activation status
  PERFORM update_user_activation_status(p_user_id);
  
  RETURN TRUE;
  
EXCEPTION WHEN OTHERS THEN
  RAISE LOG 'Error tracking activation event for user %: %', p_user_id, SQLERRM;
  RETURN FALSE;
END;
$$ LANGUAGE plpgsql;

-- Function to update user activation status based on events
CREATE OR REPLACE FUNCTION update_user_activation_status(p_user_id UUID) 
RETURNS BOOLEAN AS $$
DECLARE
  v_user_type TEXT;
  v_signup_date TIMESTAMPTZ;
  v_completed_stages INTEGER := 0;
  v_total_stages INTEGER;
  v_activation_score DECIMAL := 0.00;
  v_is_activated BOOLEAN := FALSE;
  stage_record RECORD;
BEGIN
  -- Get user information
  SELECT 
    CASE WHEN up.organization_id IS NOT NULL THEN 'supplier' ELSE 'couple' END,
    up.created_at
  INTO v_user_type, v_signup_date
  FROM user_profiles up
  WHERE up.user_id = p_user_id;
  
  -- Get total stages for user type
  SELECT COUNT(*) INTO v_total_stages
  FROM activation_stages
  WHERE user_type = v_user_type;
  
  -- Check each stage completion
  FOR stage_record IN 
    SELECT stage_order, required_events, min_events, is_critical, weight
    FROM activation_stages 
    WHERE user_type = v_user_type 
    ORDER BY stage_order
  LOOP
    -- Count matching events for this stage
    WITH matching_events AS (
      SELECT COUNT(*) as event_count
      FROM user_activation_events uae
      WHERE uae.user_id = p_user_id
      AND uae.event_name = ANY(stage_record.required_events)
    )
    SELECT 
      CASE WHEN me.event_count >= stage_record.min_events THEN 1 ELSE 0 END
    INTO v_completed_stages
    FROM matching_events me;
    
    -- Add to activation score if stage completed
    IF v_completed_stages > 0 THEN
      v_activation_score := v_activation_score + (stage_record.weight * (100.0 / v_total_stages));
    END IF;
  END LOOP;
  
  -- Determine if user is activated (completed all critical stages)
  SELECT 
    CASE WHEN COUNT(*) = COUNT(CASE WHEN completed THEN 1 END) THEN TRUE ELSE FALSE END
  INTO v_is_activated
  FROM (
    SELECT 
      s.stage_order,
      s.is_critical,
      EXISTS(
        SELECT 1 FROM user_activation_events uae
        WHERE uae.user_id = p_user_id
        AND uae.event_name = ANY(s.required_events)
        GROUP BY uae.user_id
        HAVING COUNT(*) >= s.min_events
      ) as completed
    FROM activation_stages s
    WHERE s.user_type = v_user_type AND s.is_critical = true
  ) stage_check;
  
  -- Insert or update activation status
  INSERT INTO user_activation_status (
    user_id, user_type, is_activated, activation_score, 
    stages_completed, total_stages, signed_up_at, 
    activated_at, last_activity_at
  ) VALUES (
    p_user_id, v_user_type, v_is_activated, v_activation_score,
    v_completed_stages, v_total_stages, v_signup_date,
    CASE WHEN v_is_activated THEN NOW() ELSE NULL END,
    NOW()
  )
  ON CONFLICT (user_id) DO UPDATE SET
    is_activated = EXCLUDED.is_activated,
    activation_score = EXCLUDED.activation_score,
    stages_completed = EXCLUDED.stages_completed,
    total_stages = EXCLUDED.total_stages,
    activated_at = CASE 
      WHEN user_activation_status.activated_at IS NULL AND EXCLUDED.is_activated 
      THEN NOW() 
      ELSE user_activation_status.activated_at 
    END,
    time_to_activation = CASE 
      WHEN EXCLUDED.is_activated AND user_activation_status.activated_at IS NULL
      THEN NOW() - user_activation_status.signed_up_at
      ELSE user_activation_status.time_to_activation
    END,
    last_activity_at = NOW(),
    updated_at = NOW();
    
  RETURN TRUE;
  
EXCEPTION WHEN OTHERS THEN
  RAISE LOG 'Error updating activation status for user %: %', p_user_id, SQLERRM;
  RETURN FALSE;
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- ROW LEVEL SECURITY POLICIES
-- =============================================

-- Enable RLS on activation tables
ALTER TABLE user_activation_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE activation_stages ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_activation_status ENABLE ROW LEVEL SECURITY;
ALTER TABLE activation_cohort_metrics ENABLE ROW LEVEL SECURITY;

-- User activation events policies
CREATE POLICY "Users can view their own activation events" ON user_activation_events
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "System can insert activation events" ON user_activation_events
  FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Activation stages policies (read-only for users)
CREATE POLICY "Users can view activation stages" ON activation_stages
  FOR SELECT USING (true);

-- User activation status policies
CREATE POLICY "Users can view their own activation status" ON user_activation_status
  FOR SELECT USING (auth.uid() = user_id);

-- Admin policies for cohort metrics (admin users only)
CREATE POLICY "Admins can view cohort metrics" ON activation_cohort_metrics
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM user_profiles up 
      WHERE up.user_id = auth.uid() 
      AND up.role IN ('OWNER', 'ADMIN')
    )
  );

-- =============================================
-- AUTOMATED TRIGGERS AND MAINTENANCE
-- =============================================

-- Trigger to automatically track key activation events
CREATE OR REPLACE FUNCTION auto_track_activation_events() 
RETURNS TRIGGER AS $$
BEGIN
  -- Track profile completion
  IF TG_TABLE_NAME = 'user_profiles' AND OLD.first_name IS NULL AND NEW.first_name IS NOT NULL THEN
    PERFORM track_activation_event(NEW.user_id, 'profile_completed', 
      jsonb_build_object('trigger', 'profile_update'));
  END IF;
  
  -- Track form creation
  IF TG_TABLE_NAME = 'forms' AND TG_OP = 'INSERT' THEN
    PERFORM track_activation_event(
      (SELECT user_id FROM user_profiles WHERE organization_id = NEW.organization_id AND role = 'OWNER'),
      'form_created',
      jsonb_build_object('form_id', NEW.id, 'form_name', NEW.name)
    );
  END IF;
  
  -- Track client addition
  IF TG_TABLE_NAME = 'clients' AND TG_OP = 'INSERT' THEN
    PERFORM track_activation_event(
      (SELECT user_id FROM user_profiles WHERE organization_id = NEW.organization_id AND role = 'OWNER'),
      'client_added',
      jsonb_build_object('client_id', NEW.id)
    );
  END IF;
  
  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

-- Create triggers for automatic event tracking
CREATE TRIGGER trigger_auto_track_profile_events
  AFTER UPDATE ON user_profiles
  FOR EACH ROW EXECUTE FUNCTION auto_track_activation_events();

CREATE TRIGGER trigger_auto_track_form_events
  AFTER INSERT ON forms
  FOR EACH ROW EXECUTE FUNCTION auto_track_activation_events();

-- Note: Additional triggers would be added for clients table once confirmed it exists

-- =============================================
-- PERFORMANCE MONITORING VIEWS
-- =============================================

-- View for activation funnel overview
CREATE OR REPLACE VIEW activation_funnel_overview AS
SELECT 
  user_type,
  COUNT(*) as total_users,
  COUNT(CASE WHEN is_activated THEN 1 END) as activated_users,
  ROUND(
    COUNT(CASE WHEN is_activated THEN 1 END)::DECIMAL / 
    COUNT(*)::DECIMAL * 100, 2
  ) as activation_rate,
  ROUND(AVG(activation_score), 2) as avg_activation_score,
  AVG(EXTRACT(EPOCH FROM time_to_activation) / 86400) as avg_days_to_activation
FROM user_activation_status
GROUP BY user_type;

-- View for daily activation metrics
CREATE OR REPLACE VIEW daily_activation_metrics AS
SELECT 
  DATE(signed_up_at) as signup_date,
  user_type,
  COUNT(*) as signups,
  COUNT(CASE WHEN is_activated THEN 1 END) as activations,
  ROUND(
    COUNT(CASE WHEN is_activated THEN 1 END)::DECIMAL / 
    COUNT(*)::DECIMAL * 100, 2
  ) as activation_rate
FROM user_activation_status
WHERE signed_up_at >= CURRENT_DATE - INTERVAL '30 days'
GROUP BY DATE(signed_up_at), user_type
ORDER BY signup_date DESC, user_type;

-- =============================================
-- INITIAL DATA MIGRATION
-- =============================================

-- Migrate existing users to activation tracking
-- This creates activation status records for existing users
INSERT INTO user_activation_status (
  user_id, 
  user_type, 
  signed_up_at,
  is_activated,
  activation_score,
  stages_completed,
  total_stages
)
SELECT 
  up.user_id,
  CASE WHEN up.organization_id IS NOT NULL THEN 'supplier' ELSE 'couple' END as user_type,
  up.created_at as signed_up_at,
  COALESCE(up.onboarding_completed, FALSE) as is_activated,
  CASE WHEN up.onboarding_completed THEN 100.0 ELSE 0.0 END as activation_score,
  CASE WHEN up.onboarding_completed THEN 5 ELSE 0 END as stages_completed,
  5 as total_stages
FROM user_profiles up
WHERE up.user_id NOT IN (SELECT user_id FROM user_activation_status)
ON CONFLICT (user_id) DO NOTHING;

-- Create initial email verification events for existing users
INSERT INTO user_activation_events (user_id, user_type, event_name, event_data)
SELECT 
  u.id,
  CASE WHEN up.organization_id IS NOT NULL THEN 'supplier' ELSE 'couple' END,
  'email_verified',
  jsonb_build_object('migrated', true, 'verified_at', u.email_confirmed_at)
FROM auth.users u
JOIN user_profiles up ON u.id = up.user_id
WHERE u.email_confirmed_at IS NOT NULL
ON CONFLICT DO NOTHING;

-- =============================================
-- MIGRATION COMPLETE
-- =============================================

-- Log successful migration
DO $$
BEGIN
  RAISE NOTICE 'WS-231 Activation Funnel Tracking System migration completed successfully';
  RAISE NOTICE 'Tables created: user_activation_events, activation_stages, user_activation_status, activation_cohort_metrics';
  RAISE NOTICE 'Functions created: calculate_activation_funnel, track_activation_event, update_user_activation_status';
  RAISE NOTICE 'Views created: activation_funnel_overview, daily_activation_metrics';
  RAISE NOTICE 'Default activation stages configured for suppliers and couples';
  RAISE NOTICE 'Existing users migrated to activation tracking system';
END $$;