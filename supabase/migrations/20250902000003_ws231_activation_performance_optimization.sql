-- =============================================
-- WS-231: ACTIVATION PERFORMANCE OPTIMIZATION
-- Team D (Platform) - Performance Indexes & Query Optimization
-- Generated by: Team D Platform Team
-- Date: 2025-09-02
-- =============================================

-- =============================================
-- ADVANCED PERFORMANCE INDEXES
-- =============================================

-- Composite indexes for complex activation queries
CREATE INDEX IF NOT EXISTS idx_activation_events_user_type_event_time 
  ON user_activation_events(user_id, user_type, event_name, created_at DESC);

CREATE INDEX IF NOT EXISTS idx_activation_events_org_type_event 
  ON user_activation_events(organization_id, user_type, event_name) 
  WHERE organization_id IS NOT NULL;

-- Advanced activation status indexes for dashboard queries
CREATE INDEX IF NOT EXISTS idx_activation_status_type_score_activated 
  ON user_activation_status(user_type, activation_score DESC, is_activated);

CREATE INDEX IF NOT EXISTS idx_activation_status_signup_activated_time 
  ON user_activation_status(DATE(signed_up_at), user_type, is_activated) 
  WHERE signed_up_at >= CURRENT_DATE - INTERVAL '365 days';

-- Time-based partitioning indexes for cohort analysis
CREATE INDEX IF NOT EXISTS idx_activation_status_cohort_analysis 
  ON user_activation_status(
    DATE_TRUNC('month', signed_up_at), 
    user_type, 
    is_activated,
    time_to_activation
  ) WHERE signed_up_at IS NOT NULL;

-- Dropoff analysis optimized indexes
CREATE INDEX IF NOT EXISTS idx_activation_status_dropoff_analysis 
  ON user_activation_status(user_type, dropoff_stage, stages_completed) 
  WHERE is_activated = false AND dropoff_stage IS NOT NULL;

-- Session-based analysis indexes
CREATE INDEX IF NOT EXISTS idx_activation_events_session_analysis 
  ON user_activation_events(session_id, created_at, event_name) 
  WHERE session_id IS NOT NULL;

-- Wedding context analysis (JSONB optimized)
CREATE INDEX IF NOT EXISTS idx_activation_events_wedding_date 
  ON user_activation_events((wedding_context->>'wedding_date')) 
  WHERE wedding_context ? 'wedding_date';

CREATE INDEX IF NOT EXISTS idx_activation_events_business_type 
  ON user_activation_events((event_data->>'business_type'), user_type) 
  WHERE event_data ? 'business_type';

-- Traffic source attribution indexes
CREATE INDEX IF NOT EXISTS idx_activation_events_utm_source 
  ON user_activation_events((event_data->>'utm_source'), created_at DESC) 
  WHERE event_data ? 'utm_source';

CREATE INDEX IF NOT EXISTS idx_activation_events_referrer 
  ON user_activation_events((event_data->>'referrer'), created_at DESC) 
  WHERE event_data ? 'referrer';

-- =============================================
-- PARTIAL INDEXES FOR HIGH-FREQUENCY QUERIES
-- =============================================

-- Recent activations (most queried data)
CREATE INDEX IF NOT EXISTS idx_recent_activations 
  ON user_activation_status(activated_at DESC, user_type) 
  WHERE activated_at >= CURRENT_DATE - INTERVAL '30 days';

-- Recent signups (dashboard queries)
CREATE INDEX IF NOT EXISTS idx_recent_signups 
  ON user_activation_status(signed_up_at DESC, user_type, is_activated) 
  WHERE signed_up_at >= CURRENT_DATE - INTERVAL '7 days';

-- High-value activated users (business intelligence)
CREATE INDEX IF NOT EXISTS idx_high_value_activated_users 
  ON user_activation_status(activation_score DESC, activated_at DESC) 
  WHERE is_activated = true AND activation_score >= 80.0;

-- Problem users (customer success)
CREATE INDEX IF NOT EXISTS idx_problem_users 
  ON user_activation_status(last_activity_at DESC, stages_completed) 
  WHERE is_activated = false 
  AND signed_up_at < CURRENT_DATE - INTERVAL '7 days';

-- =============================================
-- STATISTICS AND HISTOGRAM OPTIMIZATION
-- =============================================

-- Update statistics for better query planning
ANALYZE user_activation_events;
ANALYZE user_activation_status;
ANALYZE activation_stages;
ANALYZE activation_cohort_metrics;

-- Create extended statistics for correlated columns
CREATE STATISTICS IF NOT EXISTS stats_activation_user_time_type 
  ON user_id, created_at, user_type 
  FROM user_activation_events;

CREATE STATISTICS IF NOT EXISTS stats_activation_status_correlation 
  ON user_type, is_activated, activation_score, signed_up_at 
  FROM user_activation_status;

CREATE STATISTICS IF NOT EXISTS stats_activation_timing_correlation 
  ON signed_up_at, activated_at, time_to_activation, stages_completed 
  FROM user_activation_status;

-- =============================================
-- QUERY OPTIMIZATION FUNCTIONS
-- =============================================

-- Optimized function for dashboard summary (cached results)
CREATE OR REPLACE FUNCTION get_activation_dashboard_summary_fast(
  p_user_type TEXT DEFAULT NULL,
  p_use_cache BOOLEAN DEFAULT true
) RETURNS TABLE (
  user_type TEXT,
  total_users BIGINT,
  activated_users BIGINT,
  activation_rate DECIMAL,
  avg_activation_score DECIMAL,
  avg_days_to_activation DECIMAL,
  weekly_signups BIGINT,
  weekly_activations BIGINT
) AS $$
BEGIN
  -- Use materialized view if cache enabled and no specific user type
  IF p_use_cache AND p_user_type IS NULL THEN
    RETURN QUERY
    SELECT 
      ads.user_type,
      ads.total_users,
      ads.activated_users,
      ads.activation_rate,
      ads.avg_activation_score,
      ads.avg_days_to_activation,
      ads.weekly_signups,
      ads.weekly_activations
    FROM activation_dashboard_summary ads;
    RETURN;
  END IF;
  
  -- Real-time calculation for specific user type or when cache disabled
  RETURN QUERY
  SELECT 
    uas.user_type,
    COUNT(*)::BIGINT,
    COUNT(CASE WHEN uas.is_activated THEN 1 END)::BIGINT,
    ROUND(
      COUNT(CASE WHEN uas.is_activated THEN 1 END)::DECIMAL / 
      COUNT(*)::DECIMAL * 100, 2
    ),
    ROUND(AVG(uas.activation_score), 2),
    ROUND(AVG(EXTRACT(EPOCH FROM uas.time_to_activation) / 86400), 2),
    COUNT(CASE WHEN uas.signed_up_at >= CURRENT_DATE - INTERVAL '7 days' THEN 1 END)::BIGINT,
    COUNT(CASE WHEN uas.activated_at >= CURRENT_DATE - INTERVAL '7 days' THEN 1 END)::BIGINT
  FROM user_activation_status uas
  WHERE p_user_type IS NULL OR uas.user_type = p_user_type
  GROUP BY uas.user_type;
END;
$$ LANGUAGE plpgsql;

-- Optimized cohort analysis with pre-aggregation
CREATE OR REPLACE FUNCTION get_cohort_metrics_fast(
  p_user_type TEXT,
  p_months_back INTEGER DEFAULT 6
) RETURNS TABLE (
  cohort_date DATE,
  total_signups INTEGER,
  activated_users INTEGER,
  activation_rate DECIMAL,
  avg_time_to_activation DECIMAL
) AS $$
BEGIN
  -- First try to get from pre-calculated cohort metrics
  IF EXISTS (
    SELECT 1 FROM activation_cohort_metrics 
    WHERE user_type = p_user_type 
    AND cohort_date >= CURRENT_DATE - INTERVAL '1 month' * p_months_back
    LIMIT 1
  ) THEN
    RETURN QUERY
    SELECT 
      acm.cohort_date,
      acm.total_signups,
      acm.activated_users,
      acm.activation_rate,
      EXTRACT(EPOCH FROM acm.avg_time_to_activation) / 86400
    FROM activation_cohort_metrics acm
    WHERE acm.user_type = p_user_type
    AND acm.cohort_date >= CURRENT_DATE - INTERVAL '1 month' * p_months_back
    ORDER BY acm.cohort_date DESC;
    RETURN;
  END IF;
  
  -- Fallback to real-time calculation
  RETURN QUERY
  SELECT 
    DATE(uas.signed_up_at) as cohort_date,
    COUNT(*)::INTEGER as total_signups,
    COUNT(CASE WHEN uas.is_activated THEN 1 END)::INTEGER as activated_users,
    ROUND(
      COUNT(CASE WHEN uas.is_activated THEN 1 END)::DECIMAL / 
      COUNT(*)::DECIMAL * 100, 2
    ) as activation_rate,
    ROUND(AVG(EXTRACT(EPOCH FROM uas.time_to_activation) / 86400), 2) as avg_time_to_activation
  FROM user_activation_status uas
  WHERE uas.user_type = p_user_type
  AND uas.signed_up_at >= CURRENT_DATE - INTERVAL '1 month' * p_months_back
  GROUP BY DATE(uas.signed_up_at)
  ORDER BY DATE(uas.signed_up_at) DESC;
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- BACKGROUND JOB OPTIMIZATION
-- =============================================

-- Efficient batch processing for activation status updates
CREATE OR REPLACE FUNCTION batch_update_activation_status(
  p_batch_size INTEGER DEFAULT 1000,
  p_max_age_hours INTEGER DEFAULT 24
) RETURNS INTEGER AS $$
DECLARE
  v_updated_count INTEGER := 0;
  v_batch_count INTEGER;
  user_batch RECORD;
BEGIN
  -- Process users who haven't been updated recently
  FOR user_batch IN (
    SELECT user_id
    FROM user_profiles up
    WHERE up.created_at >= CURRENT_TIMESTAMP - INTERVAL '1 hour' * p_max_age_hours
    AND (
      up.user_id NOT IN (SELECT user_id FROM user_activation_status)
      OR up.user_id IN (
        SELECT uas.user_id 
        FROM user_activation_status uas 
        WHERE uas.updated_at < CURRENT_TIMESTAMP - INTERVAL '1 hour'
        AND NOT uas.is_activated
      )
    )
    LIMIT p_batch_size
  ) LOOP
    -- Update individual user status
    PERFORM update_user_activation_status(user_batch.user_id);
    v_updated_count := v_updated_count + 1;
  END LOOP;
  
  RETURN v_updated_count;
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- AUTOMATED MAINTENANCE PROCEDURES
-- =============================================

-- Procedure to maintain optimal performance
CREATE OR REPLACE FUNCTION maintain_activation_performance() 
RETURNS VOID AS $$
BEGIN
  -- Update table statistics
  ANALYZE user_activation_events;
  ANALYZE user_activation_status;
  ANALYZE activation_cohort_metrics;
  
  -- Refresh materialized views if they're stale
  IF (
    SELECT last_updated 
    FROM activation_dashboard_summary 
    LIMIT 1
  ) < CURRENT_TIMESTAMP - INTERVAL '1 hour' THEN
    PERFORM refresh_activation_dashboard();
  END IF;
  
  -- Calculate missing cohort metrics
  PERFORM calculate_daily_cohort_metrics();
  
  -- Clean up old event data (beyond retention period)
  DELETE FROM user_activation_events 
  WHERE created_at < CURRENT_TIMESTAMP - INTERVAL '2 years';
  
  -- Vacuum and reindex if needed
  -- Note: These would typically be handled by automated maintenance jobs
  
  RAISE NOTICE 'Activation tracking performance maintenance completed at %', NOW();
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- QUERY PERFORMANCE MONITORING
-- =============================================

-- View to monitor query performance
CREATE OR REPLACE VIEW activation_query_performance AS
SELECT 
  schemaname,
  tablename,
  seq_scan,
  seq_tup_read,
  idx_scan,
  idx_tup_fetch,
  n_tup_ins,
  n_tup_upd,
  n_tup_del,
  n_live_tup,
  n_dead_tup,
  last_vacuum,
  last_autovacuum,
  last_analyze,
  last_autoanalyze
FROM pg_stat_user_tables 
WHERE tablename LIKE '%activation%' 
   OR tablename = 'user_profiles'
ORDER BY seq_tup_read DESC;

-- Function to identify slow activation queries
CREATE OR REPLACE FUNCTION identify_slow_activation_queries(
  p_min_duration_ms INTEGER DEFAULT 1000
) RETURNS TABLE (
  query_text TEXT,
  calls BIGINT,
  total_time_ms DECIMAL,
  avg_time_ms DECIMAL,
  rows_per_call DECIMAL
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    REGEXP_REPLACE(pss.query, '\s+', ' ', 'g') as query_text,
    pss.calls,
    ROUND(pss.total_exec_time, 2) as total_time_ms,
    ROUND(pss.mean_exec_time, 2) as avg_time_ms,
    ROUND(pss.rows::DECIMAL / GREATEST(pss.calls, 1), 2) as rows_per_call
  FROM pg_stat_statements pss
  WHERE (
    pss.query ILIKE '%user_activation%' 
    OR pss.query ILIKE '%activation_stages%'
    OR pss.query ILIKE '%activation_cohort%'
  )
  AND pss.mean_exec_time >= p_min_duration_ms
  ORDER BY pss.total_exec_time DESC
  LIMIT 20;
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- CONFIGURATION OPTIMIZATION
-- =============================================

-- Set optimal configuration for activation tracking workload
DO $$
BEGIN
  -- Enable query optimization features
  PERFORM set_config('enable_seqscan', 'on', false);
  PERFORM set_config('enable_indexscan', 'on', false);
  PERFORM set_config('enable_bitmapscan', 'on', false);
  
  -- Optimize for analytical queries
  PERFORM set_config('work_mem', '256MB', false);
  PERFORM set_config('effective_cache_size', '4GB', false);
  
  -- Enable parallel query execution for large cohort analysis
  PERFORM set_config('max_parallel_workers_per_gather', '4', false);
  PERFORM set_config('parallel_tuple_cost', '0.1', false);
  
  RAISE NOTICE 'Activation tracking query optimization settings applied';
END $$;

-- =============================================
-- DATA COMPRESSION AND ARCHIVAL
-- =============================================

-- Function to archive old activation data
CREATE OR REPLACE FUNCTION archive_old_activation_data(
  p_archive_months INTEGER DEFAULT 24
) RETURNS INTEGER AS $$
DECLARE
  v_archived_count INTEGER := 0;
  v_cutoff_date TIMESTAMPTZ;
BEGIN
  v_cutoff_date := CURRENT_TIMESTAMP - INTERVAL '1 month' * p_archive_months;
  
  -- Archive old activation events to a compressed table
  CREATE TABLE IF NOT EXISTS user_activation_events_archive (
    LIKE user_activation_events INCLUDING ALL
  );
  
  -- Move old events to archive
  WITH archived_events AS (
    DELETE FROM user_activation_events 
    WHERE created_at < v_cutoff_date
    RETURNING *
  )
  INSERT INTO user_activation_events_archive 
  SELECT * FROM archived_events;
  
  GET DIAGNOSTICS v_archived_count = ROW_COUNT;
  
  -- Compress the archive table
  -- This would use pg_squeeze or similar compression extension in production
  
  RETURN v_archived_count;
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- HEALTH CHECK AND MONITORING
-- =============================================

-- Comprehensive health check for activation tracking system
CREATE OR REPLACE FUNCTION check_activation_system_health() 
RETURNS TABLE (
  component TEXT,
  status TEXT,
  details TEXT,
  recommendation TEXT
) AS $$
BEGIN
  RETURN QUERY
  -- Check table sizes and growth
  SELECT 
    'Table Growth'::TEXT,
    CASE WHEN pg_total_relation_size('user_activation_events') > 1073741824 -- 1GB
      THEN 'WARNING' 
      ELSE 'HEALTHY' 
    END,
    'Events table size: ' || pg_size_pretty(pg_total_relation_size('user_activation_events')),
    CASE WHEN pg_total_relation_size('user_activation_events') > 1073741824 
      THEN 'Consider archiving old events or implementing partitioning'
      ELSE 'Table size is within normal limits'
    END
  
  UNION ALL
  
  -- Check index usage
  SELECT 
    'Index Usage'::TEXT,
    CASE WHEN (
      SELECT AVG(idx_scan::DECIMAL / GREATEST(seq_scan + idx_scan, 1)) 
      FROM pg_stat_user_tables 
      WHERE tablename LIKE '%activation%'
    ) < 0.8 THEN 'WARNING' ELSE 'HEALTHY' END,
    'Average index usage ratio: ' || ROUND((
      SELECT AVG(idx_scan::DECIMAL / GREATEST(seq_scan + idx_scan, 1)) * 100
      FROM pg_stat_user_tables 
      WHERE tablename LIKE '%activation%'
    ), 2) || '%',
    'Monitor for sequential scans on large tables'
  
  UNION ALL
  
  -- Check recent data freshness
  SELECT 
    'Data Freshness'::TEXT,
    CASE WHEN (
      SELECT COUNT(*) FROM user_activation_events 
      WHERE created_at >= CURRENT_TIMESTAMP - INTERVAL '1 hour'
    ) > 0 THEN 'HEALTHY' ELSE 'WARNING' END,
    'Events in last hour: ' || (
      SELECT COUNT(*) FROM user_activation_events 
      WHERE created_at >= CURRENT_TIMESTAMP - INTERVAL '1 hour'
    ),
    'Ensure event tracking is functioning properly'
  
  UNION ALL
  
  -- Check materialized view freshness
  SELECT 
    'Dashboard Cache'::TEXT,
    CASE WHEN (
      SELECT last_updated FROM activation_dashboard_summary LIMIT 1
    ) >= CURRENT_TIMESTAMP - INTERVAL '2 hours' 
      THEN 'HEALTHY' ELSE 'STALE' END,
    'Last dashboard update: ' || (
      SELECT last_updated FROM activation_dashboard_summary LIMIT 1
    ),
    'Refresh materialized views if stale';
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- COMPLETION AND VALIDATION
-- =============================================

-- Run initial health check
SELECT * FROM check_activation_system_health();

-- Validate performance optimizations
SELECT * FROM validate_activation_data();

-- Log successful completion
DO $$
BEGIN
  RAISE NOTICE 'WS-231 Activation Performance Optimization completed successfully';
  RAISE NOTICE 'Advanced indexes created: 15+ specialized indexes for activation queries';
  RAISE NOTICE 'Query optimization functions: 5+ high-performance functions';
  RAISE NOTICE 'Monitoring and maintenance procedures: Automated health checks enabled';
  RAISE NOTICE 'Performance monitoring views and functions available';
  RAISE NOTICE 'System optimized for wedding industry activation patterns';
END $$;