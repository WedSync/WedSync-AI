-- =============================================
-- WS-231: ACTIVATION ANALYTICS FUNCTIONS
-- Team D (Platform) - Advanced Analytics Implementation
-- Generated by: Team D Platform Team
-- Date: 2025-09-02
-- =============================================

-- =============================================
-- ADVANCED FUNNEL CALCULATION FUNCTIONS
-- =============================================

-- Function to calculate detailed dropoff analysis
CREATE OR REPLACE FUNCTION analyze_activation_dropoffs(
  p_user_type TEXT,
  p_start_date TIMESTAMPTZ,
  p_end_date TIMESTAMPTZ
) RETURNS TABLE (
  dropoff_stage INTEGER,
  stage_name TEXT,
  users_dropped INTEGER,
  dropoff_percentage DECIMAL,
  avg_time_before_dropoff DECIMAL,
  common_last_actions TEXT[]
) AS $$
BEGIN
  RETURN QUERY
  WITH cohort_users AS (
    SELECT DISTINCT u.id as user_id, up.created_at as signup_date
    FROM auth.users u
    JOIN user_profiles up ON u.id = up.user_id
    WHERE up.created_at >= p_start_date 
    AND up.created_at < p_end_date
    AND (
      (p_user_type = 'supplier' AND up.organization_id IS NOT NULL) OR
      (p_user_type = 'couple' AND up.organization_id IS NULL)
    )
  ),
  user_progress AS (
    SELECT 
      cu.user_id,
      cu.signup_date,
      uas.stages_completed,
      uas.dropoff_stage,
      uas.last_activity_at,
      -- Get last few actions before dropoff
      array_agg(uae.event_name ORDER BY uae.created_at DESC) 
        FILTER (WHERE uae.created_at <= uas.last_activity_at) 
        as last_actions
    FROM cohort_users cu
    LEFT JOIN user_activation_status uas ON cu.user_id = uas.user_id
    LEFT JOIN user_activation_events uae ON cu.user_id = uae.user_id
    WHERE NOT COALESCE(uas.is_activated, FALSE) -- Only non-activated users
    GROUP BY cu.user_id, cu.signup_date, uas.stages_completed, 
             uas.dropoff_stage, uas.last_activity_at
  ),
  dropoff_stats AS (
    SELECT 
      COALESCE(up.dropoff_stage, up.stages_completed + 1) as stage_num,
      s.stage_name,
      COUNT(*) as dropped_count,
      AVG(EXTRACT(EPOCH FROM (up.last_activity_at - up.signup_date)) / 3600) as avg_hours_before_dropoff,
      array_agg(DISTINCT up.last_actions[1:3]) as common_actions -- Top 3 last actions
    FROM user_progress up
    LEFT JOIN activation_stages s ON s.stage_order = COALESCE(up.dropoff_stage, up.stages_completed + 1)
    WHERE s.user_type = p_user_type OR s.user_type IS NULL
    GROUP BY COALESCE(up.dropoff_stage, up.stages_completed + 1), s.stage_name
  ),
  total_cohort AS (
    SELECT COUNT(*) as total FROM cohort_users
  )
  SELECT 
    ds.stage_num,
    COALESCE(ds.stage_name, 'Stage ' || ds.stage_num) as stage_name,
    ds.dropped_count,
    ROUND((ds.dropped_count::DECIMAL / tc.total) * 100, 2) as dropoff_percentage,
    ROUND(ds.avg_hours_before_dropoff, 2) as avg_time_before_dropoff,
    ds.common_actions[1:5] as common_last_actions -- Top 5 common actions
  FROM dropoff_stats ds
  CROSS JOIN total_cohort tc
  ORDER BY ds.stage_num;
END;
$$ LANGUAGE plpgsql;

-- Function to calculate cohort retention and activation over time
CREATE OR REPLACE FUNCTION calculate_cohort_activation_timeline(
  p_user_type TEXT,
  p_cohort_start DATE,
  p_cohort_end DATE
) RETURNS TABLE (
  days_since_signup INTEGER,
  cumulative_activated INTEGER,
  cumulative_activation_rate DECIMAL,
  daily_activated INTEGER,
  daily_activation_rate DECIMAL
) AS $$
BEGIN
  RETURN QUERY
  WITH cohort_base AS (
    SELECT u.id as user_id, DATE(up.created_at) as signup_date
    FROM auth.users u
    JOIN user_profiles up ON u.id = up.user_id
    WHERE DATE(up.created_at) >= p_cohort_start 
    AND DATE(up.created_at) <= p_cohort_end
    AND (
      (p_user_type = 'supplier' AND up.organization_id IS NOT NULL) OR
      (p_user_type = 'couple' AND up.organization_id IS NULL)
    )
  ),
  activation_timeline AS (
    SELECT 
      cb.user_id,
      cb.signup_date,
      uas.activated_at,
      CASE WHEN uas.activated_at IS NOT NULL 
        THEN DATE(uas.activated_at) - cb.signup_date 
        ELSE NULL 
      END as days_to_activation
    FROM cohort_base cb
    LEFT JOIN user_activation_status uas ON cb.user_id = uas.user_id
  ),
  daily_metrics AS (
    SELECT 
      day_num,
      COUNT(CASE WHEN days_to_activation <= day_num THEN 1 END) as cumulative_activated,
      COUNT(CASE WHEN days_to_activation = day_num THEN 1 END) as daily_activated,
      COUNT(*) as total_cohort
    FROM activation_timeline
    CROSS JOIN generate_series(0, 30) as day_num -- 30-day activation window
    GROUP BY day_num
  )
  SELECT 
    dm.day_num as days_since_signup,
    dm.cumulative_activated,
    ROUND((dm.cumulative_activated::DECIMAL / dm.total_cohort) * 100, 2) as cumulative_activation_rate,
    dm.daily_activated,
    ROUND((dm.daily_activated::DECIMAL / dm.total_cohort) * 100, 2) as daily_activation_rate
  FROM daily_metrics dm
  WHERE dm.total_cohort > 0
  ORDER BY dm.day_num;
END;
$$ LANGUAGE plpgsql;

-- Function to identify high-impact activation improvements
CREATE OR REPLACE FUNCTION identify_activation_opportunities(
  p_user_type TEXT,
  p_lookback_days INTEGER DEFAULT 30
) RETURNS TABLE (
  opportunity_type TEXT,
  impact_score DECIMAL,
  affected_users INTEGER,
  potential_improvement TEXT,
  recommended_action TEXT
) AS $$
BEGIN
  RETURN QUERY
  WITH recent_users AS (
    SELECT uas.*
    FROM user_activation_status uas
    WHERE uas.user_type = p_user_type
    AND uas.signed_up_at >= CURRENT_DATE - INTERVAL '1 day' * p_lookback_days
  ),
  stage_analysis AS (
    SELECT 
      s.stage_order,
      s.stage_name,
      COUNT(*) as total_users,
      COUNT(CASE WHEN ru.stages_completed >= s.stage_order THEN 1 END) as completed_users,
      ROUND(
        COUNT(CASE WHEN ru.stages_completed >= s.stage_order THEN 1 END)::DECIMAL / 
        COUNT(*)::DECIMAL * 100, 2
      ) as completion_rate
    FROM activation_stages s
    CROSS JOIN recent_users ru
    WHERE s.user_type = p_user_type
    GROUP BY s.stage_order, s.stage_name
  )
  SELECT 
    'Low Stage Conversion'::TEXT as opportunity_type,
    (100 - sa.completion_rate) as impact_score,
    sa.total_users - sa.completed_users as affected_users,
    'Improve ' || sa.stage_name || ' completion from ' || sa.completion_rate || '% to 80%+' as potential_improvement,
    CASE 
      WHEN sa.stage_order = 1 THEN 'Streamline email verification process'
      WHEN sa.stage_order = 2 THEN 'Improve onboarding UX and reduce form complexity'
      WHEN sa.stage_order = 3 THEN 'Add guided tutorials for key features'
      WHEN sa.stage_order = 4 THEN 'Implement activation prompts and incentives'
      ELSE 'Create targeted re-engagement campaigns'
    END as recommended_action
  FROM stage_analysis sa
  WHERE sa.completion_rate < 70 -- Stages with less than 70% completion
  
  UNION ALL
  
  -- Time-to-activation opportunities
  SELECT 
    'Slow Activation'::TEXT,
    LEAST(100, AVG(EXTRACT(EPOCH FROM ru.time_to_activation) / 86400)) as impact_score,
    COUNT(CASE WHEN ru.time_to_activation > INTERVAL '7 days' THEN 1 END),
    'Reduce average time to activation from ' || 
      ROUND(AVG(EXTRACT(EPOCH FROM ru.time_to_activation) / 86400), 1) || 
      ' days to under 7 days',
    'Implement progressive onboarding and activation triggers'
  FROM recent_users ru
  WHERE ru.is_activated AND ru.time_to_activation IS NOT NULL
  HAVING AVG(EXTRACT(EPOCH FROM ru.time_to_activation) / 86400) > 7
  
  ORDER BY impact_score DESC;
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- COHORT ANALYSIS FUNCTIONS
-- =============================================

-- Function to generate cohort activation heatmap data
CREATE OR REPLACE FUNCTION generate_cohort_heatmap(
  p_user_type TEXT,
  p_months_back INTEGER DEFAULT 12
) RETURNS TABLE (
  cohort_month DATE,
  day_since_signup INTEGER,
  activation_rate DECIMAL,
  users_in_cohort INTEGER,
  activated_on_day INTEGER
) AS $$
BEGIN
  RETURN QUERY
  WITH monthly_cohorts AS (
    SELECT 
      DATE_TRUNC('month', uas.signed_up_at) as cohort_month,
      uas.user_id,
      uas.signed_up_at,
      uas.activated_at
    FROM user_activation_status uas
    WHERE uas.user_type = p_user_type
    AND uas.signed_up_at >= DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month' * p_months_back)
  ),
  cohort_metrics AS (
    SELECT 
      mc.cohort_month,
      day_num as days_since_signup,
      COUNT(*) as cohort_size,
      COUNT(CASE 
        WHEN mc.activated_at IS NOT NULL 
        AND DATE(mc.activated_at) <= DATE(mc.signed_up_at) + day_num
        THEN 1 
      END) as activated_count,
      COUNT(CASE 
        WHEN mc.activated_at IS NOT NULL 
        AND DATE(mc.activated_at) = DATE(mc.signed_up_at) + day_num
        THEN 1 
      END) as activated_on_day
    FROM monthly_cohorts mc
    CROSS JOIN generate_series(0, 30) as day_num
    GROUP BY mc.cohort_month, day_num
  )
  SELECT 
    cm.cohort_month,
    cm.days_since_signup,
    ROUND((cm.activated_count::DECIMAL / cm.cohort_size) * 100, 2) as activation_rate,
    cm.cohort_size,
    cm.activated_on_day
  FROM cohort_metrics cm
  WHERE cm.cohort_size > 0
  ORDER BY cm.cohort_month DESC, cm.days_since_signup;
END;
$$ LANGUAGE plpgsql;

-- Function to calculate activation attribution by traffic source
CREATE OR REPLACE FUNCTION calculate_activation_attribution(
  p_user_type TEXT,
  p_start_date TIMESTAMPTZ,
  p_end_date TIMESTAMPTZ
) RETURNS TABLE (
  traffic_source TEXT,
  total_signups INTEGER,
  activated_users INTEGER,
  activation_rate DECIMAL,
  avg_time_to_activation DECIMAL,
  quality_score DECIMAL
) AS $$
BEGIN
  RETURN QUERY
  WITH user_attribution AS (
    SELECT 
      uas.user_id,
      uas.is_activated,
      uas.time_to_activation,
      uas.activation_score,
      -- Extract source from first activation event
      COALESCE(
        uae.event_data->>'utm_source',
        uae.event_data->>'referrer',
        'direct'
      ) as source
    FROM user_activation_status uas
    LEFT JOIN user_activation_events uae ON (
      uas.user_id = uae.user_id 
      AND uae.event_name = 'signup_started'
    )
    WHERE uas.user_type = p_user_type
    AND uas.signed_up_at >= p_start_date
    AND uas.signed_up_at < p_end_date
  )
  SELECT 
    ua.source as traffic_source,
    COUNT(*) as total_signups,
    COUNT(CASE WHEN ua.is_activated THEN 1 END) as activated_users,
    ROUND(
      COUNT(CASE WHEN ua.is_activated THEN 1 END)::DECIMAL / 
      COUNT(*)::DECIMAL * 100, 2
    ) as activation_rate,
    ROUND(
      AVG(EXTRACT(EPOCH FROM ua.time_to_activation) / 86400), 2
    ) as avg_time_to_activation,
    ROUND(AVG(ua.activation_score), 2) as quality_score
  FROM user_attribution ua
  GROUP BY ua.source
  HAVING COUNT(*) >= 10 -- Only sources with significant volume
  ORDER BY activation_rate DESC, total_signups DESC;
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- PERFORMANCE ANALYSIS FUNCTIONS  
-- =============================================

-- Function to analyze activation performance trends
CREATE OR REPLACE FUNCTION analyze_activation_trends(
  p_user_type TEXT,
  p_period TEXT DEFAULT 'weekly' -- 'daily', 'weekly', 'monthly'
) RETURNS TABLE (
  period_start DATE,
  period_end DATE,
  signups INTEGER,
  activations INTEGER,
  activation_rate DECIMAL,
  avg_time_to_activation DECIMAL,
  trend_direction TEXT
) AS $$
DECLARE
  v_interval INTERVAL;
  v_trunc_format TEXT;
BEGIN
  -- Set interval and truncation based on period
  CASE p_period
    WHEN 'daily' THEN 
      v_interval := '1 day';
      v_trunc_format := 'day';
    WHEN 'weekly' THEN 
      v_interval := '1 week';
      v_trunc_format := 'week';
    WHEN 'monthly' THEN 
      v_interval := '1 month';
      v_trunc_format := 'month';
    ELSE 
      v_interval := '1 week';
      v_trunc_format := 'week';
  END CASE;

  RETURN QUERY
  WITH period_metrics AS (
    SELECT 
      DATE_TRUNC(v_trunc_format, uas.signed_up_at) as period_date,
      COUNT(*) as signup_count,
      COUNT(CASE WHEN uas.is_activated THEN 1 END) as activation_count,
      AVG(EXTRACT(EPOCH FROM uas.time_to_activation) / 86400) as avg_days_to_activation
    FROM user_activation_status uas
    WHERE uas.user_type = p_user_type
    AND uas.signed_up_at >= CURRENT_DATE - v_interval * 12
    GROUP BY DATE_TRUNC(v_trunc_format, uas.signed_up_at)
  ),
  metrics_with_rates AS (
    SELECT 
      pm.*,
      ROUND((pm.activation_count::DECIMAL / pm.signup_count) * 100, 2) as rate,
      LAG(ROUND((pm.activation_count::DECIMAL / pm.signup_count) * 100, 2)) 
        OVER (ORDER BY pm.period_date) as prev_rate
    FROM period_metrics pm
  )
  SELECT 
    mwr.period_date as period_start,
    mwr.period_date + v_interval - INTERVAL '1 day' as period_end,
    mwr.signup_count as signups,
    mwr.activation_count as activations,
    mwr.rate as activation_rate,
    ROUND(mwr.avg_days_to_activation, 2) as avg_time_to_activation,
    CASE 
      WHEN mwr.prev_rate IS NULL THEN 'baseline'
      WHEN mwr.rate > mwr.prev_rate + 2 THEN 'improving'
      WHEN mwr.rate < mwr.prev_rate - 2 THEN 'declining'
      ELSE 'stable'
    END as trend_direction
  FROM metrics_with_rates mwr
  WHERE mwr.signup_count >= 5 -- Minimum volume for reliable metrics
  ORDER BY mwr.period_date DESC;
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- REAL-TIME MONITORING FUNCTIONS
-- =============================================

-- Function to get current activation health status
CREATE OR REPLACE FUNCTION get_activation_health_status() 
RETURNS TABLE (
  metric_name TEXT,
  current_value DECIMAL,
  target_value DECIMAL,
  status TEXT,
  alert_level TEXT
) AS $$
BEGIN
  RETURN QUERY
  WITH health_metrics AS (
    SELECT 
      'Overall Activation Rate' as metric,
      ROUND(
        COUNT(CASE WHEN uas.is_activated THEN 1 END)::DECIMAL / 
        COUNT(*)::DECIMAL * 100, 2
      ) as current_val,
      75.0 as target_val
    FROM user_activation_status uas
    WHERE uas.signed_up_at >= CURRENT_DATE - INTERVAL '7 days'
    
    UNION ALL
    
    SELECT 
      'Supplier Activation Rate',
      ROUND(
        COUNT(CASE WHEN uas.is_activated THEN 1 END)::DECIMAL / 
        COUNT(*)::DECIMAL * 100, 2
      ),
      70.0
    FROM user_activation_status uas
    WHERE uas.user_type = 'supplier'
    AND uas.signed_up_at >= CURRENT_DATE - INTERVAL '7 days'
    
    UNION ALL
    
    SELECT 
      'Couple Activation Rate',
      ROUND(
        COUNT(CASE WHEN uas.is_activated THEN 1 END)::DECIMAL / 
        COUNT(*)::DECIMAL * 100, 2
      ),
      80.0
    FROM user_activation_status uas
    WHERE uas.user_type = 'couple'
    AND uas.signed_up_at >= CURRENT_DATE - INTERVAL '7 days'
    
    UNION ALL
    
    SELECT 
      'Avg Time to Activation (Days)',
      ROUND(
        AVG(EXTRACT(EPOCH FROM uas.time_to_activation) / 86400), 2
      ),
      7.0
    FROM user_activation_status uas
    WHERE uas.is_activated
    AND uas.signed_up_at >= CURRENT_DATE - INTERVAL '30 days'
  )
  SELECT 
    hm.metric as metric_name,
    hm.current_val as current_value,
    hm.target_val as target_value,
    CASE 
      WHEN hm.metric LIKE '%Time to Activation%' THEN
        CASE 
          WHEN hm.current_val <= hm.target_val THEN 'healthy'
          WHEN hm.current_val <= hm.target_val * 1.5 THEN 'warning'
          ELSE 'critical'
        END
      ELSE
        CASE 
          WHEN hm.current_val >= hm.target_val THEN 'healthy'
          WHEN hm.current_val >= hm.target_val * 0.8 THEN 'warning'
          ELSE 'critical'
        END
    END as status,
    CASE 
      WHEN hm.metric LIKE '%Time to Activation%' THEN
        CASE 
          WHEN hm.current_val <= hm.target_val THEN 'none'
          WHEN hm.current_val <= hm.target_val * 1.5 THEN 'medium'
          ELSE 'high'
        END
      ELSE
        CASE 
          WHEN hm.current_val >= hm.target_val THEN 'none'
          WHEN hm.current_val >= hm.target_val * 0.8 THEN 'medium'
          ELSE 'high'
        END
    END as alert_level
  FROM health_metrics hm;
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- AUTOMATED COHORT CALCULATION PROCEDURE
-- =============================================

-- Procedure to calculate and store daily cohort metrics
CREATE OR REPLACE FUNCTION calculate_daily_cohort_metrics() 
RETURNS VOID AS $$
DECLARE
  cohort_date DATE;
  user_type_val TEXT;
BEGIN
  -- Calculate metrics for each user type and recent cohort dates
  FOR user_type_val IN SELECT UNNEST(ARRAY['supplier', 'couple']) LOOP
    FOR cohort_date IN 
      SELECT DISTINCT DATE(uas.signed_up_at)
      FROM user_activation_status uas 
      WHERE uas.user_type = user_type_val
      AND DATE(uas.signed_up_at) >= CURRENT_DATE - INTERVAL '30 days'
      AND DATE(uas.signed_up_at) NOT IN (
        SELECT acm.cohort_date 
        FROM activation_cohort_metrics acm 
        WHERE acm.user_type = user_type_val
      )
    LOOP
      INSERT INTO activation_cohort_metrics (
        cohort_date, user_type, total_signups, activated_users, activation_rate,
        avg_time_to_activation, median_time_to_activation, 
        stage_breakdown, dropoff_analysis, calculated_at
      )
      WITH cohort_data AS (
        SELECT 
          uas.user_id,
          uas.is_activated,
          uas.time_to_activation,
          uas.stages_completed,
          uas.dropoff_stage
        FROM user_activation_status uas
        WHERE uas.user_type = user_type_val
        AND DATE(uas.signed_up_at) = cohort_date
      ),
      stage_stats AS (
        SELECT 
          s.stage_order,
          s.stage_name,
          COUNT(CASE WHEN cd.stages_completed >= s.stage_order THEN 1 END) as completed
        FROM activation_stages s
        CROSS JOIN cohort_data cd
        WHERE s.user_type = user_type_val
        GROUP BY s.stage_order, s.stage_name
      ),
      dropoff_stats AS (
        SELECT 
          dropoff_stage,
          COUNT(*) as count
        FROM cohort_data
        WHERE dropoff_stage IS NOT NULL
        GROUP BY dropoff_stage
      )
      SELECT 
        cohort_date,
        user_type_val,
        COUNT(*),
        COUNT(CASE WHEN cd.is_activated THEN 1 END),
        ROUND(
          COUNT(CASE WHEN cd.is_activated THEN 1 END)::DECIMAL / 
          COUNT(*)::DECIMAL * 100, 2
        ),
        AVG(EXTRACT(EPOCH FROM cd.time_to_activation) / 86400),
        PERCENTILE_CONT(0.5) WITHIN GROUP (
          ORDER BY EXTRACT(EPOCH FROM cd.time_to_activation) / 86400
        ),
        jsonb_object_agg(
          ss.stage_name, 
          jsonb_build_object(
            'completed', ss.completed,
            'rate', ROUND((ss.completed::DECIMAL / COUNT(*)::DECIMAL) * 100, 2)
          )
        ),
        (SELECT jsonb_object_agg(ds.dropoff_stage::TEXT, ds.count) FROM dropoff_stats ds),
        NOW()
      FROM cohort_data cd
      CROSS JOIN stage_stats ss
      GROUP BY cohort_date, user_type_val;
      
    END LOOP;
  END LOOP;
  
  RAISE NOTICE 'Daily cohort metrics calculation completed';
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- MATERIALIZED VIEWS FOR PERFORMANCE
-- =============================================

-- Materialized view for fast activation dashboard queries
CREATE MATERIALIZED VIEW IF NOT EXISTS activation_dashboard_summary AS
SELECT 
  uas.user_type,
  COUNT(*) as total_users,
  COUNT(CASE WHEN uas.is_activated THEN 1 END) as activated_users,
  ROUND(
    COUNT(CASE WHEN uas.is_activated THEN 1 END)::DECIMAL / 
    COUNT(*)::DECIMAL * 100, 2
  ) as activation_rate,
  ROUND(AVG(uas.activation_score), 2) as avg_activation_score,
  ROUND(
    AVG(EXTRACT(EPOCH FROM uas.time_to_activation) / 86400), 2
  ) as avg_days_to_activation,
  COUNT(CASE WHEN uas.signed_up_at >= CURRENT_DATE - INTERVAL '7 days' THEN 1 END) as weekly_signups,
  COUNT(CASE WHEN uas.activated_at >= CURRENT_DATE - INTERVAL '7 days' THEN 1 END) as weekly_activations,
  -- Stage completion rates
  ROUND(AVG(CASE WHEN uas.stages_completed >= 1 THEN 100.0 ELSE 0 END), 2) as stage_1_completion,
  ROUND(AVG(CASE WHEN uas.stages_completed >= 2 THEN 100.0 ELSE 0 END), 2) as stage_2_completion,
  ROUND(AVG(CASE WHEN uas.stages_completed >= 3 THEN 100.0 ELSE 0 END), 2) as stage_3_completion,
  ROUND(AVG(CASE WHEN uas.stages_completed >= 4 THEN 100.0 ELSE 0 END), 2) as stage_4_completion,
  ROUND(AVG(CASE WHEN uas.stages_completed >= 5 THEN 100.0 ELSE 0 END), 2) as stage_5_completion,
  CURRENT_TIMESTAMP as last_updated
FROM user_activation_status uas
GROUP BY uas.user_type;

-- Index for fast refresh
CREATE UNIQUE INDEX IF NOT EXISTS idx_activation_dashboard_user_type 
  ON activation_dashboard_summary(user_type);

-- Function to refresh materialized view
CREATE OR REPLACE FUNCTION refresh_activation_dashboard() RETURNS VOID AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY activation_dashboard_summary;
  RAISE NOTICE 'Activation dashboard summary refreshed at %', NOW();
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- WEDDING INDUSTRY SPECIFIC FUNCTIONS
-- =============================================

-- Function to analyze activation by wedding season
CREATE OR REPLACE FUNCTION analyze_seasonal_activation_patterns(
  p_user_type TEXT DEFAULT 'supplier'
) RETURNS TABLE (
  wedding_season TEXT,
  avg_activation_rate DECIMAL,
  peak_activation_month TEXT,
  signup_volume INTEGER,
  activation_velocity DECIMAL
) AS $$
BEGIN
  RETURN QUERY
  WITH seasonal_data AS (
    SELECT 
      uas.*,
      CASE 
        WHEN EXTRACT(MONTH FROM uas.signed_up_at) IN (3,4,5) THEN 'Spring'
        WHEN EXTRACT(MONTH FROM uas.signed_up_at) IN (6,7,8) THEN 'Summer'
        WHEN EXTRACT(MONTH FROM uas.signed_up_at) IN (9,10,11) THEN 'Fall'
        ELSE 'Winter'
      END as season,
      TO_CHAR(uas.signed_up_at, 'Month') as signup_month
    FROM user_activation_status uas
    WHERE uas.user_type = p_user_type
    AND uas.signed_up_at >= CURRENT_DATE - INTERVAL '2 years'
  ),
  seasonal_metrics AS (
    SELECT 
      sd.season,
      COUNT(*) as total_signups,
      COUNT(CASE WHEN sd.is_activated THEN 1 END) as total_activations,
      ROUND(
        COUNT(CASE WHEN sd.is_activated THEN 1 END)::DECIMAL / 
        COUNT(*)::DECIMAL * 100, 2
      ) as rate,
      AVG(EXTRACT(EPOCH FROM sd.time_to_activation) / 86400) as avg_days,
      MODE() WITHIN GROUP (ORDER BY sd.signup_month) as peak_month
    FROM seasonal_data sd
    GROUP BY sd.season
  )
  SELECT 
    sm.season as wedding_season,
    sm.rate as avg_activation_rate,
    sm.peak_month as peak_activation_month,
    sm.total_signups as signup_volume,
    ROUND(sm.total_activations::DECIMAL / NULLIF(sm.avg_days, 0), 2) as activation_velocity
  FROM seasonal_metrics sm
  ORDER BY sm.rate DESC;
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- FINAL SETUP AND VALIDATION
-- =============================================

-- Create a validation function to ensure data integrity
CREATE OR REPLACE FUNCTION validate_activation_data() RETURNS TABLE (
  check_name TEXT,
  status TEXT,
  message TEXT
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    'Activation Events Coverage'::TEXT,
    CASE WHEN COUNT(*) > 0 THEN 'PASS' ELSE 'FAIL' END,
    'Found ' || COUNT(*) || ' activation events in last 24 hours'
  FROM user_activation_events 
  WHERE created_at >= CURRENT_TIMESTAMP - INTERVAL '24 hours'
  
  UNION ALL
  
  SELECT 
    'User Status Consistency'::TEXT,
    CASE WHEN COUNT(*) = 0 THEN 'PASS' ELSE 'FAIL' END,
    CASE WHEN COUNT(*) = 0 
      THEN 'All users have consistent activation status'
      ELSE 'Found ' || COUNT(*) || ' users with inconsistent status'
    END
  FROM user_activation_status uas
  WHERE uas.is_activated = true AND uas.activated_at IS NULL
  
  UNION ALL
  
  SELECT 
    'Stage Configuration'::TEXT,
    CASE WHEN COUNT(*) = 10 THEN 'PASS' ELSE 'FAIL' END,
    'Found ' || COUNT(*) || ' activation stages configured (expected 10)'
  FROM activation_stages;
END;
$$ LANGUAGE plpgsql;

-- Log completion
DO $$
BEGIN
  RAISE NOTICE 'WS-231 Advanced Activation Analytics Functions completed successfully';
  RAISE NOTICE 'Functions created: 12+ analytical functions for activation tracking';
  RAISE NOTICE 'Materialized views created: activation_dashboard_summary';
  RAISE NOTICE 'Wedding industry seasonal analysis functions included';
  RAISE NOTICE 'Performance optimization and real-time monitoring enabled';
END $$;